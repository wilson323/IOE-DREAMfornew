# IOE-DREAM 项目修复核心原则

## 🚫 禁止脚本代码（强制执行）

**核心原则**:

- ❌ **禁止使用脚本批量修改代码**: 任何自动化脚本、正则表达式批量替换、PowerShell/Shell脚本批量修改都被严格禁止
- ✅ **唯一例外**: 影响文件数量超过50个的包路径清理、架构重构等特殊情况，必须经架构委员会批准
- ✅ **强制手动修复**: 所有编译错误、代码优化、功能实现都必须通过手动逐个文件修复

**违规检查**:

- Git pre-commit钩子自动检测脚本修改痕迹
- CI/CD流水线强制检查批量修改操作
- 代码审查必须验证无脚本修改痕迹
- 违规代码将被拒绝合并

**违规后果**:

- **代码拒绝**: 任何通过脚本修改的代码都将被拒绝合并
- **权限限制**: 严重违规者将限制代码提交权限
- **质量问责**: 脚本修改导致的问题由修改人负责修复

**正确实践**:

- ✅ 手动逐个修复编译错误
- ✅ 使用IDE的智能提示和重构功能
- ✅ 逐文件进行代码审查和优化
- ✅ 建立完善的单元测试覆盖

---

## 📋 待办事项修复指南

### 1. 修复流程（强制手动）

```
1. 阅读待办事项说明 → 理解业务需求
2. 阅读相关技术文档 → 理解架构规范
3. 使用IDE打开文件 → 手动修改代码
4. 运行单元测试 → 确保功能正确
5. 提交代码审查 → 确保符合规范
6. 合并到主分支 → 完成修复
```

### 2. 每个TODO修复步骤

**步骤1: 分析需求**
- 阅读GLOBAL_TODO_ANALYSIS_AND_SOLUTION.md中的详细说明
- 理解业务场景和技术要求
- 确认符合IOE-DREAM技术栈规范

**步骤2: 手动修复代码**
- 使用IDE（IntelliJ IDEA）打开对应文件
- 根据方案文档中的代码示例手动实现
- 遵循四层架构：Controller → Service → Manager → DAO
- 使用@Slf4j、@Resource、@Mapper等标准注解

**步骤3: 本地测试验证**
- 运行单元测试确保功能正确
- 使用日志输出验证执行流程
- 检查代码符合企业级标准

**步骤4: 代码审查**
- 提交Pull Request
- 团队成员审查代码质量
- 确保无脚本修改痕迹
- 验证符合架构规范

**步骤5: 合并发布**
- 通过审查后合并到主分支
- 运行CI/CD流水线验证
- 部署到测试环境
- 监控运行状态

### 3. 质量保障机制

**Git Pre-commit Hooks**:
- 自动检查脚本修改痕迹
- 检查批量操作模式
- 验证手动修复合规性

**CI/CD Pipeline**:
- 检查提交历史中的异常模式
- 验证代码提交的合理性
- 拒绝可疑的批量修改

**代码审查**:
- 人工审查每个PR
- 确认手动修复痕迹
- 验证符合企业级标准

---

## 🎯 典型TODO修复示例

### 示例：修复JWT令牌撤销机制（P0级）

**问题位置**: `microservices/microservices-common-security/src/main/java/net/lab1024/sa/common/auth/util/JwtTokenUtil.java`

**步骤1: 阅读需求**
```markdown
TODO内容: 实现JWT令牌撤销机制
需求: 用户登出时应该立即撤销令牌，防止已登出用户继续访问系统
技术方案: 使用Redis存储令牌黑名单
```

**步骤2: 手动实现**
```java
// 1. 使用IDE打开文件
// 2. 找到TODO注释位置
// 3. 手动编写代码实现撤销逻辑

@Slf4j
public class JwtTokenUtil {

    @Resource
    private RedisTemplate<String, String> redisTemplate;

    /**
     * 撤销JWT令牌
     * @param token JWT令牌
     */
    public void revokeToken(String token) {
        log.info("[JWT令牌] 开始撤销令牌: token={}", maskToken(token));

        try {
            // 提取令牌ID（从JWT claims中获取jti）
            String jti = extractJti(token);

            // 获取令牌过期时间
            Long expiration = extractExpiration(token);

            // 计算剩余有效期
            Long ttl = expiration - System.currentTimeMillis();

            if (ttl > 0) {
                // 存储到Redis黑名单，过期时间与JWT一致
                String key = "jwt:blacklist:" + jti;
                redisTemplate.opsForValue().set(key, "revoked", ttl, TimeUnit.MILLISECONDS);

                log.info("[JWT令牌] 令牌已撤销: jti={}, ttl={}ms", jti, ttl);
            } else {
                log.warn("[JWT令牌] 令牌已过期，无需撤销: jti={}", jti);
            }
        } catch (Exception e) {
            log.error("[JWT令牌] 撤销令牌失败: token={}, error={}", maskToken(token), e.getMessage(), e);
            throw new BusinessException("JWT令牌撤销失败");
        }
    }

    /**
     * 检查令牌是否已撤销
     */
    public boolean isTokenRevoked(String token) {
        try {
            String jti = extractJti(token);
            String key = "jwt:blacklist:" + jti;
            Boolean exists = redisTemplate.hasKey(key);
            return Boolean.TRUE.equals(exists);
        } catch (Exception e) {
            log.error("[JWT令牌] 检查令牌撤销状态失败: error={}", e.getMessage(), e);
            return false;
        }
    }

    // ... 其他辅助方法
}
```

**步骤3: 编写单元测试**
```java
@Slf4j
@SpringBootTest
class JwtTokenUtilTest {

    @Resource
    private JwtTokenUtil jwtTokenUtil;

    @Resource
    private RedisTemplate<String, String> redisTemplate;

    @Test
    void testRevokeToken() {
        log.info("[测试] 开始测试JWT令牌撤销");

        // 生成测试令牌
        String token = jwtTokenUtil.generateToken(1L);

        // 撤销令牌
        jwtTokenUtil.revokeToken(token);

        // 验证令牌已撤销
        boolean revoked = jwtTokenUtil.isTokenRevoked(token);
        assertTrue(revoked, "令牌应该已被撤销");

        log.info("[测试] JWT令牌撤销测试通过");
    }
}
```

**步骤4: 提交代码审查**
- 创建Pull Request
- 说明修复的内容和测试结果
- 等待团队审查

**步骤5: 合并发布**
- 通过审查后合并
- CI/CD自动部署
- 监控系统运行状态

---

## ⚠️ 常见错误模式（必须避免）

### ❌ 错误模式1: 使用脚本批量替换

```bash
# 错误示例
find . -name "*.java" -exec sed -i 's/@Autowired/@Resource/g' {} \;
```

### ✅ 正确做法: 手动逐个修改

```
1. 搜索@Autowired使用位置
2. 打开每个文件
3. 手动替换为@Resource
4. 检查上下文是否正确
5. 运行测试验证
6. 提交审查
```

### ❌ 错误模式2: 使用IDE批量重构（不检查）

```java
// 错误：直接全局重构，不检查每个文件
IDE: Refactor → Rename → "Rename all occurrences"
```

### ✅ 正确做法: 逐个验证后重构

```
1. 使用IDE的Find Usages查找引用
2. 逐个文件打开检查上下文
3. 确认后手动修改
4. 运行测试验证
5. 提交审查
```

### ❌ 错误模式3: 使用宏/模板批量生成代码

```bash
# 错误示例
for file in *.java; do
  cat >> $file << 'EOF'
@Slf4j
public class AutoGeneratedClass {
  // ...
}
EOF
done
```

### ✅ 正确做法: 手动创建每个类

```
1. 创建新类文件
2. 手动编写代码
3. 添加完整注释
4. 编写单元测试
5. 提交审查
```

---

## 📊 修复进度跟踪

每个TODO修复都应该记录：

```markdown
## TODO-001: JWT令牌撤销机制

**状态**: 🔄 进行中
**修复人**: 张三
**开始时间**: 2025-12-23
**预计完成**: 2025-12-25

**修复步骤**:
- [x] 阅读需求文档
- [x] 设计技术方案
- [x] 手动实现代码
- [ ] 编写单元测试
- [ ] 代码审查
- [ ] 合并发布

**修复文件**:
- JwtTokenUtil.java (新增revokeToken方法)
- JwtTokenUtilTest.java (新增测试用例)

**验证结果**:
- 单元测试: ✅ 通过
- 集成测试: ⏳ 待运行
- 代码审查: ⏳ 待审查
```

---

## 🎓 总结

**记住**: 质量永远比速度重要！

- ❌ 脚本批量修改 → 快速但质量不可控
- ✅ 手动逐个修复 → 质量可控，符合企业级标准

**IOE-DREAM项目的成功依赖于每一个细节的质量把控！**

---

**文档信息**
- **版本**: v1.0.0
- **创建时间**: 2025-12-23
- **维护团队**: IOE-DREAM架构委员会
- **文档状态**: 强制执行