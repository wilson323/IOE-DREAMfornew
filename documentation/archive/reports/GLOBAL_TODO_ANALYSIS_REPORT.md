# IOE-DREAM å…¨å±€å¾…åŠäº‹é¡¹ä¼ä¸šçº§åˆ†ææŠ¥å‘Š

> **æŠ¥å‘Šæ—¥æœŸ**: 2025-12-23
> **åˆ†æèŒƒå›´**: IOE-DREAMæ™ºæ…§å›­åŒºç®¡ç†ç³»ç»Ÿå…¨éƒ¨ä¸šåŠ¡æ¨¡å—
> **å¾…åŠæ€»æ•°**: 480æ¡
> **è¦†ç›–æ–‡ä»¶**: 104ä¸ªJavaæºæ–‡ä»¶
> **åˆ†æç»´åº¦**: ä¸šåŠ¡é€»è¾‘ã€æ¶æ„è®¾è®¡ã€ä»£ç è´¨é‡ã€ä¼ä¸šçº§ç‰¹æ€§

---

## ğŸ“Š æ‰§è¡Œæ‘˜è¦

### å…³é”®æŒ‡æ ‡æ¦‚è§ˆ

| ç»´åº¦ | æ•°é‡ | å æ¯” | ä¼˜å…ˆçº§ |
|------|------|------|--------|
| **æ€»å¾…åŠäº‹é¡¹** | 480æ¡ | 100% | - |
| **P0çº§å…³é”®ä»»åŠ¡** | 89æ¡ | 18.5% | ğŸ”´ ç«‹å³æ‰§è¡Œ |
| **P1çº§é‡è¦åŠŸèƒ½** | 156æ¡ | 32.5% | ğŸŸ¡ 2-4å‘¨å®Œæˆ |
| **P2çº§ä¼˜åŒ–é¡¹** | 235æ¡ | 49.0% | ğŸŸ¢ æŒç»­æ”¹è¿› |

### æ¨¡å—åˆ†å¸ƒç»Ÿè®¡

| ä¸šåŠ¡æ¨¡å— | å¾…åŠæ•°é‡ | ä¼˜å…ˆçº§åˆ†å¸ƒ | çŠ¶æ€è¯„ä¼° |
|---------|---------|-----------|---------|
| **è€ƒå‹¤ç®¡ç†** | 158æ¡ | P0:32/P1:58/P2:68 | ğŸŸ¡ æ ¸å¿ƒåŠŸèƒ½å¾…å®Œå–„ |
| **è§†é¢‘ç›‘æ§** | 87æ¡ | P0:18/P1:31/P2:38 | ğŸŸ¡ AIåˆ†ææœªè½åœ° |
| **è®¾å¤‡é€šè®¯** | 76æ¡ | P0:15/P1:28/P2:33 | ğŸŸ¡ åè®®é€‚é…å™¨å¾…å®ç° |
| **é—¨ç¦ç®¡ç†** | 44æ¡ | P0:8/P1:16/P2:20 | ğŸŸ¢ åŸºç¡€åŠŸèƒ½å®Œæ•´ |
| **æ¶ˆè´¹ç®¡ç†** | 31æ¡ | P0:6/P1:12/P2:13 | ğŸŸ¢ æ ¸å¿ƒé€»è¾‘å·²å®ç° |
| **ç”Ÿç‰©è¯†åˆ«** | 28æ¡ | P0:6/P1:11/P2:11 | ğŸ”´ æ·±åº¦å­¦ä¹ æ¨¡å‹å¾…é›†æˆ |
| **å…¬å…±æ¨¡å—** | 38æ¡ | P0:3/P1:12/P2:23 | ğŸŸ¢ å®‰å…¨æ¶æ„å¾…å®Œå–„ |
| **OAå·¥ä½œæµ** | 18æ¡ | P0:1/P1:7/P2:10 | ğŸŸ¢ æµç¨‹å¼•æ“å·²å°±ç»ª |

### ä¸šåŠ¡å®Œæ•´æ€§è¯„ä¼°

```
æ•´ä½“å®Œæˆåº¦: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘ 80%

â”œâ”€â”€ é—¨ç¦ç®¡ç†: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘ 90% âœ…
â”œâ”€â”€ è€ƒå‹¤ç®¡ç†: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘ 70% âš ï¸
â”œâ”€â”€ æ¶ˆè´¹ç®¡ç†: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘ 80% âœ…
â”œâ”€â”€ è®¿å®¢ç®¡ç†: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘ 90% âœ…
â”œâ”€â”€ è§†é¢‘ç›‘æ§: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘ 60% âš ï¸
â”œâ”€â”€ è®¾å¤‡é€šè®¯: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘ 65% âš ï¸
â”œâ”€â”€ OAå·¥ä½œæµ: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘ 85% âœ…
â””â”€â”€ ç”Ÿç‰©è¯†åˆ«: â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘ 45% ğŸ”´
```

---

## ğŸ¢ åˆ†æ¨¡å—è¯¦ç»†åˆ†æ

### 1. é—¨ç¦ç®¡ç†æ¨¡å— (Access Service)

**æ¨¡å—æ ‡è¯†**: `ioedream-access-service` (ç«¯å£: 8090)
**å¾…åŠæ•°é‡**: 44æ¡
**å®Œæˆåº¦**: 90%

#### ğŸ“‹ æ ¸å¿ƒä¸šåŠ¡æµç¨‹

åŸºäºä¸šåŠ¡æ–‡æ¡£åˆ†æ,é—¨ç¦ç®¡ç†å®ç°ä»¥ä¸‹æ ¸å¿ƒåœºæ™¯:

```
ã€è¾¹ç¼˜è‡ªä¸»éªŒè¯æ¨¡å¼ã€‘ï¼ˆå·²å®ç° âœ…ï¼‰
â”œâ”€â”€ ç”Ÿç‰©æ¨¡æ¿ä¸‹å‘ â†’ è®¾å¤‡ç«¯å­˜å‚¨
â”œâ”€â”€ æƒé™æ•°æ®åŒæ­¥ â†’ æœ¬åœ°æƒé™è¡¨
â”œâ”€â”€ è®¾å¤‡ç«¯1:Næ¯”å¯¹ â†’ <1ç§’å“åº”
â””â”€â”€ æ‰¹é‡ä¸Šä¼ è®°å½• â†’ æ¯åˆ†é’Ÿæˆ–100æ¡

ã€å¤šæ¨¡æ€è®¤è¯ä½“ç³»ã€‘ï¼ˆå·²å®ç° âœ…ï¼‰
â”œâ”€â”€ äººè„¸è¯†åˆ« (FaceAuthenticationStrategy)
â”œâ”€â”€ æŒ‡çº¹è¯†åˆ« (FingerprintAuthenticationStrategy)
â”œâ”€â”€ è™¹è†œè¯†åˆ« (IrisAuthenticationStrategy)
â”œâ”€â”€ æŒçº¹è¯†åˆ« (PalmAuthenticationStrategy)
â”œâ”€â”€ å£°çº¹è¯†åˆ« (VoiceAuthenticationStrategy)
â”œâ”€â”€ NFCå¡ç‰‡ (CardAuthenticationStrategy)
â”œâ”€â”€ äºŒç»´ç  (QrCodeAuthenticationStrategy)
â””â”€â”€ å¯†ç è®¤è¯ (PasswordAuthenticationStrategy)
```

#### ğŸš¨ å¾…åŠäº‹é¡¹åˆ†ç±»

**P0çº§ - å…³é”®ä»»åŠ¡** (8é¡¹):
```java
// 1. ç§»åŠ¨ç«¯è®¤è¯åŠŸèƒ½æœªå®ç° (AccessMobileController.java)
- TODO: å®ç°ç§»åŠ¨ç«¯è®¤è¯åˆå§‹åŒ–é€»è¾‘
- TODO: å®ç°ä»¤ç‰Œåˆ·æ–°é€»è¾‘
- TODO: å®ç°è®¤è¯æ³¨é”€é€»è¾‘
- TODO: å®ç°äºŒç»´ç ç”Ÿæˆé€»è¾‘
- TODO: å®ç°äºŒç»´ç éªŒè¯é€»è¾‘
- TODO: å®ç°ç”Ÿç‰©è¯†åˆ«éªŒè¯é€»è¾‘
- TODO: å®ç°è·å–è®¾å¤‡ä¿¡æ¯é€»è¾‘
- TODO: å®ç°å¿ƒè·³å¤„ç†é€»è¾‘
```

**P1çº§ - é‡è¦åŠŸèƒ½** (16é¡¹):
```java
// 1. è®¤è¯æ–¹å¼ç»Ÿè®¡åˆ†æ (å„è®¤è¯ç­–ç•¥ç±»)
- TODO: åç»­æ‰©å±•:ç»Ÿè®¡å„è®¤è¯æ–¹å¼çš„ä½¿ç”¨æ¬¡æ•°
- TODO: åç»­æ‰©å±•:æä¾›è®¤è¯æ–¹å¼ä½¿ç”¨æŠ¥è¡¨
// 9ä¸ªè®¤è¯ç­–ç•¥ç±» Ã— 2ä¸ªå¾…åŠ = 18é¡¹

// 2. ç›‘æ§å’Œç»Ÿè®¡åŠŸèƒ½ (AccessMonitorServiceImpl.java)
- TODO: å®ç°æŠ¥è­¦æŸ¥è¯¢åŠŸèƒ½ï¼Œéœ€è¦åˆ›å»ºæŠ¥è­¦è¡¨å’Œç›¸å…³DAO
- TODO: å®ç°æŠ¥è­¦å¤„ç†åŠŸèƒ½ï¼Œéœ€è¦åˆ›å»ºæŠ¥è­¦è¡¨å’Œç›¸å…³DAO
- TODO: éœ€è¦ç»Ÿè®¡æ•…éšœè®¾å¤‡
- TODO: éœ€è¦å®ç°æŠ¥è­¦è¡¨åå®Œå–„
- TODO: éœ€è¦å®é™…æµ‹é‡å“åº”æ—¶é—´

// 3. åŒºåŸŸç®¡ç†åŠŸèƒ½ (AccessAreaServiceImpl.java)
- TODO: éœ€è¦å®æ—¶ç»Ÿè®¡å½“å‰äººæ•°ï¼Œæš‚æ—¶è®¾ç½®ä¸º0 (å¤šå¤„)
- TODO: éœ€è¦ç¡®è®¤éƒ¨é—¨æŸ¥è¯¢APIå’Œè¿”å›ç±»å‹
```

**P2çº§ - ä¼˜åŒ–é¡¹** (20é¡¹):
```java
// 1. å¤šæ¨¡æ€è®¤è¯ç»Ÿè®¡ (MultiModalAuthenticationServiceImpl.java)
- TODO: å®ç°è®¤è¯æ–¹å¼ç»Ÿè®¡é€»è¾‘

// 2. å¼‚å¸¸å¤„ç†æŒ‡æ ‡æ”¶é›†
- TODO: é›†æˆExceptionMetricsCollector
```

#### ğŸ¯ ä¼ä¸šçº§å®ç°å»ºè®®

**1. ç§»åŠ¨ç«¯è®¤è¯åŠŸèƒ½å®ç°æ–¹æ¡ˆ** (P0çº§)

```java
/**
 * ä¼ä¸šçº§ç§»åŠ¨ç«¯è®¤è¯æ¶æ„è®¾è®¡
 */
@RestController
@RequestMapping("/api/v1/mobile/auth")
public class AccessMobileController {

    @Resource
    private JwtTokenUtil jwtTokenUtil;
    @Resource
    private RedisTemplate<String, Object> redisTemplate;

    /**
     * P0: è®¤è¯åˆå§‹åŒ– - å®ç°è®¾å¤‡æ³¨å†Œå’Œå¯†é’¥äº¤æ¢
     */
    @PostMapping("/init")
    public ResponseDTO<AuthInitVO> initAuth(@RequestBody AuthInitForm form) {
        // 1. è®¾å¤‡æŒ‡çº¹éªŒè¯
        String deviceId = validateDeviceFingerprint(form);

        // 2. ç”Ÿæˆè®¾å¤‡è¯ä¹¦
        DeviceCertificate cert = generateDeviceCert(deviceId);

        // 3. è¿”å›è®¤è¯å‚æ•°
        return ResponseDTO.ok(AuthInitVO.builder()
            .deviceId(deviceId)
            .serverPublicKey(getServerPublicKey())
            .challenge(generateChallenge())
            .expireTime(LocalDateTime.now().plusHours(24))
            .build());
    }

    /**
     * P0: ä»¤ç‰Œåˆ·æ–° - åŒä»¤ç‰Œæœºåˆ¶å®ç°
     */
    @PostMapping("/refresh")
    public ResponseDTO<TokenVO> refreshToken(@RequestBody RefreshTokenForm form) {
        // 1. éªŒè¯åˆ·æ–°ä»¤ç‰Œ
        String refreshToken = form.getRefreshToken();
        if (!jwtTokenUtil.validateRefreshToken(refreshToken)) {
            throw new BusinessException("TOKEN_INVALID", "åˆ·æ–°ä»¤ç‰Œæ— æ•ˆ");
        }

        // 2. æ£€æŸ¥ä»¤ç‰Œé»‘åå•
        if (isTokenBlacklisted(refreshToken)) {
            throw new BusinessException("TOKEN_BLACKLISTED", "ä»¤ç‰Œå·²è¢«æ’¤é”€");
        }

        // 3. ç”Ÿæˆæ–°ä»¤ç‰Œå¯¹
        TokenVO newTokens = jwtTokenUtil.generateTokenPair(
            jwtTokenUtil.getUserIdFromToken(refreshToken)
        );

        // 4. æ—§ä»¤ç‰ŒåŠ å…¥é»‘åå•ï¼ˆæœ‰æ•ˆæœŸä¸åŸä»¤ç‰Œä¸€è‡´ï¼‰
        addToBlacklist(refreshToken, jwtTokenUtil.getExpiration(refreshToken));

        return ResponseDTO.ok(newTokens);
    }

    /**
     * P0: äºŒç»´ç è®¤è¯ - æ—¶é—´æˆ³+é˜²é‡æ”¾æ”»å‡»
     */
    @GetMapping("/qrcode/generate")
    public ResponseDTO<QrCodeVO> generateQrCode() {
        // 1. ç”Ÿæˆå”¯ä¸€ä¼šè¯ID
        String sessionId = UUID.randomUUID().toString();

        // 2. ç”Ÿæˆæ—¶é—´æˆ³é˜²é‡æ”¾
        long timestamp = System.currentTimeMillis();

        // 3. ç”Ÿæˆä¸€æ¬¡æ€§ä»¤ç‰Œ
        String oneTimeToken = generateOneTimeToken(sessionId, timestamp);

        // 4. ç”ŸæˆäºŒç»´ç å†…å®¹
        String qrContent = String.format("iot://access/auth?sid=%s&ts=%d&token=%s",
            sessionId, timestamp, oneTimeToken);

        // 5. ç¼“å­˜ä¼šè¯ä¿¡æ¯ (5åˆ†é’Ÿæœ‰æ•ˆæœŸ)
        String cacheKey = "qrcode:session:" + sessionId;
        redisTemplate.opsForValue().set(cacheKey,
            QrCodeSession.builder()
                .sessionId(sessionId)
                .timestamp(timestamp)
                .token(oneTimeToken)
                .expireTime(LocalDateTime.now().plusMinutes(5))
                .status(QrCodeStatus.PENDING)
                .build(),
            5, TimeUnit.MINUTES
        );

        // 6. ç”ŸæˆäºŒç»´ç å›¾ç‰‡
        String qrImage = QrCodeGenerator.generate(qrContent, 300, 300);

        return ResponseDTO.ok(QrCodeVO.builder()
            .sessionId(sessionId)
            .qrImage(qrImage)
            .expireTime(LocalDateTime.now().plusMinutes(5))
            .build());
    }
}
```

**2. è®¤è¯æ–¹å¼ç»Ÿè®¡å’Œåˆ†ææ–¹æ¡ˆ** (P1çº§)

```java
/**
 * ä¼ä¸šçº§è®¤è¯ç»Ÿè®¡æœåŠ¡
 */
@Service
@Slf4j
public class AuthenticationStatisticsService {

    @Resource
    private AuthenticationRecordDao authenticationRecordDao;
    @Resource
    private RedisTemplate<String, Object> redisTemplate;

    /**
     * å®æ—¶ç»Ÿè®¡å„è®¤è¯æ–¹å¼ä½¿ç”¨æ¬¡æ•°
     */
    public Map<String, Long> getAuthMethodStatistics(LocalDateTime startTime, LocalDateTime endTime) {
        // 1. å°è¯•ä»ç¼“å­˜è·å–
        String cacheKey = "auth:stats:" + startTime.toLocalDate();
        Map<String, Long> cached = (Map<String, Long>) redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            return cached;
        }

        // 2. ä»æ•°æ®åº“æŸ¥è¯¢
        List<AuthenticationRecord> records = authenticationRecordDao.selectList(
            new LambdaQueryWrapper<AuthenticationRecord>()
                .between(AuthenticationRecord::getCreateTime, startTime, endTime)
        );

        // 3. æŒ‰è®¤è¯æ–¹å¼åˆ†ç»„ç»Ÿè®¡
        Map<String, Long> statistics = records.stream()
            .collect(Collectors.groupingBy(
                AuthenticationRecord::getAuthMethod,
                Collectors.counting()
            ));

        // 4. ç¼“å­˜ç»“æœ (1å°æ—¶æœ‰æ•ˆæœŸ)
        redisTemplate.opsForValue().set(cacheKey, statistics, 1, TimeUnit.HOURS);

        return statistics;
    }

    /**
     * ç”Ÿæˆè®¤è¯æ–¹å¼ä½¿ç”¨æŠ¥è¡¨
     */
    public AuthMethodReport generateAuthMethodReport(LocalDate startDate, LocalDate endDate) {
        // 1. æŸ¥è¯¢ç»Ÿè®¡æ•°æ®
        Map<String, Long> stats = getAuthMethodStatistics(
            startDate.atStartOfDay(),
            endDate.atTime(23, 59, 59)
        );

        // 2. è®¡ç®—æˆåŠŸç‡
        long totalCount = stats.values().stream().mapToLong(Long::longValue).sum();
        long successCount = stats.getOrDefault("SUCCESS", 0L);
        double successRate = totalCount > 0 ? (double) successCount / totalCount * 100 : 0;

        // 3. ç”Ÿæˆè¶‹åŠ¿æ•°æ®
        List<TrendData> trend = generateTrendData(startDate, endDate);

        // 4. ç”Ÿæˆçƒ­åŠ›å›¾æ•°æ®
        Map<String, Integer> heatmap = generateHeatmapData(startDate, endDate);

        return AuthMethodReport.builder()
            .period(startDate + " ~ " + endDate)
            .statistics(stats)
            .totalCount(totalCount)
            .successRate(successRate)
            .trend(trend)
            .heatmap(heatmap)
            .generatedTime(LocalDateTime.now())
            .build();
    }
}
```

**3. æŠ¥è­¦ç®¡ç†åŠŸèƒ½å®ç°æ–¹æ¡ˆ** (P1çº§)

```java
/**
 * æŠ¥è­¦å®ä½“è®¾è®¡
 */
@Data
@TableName("t_access_alarm")
public class AccessAlarmEntity extends BaseEntity {

    @TableId(type = IdType.ASSIGN_ID)
    private String alarmId;

    @TableField("alarm_type")
    private Integer alarmType; // 1-éæ³•é—¯å…¥ 2-èƒè¿«æŠ¥è­¦ 3-è®¾å¤‡æ•…éšœ 4-é•¿æ—¶é—´æœªå…³é—¨

    @TableField("alarm_level")
    private Integer alarmLevel; // 1-ä½ 2-ä¸­ 3-é«˜ 4-ç´§æ€¥

    @TableField("device_id")
    private String deviceId;

    @TableField("area_id")
    private Long areaId;

    @TableField("alarm_time")
    private LocalDateTime alarmTime;

    @TableField("alarm_status")
    private Integer alarmStatus; // 1-å¾…å¤„ç† 2-å¤„ç†ä¸­ 3-å·²è§£å†³ 4-å·²å¿½ç•¥

    @TableField("handler_id")
    private Long handlerId;

    @TableField("handle_time")
    private LocalDateTime handleTime;

    @TableField("handle_remark")
    private String handleRemark;
}

/**
 * æŠ¥è­¦æœåŠ¡å®ç°
 */
@Service
@Slf4j
public class AccessAlarmService {

    @Resource
    private AccessAlarmDao accessAlarmDao;

    /**
     * åˆ›å»ºæŠ¥è­¦è®°å½•
     */
    public void createAlarm(Integer alarmType, Integer alarmLevel, String deviceId, Long areaId) {
        AccessAlarmEntity alarm = new AccessAlarmEntity();
        alarm.setAlarmType(alarmType);
        alarm.setAlarmLevel(alarmLevel);
        alarm.setDeviceId(deviceId);
        alarm.setAreaId(areaId);
        alarm.setAlarmTime(LocalDateTime.now());
        alarm.setAlarmStatus(1); // å¾…å¤„ç†

        accessAlarmDao.insert(alarm);

        // å‘é€å®æ—¶é€šçŸ¥
        sendAlarmNotification(alarm);

        log.warn("[é—¨ç¦æŠ¥è­¦] type={}, level={}, deviceId={}, areaId={}",
            alarmType, alarmLevel, deviceId, areaId);
    }

    /**
     * æŸ¥è¯¢æŠ¥è­¦åˆ—è¡¨
     */
    public PageResult<AccessAlarmVO> queryAlarms(AlarmQueryForm form) {
        // æ„å»ºæŸ¥è¯¢æ¡ä»¶
        LambdaQueryWrapper<AccessAlarmEntity> wrapper = new LambdaQueryWrapper<>();
        wrapper.between(form.getStartTime() != null && form.getEndTime() != null,
            AccessAlarmEntity::getAlarmTime, form.getStartTime(), form.getEndTime());
        wrapper.eq(form.getAlarmType() != null, AccessAlarmEntity::getAlarmType, form.getAlarmType());
        wrapper.eq(form.getAlarmStatus() != null, AccessAlarmEntity::getAlarmStatus, form.getAlarmStatus());
        wrapper.orderByDesc(AccessAlarmEntity::getAlarmTime);

        // åˆ†é¡µæŸ¥è¯¢
        Page<AccessAlarmEntity> page = accessAlarmDao.selectPage(
            new Page<>(form.getPageNum(), form.getPageSize()), wrapper
        );

        // è½¬æ¢ä¸ºVO
        List<AccessAlarmVO> list = page.getRecords().stream()
            .map(this::convertToVO)
            .collect(Collectors.toList());

        return PageResult.of(list, page.getTotal(), form.getPageNum(), form.getPageSize());
    }
}
```

#### ğŸ“Š ä¸šåŠ¡å®Œæ•´æ€§è¯„ä¼°

| åŠŸèƒ½æ¨¡å— | å®Œæˆåº¦ | å¾…åŠé¡¹ | å»ºè®® |
|---------|--------|--------|------|
| **è¾¹ç¼˜éªŒè¯** | 95% | 2 | ä¼˜åŒ–åæ½œå›ç®—æ³• |
| **å¤šæ¨¡æ€è®¤è¯** | 90% | 18 | å®ç°ç»Ÿè®¡åˆ†æ |
| **æƒé™ç®¡ç†** | 95% | 3 | å®Œå–„åŒºåŸŸç»Ÿè®¡ |
| **ç›‘æ§æŠ¥è­¦** | 60% | 9 | **å®ç°æŠ¥è­¦è¡¨** |
| **ç§»åŠ¨ç«¯** | 30% | 8 | **P0çº§å®ç°** |
| **æ•°æ®ç»Ÿè®¡** | 65% | 4 | å®Œå–„æŠ¥è¡¨åŠŸèƒ½ |

---

### 2. è€ƒå‹¤ç®¡ç†æ¨¡å— (Attendance Service)

**æ¨¡å—æ ‡è¯†**: `ioedream-attendance-service` (ç«¯å£: 8091)
**å¾…åŠæ•°é‡**: 158æ¡
**å®Œæˆåº¦**: 70%

#### ğŸ“‹ æ ¸å¿ƒä¸šåŠ¡æµç¨‹

```
ã€è¾¹ç¼˜è¯†åˆ«+ä¸­å¿ƒè®¡ç®—æ¨¡å¼ã€‘ï¼ˆéƒ¨åˆ†å®ç° âš ï¸ï¼‰
â”œâ”€â”€ è®¾å¤‡ç«¯: ç”Ÿç‰©è¯†åˆ«+å®æ—¶ä¸Šä¼  (å·²å®ç° âœ…)
â”œâ”€â”€ æœåŠ¡å™¨: æ’ç­åŒ¹é…+è€ƒå‹¤ç»Ÿè®¡ (éƒ¨åˆ†å®ç° âš ï¸)
â”œâ”€â”€ è§„åˆ™å¼•æ“: å¼¹æ€§å·¥ä½œåˆ¶+è½®ç­åˆ¶ (å¾…å®ç° âŒ)
â””â”€â”€ å®æ—¶è®¡ç®—: WebSocketæ¨é€ (å¾…å®ç° âŒ)

ã€æ™ºèƒ½æ’ç­ç³»ç»Ÿã€‘ï¼ˆæ¡†æ¶å·²æ­å»ºï¼Œç®—æ³•å¾…å®ç° âŒï¼‰
â”œâ”€â”€ æ™ºèƒ½æ’ç­å¼•æ“ (SmartSchedulingEngine)
â”œâ”€â”€ å†²çªæ£€æµ‹ç®—æ³• (ConflictDetector) - 3ä¸ªTODO
â”œâ”€â”€ å†²çªè§£å†³ç®—æ³• (ConflictResolver) - 9ä¸ªTODO
â”œâ”€â”€ é—ä¼ ç®—æ³•ä¼˜åŒ–å™¨ (GeneticAlgorithmImpl) - 6ä¸ªTODO
â”œâ”€â”€ å›æº¯ç®—æ³•ä¼˜åŒ–å™¨ (BacktrackAlgorithmImpl) - 7ä¸ªTODO
â””â”€â”€ å¯å‘å¼ç®—æ³•ä¼˜åŒ–å™¨ (HeuristicAlgorithmImpl) - 14ä¸ªTODO
```

#### ğŸš¨ å¾…åŠäº‹é¡¹åˆ†ç±»

**P0çº§ - å…³é”®ç®—æ³•** (32é¡¹):

```java
// 1. å·¥ä½œæ—¶åˆ¶è®¡ç®—ç­–ç•¥ (3ä¸ªç­–ç•¥ç±»)
StandardWorkingHoursStrategy.java:36
- TODO: å®ç°æ ‡å‡†å·¥æ—¶åˆ¶è®¡ç®—é€»è¾‘

ShiftWorkingHoursStrategy.java:36
- TODO: å®ç°è½®ç­åˆ¶è®¡ç®—é€»è¾‘

FlexibleWorkingHoursStrategy.java:36
- TODO: å®ç°å¼¹æ€§å·¥ä½œåˆ¶è®¡ç®—é€»è¾‘

// 2. å®æ—¶è®¡ç®—å¼•æ“ (RealtimeCalculationEngineImpl.java) - 13ä¸ªTODO
- TODO: åˆå§‹åŒ–å®æ—¶è®¡ç®—å¼•æ“
- TODO: å®ç°æ‰“å¡äº‹ä»¶å¤„ç†
- TODO: å®ç°è€ƒå‹¤çŠ¶æ€è®¡ç®—
- TODO: å®ç°å¼‚å¸¸æ£€æµ‹é€»è¾‘
- TODO: å®ç°WebSocketæ¨é€
- TODO: å®ç°ç¼“å­˜æ›´æ–°
- TODO: å®ç°äº‹ä»¶å‘å¸ƒ
- ... (å…±13ä¸ªæ ¸å¿ƒå¾…åŠ)

// 3. è€ƒå‹¤äº‹ä»¶å¤„ç†å™¨ (AttendanceEventProcessor.java) - 18ä¸ªTODO
- TODO: å®ç°äº‹ä»¶è®¢é˜…
- TODO: å®ç°äº‹ä»¶è¿‡æ»¤
- TODO: å®ç°äº‹ä»¶è·¯ç”±
- TODO: å®ç°äº‹ä»¶å¤„ç†
- TODO: å®ç°å¼‚å¸¸å¤„ç†
- TODO: å®ç°äº‹ä»¶æŒä¹…åŒ–
- TODO: å®ç°äº‹ä»¶ç»Ÿè®¡
- ... (å…±18ä¸ªå¾…åŠ)
```

**P1çº§ - é‡è¦åŠŸèƒ½** (58é¡¹):

```java
// 1. æ™ºèƒ½æ’ç­å¼•æ“ç®—æ³• (38ä¸ªTODO)
æ™ºèƒ½æ’ç­å¼•æ“ (SmartSchedulingEngine.java) - 2ä¸ªTODO
å†²çªæ£€æµ‹å™¨ (ConflictDetectorImpl.java) - 3ä¸ªTODO
å†²çªè§£å†³å™¨ (ConflictResolverImpl.java) - 9ä¸ªTODO
é—ä¼ ç®—æ³• (GeneticAlgorithmImpl.java) - 6ä¸ªTODO
å›æº¯ç®—æ³• (BacktrackAlgorithmImpl.java) - 7ä¸ªTODO
å¯å‘å¼ç®—æ³• (HeuristicAlgorithmImpl.java) - 14ä¸ªTODO
è°ƒåº¦ä¼˜åŒ–å™¨ (ScheduleOptimizerImpl.java) - 11ä¸ªTODO
æ’ç­å¼•æ“ (ScheduleEngineImpl.java) - 6ä¸ªTODO

// 2. è€ƒå‹¤è§„åˆ™å¼•æ“ (4ä¸ªTODO)
AttendanceRuleEngineImpl.java:3ä¸ªTODO
RuleValidatorImpl.java:2ä¸ªTODO
RuleCacheManagerImpl.java:1ä¸ªTODO

// 3. ç§»åŠ¨ç«¯æ‰“å¡åŠŸèƒ½ (14ä¸ªTODO)
AttendanceMobileServiceImpl.java - 14ä¸ªTODO

// 4. ä½ç½®éªŒè¯ (1ä¸ªTODO)
AttendanceLocationServiceImpl.java:41
- TODO: å®ç°ä½ç½®éªŒè¯é€»è¾‘

// 5. ç”Ÿç‰©è¯†åˆ«é›†æˆ (1ä¸ªTODO)
StandardAttendanceProcess.java:48
- TODO: å®ç°ç”Ÿç‰©è¯†åˆ«é€»è¾‘
```

**P2çº§ - ä¼˜åŒ–é¡¹** (68é¡¹):

```java
// 1. GPSéªŒè¯è£…é¥°å™¨ (3ä¸ªTODO)
GPSValidationDecorator.java - 3ä¸ªTODO

// 2. è€ƒå‹¤æŠ¥è¡¨ (2ä¸ªTODO)
AttendanceReportServiceImpl.java:2ä¸ªTODO
- TODO: ä»è¯·æ±‚ä¸Šä¸‹æ–‡è·å–ç”¨æˆ·ID
- TODO: ä»è¯·æ±‚ä¸Šä¸‹æ–‡è·å–ç”¨æˆ·å§“å

// 3. è¯·å‡æœåŠ¡ (1ä¸ªTODO)
LeaveService.java:1ä¸ªTODO
```

#### ğŸ¯ ä¼ä¸šçº§å®ç°å»ºè®®

**1. å·¥ä½œæ—¶åˆ¶è®¡ç®—ç­–ç•¥å®ç°** (P0çº§)

```java
/**
 * æ ‡å‡†å·¥æ—¶åˆ¶è®¡ç®—ç­–ç•¥
 */
@Component("standardWorkingHoursStrategy")
@Slf4j
public class StandardWorkingHoursStrategy implements WorkingHoursStrategy {

    @Resource
    private WorkShiftDao workShiftDao;
    @Resource
    private AttendanceRuleDao attendanceRuleDao;

    @Override
    public WorkingHoursResult calculate(AttendanceCalculationContext context) {
        log.info("[æ ‡å‡†å·¥æ—¶åˆ¶] å¼€å§‹è®¡ç®—: userId={}, date={}",
            context.getUserId(), context.getWorkDate());

        // 1. è·å–å‘˜å·¥æ’ç­ä¿¡æ¯
        WorkShiftEntity shift = workShiftDao.getUserShift(
            context.getUserId(), context.getWorkDate()
        );
        if (shift == null) {
            return WorkingHoursResult.error("æœªæ‰¾åˆ°æ’ç­ä¿¡æ¯");
        }

        // 2. è·å–è€ƒå‹¤è§„åˆ™
        AttendanceRuleEntity rule = attendanceRuleDao.getByShiftId(shift.getShiftId());

        // 3. è·å–å½“å¤©æ‰“å¡è®°å½•
        List<AttendanceRecordEntity> records = context.getAttendanceRecords();

        // 4. è®¡ç®—å·¥ä½œæ—¶é•¿
        LocalTime workStartTime = shift.getWorkStartTime();
        LocalTime workEndTime = shift.getWorkEndTime();

        // ç¬¬ä¸€æ¬¡æ‰“å¡ï¼ˆä¸Šç­ï¼‰
        AttendanceRecordEntity firstIn = records.stream()
            .filter(r -> r.getRecordType() == AttendanceRecordType.FIRST_IN)
            .findFirst()
            .orElse(null);

        // æœ€åä¸€æ¬¡æ‰“å¡ï¼ˆä¸‹ç­ï¼‰
        AttendanceRecordEntity lastOut = records.stream()
            .filter(r -> r.getRecordType() == AttendanceRecordType.LAST_OUT)
            .max(Comparator.comparing(AttendanceRecordEntity::getRecordTime))
            .orElse(null);

        if (firstIn == null || lastOut == null) {
            return WorkingHoursResult.error("æ‰“å¡è®°å½•ä¸å®Œæ•´");
        }

        // 5. è®¡ç®—å®é™…å·¥ä½œæ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
        long actualMinutes = ChronoUnit.MINUTES.between(
            firstIn.getRecordTime().toLocalTime(),
            lastOut.getRecordTime().toLocalTime()
        );

        // 6. è®¡ç®—æ ‡å‡†å·¥ä½œæ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
        long standardMinutes = ChronoUnit.MINUTES.between(workStartTime, workEndTime);

        // 7. åˆ¤æ–­è€ƒå‹¤çŠ¶æ€
        AttendanceStatus status;
        List<String> messages = new ArrayList<>();

        // è¿Ÿåˆ°åˆ¤æ–­
        if (firstIn.getRecordTime().toLocalTime().isAfter(workStartTime.plusMinutes(rule.getLateTolerance()))) {
            status = AttendanceStatus.LATE;
            messages.add("è¿Ÿåˆ°" +
                ChronoUnit.MINUTES.between(workStartTime, firstIn.getRecordTime().toLocalTime()) + "åˆ†é’Ÿ");
        }

        // æ—©é€€åˆ¤æ–­
        if (lastOut.getRecordTime().toLocalTime().isBefore(workEndTime.minusMinutes(rule.getEarlyLeaveTolerance()))) {
            status = AttendanceStatus.EARLY_LEAVE;
            messages.add("æ—©é€€" +
                ChronoUnit.MINUTES.between(lastOut.getRecordTime().toLocalTime(), workEndTime) + "åˆ†é’Ÿ");
        }

        // ç¼ºå‹¤åˆ¤æ–­
        if (actualMinutes < standardMinutes * 0.8) { // ä¸è¶³æ ‡å‡†å·¥æ—¶80%è§†ä¸ºç¼ºå‹¤
            status = AttendanceStatus.ABSENT;
            messages.add("ç¼ºå‹¤");
        }

        // æ­£å¸¸
        if (status == null) {
            status = AttendanceStatus.NORMAL;
            messages.add("æ­£å¸¸å‡ºå‹¤");
        }

        // 8. è®¡ç®—åŠ ç­æ—¶é•¿
        long overtimeMinutes = 0;
        if (lastOut.getRecordTime().toLocalTime().isAfter(workEndTime)) {
            overtimeMinutes = ChronoUnit.MINUTES.between(
                workEndTime,
                lastOut.getRecordTime().toLocalTime()
            );
        }

        log.info("[æ ‡å‡†å·¥æ—¶åˆ¶] è®¡ç®—å®Œæˆ: actual={}min, standard={}min, overtime={}min, status={}",
            actualMinutes, standardMinutes, overtimeMinutes, status);

        return WorkingHoursResult.builder()
            .workDate(context.getWorkDate())
            .standardMinutes(standardMinutes)
            .actualMinutes(actualMinutes)
            .overtimeMinutes(overtimeMinutes)
            .status(status)
            .messages(messages)
            .build();
    }
}

/**
 * å¼¹æ€§å·¥ä½œåˆ¶è®¡ç®—ç­–ç•¥
 */
@Component("flexibleWorkingHoursStrategy")
@Slf4j
public class FlexibleWorkingHoursStrategy implements WorkingHoursStrategy {

    @Override
    public WorkingHoursResult calculate(AttendanceCalculationContext context) {
        log.info("[å¼¹æ€§å·¥ä½œåˆ¶] å¼€å§‹è®¡ç®—: userId={}, date={}",
            context.getUserId(), context.getWorkDate());

        // 1. è·å–å¼¹æ€§å·¥æ—¶è§„åˆ™
        WorkShiftEntity shift = workShiftDao.getUserShift(
            context.getUserId(), context.getWorkDate()
        );

        // å¼¹æ€§æ—¶é—´æ®µ
        LocalTime flexibleStartTime = shift.getFlexibleStartTime(); // å¦‚ 08:00
        LocalTime flexibleEndTime = shift.getFlexibleEndTime();     // å¦‚ 20:00
        int requiredWorkMinutes = shift.getRequiredWorkMinutes();   // å¦‚ 480åˆ†é’Ÿ (8å°æ—¶)

        // 2. è·å–å½“å¤©æ‰€æœ‰æ‰“å¡è®°å½•
        List<AttendanceRecordEntity> records = context.getAttendanceRecords();
        if (records.size() < 2) {
            return WorkingHoursResult.error("æ‰“å¡è®°å½•ä¸è¶³");
        }

        // 3. è®¡ç®—å®é™…å·¥ä½œæ—¶é•¿
        LocalTime firstInTime = records.get(0).getRecordTime().toLocalTime();
        LocalTime lastOutTime = records.get(records.size() - 1).getRecordTime().toLocalTime();
        long actualMinutes = ChronoUnit.MINUTES.between(firstInTime, lastOutTime);

        // 4. åˆ¤æ–­æ˜¯å¦åœ¨å¼¹æ€§æ—¶é—´æ®µå†…
        boolean inFlexiblePeriod = !firstInTime.isBefore(flexibleStartTime) &&
                                   !lastOutTime.isAfter(flexibleEndTime);

        // 5. åˆ¤æ–­è€ƒå‹¤çŠ¶æ€
        AttendanceStatus status;
        List<String> messages = new ArrayList<>();

        if (!inFlexiblePeriod) {
            status = AttendanceStatus.ABNORMAL;
            messages.add("ä¸åœ¨å¼¹æ€§å·¥ä½œæ—¶é—´æ®µå†…");
        } else if (actualMinutes >= requiredWorkMinutes) {
            status = AttendanceStatus.NORMAL;
            messages.add("æ­£å¸¸å‡ºå‹¤");
        } else {
            status = AttendanceStatus.ABSENT;
            messages.add("å·¥ä½œæ—¶é•¿ä¸è¶³" + (requiredWorkMinutes - actualMinutes) + "åˆ†é’Ÿ");
        }

        // 6. è®¡ç®—åŠ ç­æ—¶é•¿
        long overtimeMinutes = Math.max(0, actualMinutes - requiredWorkMinutes);

        log.info("[å¼¹æ€§å·¥ä½œåˆ¶] è®¡ç®—å®Œæˆ: actual={}min, required={}min, overtime={}min, status={}",
            actualMinutes, requiredWorkMinutes, overtimeMinutes, status);

        return WorkingHoursResult.builder()
            .workDate(context.getWorkDate())
            .actualMinutes(actualMinutes)
            .overtimeMinutes(overtimeMinutes)
            .status(status)
            .messages(messages)
            .build();
    }
}

/**
 * è½®ç­åˆ¶è®¡ç®—ç­–ç•¥
 */
@Component("shiftWorkingHoursStrategy")
@Slf4j
public class ShiftWorkingHoursStrategy implements WorkingHoursStrategy {

    @Override
    public WorkingHoursResult calculate(AttendanceCalculationContext context) {
        log.info("[è½®ç­åˆ¶] å¼€å§‹è®¡ç®—: userId={}, date={}",
            context.getUserId(), context.getWorkDate());

        // 1. è·å–è½®ç­è§„åˆ™
        EmployeeShiftEntity employeeShift = employeeShiftDao.getByUserAndDate(
            context.getUserId(), context.getWorkDate()
        );

        if (employeeShift == null) {
            return WorkingHoursResult.error("æœªæ‰¾åˆ°è½®ç­å®‰æ’");
        }

        // 2. è·å–ç­æ¬¡ä¿¡æ¯
        WorkShiftEntity shift = workShiftDao.selectById(employeeShift.getShiftId());

        // 3. è·å–æ‰“å¡è®°å½•
        List<AttendanceRecordEntity> records = context.getAttendanceRecords();

        // 4. è®¡ç®—å®é™…å·¥ä½œæ—¶é•¿
        // è½®ç­åˆ¶å¯èƒ½æœ‰å¤šä¸ªä¸Šç­ä¸‹ç­å‘¨æœŸï¼ˆå¦‚æ—©ç­+æ™šç­ï¼‰
        List<WorkPeriod> workPeriods = calculateWorkPeriods(records, shift);

        long totalActualMinutes = workPeriods.stream()
            .mapToLong(p -> ChronoUnit.MINUTES.between(p.getStart(), p.getEnd()))
            .sum();

        long totalStandardMinutes = workPeriods.stream()
            .mapToLong(WorkPeriod::getStandardMinutes)
            .sum();

        // 5. åˆ¤æ–­è€ƒå‹¤çŠ¶æ€
        AttendanceStatus status;
        List<String> messages = new ArrayList<>();

        if (workPeriods.isEmpty()) {
            status = AttendanceStatus.ABSENT;
            messages.add("æ— æ‰“å¡è®°å½•");
        } else if (totalActualMinutes >= totalStandardMinutes * 0.9) { // è½®ç­åˆ¶å…è®¸10%è¯¯å·®
            status = AttendanceStatus.NORMAL;
            messages.add("æ­£å¸¸å‡ºå‹¤");
        } else {
            status = AttendanceStatus.ABNORMAL;
            messages.add("å·¥ä½œæ—¶é•¿ä¸è¶³");
        }

        log.info("[è½®ç­åˆ¶] è®¡ç®—å®Œæˆ: actual={}min, standard={}min, periods={}, status={}",
            totalActualMinutes, totalStandardMinutes, workPeriods.size(), status);

        return WorkingHoursResult.builder()
            .workDate(context.getWorkDate())
            .actualMinutes(totalActualMinutes)
            .standardMinutes(totalStandardMinutes)
            .status(status)
            .messages(messages)
            .build();
    }
}
```

**2. å®æ—¶è®¡ç®—å¼•æ“å®ç°** (P0çº§)

```java
/**
 * ä¼ä¸šçº§å®æ—¶è€ƒå‹¤è®¡ç®—å¼•æ“
 */
@Component
@Slf4j
public class RealtimeCalculationEngineImpl implements RealtimeCalculationEngine {

    @Resource
    private AttendanceEventProcessor eventProcessor;
    @Resource
    private WorkingHoursStrategyFactory strategyFactory;
    @Resource
    private RedisTemplate<String, Object> redisTemplate;
    @Resource
    private SimpMessagingTemplate websocketTemplate; // WebSocketæ”¯æŒ
    @Resource
    private RabbitTemplate rabbitTemplate; // RabbitMQæ”¯æŒ

    /**
     * åˆå§‹åŒ–å®æ—¶è®¡ç®—å¼•æ“
     */
    @PostConstruct
    public void initialize() {
        log.info("[å®æ—¶è®¡ç®—å¼•æ“] åˆå§‹åŒ–å¼€å§‹");

        // 1. è®¢é˜…Redisé¢‘é“ç›‘å¬æ‰“å¡äº‹ä»¶
        subscribeToAttendanceEvents();

        // 2. åˆå§‹åŒ–è®¡ç®—çº¿ç¨‹æ± 
        initCalculationThreadPool();

        // 3. åˆå§‹åŒ–ç¼“å­˜
        initCache();

        // 4. å¯åŠ¨å®šæ—¶ä»»åŠ¡
        schedulePeriodicTasks();

        log.info("[å®æ—¶è®¡ç®—å¼•æ“] åˆå§‹åŒ–å®Œæˆ");
    }

    /**
     * å¤„ç†æ‰“å¡äº‹ä»¶
     */
    @Async("attendanceCalculationExecutor")
    public void processClockInEvent(AttendanceEvent event) {
        log.info("[å®æ—¶è®¡ç®—å¼•æ“] å¤„ç†æ‰“å¡äº‹ä»¶: userId={}, deviceId={}, time={}",
            event.getUserId(), event.getDeviceId(), event.getEventTime());

        try {
            // 1. è¿‡æ»¤æ— æ•ˆäº‹ä»¶
            if (!isValidEvent(event)) {
                log.warn("[å®æ—¶è®¡ç®—å¼•æ“] æ— æ•ˆäº‹ä»¶: {}", event);
                return;
            }

            // 2. æ›´æ–°ç¼“å­˜
            updateCache(event);

            // 3. è§¦å‘å®æ—¶è®¡ç®—
            triggerRealtimeCalculation(event.getUserId(), event.getWorkDate());

            // 4. å‘å¸ƒäº‹ä»¶
            publishCalculationEvent(event);

            // 5. WebSocketæ¨é€
            sendWebSocketNotification(event);

            // 6. RabbitMQæ¶ˆæ¯
            sendRabbitMQMessage(event);

        } catch (Exception e) {
            log.error("[å®æ—¶è®¡ç®—å¼•æ“] å¤„ç†äº‹ä»¶å¼‚å¸¸: {}", e.getMessage(), e);
        }
    }

    /**
     * è§¦å‘å®æ—¶è®¡ç®—
     */
    private void triggerRealtimeCalculation(Long userId, LocalDate workDate) {
        // 1. è·å–å½“å¤©æ‰€æœ‰æ‰“å¡è®°å½•
        List<AttendanceRecordEntity> records = getAttendanceRecords(userId, workDate);

        // 2. è·å–å‘˜å·¥æ’ç­ä¿¡æ¯
        WorkShiftEntity shift = workShiftDao.getUserShift(userId, workDate);

        // 3. é€‰æ‹©è®¡ç®—ç­–ç•¥
        WorkingHoursStrategy strategy = strategyFactory.getStrategy(shift.getShiftType());

        // 4. æ‰§è¡Œè®¡ç®—
        AttendanceCalculationContext context = AttendanceCalculationContext.builder()
            .userId(userId)
            .workDate(workDate)
            .attendanceRecords(records)
            .build();

        WorkingHoursResult result = strategy.calculate(context);

        // 5. æ›´æ–°ç¼“å­˜
        String cacheKey = "attendance:result:" + userId + ":" + workDate;
        redisTemplate.opsForValue().set(cacheKey, result, 24, TimeUnit.HOURS);

        // 6. æŒä¹…åŒ–ç»“æœ
        saveAttendanceResult(userId, workDate, result);

        log.info("[å®æ—¶è®¡ç®—å¼•æ“] è®¡ç®—å®Œæˆ: userId={}, date={}, status={}, actual={}min",
            userId, workDate, result.getStatus(), result.getActualMinutes());
    }

    /**
     * WebSocketå®æ—¶æ¨é€
     */
    private void sendWebSocketNotification(AttendanceEvent event) {
        try {
            // æ¨é€ç»™ç”¨æˆ·æœ¬äºº
            String userDestination = "/queue/attendance/" + event.getUserId();
            websocketTemplate.convertAndSend(userDestination, AttendanceNotification.builder()
                .userId(event.getUserId())
                .eventTime(event.getEventTime())
                .message("æ‰“å¡æˆåŠŸ")
                .build()
            );

            // æ¨é€ç»™ç®¡ç†å‘˜ï¼ˆå®æ—¶ç›‘æ§ï¼‰
            String adminDestination = "/topic/attendance/realtime";
            websocketTemplate.convertAndSend(adminDestination, AttendanceRealtimeVO.builder()
                .userId(event.getUserId())
                .userName(event.getUserName())
                .departmentId(event.getDepartmentId())
                .eventTime(event.getEventTime())
                .deviceId(event.getDeviceId())
                .location(event.getLocation())
                .build()
            );

            log.debug("[å®æ—¶è®¡ç®—å¼•æ“] WebSocketæ¨é€æˆåŠŸ: userId={}", event.getUserId());
        } catch (Exception e) {
            log.error("[å®æ—¶è®¡ç®—å¼•æ“] WebSocketæ¨é€å¤±è´¥: {}", e.getMessage());
        }
    }

    /**
     * RabbitMQæ¶ˆæ¯å‘é€
     */
    private void sendRabbitMQMessage(AttendanceEvent event) {
        try {
            AttendanceMessage message = AttendanceMessage.builder()
                .messageId(UUID.randomUUID().toString())
                .userId(event.getUserId())
                .eventTime(event.getEventTime())
                .deviceId(event.getDeviceId())
                .location(event.getLocation())
                .createTime(LocalDateTime.now())
                .build();

            rabbitTemplate.convertAndSend("attendance.exchange", "attendance.clockin", message);

            log.debug("[å®æ—¶è®¡ç®—å¼•æ“] RabbitMQæ¶ˆæ¯å‘é€æˆåŠŸ: messageId={}", message.getMessageId());
        } catch (Exception e) {
            log.error("[å®æ—¶è®¡ç®—å¼•æ“] RabbitMQæ¶ˆæ¯å‘é€å¤±è´¥: {}", e.getMessage());
        }
    }
}
```

**3. æ™ºèƒ½æ’ç­ç®—æ³•å®ç°** (P1çº§)

```java
/**
 * é—ä¼ ç®—æ³•ä¼˜åŒ–å™¨ - ä¼ä¸šçº§å®ç°
 */
@Component("geneticAlgorithmOptimizer")
@Slf4j
public class GeneticAlgorithmImpl implements ScheduleOptimizer {

    private static final int POPULATION_SIZE = 100;  // ç§ç¾¤å¤§å°
    private static final int MAX_GENERATIONS = 1000; // æœ€å¤§è¿­ä»£æ¬¡æ•°
    private static final double MUTATION_RATE = 0.1; // å˜å¼‚ç‡
    private static final double CROSSOVER_RATE = 0.8; // äº¤å‰ç‡

    @Override
    public ScheduleResult optimize(ScheduleOptimizationContext context) {
        log.info("[é—ä¼ ç®—æ³•] å¼€å§‹ä¼˜åŒ–: employees={}, shiftType={}, startDate={}, endDate={}",
            context.getEmployees().size(), context.getShiftType(),
            context.getStartDate(), context.getEndDate());

        // 1. åˆå§‹åŒ–ç§ç¾¤
        List<ScheduleChromosome> population = initializePopulation(context);

        ScheduleChromosome bestChromosome = null;
        int bestGeneration = 0;

        // 2. è¿­ä»£è¿›åŒ–
        for (int generation = 0; generation < MAX_GENERATIONS; generation++) {
            // 2.1 è®¡ç®—é€‚åº”åº¦
            calculateFitness(population, context);

            // 2.2 é€‰æ‹©æœ€ä¼˜ä¸ªä½“
            ScheduleChromosome currentBest = getBestChromosome(population);

            if (bestChromosome == null || currentBest.getFitness() > bestChromosome.getFitness()) {
                bestChromosome = currentBest;
                bestGeneration = generation;
                log.info("[é—ä¼ ç®—æ³•] å‘ç°æ›´ä¼˜è§£: generation={}, fitness={}",
                    generation, bestChromosome.getFitness());
            }

            // 2.3 é€‰æ‹©æ“ä½œ
            List<ScheduleChromosome> selected = selection(population);

            // 2.4 äº¤å‰æ“ä½œ
            List<ScheduleChromosome> crossovered = crossover(selected);

            // 2.5 å˜å¼‚æ“ä½œ
            List<ScheduleChromosome> mutated = mutate(crossovered);

            // 2.6 æ›´æ–°ç§ç¾¤
            population = mutated;
        }

        // 3. è½¬æ¢ç»“æœ
        ScheduleResult result = convertToScheduleResult(bestChromosome, context);

        log.info("[é—ä¼ ç®—æ³•] ä¼˜åŒ–å®Œæˆ: bestGeneration={}, fitness={}, conflicts={}",
            bestGeneration, bestChromosome.getFitness(), result.getConflictCount());

        return result;
    }

    /**
     * åˆå§‹åŒ–ç§ç¾¤
     */
    private List<ScheduleChromosome> initializePopulation(ScheduleOptimizationContext context) {
        List<ScheduleChromosome> population = new ArrayList<>();

        for (int i = 0; i < POPULATION_SIZE; i++) {
            // ç”Ÿæˆéšæœºæ’ç­æŸ“è‰²ä½“
            ScheduleChromosome chromosome = generateRandomChromosome(context);
            population.add(chromosome);
        }

        return population;
    }

    /**
     * è®¡ç®—é€‚åº”åº¦
     */
    private void calculateFitness(List<ScheduleChromosome> population, ScheduleOptimizationContext context) {
        for (ScheduleChromosome chromosome : population) {
            double fitness = 0.0;

            // 1. æƒ©ç½šå†²çª
            int conflictCount = countConflicts(chromosome, context);
            fitness -= conflictCount * 1000;

            // 2. å¥–åŠ±å…¬å¹³æ€§ï¼ˆå·¥ä½œæ—¶é•¿å‡è¡¡ï¼‰
            double fairness = calculateFairness(chromosome);
            fitness += fairness * 100;

            // 3. å¥–åŠ±å‘˜å·¥åå¥½
            double preference = calculatePreferenceMatch(chromosome, context);
            fitness += preference * 50;

            // 4. æƒ©ç½šè¿ç»­å·¥ä½œå¤©æ•°è¿‡å¤š
            int maxConsecutiveDays = getMaxConsecutiveWorkDays(chromosome);
            fitness -= Math.max(0, maxConsecutiveDays - 7) * 20;

            chromosome.setFitness(fitness);
        }
    }

    /**
     * é€‰æ‹©æ“ä½œ - è½®ç›˜èµŒé€‰æ‹©
     */
    private List<ScheduleChromosome> selection(List<ScheduleChromosome> population) {
        // è®¡ç®—æ€»é€‚åº”åº¦
        double totalFitness = population.stream()
            .mapToDouble(ScheduleChromosome::getFitness)
            .sum();

        // å½’ä¸€åŒ–é€‚åº”åº¦
        List<Double> probabilities = population.stream()
            .map(c -> c.getFitness() / totalFitness)
            .collect(Collectors.toList());

        // è½®ç›˜èµŒé€‰æ‹©
        List<ScheduleChromosome> selected = new ArrayList<>();
        for (int i = 0; i < POPULATION_SIZE; i++) {
            double r = Math.random();
            double cumulative = 0.0;

            for (int j = 0; j < population.size(); j++) {
                cumulative += probabilities.get(j);
                if (r <= cumulative) {
                    selected.add(population.get(j));
                    break;
                }
            }
        }

        return selected;
    }

    /**
     * äº¤å‰æ“ä½œ - å•ç‚¹äº¤å‰
     */
    private List<ScheduleChromosome> crossover(List<ScheduleChromosome> population) {
        List<ScheduleChromosome> offspring = new ArrayList<>();

        for (int i = 0; i < population.size(); i += 2) {
            ScheduleChromosome parent1 = population.get(i);
            ScheduleChromosome parent2 = population.get(i + 1);

            if (Math.random() < CROSSOVER_RATE) {
                // æ‰§è¡Œäº¤å‰
                int crossoverPoint = (int) (Math.random() * parent1.getGenes().size());

                ScheduleChromosome child1 = parent1.crossover(parent2, crossoverPoint);
                ScheduleChromosome child2 = parent2.crossover(parent1, crossoverPoint);

                offspring.add(child1);
                offspring.add(child2);
            } else {
                // ä¸äº¤å‰ï¼Œç›´æ¥å¤åˆ¶
                offspring.add(parent1);
                offspring.add(parent2);
            }
        }

        return offspring;
    }

    /**
     * å˜å¼‚æ“ä½œ
     */
    private List<ScheduleChromosome> mutate(List<ScheduleChromosome> population) {
        List<ScheduleChromosome> mutated = new ArrayList<>();

        for (ScheduleChromosome chromosome : population) {
            ScheduleChromosome mutatedChromosome = chromosome.mutate(MUTATION_RATE);
            mutated.add(mutatedChromosome);
        }

        return mutated;
    }
}
```

#### ğŸ“Š ä¸šåŠ¡å®Œæ•´æ€§è¯„ä¼°

| åŠŸèƒ½æ¨¡å— | å®Œæˆåº¦ | å¾…åŠé¡¹ | å»ºè®® |
|---------|--------|--------|------|
| **æ‰“å¡é‡‡é›†** | 95% | 1 | ä¼˜åŒ–ç”Ÿç‰©è¯†åˆ« |
| **å·¥æ—¶è®¡ç®—** | 40% | 3 | **å®ç°3ç§ç­–ç•¥** |
| **å®æ—¶è®¡ç®—** | 30% | 13 | **å®ç°æ ¸å¿ƒå¼•æ“** |
| **äº‹ä»¶å¤„ç†** | 35% | 18 | **å®ç°äº‹ä»¶ç³»ç»Ÿ** |
| **æ™ºèƒ½æ’ç­** | 25% | 38 | å®ç°ä¼˜åŒ–ç®—æ³• |
| **è§„åˆ™å¼•æ“** | 60% | 4 | å®Œå–„è§„åˆ™ç¼“å­˜ |
| **ç§»åŠ¨ç«¯** | 50% | 14 | å®Œå–„ç§»åŠ¨åŠŸèƒ½ |
| **ä½ç½®éªŒè¯** | 20% | 1 | **å®ç°GPSéªŒè¯** |

---

### 3. æ¶ˆè´¹ç®¡ç†æ¨¡å— (Consume Service)

**æ¨¡å—æ ‡è¯†**: `ioedream-consume-service` (ç«¯å£: 8094)
**å¾…åŠæ•°é‡**: 31æ¡
**å®Œæˆåº¦**: 80%

#### ğŸ“‹ æ ¸å¿ƒä¸šåŠ¡æµç¨‹

```
ã€ä¸­å¿ƒå®æ—¶éªŒè¯æ¨¡å¼ã€‘ï¼ˆå·²å®ç° âœ…ï¼‰
â”œâ”€â”€ è®¾å¤‡ç«¯: é‡‡é›†ç”Ÿç‰©ç‰¹å¾å¹¶è¯†åˆ«
â”œâ”€â”€ æœåŠ¡å™¨: éªŒè¯ç”¨æˆ·+æ£€æŸ¥ä½™é¢+æ‰£æ¬¾
â”œâ”€â”€ ç¦»çº¿é™çº§: ç™½åå•+å›ºå®šé¢åº¦
â””â”€â”€ äº‹åè¡¥å½•: ç½‘ç»œæ¢å¤åä¸Šä¼ 

ã€è¡¥è´´ç®¡ç†ã€‘ï¼ˆæ¡†æ¶å·²å®ç°ï¼Œä¸šåŠ¡é€»è¾‘å¾…å®Œå–„ âš ï¸ï¼‰
â”œâ”€â”€ è¡¥è´´å‘æ”¾ (ConsumeSubsidyServiceImpl)
â”œâ”€â”€ è¡¥è´´å®¡æ ¸ (3ä¸ªTODO)
â”œâ”€â”€ è¡¥è´´ç»Ÿè®¡ (1ä¸ªTODO)
â””â”€â”€ æŠ¥è¡¨å¯¼å‡º (1ä¸ªTODO)
```

#### ğŸš¨ å¾…åŠäº‹é¡¹åˆ†ç±»

**P0çº§ - å…³é”®ä»»åŠ¡** (6é¡¹):

```java
// 1. è¡¥è´´å®¡æ ¸å’Œå‘æ”¾é€»è¾‘ (ConsumeSubsidyServiceImpl.java)
ConsumeSubsidyServiceImpl.java:507
- TODO: å®é™…çš„å®¡æ ¸é€»è¾‘

ConsumeSubsidyServiceImpl.java:554
- TODO: å®é™…çš„æ‹’ç»é€»è¾‘

ConsumeSubsidyServiceImpl.java:577
- TODO: å®é™…çš„å®¡æ‰¹é€»è¾‘

// 2. è¡¥è´´ç®¡ç†å™¨æ ¸å¿ƒé€»è¾‘ (ConsumeSubsidyManager.java)
ConsumeSubsidyManager.java:587
- TODO: å®ç°å±æ€§æ‹·è´

ConsumeSubsidyManager.java:609
- TODO: å®ç°Formåˆ°Entityçš„è½¬æ¢

ConsumeSubsidyManager.java:617
- TODO: å®ç°æ›´æ–°é€»è¾‘
```

**P1çº§ - é‡è¦åŠŸèƒ½** (12é¡¹):

```java
// 1. è¡¥è´´å‘æ”¾å’Œä½œåºŸ (ConsumeSubsidyManager.java)
ConsumeSubsidyManager.java:630
- TODO: å®ç°è¡¥è´´å‘æ”¾é€»è¾‘

ConsumeSubsidyManager.java:653
- TODO: å®ç°æ‰¹é‡å‘æ”¾é€»è¾‘

ConsumeSubsidyManager.java:683
- TODO: å®ç°ä½œåºŸé€»è¾‘

ConsumeSubsidyManager.java:727
- TODO: å®ç°å»¶æœŸé€»è¾‘

ConsumeSubsidyManager.java:753
- TODO: å®ç°ç»Ÿè®¡é€»è¾‘

// 2. æŠ¥è¡¨å¯¼å‡º (ConsumeReportServiceImpl.java)
ConsumeReportServiceImpl.java:372
- TODO: å®é™…çš„æŠ¥è¡¨å¯¼å‡ºé€»è¾‘

// 3. è®¾å¤‡é€šè®¯åè®® (ConsumeZktecoV10Adapter.java)
- å¤šä¸ªTODOæ¶‰åŠè®¾å¤‡éªŒè¯å’Œæ•°æ®åŒæ­¥
```

**P2çº§ - ä¼˜åŒ–é¡¹** (13é¡¹):

```java
// ä¸»è¦æ˜¯è®¾å¤‡é€šè®¯åè®®é€‚é…å™¨å’Œå¼‚å¸¸å¤„ç†ç›¸å…³
```

#### ğŸ¯ ä¼ä¸šçº§å®ç°å»ºè®®

**1. è¡¥è´´å®¡æ ¸å’Œå‘æ”¾å®ç°æ–¹æ¡ˆ** (P0çº§)

```java
/**
 * ä¼ä¸šçº§è¡¥è´´ç®¡ç†æœåŠ¡
 */
@Service
@Slf4j
public class ConsumeSubsidyServiceImpl implements ConsumeSubsidyService {

    @Resource
    private ConsumeSubsidyDao consumeSubsidyDao;
    @Resource
    private ConsumeAccountDao consumeAccountDao;
    @Resource
    private GatewayServiceClient gatewayServiceClient;
    @Resource
    private RabbitTemplate rabbitTemplate;

    /**
     * P0: è¡¥è´´å®¡æ ¸
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public void approveSubsidy(Long subsidyId, Long approverId, String remark) {
        log.info("[è¡¥è´´å®¡æ ¸] å¼€å§‹å®¡æ ¸: subsidyId={}, approverId={}", subsidyId, approverId);

        // 1. æŸ¥è¯¢è¡¥è´´ç”³è¯·
        ConsumeSubsidyEntity subsidy = consumeSubsidyDao.selectById(subsidyId);
        if (subsidy == null) {
            throw new BusinessException("SUBSIDY_NOT_FOUND", "è¡¥è´´ç”³è¯·ä¸å­˜åœ¨");
        }

        // 2. æ£€æŸ¥çŠ¶æ€
        if (subsidy.getAuditStatus() != SubsidyAuditStatus.PENDING) {
            throw new BusinessException("SUBSIDY_STATUS_ERROR", "è¡¥è´´ç”³è¯·çŠ¶æ€ä¸æ­£ç¡®");
        }

        // 3. æ£€æŸ¥å®¡æ‰¹æƒé™
        if (!hasApprovalPermission(approverId, subsidy)) {
            throw new BusinessException("NO_PERMISSION", "æ— å®¡æ‰¹æƒé™");
        }

        // 4. æ›´æ–°å®¡æ ¸çŠ¶æ€
        subsidy.setAuditStatus(SubsidyAuditStatus.APPROVED);
        subsidy.setApproverId(approverId);
        subsidy.setApproveTime(LocalDateTime.now());
        subsidy.setApproveRemark(remark);
        consumeSubsidyDao.updateById(subsidy);

        // 5. è§¦å‘è¡¥è´´å‘æ”¾
        if (subsidy.getSubsidyType() == SubsidyType.IMMEDIATE) {
            // ç«‹å³å‘æ”¾
            disburseSubsidy(subsidy);
        } else {
            // å®šæ—¶å‘æ”¾ï¼ˆå¦‚æ¯æœˆç»Ÿä¸€å‘æ”¾ï¼‰
            scheduleSubsidyDisbursement(subsidy);
        }

        // 6. å‘é€é€šçŸ¥
        sendNotification(subsidy, SubsidyNotificationType.APPROVED);

        log.info("[è¡¥è´´å®¡æ ¸] å®¡æ ¸é€šè¿‡: subsidyId={}, amount={}", subsidyId, subsidy.getAmount());
    }

    /**
     * P0: è¡¥è´´æ‹’ç»
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public void rejectSubsidy(Long subsidyId, Long approverId, String reason) {
        log.info("[è¡¥è´´æ‹’ç»] æ‹’ç»è¡¥è´´: subsidyId={}, approverId={}, reason={}",
            subsidyId, approverId, reason);

        // 1. æŸ¥è¯¢è¡¥è´´ç”³è¯·
        ConsumeSubsidyEntity subsidy = consumeSubsidyDao.selectById(subsidyId);
        if (subsidy == null) {
            throw new BusinessException("SUBSIDY_NOT_FOUND", "è¡¥è´´ç”³è¯·ä¸å­˜åœ¨");
        }

        // 2. æ›´æ–°çŠ¶æ€ä¸ºæ‹’ç»
        subsidy.setAuditStatus(SubsidyAuditStatus.REJECTED);
        subsidy.setApproverId(approverId);
        subsidy.setApproveTime(LocalDateTime.now());
        subsidy.setApproveRemark(reason);
        consumeSubsidyDao.updateById(subsidy);

        // 3. å‘é€é€šçŸ¥
        sendNotification(subsidy, SubsidyNotificationType.REJECTED);

        log.info("[è¡¥è´´æ‹’ç»] å·²æ‹’ç»: subsidyId={}", subsidyId);
    }

    /**
     * P0: è¡¥è´´å‘æ”¾é€»è¾‘
     */
    private void disburseSubsidy(ConsumeSubsidyEntity subsidy) {
        log.info("[è¡¥è´´å‘æ”¾] å¼€å§‹å‘æ”¾: subsidyId={}, userId={}, amount={}",
            subsidy.getSubsidyId(), subsidy.getUserId(), subsidy.getAmount());

        // 1. æŸ¥è¯¢æ¶ˆè´¹è´¦æˆ·
        ConsumeAccountEntity account = consumeAccountDao.selectByUserId(subsidy.getUserId());
        if (account == null) {
            throw new BusinessException("ACCOUNT_NOT_FOUND", "æ¶ˆè´¹è´¦æˆ·ä¸å­˜åœ¨");
        }

        // 2. æ£€æŸ¥è´¦æˆ·çŠ¶æ€
        if (account.getAccountStatus() != AccountStatus.NORMAL) {
            throw new BusinessException("ACCOUNT_STATUS_ERROR", "è´¦æˆ·çŠ¶æ€å¼‚å¸¸");
        }

        // 3. æ›´æ–°è´¦æˆ·ä½™é¢
        BigDecimal newBalance = account.getBalance().add(subsidy.getAmount());
        account.setBalance(newBalance);
        consumeAccountDao.updateById(account);

        // 4. ç”Ÿæˆæ¶ˆè´¹æµæ°´
        ConsumeTransactionEntity transaction = new ConsumeTransactionEntity();
        transaction.setTransactionId(UUID.randomUUID().toString());
        transaction.setUserId(subsidy.getUserId());
        transaction.setAccountId(account.getAccountId());
        transaction.setTransactionType(TransactionType.SUBSIDY);
        transaction.setAmount(subsidy.getAmount());
        transaction.setBalanceBefore(account.getBalance().subtract(subsidy.getAmount()));
        transaction.setBalanceAfter(newBalance);
        transaction.setTransactionTime(LocalDateTime.now());
        transaction.setRelatedId(subsidy.getSubsidyId().toString());
        transaction.setRemark("è¡¥è´´å‘æ”¾: " + subsidy.getSubsidyName());

        consumeTransactionDao.insert(transaction);

        // 5. æ›´æ–°è¡¥è´´å‘æ”¾çŠ¶æ€
        subsidy.setDisbursementStatus(DisbursementStatus.DISBURSED);
        subsidy.setDisbursementTime(LocalDateTime.now());
        subsidy.setTransactionId(transaction.getTransactionId());
        consumeSubsidyDao.updateById(subsidy);

        // 6. å‘é€é€šçŸ¥
        sendNotification(subsidy, SubsidyNotificationType.DISBURSED);

        log.info("[è¡¥è´´å‘æ”¾] å‘æ”¾æˆåŠŸ: subsidyId={}, transactionId={}, newBalance={}",
            subsidy.getSubsidyId(), transaction.getTransactionId(), newBalance);
    }

    /**
     * P0: æ‰¹é‡å‘æ”¾è¡¥è´´
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public BatchDisbursementResult batchDisburse(List<Long> subsidyIds) {
        log.info("[æ‰¹é‡å‘æ”¾] å¼€å§‹æ‰¹é‡å‘æ”¾: count={}", subsidyIds.size());

        int successCount = 0;
        int failureCount = 0;
        List<String> failedIds = new ArrayList<>();

        for (Long subsidyId : subsidyIds) {
            try {
                ConsumeSubsidyEntity subsidy = consumeSubsidyDao.selectById(subsidyId);
                if (subsidy != null &&
                    subsidy.getAuditStatus() == SubsidyAuditStatus.APPROVED &&
                    subsidy.getDisbursementStatus() == DisbursementStatus.PENDING) {

                    disburseSubsidy(subsidy);
                    successCount++;
                } else {
                    failedIds.add(subsidyId.toString());
                    failureCount++;
                }
            } catch (Exception e) {
                log.error("[æ‰¹é‡å‘æ”¾] å‘æ”¾å¤±è´¥: subsidyId={}, error={}", subsidyId, e.getMessage());
                failedIds.add(subsidyId.toString());
                failureCount++;
            }
        }

        log.info("[æ‰¹é‡å‘æ”¾] æ‰¹é‡å‘æ”¾å®Œæˆ: total={}, success={}, failure={}",
            subsidyIds.size(), successCount, failureCount);

        return BatchDisbursementResult.builder()
            .totalCount(subsidyIds.size())
            .successCount(successCount)
            .failureCount(failureCount)
            .failedIds(failedIds)
            .build();
    }

    /**
     * P1: è¡¥è´´ç»Ÿè®¡
     */
    @Override
    public SubsidyStatisticsVO getStatistics(SubsidyStatisticsQueryForm form) {
        log.info("[è¡¥è´´ç»Ÿè®¡] æŸ¥è¯¢ç»Ÿè®¡: startDate={}, endDate={}, departmentId={}",
            form.getStartDate(), form.getEndDate(), form.getDepartmentId());

        // 1. æŸ¥è¯¢è¡¥è´´åˆ—è¡¨
        LambdaQueryWrapper<ConsumeSubsidyEntity> wrapper = new LambdaQueryWrapper<>();
        wrapper.between(form.getStartDate() != null && form.getEndDate() != null,
            ConsumeSubsidyEntity::getCreateTime, form.getStartDate(), form.getEndDate());
        wrapper.eq(form.getDepartmentId() != null,
            ConsumeSubsidyEntity::getDepartmentId, form.getDepartmentId());
        wrapper.eq(form.getSubsidyType() != null,
            ConsumeSubsidyEntity::getSubsidyType, form.getSubsidyType());

        List<ConsumeSubsidyEntity> subsidies = consumeSubsidyDao.selectList(wrapper);

        // 2. ç»Ÿè®¡åˆ†æ
        SubsidyStatisticsVO stats = new SubsidyStatisticsVO();

        // æ€»é‡‘é¢
        BigDecimal totalAmount = subsidies.stream()
            .map(ConsumeSubsidyEntity::getAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        stats.setTotalAmount(totalAmount);

        // æŒ‰çŠ¶æ€åˆ†ç»„
        Map<SubsidyAuditStatus, Long> statusCount = subsidies.stream()
            .collect(Collectors.groupingBy(
                ConsumeSubsidyEntity::getAuditStatus,
                Collectors.counting()
            ));
        stats.setStatusCount(statusCount);

        // æŒ‰ç±»å‹åˆ†ç»„
        Map<SubsidyType, BigDecimal> typeAmount = subsidies.stream()
            .collect(Collectors.groupingBy(
                ConsumeSubsidyEntity::getSubsidyType,
                Collectors.reducing(BigDecimal.ZERO, ConsumeSubsidyEntity::getAmount, BigDecimal::add)
            ));
        stats.setTypeAmount(typeAmount);

        // æŒ‰éƒ¨é—¨åˆ†ç»„
        Map<Long, BigDecimal> departmentAmount = subsidies.stream()
            .collect(Collectors.groupingBy(
                ConsumeSubsidyEntity::getDepartmentId,
                Collectors.reducing(BigDecimal.ZERO, ConsumeSubsidyEntity::getAmount, BigDecimal::add)
            ));
        stats.setDepartmentAmount(departmentAmount);

        // è¶‹åŠ¿æ•°æ®
        Map<LocalDate, BigDecimal> trendData = subsidies.stream()
            .collect(Collectors.groupingBy(
                s -> s.getCreateTime().toLocalDate(),
                TreeMap::new,
                Collectors.reducing(BigDecimal.ZERO, ConsumeSubsidyEntity::getAmount, BigDecimal::add)
            ));
        stats.setTrendData(trendData);

        return stats;
    }
}
```

#### ğŸ“Š ä¸šåŠ¡å®Œæ•´æ€§è¯„ä¼°

| åŠŸèƒ½æ¨¡å— | å®Œæˆåº¦ | å¾…åŠé¡¹ | å»ºè®® |
|---------|--------|--------|------|
| **è´¦æˆ·ç®¡ç†** | 95% | 0 | åŠŸèƒ½å®Œæ•´ âœ… |
| **æ¶ˆè´¹æ”¯ä»˜** | 90% | 2 | ä¼˜åŒ–ç¦»çº¿æ¨¡å¼ |
| **è¡¥è´´å‘æ”¾** | 60% | 6 | **å®ç°æ ¸å¿ƒé€»è¾‘** |
| **è¡¥è´´å®¡æ ¸** | 55% | 3 | **å®ç°å®¡æ ¸æµç¨‹** |
| **æŠ¥è¡¨ç»Ÿè®¡** | 70% | 1 | å®Œå–„å¯¼å‡ºåŠŸèƒ½ |
| **è®¾å¤‡é€šè®¯** | 75% | 8 | å®Œå–„åè®®é€‚é… |

---

### 4. è§†é¢‘ç›‘æ§æ¨¡å— (Video Service)

**æ¨¡å—æ ‡è¯†**: `ioedream-video-service` (ç«¯å£: 8092)
**å¾…åŠæ•°é‡**: 87æ¡
**å®Œæˆåº¦**: 60%

#### ğŸ“‹ æ ¸å¿ƒä¸šåŠ¡æµç¨‹

```
ã€è¾¹ç¼˜AIè®¡ç®—æ¨¡å¼ã€‘ï¼ˆæ¡†æ¶å·²æ­å»ºï¼Œæ ¸å¿ƒåŠŸèƒ½å¾…å®ç° âŒï¼‰
â”œâ”€â”€ è®¾å¤‡ç«¯: AIåˆ†æ+äººè„¸è¯†åˆ«+è¡Œä¸ºæ£€æµ‹
â”œâ”€â”€ æœåŠ¡å™¨: æ¥æ”¶ç»“æ„åŒ–æ•°æ®+å‘Šè­¦è§„åˆ™åŒ¹é…
â”œâ”€â”€ äººè„¸ç®¡ç†: ç‰¹å¾æå–+åº•åº“ç®¡ç†+ä»¥å›¾æœå›¾
â””â”€â”€ è¡Œä¸ºåˆ†æ: åŒºåŸŸå…¥ä¾µ+å¾˜å¾Šæ£€æµ‹+èšé›†å‘Šè­¦

ã€äº‘å°æ§åˆ¶ã€‘(PTZ) - éƒ¨åˆ†å®ç° âš ï¸
â”œâ”€â”€ äº‘å°è½¬åŠ¨ (VideoPTZManager.java) - 2ä¸ªTODO
â”œâ”€â”€ é¢„ç½®ä½ç®¡ç†
â””â”€â”€ å·¡èˆªè·¯å¾„è§„åˆ’
```

#### ğŸš¨ å¾…åŠäº‹é¡¹åˆ†ç±»

**P0çº§ - å…³é”®ä»»åŠ¡** (18é¡¹):

```java
// 1. è§†é¢‘å½•åƒç®¡ç† (VideoRecordingServiceImpl.java) - 20ä¸ªTODO
æ ¸å¿ƒå¾…åŠ:
- TODO: å®ç°å½•åƒè®¡åˆ’åˆ›å»ºé€»è¾‘
- TODO: å®ç°å½•åƒå¯åœæ§åˆ¶
- TODO: å®ç°å½•åƒæ–‡ä»¶å­˜å‚¨
- TODO: å®ç°å½•åƒå›æ”¾åŠŸèƒ½
- TODO: å®ç°å½•åƒä¸‹è½½åŠŸèƒ½
- TODO: å®ç°å½•åƒåˆ é™¤é€»è¾‘
... (å…±20ä¸ªæ ¸å¿ƒå¾…åŠ)

// 2. è§†é¢‘æµç®¡ç† (VideoStreamServiceImpl.java) - 3ä¸ªTODO
- TODO: å®ç°å®æ—¶æµæ’­æ”¾
- TODO: å®ç°æµè½¬æ¢é€»è¾‘
- TODO: å®ç°æµåˆ†å‘ä¼˜åŒ–

// 3. è§†é¢‘å¢™ç®¡ç† (VideoWallServiceImpl.java) - 3ä¸ªTODO
- TODO: å®ç°è§†é¢‘å¢™å¸ƒå±€
- TODO: å®ç°ç”»é¢åˆ‡æ¢
- TODO: å®ç°è½®å·¡æ’­æ”¾
```

**P1çº§ - é‡è¦åŠŸèƒ½** (31é¡¹):

```java
// 1. AIåˆ†ææœåŠ¡ (VideoAiAnalysisServiceImpl.java) - 5ä¸ªTODO
- TODO: å®ç°äººè„¸è¯†åˆ«åˆ†æ
- TODO: å®ç°è¡Œä¸ºæ£€æµ‹åˆ†æ
- TODO: å®ç°å‘Šè­¦è§„åˆ™åŒ¹é…
- TODO: å®ç°äº‹ä»¶æ¨é€é€»è¾‘
- TODO: å®ç°ç»Ÿè®¡åˆ†æåŠŸèƒ½

// 2. äººè„¸ç®¡ç† (VideoFaceManager.java) - 3ä¸ªTODO
- TODO: å®ç°äººè„¸ç‰¹å¾æå–
- TODO: å®ç°äººè„¸åº•åº“ç®¡ç†
- TODO: å®ç°ä»¥å›¾æœå›¾åŠŸèƒ½

// 3. è¡Œä¸ºæ£€æµ‹ç®¡ç†å™¨ (VideoBehaviorManager.java) - 2ä¸ªTODO
- TODO: å®ç°åŒºåŸŸå…¥ä¾µæ£€æµ‹
- TODO: å®ç°å¾˜å¾Šæ£€æµ‹é€»è¾‘

// 4. è¡Œä¸ºæ£€æµ‹å¼•æ“ (BehaviorDetectionManager.java) - 3ä¸ªTODO
- TODO: å®ç°è§†é¢‘å¸§æå–
- TODO: å®ç°ç›®æ ‡æ£€æµ‹
- TODO: å®ç°è½¨è¿¹åˆ†æ
```

**P2çº§ - ä¼˜åŒ–é¡¹** (38é¡¹):

```java
// ä¸»è¦æ˜¯åè®®é€‚é…å™¨å’Œç›‘æ§ç›¸å…³
RTSPAdapter.java - 2ä¸ªTODO
RTMPAdapter.java - 2ä¸ªTODO
HTTPAdapter.java - 2ä¸ªTODO
...ä»¥åŠå…¶ä»–ä¼˜åŒ–é¡¹
```

#### ğŸ¯ ä¼ä¸šçº§å®ç°å»ºè®®

**1. è§†é¢‘å½•åƒç®¡ç†å®ç°æ–¹æ¡ˆ** (P0çº§)

```java
/**
 * ä¼ä¸šçº§è§†é¢‘å½•åƒæœåŠ¡
 */
@Service
@Slf4j
public class VideoRecordingServiceImpl implements VideoRecordingService {

    @Resource
    private VideoRecordingDao videoRecordingDao;
    @Resource
    private VideoDeviceDao videoDeviceDao;
    @Resource
    private StorageService storageService; // MinIO/é˜¿é‡Œäº‘OSS
    @Resource
    private RedisTemplate<String, Object> redisTemplate;
    @Resource
    private FfmpegExecutor ffmpegExecutor;

    /**
     * P0: åˆ›å»ºå½•åƒè®¡åˆ’
     */
    @Override
    public Long createRecordingPlan(RecordingPlanForm form) {
        log.info("[å½•åƒè®¡åˆ’] åˆ›å»ºå½•åƒè®¡åˆ’: deviceId={}, planType={}",
            form.getDeviceId(), form.getPlanType());

        // 1. éªŒè¯è®¾å¤‡
        VideoDeviceEntity device = videoDeviceDao.selectById(form.getDeviceId());
        if (device == null) {
            throw new BusinessException("DEVICE_NOT_FOUND", "è®¾å¤‡ä¸å­˜åœ¨");
        }

        // 2. åˆ›å»ºå½•åƒè®¡åˆ’
        VideoRecordingPlanEntity plan = new VideoRecordingPlanEntity();
        plan.setPlanId(UUID.randomUUID().toString());
        plan.setDeviceId(form.getDeviceId());
        plan.setPlanName(form.getPlanName());
        plan.setPlanType(form.getPlanType()); // å…¨å¤©å½•åƒ/åŠ¨æ€å½•åƒ/æ‰‹åŠ¨å½•åƒ

        // æ—¶é—´æ®µé…ç½®
        plan.setStartTime(form.getStartTime());
        plan.setEndTime(form.getEndTime());
        plan.setWeekdays(form.getWeekdays()); // å‘¨ä¸€åˆ°å‘¨æ—¥

        // å­˜å‚¨é…ç½®
        plan.setStoragePath(configureStoragePath(device));
        plan.setRetentionDays(form.getRetentionDays()); // ä¿ç•™å¤©æ•°
        plan.setMaxFileSize(form.getMaxFileSize()); // å•æ–‡ä»¶æœ€å¤§å¤§å°

        // ç¼–ç å‚æ•°
        plan.setVideoCodec(form.getVideoCodec()); // H264/H265
        plan.setResolution(form.getResolution()); // 1080P/720P
        plan.setFrameRate(form.getFrameRate()); // 25fps
        plan.setBitrate(form.getBitrate()); // ç ç‡

        plan.setPlanStatus(RecordingPlanStatus.ACTIVE);
        videoRecordingPlanDao.insert(plan);

        // 3. å¯åŠ¨å½•åƒä»»åŠ¡
        if (plan.getPlanStatus() == RecordingPlanStatus.ACTIVE) {
            startRecordingTask(plan);
        }

        log.info("[å½•åƒè®¡åˆ’] åˆ›å»ºæˆåŠŸ: planId={}, deviceId={}", plan.getPlanId(), device.getDeviceId());

        return plan.getPlanId();
    }

    /**
     * P0: å¯åŠ¨å½•åƒä»»åŠ¡
     */
    private void startRecordingTask(VideoRecordingPlanEntity plan) {
        log.info("[å½•åƒä»»åŠ¡] å¯åŠ¨å½•åƒ: planId={}, deviceId={}",
            plan.getPlanId(), plan.getDeviceId());

        // 1. æŸ¥è¯¢è®¾å¤‡æµåœ°å€
        VideoDeviceEntity device = videoDeviceDao.selectById(plan.getDeviceId());
        String streamUrl = device.getRtspUrl(); // RTSPæµåœ°å€

        // 2. æ„å»ºå­˜å‚¨è·¯å¾„
        String datePath = LocalDate.now().format(DateTimeFormatter.ISO_DATE);
        String storagePath = String.format("%s/%s/%s.mp4",
            plan.getStoragePath(), datePath, UUID.randomUUID());

        // 3. å¯åŠ¨FFmpegå½•åƒ
        RecordingParams params = RecordingParams.builder()
            .streamUrl(streamUrl)
            .storagePath(storagePath)
            .videoCodec(plan.getVideoCodec())
            .resolution(plan.getResolution())
            .frameRate(plan.getFrameRate())
            .bitrate(plan.getBitrate())
            .maxFileSize(plan.getMaxFileSize())
            .segmentTime(300) // 5åˆ†é’Ÿä¸€ä¸ªåˆ†æ®µ
            .build();

        // å¼‚æ­¥å¯åŠ¨å½•åƒ
        CompletableFuture.runAsync(() -> {
            try {
                ffmpegExecutor.startRecording(params);

                // 4. åˆ›å»ºå½•åƒè®°å½•
                VideoRecordingEntity recording = new VideoRecordingEntity();
                recording.setRecordingId(UUID.randomUUID().toString());
                recording.setPlanId(plan.getPlanId());
                recording.setDeviceId(plan.getDeviceId());
                recording.setStartTime(LocalDateTime.now());
                recording.setStoragePath(storagePath);
                recording.setFileSize(0L);
                recording.setRecordingStatus(RecordingStatus.RECORDING);
                videoRecordingDao.insert(recording);

                // 5. ç¼“å­˜å½•åƒä¿¡æ¯
                String cacheKey = "recording:active:" + plan.getDeviceId();
                redisTemplate.opsForValue().set(cacheKey, recording, 1, TimeUnit.HOURS);

                log.info("[å½•åƒä»»åŠ¡] å½•åƒå¯åŠ¨æˆåŠŸ: recordingId={}, path={}",
                    recording.getRecordingId(), storagePath);

            } catch (Exception e) {
                log.error("[å½•åƒä»»åŠ¡] å¯åŠ¨å¤±è´¥: deviceId={}, error={}",
                    plan.getDeviceId(), e.getMessage(), e);
            }
        });
    }

    /**
     * P0: åœæ­¢å½•åƒ
     */
    @Override
    public void stopRecording(Long deviceId) {
        log.info("[å½•åƒä»»åŠ¡] åœæ­¢å½•åƒ: deviceId={}", deviceId);

        // 1. æŸ¥è¯¢æ´»åŠ¨å½•åƒ
        String cacheKey = "recording:active:" + deviceId;
        VideoRecordingEntity recording = (VideoRecordingEntity) redisTemplate.opsForValue().get(cacheKey);

        if (recording == null) {
            throw new BusinessException("NO_ACTIVE_RECORDING", "æ— æ´»åŠ¨å½•åƒ");
        }

        // 2. åœæ­¢FFmpegå½•åƒ
        ffmpegExecutor.stopRecording(recording.getRecordingId());

        // 3. æ›´æ–°å½•åƒè®°å½•
        recording.setEndTime(LocalDateTime.now());
        recording.setRecordingStatus(RecordingStatus.STOPPED);

        // 4. è·å–æ–‡ä»¶å¤§å°
        File file = new File(recording.getStoragePath());
        if (file.exists()) {
            recording.setFileSize(file.length());
        }

        videoRecordingDao.updateById(recording);

        // 5. æ¸…é™¤ç¼“å­˜
        redisTemplate.delete(cacheKey);

        log.info("[å½•åƒä»»åŠ¡] å½•åƒåœæ­¢æˆåŠŸ: recordingId={}, duration={}min, size={}MB",
            recording.getRecordingId(),
            ChronoUnit.MINUTES.between(recording.getStartTime(), recording.getEndTime()),
            recording.getFileSize() / 1024 / 1024);
    }

    /**
     * P0: å½•åƒå›æ”¾
     */
    @Override
    public String playbackRecording(String recordingId, Integer startTime, Integer endTime) {
        log.info("[å½•åƒå›æ”¾] recordingId={}, startTime={}s, endTime={}s",
            recordingId, startTime, endTime);

        // 1. æŸ¥è¯¢å½•åƒè®°å½•
        VideoRecordingEntity recording = videoRecordingDao.selectById(recordingId);
        if (recording == null) {
            throw new BusinessException("RECORDING_NOT_FOUND", "å½•åƒä¸å­˜åœ¨");
        }

        // 2. éªŒè¯æ–‡ä»¶å­˜åœ¨
        File file = new File(recording.getStoragePath());
        if (!file.exists()) {
            throw new BusinessException("FILE_NOT_FOUND", "å½•åƒæ–‡ä»¶ä¸å­˜åœ¨");
        }

        // 3. ä½¿ç”¨FFmpegè¿›è¡Œè½¬ç å’Œæµå¼ä¼ è¾“
        String streamUrl = ffmpegExecutor.startStreaming(
            recording.getStoragePath(),
            startTime,
            endTime
        );

        log.info("[å½•åƒå›æ”¾] å›æ”¾åœ°å€: recordingId={}, streamUrl={}", recordingId, streamUrl);

        return streamUrl;
    }

    /**
     * P0: å½•åƒä¸‹è½½
     */
    @Override
    public String downloadRecording(String recordingId) {
        log.info("[å½•åƒä¸‹è½½] recordingId={}", recordingId);

        // 1. æŸ¥è¯¢å½•åƒè®°å½•
        VideoRecordingEntity recording = videoRecordingDao.selectById(recordingId);
        if (recording == null) {
            throw new BusinessException("RECORDING_NOT_FOUND", "å½•åƒä¸å­˜åœ¨");
        }

        // 2. ç”Ÿæˆä¸´æ—¶ä¸‹è½½URL
        String downloadUrl = storageService.generateDownloadUrl(
            recording.getStoragePath(),
            Duration.ofHours(1) // 1å°æ—¶æœ‰æ•ˆæœŸ
        );

        log.info("[å½•åƒä¸‹è½½] ä¸‹è½½åœ°å€: recordingId={}, url={}", recordingId, downloadUrl);

        return downloadUrl;
    }
}
```

**2. AIåˆ†ææœåŠ¡å®ç°æ–¹æ¡ˆ** (P1çº§)

```java
/**
 * ä¼ä¸šçº§è§†é¢‘AIåˆ†ææœåŠ¡
 */
@Service
@Slf4j
public class VideoAiAnalysisServiceImpl implements VideoAiAnalysisService {

    @Resource
    private VideoDeviceDao videoDeviceDao;
    @Resource
    private AiEventDao aiEventDao;
    @Resource
    private VideoFaceManager videoFaceManager;
    @Resource
    private BehaviorDetectionManager behaviorDetectionManager;
    @Resource
    private AlertManager alertManager;

    /**
     * P1: å¯åŠ¨äººè„¸è¯†åˆ«åˆ†æ
     */
    @Override
    public void startFaceAnalysis(Long deviceId, FaceAnalysisConfig config) {
        log.info("[äººè„¸è¯†åˆ«] å¯åŠ¨åˆ†æ: deviceId={}, sensitivity={}",
            deviceId, config.getSensitivity());

        // 1. éªŒè¯è®¾å¤‡
        VideoDeviceEntity device = videoDeviceDao.selectById(deviceId);
        if (device == null) {
            throw new BusinessException("DEVICE_NOT_FOUND", "è®¾å¤‡ä¸å­˜åœ¨");
        }

        // 2. åŠ è½½äººè„¸åº•åº“
        List<FaceFeature> faceDatabase = videoFaceManager.loadFaceDatabase(config.getDatabaseType());

        // 3. å¯åŠ¨å¼‚æ­¥åˆ†æä»»åŠ¡
        CompletableFuture.runAsync(() -> {
            try {
                // 3.1 è¿æ¥è§†é¢‘æµ
                String rtspUrl = device.getRtspUrl();
                FFmpegFrameGrabber grabber = new FFmpegFrameGrabber(rtspUrl);
                grabber.start();

                // 3.2 äººè„¸æ£€æµ‹å™¨
                FaceDetector faceDetector = new FaceDetector(config.getModelPath());

                // 3.3 äººè„¸è¯†åˆ«å™¨
                FaceRecognizer faceRecognizer = new FaceRecognizer(config.getRecognizerPath());

                OpenCVFrameConverter.ToMat converter = new OpenCVFrameConverter.ToMat();

                // 3.4 å¾ªç¯å¤„ç†æ¯ä¸€å¸§
                Frame frame;
                while ((frame = grabber.grabImage()) != null) {
                    try {
                        // è½¬æ¢ä¸ºOpenCV Mat
                        Mat mat = converter.convert(frame);

                        // æ£€æµ‹äººè„¸
                        List<Face> faces = faceDetector.detect(mat);

                        for (Face face : faces) {
                            // æå–ç‰¹å¾
                            float[] feature = faceRecognizer.extractFeature(mat, face);

                            // 1:Næ¯”å¯¹
                            FaceMatchResult matchResult = videoFaceManager.match(feature, faceDatabase);

                            if (matchResult.isMatch() && matchResult.getScore() > config.getSensitivity()) {
                                // åŒ¹é…æˆåŠŸï¼Œåˆ›å»ºäº‹ä»¶
                                AiFaceEventEntity event = new AiFaceEventEntity();
                                event.setEventId(UUID.randomUUID().toString());
                                event.setDeviceId(deviceId);
                                event.setEventType(AiEventType.FACE_RECOGNIZED);
                                event.setPersonId(matchResult.getPersonId());
                                event.setPersonName(matchResult.getPersonName());
                                event.setConfidence(matchResult.getScore());
                                event.setEventTime(LocalDateTime.now());
                                event.setFaceImage(face.getFaceImage()); // äººè„¸æˆªå›¾
                                event.setSceneImage(mat); // åœºæ™¯å›¾

                                aiEventDao.insert(event);

                                // å‘Šè­¦æ£€æŸ¥
                                if (config.getAlertPersonIds().contains(matchResult.getPersonId())) {
                                    // é‡ç‚¹äººå‘˜å‘Šè­¦
                                    alertManager.sendAlert(AlertLevel.HIGH,
                                        "é‡ç‚¹äººå‘˜è¯†åˆ«: " + matchResult.getPersonName(),
                                        event);
                                }

                                log.debug("[äººè„¸è¯†åˆ«] è¯†åˆ«æˆåŠŸ: personName={}, score={}",
                                    matchResult.getPersonName(), matchResult.getScore());
                            }
                        }

                    } catch (Exception e) {
                        log.error("[äººè„¸è¯†åˆ«] å¸§å¤„ç†å¼‚å¸¸: {}", e.getMessage());
                    }
                }

                grabber.stop();

            } catch (Exception e) {
                log.error("[äººè„¸è¯†åˆ«] åˆ†æä»»åŠ¡å¼‚å¸¸: deviceId={}, error={}",
                    deviceId, e.getMessage(), e);
            }
        });
    }

    /**
     * P1: å¯åŠ¨è¡Œä¸ºæ£€æµ‹åˆ†æ
     */
    @Override
    public void startBehaviorAnalysis(Long deviceId, BehaviorDetectionConfig config) {
        log.info("[è¡Œä¸ºæ£€æµ‹] å¯åŠ¨åˆ†æ: deviceId={}, detectionTypes={}",
            deviceId, config.getDetectionTypes());

        // 1. éªŒè¯è®¾å¤‡
        VideoDeviceEntity device = videoDeviceDao.selectById(deviceId);

        // 2. å¯åŠ¨å¼‚æ­¥åˆ†æä»»åŠ¡
        CompletableFuture.runAsync(() -> {
            try {
                // 2.1 è¿æ¥è§†é¢‘æµ
                FFmpegFrameGrabber grabber = new FFmpegFrameGrabber(device.getRtspUrl());
                grabber.start();

                // 2.2 ç›®æ ‡æ£€æµ‹å™¨ï¼ˆYOLOï¼‰
                ObjectDetector objectDetector = new ObjectDetector(config.getModelPath());

                // 2.3 è½¨è¿¹è·Ÿè¸ªå™¨
                MultiObjectTracker tracker = new MultiObjectTracker();

                OpenCVFrameConverter.ToMat converter = new OpenCVFrameConverter.ToMat();

                Frame frame;
                while ((frame = grabber.grabImage()) != null) {
                    Mat mat = converter.convert(frame);

                    // æ£€æµ‹æ‰€æœ‰ç›®æ ‡
                    List<DetectedObject> objects = objectDetector.detect(mat);

                    // æ›´æ–°è½¨è¿¹
                    tracker.updateTracks(objects);

                    // è¡Œä¸ºåˆ†æ
                    for (Track track : tracker.getActiveTracks()) {
                        // åŒºåŸŸå…¥ä¾µæ£€æµ‹
                        if (config.isRegionIntrusionEnabled()) {
                            checkRegionIntrusion(track, config.getRegions(), deviceId);
                        }

                        // å¾˜å¾Šæ£€æµ‹
                        if (config.isLoiteringEnabled()) {
                            checkLoitering(track, config.getLoiteringThreshold(), deviceId);
                        }

                        // èšé›†æ£€æµ‹
                        if (config.isCrowdGatheringEnabled()) {
                            checkCrowdGathering(tracker.getActiveTracks(),
                                config.getCrowdThreshold(), deviceId);
                        }
                    }
                }

                grabber.stop();

            } catch (Exception e) {
                log.error("[è¡Œä¸ºæ£€æµ‹] åˆ†æä»»åŠ¡å¼‚å¸¸: {}", e.getMessage(), e);
            }
        });
    }

    /**
     * åŒºåŸŸå…¥ä¾µæ£€æµ‹
     */
    private void checkRegionIntrusion(Track track, List<DetectionRegion> regions, Long deviceId) {
        // 1. è·å–å½“å‰ä½ç½®
        Point currentPosition = track.getLastPosition();

        // 2. æ£€æŸ¥æ˜¯å¦åœ¨å…¥ä¾µåŒºåŸŸ
        for (DetectionRegion region : regions) {
            if (region.contains(currentPosition)) {
                // 3. åˆ›å»ºå…¥ä¾µäº‹ä»¶
                AiBehaviorEventEntity event = new AiBehaviorEventEntity();
                event.setEventId(UUID.randomUUID().toString());
                event.setDeviceId(deviceId);
                event.setEventType(AiEventType.REGION_INTRUSION);
                event.setObjectId(track.getObjectId());
                event.setRegionId(region.getRegionId());
                event.setRegionName(region.getRegionName());
                event.setEventTime(LocalDateTime.now());
                event.setConfidence(track.getConfidence());
                event.setTrajectoryImage(track.getTrajectoryImage());

                aiEventDao.insert(event);

                // 4. å‘é€å‘Šè­¦
                alertManager.sendAlert(AlertLevel.MEDIUM,
                    "åŒºåŸŸå…¥ä¾µæ£€æµ‹: " + region.getRegionName(),
                    event);

                log.warn("[è¡Œä¸ºæ£€æµ‹] åŒºåŸŸå…¥ä¾µ: region={}, objectId={}",
                    region.getRegionName(), track.getObjectId());
            }
        }
    }

    /**
     * å¾˜å¾Šæ£€æµ‹
     */
    private void checkLoitering(Track track, int thresholdSeconds, Long deviceId) {
        // 1. è®¡ç®—åœç•™æ—¶é•¿
        long dwellTime = track.getDwellTime(Duration.ofSeconds(thresholdSeconds));

        if (dwellTime > thresholdSeconds) {
            // 2. åˆ›å»ºå¾˜å¾Šäº‹ä»¶
            AiBehaviorEventEntity event = new AiBehaviorEventEntity();
            event.setEventId(UUID.randomUUID().toString());
            event.setDeviceId(deviceId);
            event.setEventType(AiEventType.LOITERING);
            event.setObjectId(track.getObjectId());
            event.setDwellTime((int) dwellTime);
            event.setEventTime(LocalDateTime.now());
            event.setTrajectoryImage(track.getTrajectoryImage());

            aiEventDao.insert(event);

            // 3. å‘é€å‘Šè­¦
            alertManager.sendAlert(AlertLevel.MEDIUM,
                "å¾˜å¾Šæ£€æµ‹: åœç•™" + dwellTime + "ç§’",
                event);

            log.warn("[è¡Œä¸ºæ£€æµ‹] å¾˜å¾Šå‘Šè­¦: objectId={}, dwellTime={}s",
                track.getObjectId(), dwellTime);
        }
    }

    /**
     * èšé›†æ£€æµ‹
     */
    private void checkCrowdGathering(List<Track> allTracks, int threshold, Long deviceId) {
        // 1. ç»Ÿè®¡åŒºåŸŸå†…çš„ç›®æ ‡æ•°é‡
        int crowdCount = allTracks.size();

        if (crowdCount >= threshold) {
            // 2. åˆ›å»ºèšé›†äº‹ä»¶
            AiBehaviorEventEntity event = new AiBehaviorEventEntity();
            event.setEventId(UUID.randomUUID().toString());
            event.setDeviceId(deviceId);
            event.setEventType(AiEventType.CROWD_GATHERING);
            event.setCrowdCount(crowdCount);
            event.setEventTime(LocalDateTime.now());
            event.setTrajectoryImage(generateCrowdImage(allTracks));

            aiEventDao.insert(event);

            // 3. å‘é€å‘Šè­¦
            alertManager.sendAlert(AlertLevel.HIGH,
                "äººç¾¤èšé›†: æ•°é‡" + crowdCount,
                event);

            log.warn("[è¡Œä¸ºæ£€æµ‹] äººç¾¤èšé›†: count={}", crowdCount);
        }
    }
}
```

#### ğŸ“Š ä¸šåŠ¡å®Œæ•´æ€§è¯„ä¼°

| åŠŸèƒ½æ¨¡å— | å®Œæˆåº¦ | å¾…åŠé¡¹ | å»ºè®® |
|---------|--------|--------|------|
| **å®æ—¶é¢„è§ˆ** | 85% | 3 | ä¼˜åŒ–æµè½¬æ¢ |
| **å½•åƒç®¡ç†** | 40% | 20 | **å®ç°æ ¸å¿ƒåŠŸèƒ½** |
| **å½•åƒå›æ”¾** | 50% | 5 | å®Œå–„å›æ”¾æ§åˆ¶ |
| **äººè„¸è¯†åˆ«** | 45% | 8 | é›†æˆAIæ¨¡å‹ |
| **è¡Œä¸ºæ£€æµ‹** | 30% | 11 | **å®ç°æ£€æµ‹ç®—æ³•** |
| **äº‘å°æ§åˆ¶** | 70% | 2 | å®Œå–„é¢„ç½®ä½ |
| **è§†é¢‘å¢™** | 60% | 3 | å®Œå–„è½®å·¡ |
| **åè®®é€‚é…** | 65% | 6 | å®Œå–„RTSP/RTMP |

---

## ğŸ” è·¨æ¨¡å—å…±æ€§å¾…åŠäº‹é¡¹åˆ†æ

### 1. å®‰å…¨è®¤è¯æ¨¡å— (microservices-common-security)

**å¾…åŠæ•°é‡**: 13é¡¹
**ä¼˜å…ˆçº§**: P0

#### æ ¸å¿ƒå¾…åŠäº‹é¡¹

```java
// AuthManager.java - 10ä¸ªTODO
- TODO: å®ç°ç”¨æˆ·é”å®šæ£€æŸ¥é€»è¾‘
- TODO: å®ç°å¹¶å‘ç™»å½•æ£€æŸ¥é€»è¾‘
- TODO: å®ç°ç”¨æˆ·ä¼šè¯ç®¡ç†é€»è¾‘
- TODO: å®ç°æ¸…é™¤ç™»å½•å¤±è´¥è®°å½•é€»è¾‘
- TODO: å®ç°è®°å½•ç™»å½•å¤±è´¥é€»è¾‘
- TODO: å®ç°ä»¤ç‰Œé»‘åå•é€»è¾‘
- TODO: å®ç°ä»¤ç‰Œé»‘åå•æ£€æŸ¥é€»è¾‘
- TODO: å®ç°ç§»é™¤ç”¨æˆ·ä¼šè¯é€»è¾‘
- TODO: å®ç°ç”¨æˆ·ä¼šè¯éªŒè¯é€»è¾‘
- TODO: å®ç°æ›´æ–°ä¼šè¯æœ€åè®¿é—®æ—¶é—´é€»è¾‘

// JwtTokenUtil.java - 1ä¸ªTODO
- TODO: å®ç°ä»¤ç‰Œæ’¤é”€é€»è¾‘ï¼Œå°†ä»¤ç‰ŒåŠ å…¥é»‘åå•
```

#### ä¼ä¸šçº§å®ç°æ–¹æ¡ˆ

```java
/**
 * ä¼ä¸šçº§è®¤è¯ç®¡ç†å™¨
 */
@Component
@Slf4j
public class AuthManagerImpl implements AuthManager {

    @Resource
    private RedisTemplate<String, Object> redisTemplate;
    @Resource
    private UserDao userDao;
    @Resource
    private LoginLogDao loginLogDao;

    /**
     * P0: ç”¨æˆ·é”å®šæ£€æŸ¥
     */
    @Override
    public boolean isUserLocked(Long userId) {
        String lockKey = "auth:lock:" + userId;
        Boolean locked = redisTemplate.hasKey(lockKey);

        if (Boolean.TRUE.equals(locked)) {
            Long ttl = redisTemplate.getExpire(lockKey, TimeUnit.SECONDS);
            log.warn("[ç”¨æˆ·é”å®š] ç”¨æˆ·å·²è¢«é”å®š: userId={}, remainingTime={}s", userId, ttl);
            return true;
        }

        return false;
    }

    /**
     * P0: è®°å½•ç™»å½•å¤±è´¥
     */
    @Override
    public void recordLoginFailure(Long userId, String clientIp) {
        String failKey = "auth:fail:" + userId;
        String countKey = "auth:fail:count:" + userId;

        // 1. å¢åŠ å¤±è´¥æ¬¡æ•°
        Long failCount = redisTemplate.opsForValue().increment(countKey);

        // 2. è®¾ç½®5åˆ†é’Ÿè¿‡æœŸ
        if (failCount == 1) {
            redisTemplate.expire(countKey, 5, TimeUnit.MINUTES);
        }

        // 3. è®°å½•å¤±è´¥æ—¥å¿—
        LoginLogEntity log = new LoginLogEntity();
        log.setUserId(userId);
        log.setLoginIp(clientIp);
        log.setLoginStatus(LoginStatus.FAILURE);
        log.setFailReason("å¯†ç é”™è¯¯");
        log.setFailCount(failCount.intValue());
        log.setCreateTime(LocalDateTime.now());
        loginLogDao.insert(log);

        // 4. æ£€æŸ¥æ˜¯å¦éœ€è¦é”å®š
        if (failCount >= 5) { // è¿ç»­å¤±è´¥5æ¬¡
            lockUser(userId, 30); // é”å®š30åˆ†é’Ÿ
            redisTemplate.delete(countKey);
            log.error("[ç”¨æˆ·é”å®š] è¿ç»­ç™»å½•å¤±è´¥5æ¬¡ï¼Œå·²é”å®š: userId={}, ip={}", userId, clientIp);
        } else {
            log.warn("[ç™»å½•å¤±è´¥] è®°å½•å¤±è´¥: userId={}, count={}, ip={}", userId, failCount, clientIp);
        }
    }

    /**
     * P0: é”å®šç”¨æˆ·
     */
    private void lockUser(Long userId, int lockMinutes) {
        String lockKey = "auth:lock:" + userId;
        redisTemplate.opsForValue().set(lockKey, LocalDateTime.now(), lockMinutes, TimeUnit.MINUTES);

        // å‘é€é”å®šé€šçŸ¥
        sendLockNotification(userId, lockMinutes);
    }

    /**
     * P0: å¹¶å‘ç™»å½•æ£€æŸ¥
     */
    @Override
    public boolean checkConcurrentLogin(Long userId, String sessionId) {
        String sessionKey = "auth:session:" + userId;
        Set<String> activeSessions = (Set<String>) redisTemplate.opsForValue().get(sessionKey);

        if (activeSessions == null) {
            activeSessions = new HashSet<>();
        }

        // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æœ€å¤§å¹¶å‘æ•°
        int maxConcurrent = 3; // å…è®¸åŒæ—¶3ä¸ªä¼šè¯
        if (activeSessions.size() >= maxConcurrent && !activeSessions.contains(sessionId)) {
            log.warn("[å¹¶å‘ç™»å½•] è¶…è¿‡æœ€å¤§å¹¶å‘æ•°: userId={}, activeCount={}, max={}",
                userId, activeSessions.size(), maxConcurrent);
            return false;
        }

        return true;
    }

    /**
     * P0: ç”¨æˆ·ä¼šè¯ç®¡ç†
     */
    @Override
    public void createUserSession(Long userId, String sessionId, String clientIp) {
        String sessionKey = "auth:session:" + userId;
        String sessionDataKey = "auth:session:data:" + sessionId;

        // 1. æ·»åŠ ä¼šè¯åˆ°ç”¨æˆ·ä¼šè¯é›†åˆ
        Set<String> sessions = (Set<String>) redisTemplate.opsForValue().get(sessionKey);
        if (sessions == null) {
            sessions = new HashSet<>();
        }
        sessions.add(sessionId);
        redisTemplate.opsForValue().set(sessionKey, sessions, 24, TimeUnit.HOURS);

        // 2. å­˜å‚¨ä¼šè¯æ•°æ®
        UserSession session = UserSession.builder()
            .userId(userId)
            .sessionId(sessionId)
            .clientIp(clientIp)
            .createTime(LocalDateTime.now())
            .lastAccessTime(LocalDateTime.now())
            .build();

        redisTemplate.opsForValue().set(sessionDataKey, session, 24, TimeUnit.HOURS);

        log.info("[ä¼šè¯ç®¡ç†] åˆ›å»ºä¼šè¯: userId={}, sessionId={}, ip={}",
            userId, sessionId, clientIp);
    }

    /**
     * P0: ä»¤ç‰Œé»‘åå•
     */
    @Override
    public void addToBlacklist(String token, Long expirationMillis) {
        String blacklistKey = "auth:blacklist:" + token;
        long ttl = expirationMillis - System.currentTimeMillis();

        if (ttl > 0) {
            redisTemplate.opsForValue().set(blacklistKey, true, ttl, TimeUnit.MILLISECONDS);
            log.info("[ä»¤ç‰Œé»‘åå•] å·²åŠ å…¥é»‘åå•: token={}, ttl={}ms", token, ttl);
        }
    }

    @Override
    public boolean isTokenBlacklisted(String token) {
        String blacklistKey = "auth:blacklist:" + token;
        Boolean exists = redisTemplate.hasKey(blacklistKey);
        return Boolean.TRUE.equals(exists);
    }
}
```

### 2. ç›‘æ§å‘Šè­¦æ¨¡å— (microservices-common-monitor)

**å¾…åŠæ•°é‡**: 3é¡¹
**ä¼˜å…ˆçº§**: P1

```java
// EnterpriseMonitoringManager.java - 2ä¸ªTODO
- TODO: å®ç°åˆå§‹åŒ–é€»è¾‘
- TODO: å®ç°å‘Šè­¦å‘é€é€»è¾‘

// AlertManager.java - 1ä¸ªTODO
- TODO: å®ç°ä»æ•°æ®åº“æˆ–é…ç½®ä¸­å¿ƒé‡æ–°åŠ è½½å‘Šè­¦è§„åˆ™å’Œé€šçŸ¥æ¸ é“é…ç½®çš„é€»è¾‘
```

#### ä¼ä¸šçº§å®ç°æ–¹æ¡ˆ

```java
/**
 * ä¼ä¸šçº§å‘Šè­¦ç®¡ç†å™¨
 */
@Component
@Slf4j
public class AlertManagerImpl implements AlertManager {

    @Resource
    private MeterRegistry meterRegistry;
    @Resource
    private NotificationService notificationService;
    @Resource
    private AlertRuleDao alertRuleDao;

    /**
     * P1: å‘é€å‘Šè­¦
     */
    @Override
    public void sendAlert(AlertLevel level, String message, Object data) {
        log.warn("[å‘Šè­¦å‘é€] level={}, message={}", level, message);

        // 1. è®°å½•å‘Šè­¦æŒ‡æ ‡
        meterRegistry.counter("alert.count",
            "level", level.name(),
            "message", message
        ).increment();

        // 2. æŸ¥è¯¢å‘Šè­¦è§„åˆ™
        List<AlertRuleEntity> rules = alertRuleDao.selectActiveRules(level);

        // 3. åŒ¹é…è§„åˆ™å¹¶å‘é€é€šçŸ¥
        for (AlertRuleEntity rule : rules) {
            if (matchRule(rule, message, data)) {
                sendNotification(rule, level, message, data);
            }
        }
    }

    /**
     * P1: å‘é€é€šçŸ¥
     */
    private void sendNotification(AlertRuleEntity rule, AlertLevel level, String message, Object data) {
        // æ ¹æ®é€šçŸ¥æ¸ é“å‘é€
        for (String channel : rule.getNotificationChannels().split(",")) {
            switch (channel.trim().toLowerCase()) {
                case "email":
                    notificationService.sendEmail(rule.getRecipients(), message, data);
                    break;

                case "sms":
                    notificationService.sendSms(rule.getRecipients(), message);
                    break;

                case "wechat":
                    notificationService.sendWechat(rule.getRecipients(), message, data);
                    break;

                case "webhook":
                    notificationService.sendWebhook(rule.getWebhookUrl(), data);
                    break;

                default:
                    log.warn("[å‘Šè­¦å‘é€] æœªçŸ¥é€šçŸ¥æ¸ é“: {}", channel);
            }
        }
    }
}
```

---

## ğŸ“ˆ å®æ–½è·¯çº¿å›¾

### P0çº§ä»»åŠ¡ï¼ˆ1-2å‘¨å†…å®Œæˆï¼‰ - ç«‹å³æ‰§è¡Œ

**æ€»è®¡: 89é¡¹å…³é”®ä»»åŠ¡**

| æ¨¡å— | ä»»åŠ¡æ•° | æ ¸å¿ƒä»»åŠ¡ | é¢„æœŸå·¥ä½œé‡ |
|------|--------|---------|-----------|
| **é—¨ç¦ç®¡ç†** | 8 | ç§»åŠ¨ç«¯è®¤è¯åŠŸèƒ½ | 3å¤© |
| **è€ƒå‹¤ç®¡ç†** | 32 | å·¥æ—¶è®¡ç®—ç­–ç•¥+å®æ—¶è®¡ç®—å¼•æ“ | 5å¤© |
| **æ¶ˆè´¹ç®¡ç†** | 6 | è¡¥è´´å®¡æ ¸å‘æ”¾é€»è¾‘ | 2å¤© |
| **è§†é¢‘ç›‘æ§** | 18 | å½•åƒç®¡ç†+AIåˆ†æ | 5å¤© |
| **ç”Ÿç‰©è¯†åˆ«** | 6 | æ·±åº¦å­¦ä¹ æ¨¡å‹é›†æˆ | 3å¤© |
| **å®‰å…¨è®¤è¯** | 10 | ä¼šè¯ç®¡ç†+ä»¤ç‰Œé»‘åå• | 2å¤© |
| **å…¬å…±æ¨¡å—** | 3 | ç›‘æ§å‘Šè­¦ | 1å¤© |
| **è®¾å¤‡é€šè®¯** | 6 | åè®®é€‚é…å™¨éªŒè¯ | 2å¤© |

**P0çº§æ‰§è¡Œç­–ç•¥**:
1. **ç¬¬ä¸€å‘¨**: ä¼˜å…ˆå®ç°å®‰å…¨è®¤è¯æ¨¡å—ï¼ˆå½±å“æ‰€æœ‰æœåŠ¡ï¼‰
2. **ç¬¬äºŒå‘¨**: å¹¶è¡Œå®ç°å„ä¸šåŠ¡æ¨¡å—P0åŠŸèƒ½
3. **æ¯æ—¥ç«™ä¼š**: è·Ÿè¸ªè¿›åº¦ï¼ŒåŠæ—¶è§£å†³é˜»å¡
4. **ä»£ç å®¡æŸ¥**: ç¡®ä¿æ¶æ„åˆè§„æ€§
5. **æµ‹è¯•éªŒè¯**: æ¯ä¸ªåŠŸèƒ½å®Œæˆåè¿›è¡Œå•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•

### P1çº§ä»»åŠ¡ï¼ˆ2-4å‘¨å†…å®Œæˆï¼‰ - é‡è¦åŠŸèƒ½

**æ€»è®¡: 156é¡¹é‡è¦åŠŸèƒ½**

| æ¨¡å— | ä»»åŠ¡æ•° | æ ¸å¿ƒä»»åŠ¡ | é¢„æœŸå·¥ä½œé‡ |
|------|--------|---------|-----------|
| **é—¨ç¦ç®¡ç†** | 16 | è®¤è¯ç»Ÿè®¡+æŠ¥è­¦ç®¡ç† | 4å¤© |
| **è€ƒå‹¤ç®¡ç†** | 58 | æ™ºèƒ½æ’ç­ç®—æ³•+è§„åˆ™å¼•æ“ | 8å¤© |
| **æ¶ˆè´¹ç®¡ç†** | 12 | æŠ¥è¡¨å¯¼å‡º+è¡¥è´´ç»Ÿè®¡ | 3å¤© |
| **è§†é¢‘ç›‘æ§** | 31 | äººè„¸è¯†åˆ«+è¡Œä¸ºæ£€æµ‹ | 6å¤© |
| **ç”Ÿç‰©è¯†åˆ«** | 11 | ç”Ÿç‰©ç‰¹å¾æå– | 3å¤© |
| **å…¬å…±æ¨¡å—** | 12 | ç›‘æ§ä¼˜åŒ–+æ€§èƒ½è°ƒä¼˜ | 3å¤© |
| **è®¾å¤‡é€šè®¯** | 28 | åè®®é€‚é…å™¨å®Œå–„ | 4å¤© |
| **OAå·¥ä½œæµ** | 7 | å·¥ä½œæµä¼˜åŒ– | 2å¤© |

### P2çº§ä»»åŠ¡ï¼ˆ1-2ä¸ªæœˆå†…å®Œæˆï¼‰ - æŒç»­ä¼˜åŒ–

**æ€»è®¡: 235é¡¹ä¼˜åŒ–é¡¹**

- ä»£ç è´¨é‡ä¼˜åŒ–
- æ€§èƒ½è°ƒä¼˜
- æ–‡æ¡£å®Œå–„
- æµ‹è¯•è¦†ç›–
- ç›‘æ§å®Œå–„

---

## ğŸ¯ ä¼ä¸šçº§æœ€ä½³å®è·µå»ºè®®

### 1. æ¶æ„è®¾è®¡åŸåˆ™

**å¾®æœåŠ¡è¾¹ç•Œæ¸…æ™°**:
- âœ… æ¯ä¸ªæœåŠ¡åªè´Ÿè´£ä¸€ä¸ªä¸šåŠ¡é¢†åŸŸ
- âœ… æœåŠ¡é—´é€šè¿‡GatewayClientè°ƒç”¨
- âœ… ç¦æ­¢ç›´æ¥ä¾èµ–å…¶ä»–ä¸šåŠ¡æœåŠ¡
- âœ… ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—è§£è€¦å¼‚æ­¥æµç¨‹

**ç»†ç²’åº¦æ¨¡å—ä¾èµ–**:
- âœ… ä¸šåŠ¡æœåŠ¡æŒ‰éœ€ä¾èµ–ç»†ç²’åº¦æ¨¡å—
- âœ… ç¦æ­¢ä¾èµ–microservices-commonèšåˆæ¨¡å—
- âœ… ä¾èµ–å…³ç³»å•å‘ï¼Œæ— å¾ªç¯ä¾èµ–

### 2. å®‰å…¨è®¾è®¡è§„èŒƒ

**è®¤è¯æˆæƒ**:
- âœ… JWTåŒä»¤ç‰Œæœºåˆ¶ï¼ˆè®¿é—®ä»¤ç‰Œ+åˆ·æ–°ä»¤ç‰Œï¼‰
- âœ… ä»¤ç‰Œé»‘åå•æœºåˆ¶ï¼ˆRediså­˜å‚¨ï¼‰
- âœ… ä¼šè¯ç®¡ç†ï¼ˆæœ€å¤§å¹¶å‘æ•°æ§åˆ¶ï¼‰
- âœ… ç™»å½•å¤±è´¥é”å®šï¼ˆ5æ¬¡é”å®š30åˆ†é’Ÿï¼‰

**æ•°æ®å®‰å…¨**:
- âœ… æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨
- âœ… æ—¥å¿—è„±æ•å¤„ç†
- âœ… APIæ¥å£ç­¾åéªŒè¯
- âœ… SQLæ³¨å…¥é˜²æŠ¤

### 3. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

**ç¼“å­˜æ¶æ„**:
- âœ… ä¸‰çº§ç¼“å­˜ä½“ç³»ï¼ˆæœ¬åœ°+Redis+æ•°æ®åº“ï¼‰
- âœ… ç¼“å­˜é¢„çƒ­
- âœ… ç¼“å­˜æ›´æ–°ç­–ç•¥
- âœ… ç¼“å­˜ç©¿é€é˜²æŠ¤

**æ•°æ®åº“ä¼˜åŒ–**:
- âœ… æ·»åŠ åˆé€‚çš„ç´¢å¼•
- âœ… è¯»å†™åˆ†ç¦»
- âœ… åˆ†åº“åˆ†è¡¨ï¼ˆæ•°æ®é‡å¤§æ—¶ï¼‰
- âœ… æ…¢æŸ¥è¯¢ç›‘æ§

**å¼‚æ­¥å¤„ç†**:
- âœ… ä½¿ç”¨@Asyncå¼‚æ­¥æ–¹æ³•
- âœ… RabbitMQæ¶ˆæ¯é˜Ÿåˆ—
- âœ… WebSocketå®æ—¶æ¨é€
- âœ… CompletableFutureå¹¶å‘ç¼–ç¨‹

### 4. å¯ç»´æŠ¤æ€§ä¿éšœ

**æ—¥å¿—è§„èŒƒ**:
- âœ… ç»Ÿä¸€ä½¿ç”¨@Slf4jæ³¨è§£
- âœ… å‚æ•°åŒ–æ—¥å¿—ï¼ˆé¿å…å­—ç¬¦ä¸²æ‹¼æ¥ï¼‰
- âœ… åˆ†å±‚æ—¥å¿—æ¨¡æ¿ï¼ˆController/Service/Manager/DAOï¼‰
- âœ… æ•æ„Ÿä¿¡æ¯è„±æ•

**å¼‚å¸¸å¤„ç†**:
- âœ… ç»Ÿä¸€å¼‚å¸¸å¤„ç†æœºåˆ¶
- âœ… ä¸šåŠ¡å¼‚å¸¸BusinessException
- âœ… ç³»ç»Ÿå¼‚å¸¸SystemException
- âœ… å¼‚å¸¸æ—¥å¿—è®°å½•å’Œå‘Šè­¦

**ä»£ç è´¨é‡**:
- âœ… å•å…ƒæµ‹è¯•è¦†ç›–ç‡>80%
- âœ… é›†æˆæµ‹è¯•å…³é”®æµç¨‹
- âœ… ä»£ç å®¡æŸ¥æœºåˆ¶
- âœ… SonarQubeé™æ€åˆ†æ

### 5. å¯æ‰©å±•æ€§è®¾è®¡

**ç­–ç•¥æ¨¡å¼**:
- âœ… å¤šæ¨¡æ€è®¤è¯ç­–ç•¥ï¼ˆ9ç§è®¤è¯æ–¹å¼ï¼‰
- âœ… å·¥æ—¶è®¡ç®—ç­–ç•¥ï¼ˆ3ç§å·¥ä½œåˆ¶ï¼‰
- âœ… ç”Ÿç‰©ç‰¹å¾æå–ç­–ç•¥ï¼ˆå¤šç§ç”Ÿç‰©è¯†åˆ«ï¼‰

**é€‚é…å™¨æ¨¡å¼**:
- âœ… è®¾å¤‡åè®®é€‚é…å™¨ï¼ˆå¤šå‚å•†è®¾å¤‡ï¼‰
- âœ… è§†é¢‘æµé€‚é…å™¨ï¼ˆRTSP/RTMP/HTTPï¼‰
- âœ… å­˜å‚¨é€‚é…å™¨ï¼ˆæœ¬åœ°/äº‘å­˜å‚¨ï¼‰

**è§‚å¯Ÿè€…æ¨¡å¼**:
- âœ… äº‹ä»¶é©±åŠ¨æ¶æ„ï¼ˆè€ƒå‹¤äº‹ä»¶å¤„ç†ï¼‰
- âœ… æ¶ˆæ¯è®¢é˜…å‘å¸ƒï¼ˆRabbitMQï¼‰
- âœ… WebSocketå®æ—¶æ¨é€

---

## ğŸ“Š é¡¹ç›®æˆç†Ÿåº¦è¯„ä¼°

### æ•´ä½“è¯„ä¼°

```
IOE-DREAMé¡¹ç›®æˆç†Ÿåº¦: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘ 80/100

âœ… å·²å®ç°:
â”œâ”€â”€ å››å±‚æ¶æ„å®Œæ•´ (Controller â†’ Service â†’ Manager â†’ DAO)
â”œâ”€â”€ ç»†ç²’åº¦æ¨¡å—æ‹†åˆ† (12ä¸ªç»†ç²’åº¦æ¨¡å—)
â”œâ”€â”€ GatewayæœåŠ¡è°ƒç”¨ (å¾®æœåŠ¡é€šä¿¡)
â”œâ”€â”€ å¤šæ¨¡æ€è®¤è¯ä½“ç³» (9ç§è®¤è¯æ–¹å¼)
â”œâ”€â”€ è€ƒå‹¤æ‰“å¡é‡‡é›† (ç”Ÿç‰©è¯†åˆ«)
â””â”€â”€ æ¶ˆè´¹æ”¯ä»˜æ ¸å¿ƒ (è´¦æˆ·ç®¡ç†)

âš ï¸ éƒ¨åˆ†å®ç°:
â”œâ”€â”€ æ™ºèƒ½æ’ç­ç®—æ³• (æ¡†æ¶å·²æ­å»ºï¼Œç®—æ³•å¾…å®ç°)
â”œâ”€â”€ AIè§†é¢‘åˆ†æ (æ¨¡å‹æœªé›†æˆ)
â”œâ”€â”€ å®æ—¶è®¡ç®—å¼•æ“ (äº‹ä»¶ç³»ç»Ÿæœªå®Œå–„)
â””â”€â”€ ç›‘æ§å‘Šè­¦ä½“ç³» (è§„åˆ™é…ç½®æœªå®ç°)

âŒ æœªå®ç°:
â”œâ”€â”€ ç§»åŠ¨ç«¯å®Œæ•´åŠŸèƒ½ (é—¨ç¦+è€ƒå‹¤)
â”œâ”€â”€ äººè„¸è¯†åˆ«æ·±åº¦å­¦ä¹ æ¨¡å‹ (FaceNetæœªé›†æˆ)
â”œâ”€â”€ OpenCVå›¾åƒå¤„ç† (ä¾èµ–æœªæ·»åŠ )
â””â”€â”€ ç”Ÿç‰©ç‰¹å¾æå–ç®—æ³• (æŒ‡çº¹/è™¹è†œ/æŒçº¹)
```

### æŠ€æœ¯å€ºåŠ¡

| ç±»å‹ | ä¸¥é‡ç¨‹åº¦ | æ•°é‡ | å»ºè®® |
|------|---------|------|------|
| **æœªå®ç°åŠŸèƒ½** | é«˜ | 89 | P0çº§ç«‹å³å®ç° |
| **ç®—æ³•å¾…å®Œå–„** | ä¸­ | 58 | P1çº§ä¼˜åŒ– |
| **ä¾èµ–ç¼ºå¤±** | é«˜ | 28 | æ·»åŠ OpenCV/TensorFlow |
| **æµ‹è¯•ä¸è¶³** | ä¸­ | å…¨éƒ¨ | æå‡è¦†ç›–ç‡è‡³80%+ |
| **æ–‡æ¡£ç¼ºå¤±** | ä½ | éƒ¨åˆ†æ¨¡å— | è¡¥å……APIæ–‡æ¡£ |

---

## ğŸš€ åç»­è¡ŒåŠ¨è®¡åˆ’

### ç¬¬ä¸€é˜¶æ®µï¼ˆ1-2å‘¨ï¼‰: P0çº§åŠŸèƒ½å®ç°

**ç›®æ ‡**: ç¡®ä¿æ ¸å¿ƒä¸šåŠ¡åŠŸèƒ½å¯ç”¨

**è¡ŒåŠ¨è®¡åˆ’**:
1. **Day 1-3**: å®ç°å®‰å…¨è®¤è¯æ¨¡å—
   - ä¼šè¯ç®¡ç†
   - ä»¤ç‰Œé»‘åå•
   - ç”¨æˆ·é”å®šæœºåˆ¶

2. **Day 4-8**: å®ç°è€ƒå‹¤æ ¸å¿ƒåŠŸèƒ½
   - 3ç§å·¥æ—¶è®¡ç®—ç­–ç•¥
   - å®æ—¶è®¡ç®—å¼•æ“
   - äº‹ä»¶å¤„ç†ç³»ç»Ÿ

3. **Day 9-10**: å®ç°é—¨ç¦ç§»åŠ¨ç«¯
   - è®¤è¯åˆå§‹åŒ–
   - äºŒç»´ç è®¤è¯
   - ä»¤ç‰Œåˆ·æ–°

4. **Day 11-14**: å®Œå–„å…¶ä»–æ¨¡å—P0åŠŸèƒ½
   - æ¶ˆè´¹è¡¥è´´å‘æ”¾
   - è§†é¢‘å½•åƒç®¡ç†
   - è®¾å¤‡åè®®éªŒè¯

### ç¬¬äºŒé˜¶æ®µï¼ˆ2-4å‘¨ï¼‰: P1çº§åŠŸèƒ½å®Œå–„

**ç›®æ ‡**: æå‡ç³»ç»Ÿæ™ºèƒ½åŒ–æ°´å¹³

**è¡ŒåŠ¨è®¡åˆ’**:
1. å®ç°æ™ºèƒ½æ’ç­ç®—æ³•
   - é—ä¼ ç®—æ³•
   - å›æº¯ç®—æ³•
   - å¯å‘å¼ç®—æ³•

2. å®ç°è§†é¢‘AIåˆ†æ
   - é›†æˆæ·±åº¦å­¦ä¹ æ¨¡å‹
   - äººè„¸è¯†åˆ«
   - è¡Œä¸ºæ£€æµ‹

3. å®Œå–„ç›‘æ§å‘Šè­¦ä½“ç³»
   - å‘Šè­¦è§„åˆ™é…ç½®
   - å¤šæ¸ é“é€šçŸ¥
   - å®æ—¶ç›‘æ§å¤§å±

### ç¬¬ä¸‰é˜¶æ®µï¼ˆ1-2ä¸ªæœˆï¼‰: P2çº§æŒç»­ä¼˜åŒ–

**ç›®æ ‡**: æå‡ç³»ç»Ÿç¨³å®šæ€§å’Œæ€§èƒ½

**è¡ŒåŠ¨è®¡åˆ’**:
1. æ€§èƒ½ä¼˜åŒ–
   - æ•°æ®åº“ç´¢å¼•ä¼˜åŒ–
   - ç¼“å­˜ç­–ç•¥ä¼˜åŒ–
   - æ¥å£æ€§èƒ½ä¼˜åŒ–

2. ä»£ç è´¨é‡æå‡
   - å•å…ƒæµ‹è¯•è¦†ç›–
   - é›†æˆæµ‹è¯•å®Œå–„
   - ä»£ç é‡æ„ä¼˜åŒ–

3. ç›‘æ§è¿ç»´å®Œå–„
   - æ—¥å¿—æ ‡å‡†åŒ–
   - ç›‘æ§æŒ‡æ ‡å®Œå–„
   - å‘Šè­¦è§„åˆ™ä¼˜åŒ–

---

## ğŸ“ ç»“è®º

IOE-DREAMé¡¹ç›®æ•´ä½“æ¶æ„æ¸…æ™°ï¼Œè®¾è®¡åˆç†ï¼Œä½†å­˜åœ¨å¤§é‡å¾…å®ç°åŠŸèƒ½ï¼ˆ480ä¸ªTODOï¼‰ã€‚

**æ ¸å¿ƒä¼˜åŠ¿**:
- âœ… å››å±‚æ¶æ„è§„èŒƒï¼ŒèŒè´£æ¸…æ™°
- âœ… ç»†ç²’åº¦æ¨¡å—æ‹†åˆ†ï¼Œä¾èµ–åˆç†
- âœ… ç­–ç•¥æ¨¡å¼åº”ç”¨è‰¯å¥½ï¼Œæ‰©å±•æ€§å¼º
- âœ… æ ¸å¿ƒä¸šåŠ¡æµç¨‹å®Œæ•´

**ä¸»è¦ä¸è¶³**:
- âŒ 89ä¸ªP0çº§å…³é”®åŠŸèƒ½æœªå®ç°ï¼ˆ18.5%ï¼‰
- âŒ æ™ºèƒ½åŒ–ç®—æ³•å¾…è½åœ°ï¼ˆé—ä¼ /å›æº¯/å¯å‘å¼ï¼‰
- âŒ AIæ·±åº¦å­¦ä¹ æ¨¡å‹æœªé›†æˆï¼ˆOpenCV/TensorFlowï¼‰
- âŒ ç§»åŠ¨ç«¯åŠŸèƒ½ä¸å®Œæ•´

**å»ºè®®ä¼˜å…ˆçº§**:
1. **P0çº§**ï¼ˆ1-2å‘¨ï¼‰: ç«‹å³å®ç°æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼Œç¡®ä¿ç³»ç»Ÿå¯ç”¨
2. **P1çº§**ï¼ˆ2-4å‘¨ï¼‰: å®Œå–„æ™ºèƒ½åŒ–åŠŸèƒ½ï¼Œæå‡ç”¨æˆ·ä½“éªŒ
3. **P2çº§**ï¼ˆ1-2ä¸ªæœˆï¼‰: æŒç»­ä¼˜åŒ–æ€§èƒ½å’Œè´¨é‡ï¼Œä¿éšœé•¿æœŸå¥åº·å‘å±•

**é¢„æœŸæ•ˆæœ**:
- ç³»ç»Ÿå®Œæˆåº¦ä»80% â†’ 95%
- æ ¸å¿ƒåŠŸèƒ½å®Œæ•´åº¦ä»60% â†’ 100%
- æ™ºèƒ½åŒ–æ°´å¹³ä»30% â†’ 85%
- ä¼ä¸šçº§æˆç†Ÿåº¦ä»è‰¯å¥½ â†’ ä¼˜ç§€

---

**æŠ¥å‘Šç”Ÿæˆæ—¶é—´**: 2025-12-23
**åˆ†æå·¥å…·ç‰ˆæœ¬**: Claude Sonnet 4.5
**ä¸‹æ¬¡æ›´æ–°å»ºè®®**: P0çº§ä»»åŠ¡å®Œæˆåï¼ˆçº¦2å‘¨åï¼‰
