# æ™ºèƒ½è§†é¢‘ç›‘æ§ç³»ç»ŸåŠŸèƒ½æ¨¡å—è¯¦ç»†è®¾è®¡

> **ç‰ˆæœ¬**: v1.0
> **æ›´æ–°æ—¶é—´**: 2025-11-13
> **åˆ†ç±»**: æ ¸å¿ƒåŠŸèƒ½æ¨¡å— > æ™ºèƒ½è§†é¢‘ç›‘æ§ç³»ç»Ÿ
> **æ ‡ç­¾**: ["æ™ºèƒ½è§†é¢‘ç›‘æ§", "AIåˆ†æ", "å®æ—¶ç›‘æ§", "è¡Œä¸ºåˆ†æ", "å‘Šè­¦ç®¡ç†"]
> **ä½œè€…**: SmartAdminè§„èŒƒæ²»ç†å§”å‘˜ä¼š
> **æè¿°**: IOE-DREAMæ™ºæ…§å›­åŒºä¸€å¡é€šç®¡ç†å¹³å°æ™ºèƒ½è§†é¢‘ç›‘æ§ç³»ç»Ÿçš„8å¤§æ ¸å¿ƒåŠŸèƒ½æ¨¡å—è¯¦ç»†æŠ€æœ¯è®¾è®¡

## ğŸ“‹ æ¨¡å—æ¦‚è¿°

### æ ¸å¿ƒå®šä½

**æ™ºèƒ½è§†é¢‘ç›‘æ§ç³»ç»ŸåŠŸèƒ½æ¨¡å—**æ˜¯IOE-DREAMæ™ºæ…§å›­åŒºä¸€å¡é€šç®¡ç†å¹³å°çš„æ ¸å¿ƒå®‰å…¨ç›‘æ§æ¨¡å—ï¼Œé›†æˆAIç®—æ³•ã€å®æ—¶ç›‘æ§ã€æ™ºèƒ½åˆ†æç­‰å…ˆè¿›æŠ€æœ¯ï¼Œæä¾›8å¤§æ ¸å¿ƒåŠŸèƒ½æ¨¡å—çš„å®Œæ•´æŠ€æœ¯å®ç°ã€‚æ¨¡å—é‡‡ç”¨äº”çº§å®‰å…¨æƒé™ä½“ç³»ï¼Œæ”¯æŒå¤§è§„æ¨¡å¹¶å‘ç›‘æ§ã€å®æ—¶åˆ†æã€æ™ºèƒ½å‘Šè­¦å’Œè”åŠ¨æ§åˆ¶ã€‚

### æ ¸å¿ƒç‰¹æ€§

- âœ… **8å¤§åŠŸèƒ½æ¨¡å—** - å®æ—¶ç›‘æ§ã€è®¾å¤‡ç®¡ç†ã€å½•åƒå›æ”¾ã€è¡Œä¸ºåˆ†æã€å‘Šè­¦ç®¡ç†ã€è§£ç ä¸Šå¢™ã€æ¶ˆæ¯ä¸­å¿ƒã€åœ°å›¾æ˜¾ç¤º
- âœ… **å¤šåè®®æ”¯æŒ** - RTSPã€RTMPã€HLSã€WebRTCã€HTTP-FLVç­‰å¤šç§è§†é¢‘æµåè®®
- âœ… **AIæ™ºèƒ½åˆ†æ** - äººè„¸è¯†åˆ«ã€è¡Œä¸ºåˆ†æã€å¼‚å¸¸æ£€æµ‹ã€æ™ºèƒ½æ£€ç´¢
- âœ… **äº”çº§æƒé™æ§åˆ¶** - ç»å¯†ã€æœºå¯†ã€ç§˜å¯†ã€å†…éƒ¨ã€å…¬å¼€äº”çº§å®‰å…¨æƒé™ç®¡ç†
- âœ… **å®æ—¶è”åŠ¨æ§åˆ¶** - ä¸é—¨ç¦ã€æŠ¥è­¦ã€ç…§æ˜ç­‰ç³»ç»Ÿçš„æ™ºèƒ½è”åŠ¨
- âœ… **å¤§å±è§£ç ä¸Šå¢™** - å¤šå±è”åŠ¨ã€å®æ—¶ä¸Šå¢™ã€è§£ç å™¨ç®¡ç†
- âœ… **æ™ºèƒ½å‘Šè­¦ç³»ç»Ÿ** - è§„åˆ™é…ç½®ã€æ™ºèƒ½åˆ†æã€å®æ—¶å‘Šè­¦ã€è”åŠ¨å¤„ç½®

## ğŸ—ï¸ æ™ºèƒ½è§†é¢‘ç›‘æ§ç³»ç»Ÿæ¨¡å—æ¶æ„

### ç³»ç»Ÿæ¶æ„å›¾

```mermaid
graph TB
    subgraph "æ™ºèƒ½è§†é¢‘ç›‘æ§ç³»ç»Ÿæ¶æ„"
        subgraph "ç”¨æˆ·äº¤äº’å±‚"
            MONITOR[å®æ—¶ç›‘æ§ç•Œé¢]
            DEVICE[è®¾å¤‡ç®¡ç†ç•Œé¢]
            PLAYBACK[å½•åƒå›æ”¾ç•Œé¢]
            ANALYSIS[è¡Œä¸ºåˆ†æç•Œé¢]
            ALARM[å‘Šè­¦ç®¡ç†ç•Œé¢]
            WALL[è§£ç ä¸Šå¢™ç•Œé¢]
            MAP[åœ°å›¾æ˜¾ç¤ºç•Œé¢]
            MSG[æ¶ˆæ¯ä¸­å¿ƒç•Œé¢]
        end

        subgraph "ä¸šåŠ¡é€»è¾‘å±‚"
            subgraph "æ ¸å¿ƒæœåŠ¡æ¨¡å—"
                RMS[å®æ—¶ç›‘æ§æœåŠ¡]
                DMS[è®¾å¤‡ç®¡ç†æœåŠ¡]
                VPS[å½•åƒå›æ”¾æœåŠ¡]
                BAS[è¡Œä¸ºåˆ†ææœåŠ¡]
                AMS[å‘Šè­¦ç®¡ç†æœåŠ¡]
                WDS[è§£ç ä¸Šå¢™æœåŠ¡]
                MSS[æ¶ˆæ¯ä¸­å¿ƒæœåŠ¡]
                GMS[åœ°å›¾æœåŠ¡]
            end

            subgraph "AIåˆ†æå¼•æ“"
                FRS[äººè„¸è¯†åˆ«å¼•æ“]
                BAE[è¡Œä¸ºåˆ†æå¼•æ“]
                ADE[å¼‚å¸¸æ£€æµ‹å¼•æ“]
                IVS[æ™ºèƒ½è§†é¢‘æœç´¢]
            end
        end

        subgraph "æ•°æ®è®¿é—®å±‚"
            VIDEO_DAO[è§†é¢‘æ•°æ®è®¿é—®]
            DEVICE_DAO[è®¾å¤‡æ•°æ®è®¿é—®]
            RECORD_DAO[å½•åƒæ•°æ®è®¿é—®]
            ALARM_DAO[å‘Šè­¦æ•°æ®è®¿é—®]
            CONFIG_DAO[é…ç½®æ•°æ®è®¿é—®]
            CACHE_LAYER[ç¼“å­˜å±‚]
        end

        subgraph "åŸºç¡€è®¾æ–½å±‚"
            VIDEO_STREAM[è§†é¢‘æµæœåŠ¡]
            STORAGE[åˆ†å¸ƒå¼å­˜å‚¨]
            AI_ENGINE[AIè®¡ç®—å¼•æ“]
            MESSAGE_QUEUE[æ¶ˆæ¯é˜Ÿåˆ—]
            STREAM_SERVER[æµåª’ä½“æœåŠ¡å™¨]
        end
    end

    MONITOR --> RMS
    DEVICE --> DMS
    PLAYBACK --> VPS
    ANALYSIS --> BAS
    ALARM --> AMS
    WALL --> WDS
    MAP --> GMS
    MSG --> MSS

    RMS --> FRS
    DMS --> VIDEO_STREAM
    VPS --> STORAGE
    BAS --> BAE
    AMS --> ADE
    WDS --> CACHE_LAYER
    GMS --> MAP_SERVICE

    VIDEO_DAO --> CACHE_LAYER
    DEVICE_DAO --> CACHE_LAYER
    RECORD_DAO --> STORAGE
    ALARM_DAO --> MESSAGE_QUEUE
```

### æ ¸å¿ƒæ¨¡å—åŠŸèƒ½çŸ©é˜µ

| æ¨¡å—åç§° | å®æ—¶ç›‘æ§ | è®¾å¤‡ç®¡ç† | å½•åƒå›æ”¾ | è¡Œä¸ºåˆ†æ | å‘Šè­¦ç®¡ç† | è§£ç ä¸Šå¢™ | æ¶ˆæ¯ä¸­å¿ƒ | åœ°å›¾æ˜¾ç¤º |
|---------|----------|----------|----------|----------|----------|----------|----------|----------|
| **æƒé™çº§åˆ«** | âœ…âœ…âœ…âœ… | âœ…âœ…âœ…âœ… | âœ…âœ…âœ…âœ… | âœ…âœ…âœ…âŒ | âœ…âœ…âœ…âŒ | âœ…âœ…âœ…âŒ | âœ…âœ…âœ…âœ… | âœ…âœ…âœ…âœ… |
| **ç”¨æˆ·æƒé™** | Level 1+ | Level 1+ | Level 1+ | Level 3+ | Level 2+ | Level 2+ | Level 2+ | Level 1+ |

## ğŸ”§ æ ¸å¿ƒåŠŸèƒ½è¯¦ç»†è®¾è®¡

### 1. å®æ—¶ç›‘æ§æ¨¡å—

#### 1.1 å¤šç”»é¢é¢„è§ˆåŠŸèƒ½

**åŠŸèƒ½æè¿°**ï¼šæ”¯æŒ1/4/9/16/25ç”»é¢å¤šç§å¸ƒå±€ï¼Œå®æ—¶é¢„è§ˆå¤šä¸ªç›‘æ§ç”»é¢

**æŠ€æœ¯å®ç°**ï¼š
```java
@RestController
@RequestMapping("/api/monitor")
@SecurityLevel(value = 1)
public class MonitorController {

    @Resource
    private VideoStreamManager videoStreamManager;

    @Resource
    private PermissionService permissionService;

    @GetMapping("/layouts")
    public ResponseDTO<List<ScreenLayoutVO>> getAvailableLayouts() {
        List<ScreenLayoutVO> layouts = Arrays.asList(
                ScreenLayoutVO.builder().layoutType("1x1").name("å•ç”»é¢").description("1x1å¸ƒå±€"),
                ScreenLayoutVO.builder().layoutType("2x2").name("4ç”»é¢").description("2x2å¸ƒå±€"),
                ScreenLayoutVO.builder().layoutType("3x3").name("9ç”»é¢").description("3x3å¸ƒå±€"),
                ScreenView.builder().layoutType("4x4").name("16ç”»é¢").description("4x4å¸ƒå±€"),
                ScreenLayoutVO.builder().layoutType("5x5").name("25ç”»é¢").description("5x5å¸ƒå±€")
        );
        return ResponseDTO.ok(layouts);
    }

    @GetMapping("/stream/{deviceId}")
    @SecurityLevel(value = 2)
    public ResponseDTO<Map<String, String>> getStreamUrl(@PathVariable Long deviceId) {
        Long userId = SmartRequestUtil.getRequestUserId();

        // æ£€æŸ¥è®¾å¤‡è®¿é—®æƒé™
        if (!permissionService.hasDevicePermission(userId, deviceId, "view")) {
            throw new ForbiddenException("æ— è®¾å¤‡è®¿é—®æƒé™");
        }

        DeviceEntity device = deviceService.getById(deviceId);
        String streamUrl = videoStreamManager.getStreamUrl(device, "main");
        String playUrl = transformPlayUrl(streamUrl);

        Map<String, String> result = new HashMap<>();
        result.put("streamUrl", streamUrl);
        result.put("playUrl", playUrl);

        return ResponseDTO.ok(result);
    }

    @PostMapping("/multi-screen")
    @SecurityLevel(value = 2)
    public ResponseDTO<MultiScreenVO> createMultiScreen(@RequestBody MultiScreenCreateForm form) {
        try {
            // éªŒè¯ç”¨æˆ·æƒé™
            validateMultiScreenPermission(form.getDeviceIds());

            // åˆ›å»ºå¤šå±å¹•é…ç½®
            MultiScreenVO multiScreen = MultiScreenVO.builder()
                    .screenId(IdGenerator.generateId())
                    .layoutType(form.getLayoutType())
                    .name(form.getName())
                    .deviceIds(form.getDeviceIds())
                    .createTime(LocalDateTime.now())
                    .createUserId(SmartRequestUtil.getRequestUserId())
                    .build();

            // ç”Ÿæˆè§†é¢‘æµç»„åˆURL
            List<String> streamUrls = form.getDeviceIds().stream()
                    .map(this::generateStreamUrl)
                    .collect(Collectors.toList());
            multiScreen.setStreamUrls(streamUrls);

            // ä¿å­˜å¤šå±å¹•é…ç½®
            multiScreenService.saveMultiScreen(multiScreen);

            return ResponseDTO.ok(multiScreen);

        } catch (Exception e) {
            log.error("åˆ›å»ºå¤šå±å¹•å¤±è´¥", e);
            return ResponseDTO.error("åˆ›å»ºå¤±è´¥");
        }
    }
}
```

#### 1.2 äº‘å°æ§åˆ¶åŠŸèƒ½

**åŠŸèƒ½æè¿°**ï¼šæ”¯æŒPTZï¼ˆPan-Tilt-Zoomï¼‰äº‘å°æ§åˆ¶ï¼ŒåŒ…æ‹¬æ–¹å‘æ§åˆ¶ã€å˜ç„¦ã€é¢„ç½®ä½ç­‰

**æŠ€æœ¯å®ç°**ï¼š
```java
@Service
@Slf4j
public class PtzControlService {

    @Resource
    private DeviceProtocolAdapter deviceProtocolAdapter;

    @Resource
    private DeviceConnectionPool connectionPool;

    /**
     * PTZæ§åˆ¶
     */
    public PtzControlResult ptzControl(PtzControlRequest request) {
        try {
            // 1. è·å–è®¾å¤‡è¿æ¥
            DeviceConnection connection = connectionPool.getConnection(request.getDeviceId());
            if (connection == null) {
                return PtzControlResult.failed("è®¾å¤‡ç¦»çº¿");
            }

            // 2. æ„å»ºPTZå‘½ä»¤
            PtzCommand command = PtzCommand.builder()
                    .action(request.getAction())
                    .speed(request.getSpeed())
                    .horizontalSpeed(request.getHorizontalSpeed())
                    .verticalSpeed(request.getVerticalSpeed())
                    .zoomSpeed(request.getZoomSpeed())
                    .presetId(request.getPresetId())
                    .build();

            // 3. å‘é€PTZæŒ‡ä»¤
            PtzResponse response = deviceProtocolAdapter.sendPtzCommand(connection, command);

            if (response.isSuccess()) {
                return PtzControlResult.success("PTZæ§åˆ¶æˆåŠŸ");
            } else {
                return PtzControlResult.failed("PTZæ§åˆ¶å¤±è´¥: " + response.getErrorMessage());
            }

        } catch (Exception e) {
            log.error("PTZæ§åˆ¶å¤±è´¥", e);
            return PtzControlResult.failed("PTZæ§åˆ¶å¼‚å¸¸");
        }
    }

    /**
     * è®¾ç½®é¢„ç½®ä½
     */
    @Transactional(rollbackFor = Exception.class)
    public void setPresetPosition(Long deviceId, int presetId, PtzPresetPosition position) {
        try {
            DeviceConnection connection = connectionPool.getConnection(deviceId);

            // 1. ç§»åŠ¨åˆ°æŒ‡å®šä½ç½®
            PtzCommand moveCommand = PtzCommand.builder()
                    .action("MOVE")
                    .horizontalSpeed(10)
                    .verticalSpeed(10)
                    .build();
            deviceProtocolAdapter.sendPtzCommand(connection, moveCommand);

            // 2. ç­‰å¾…ç§»åŠ¨å®Œæˆ
            Thread.sleep(2000);

            // 3. ä¿å­˜é¢„ç½®ä½
            PtzPreset preset = PtzPreset.builder()
                    .deviceId(deviceId)
                    .presetId(presetId)
                    .name("é¢„ç½®ä½" + presetId)
                    .horizontalAngle(position.getHorizontalAngle())
                    .verticalAngle(position.getVerticalAngle())
                    .zoomLevel(position.getZoomLevel())
                    .createTime(LocalDateTime.now())
                    .build();

            ptzPresetDao.insert(preset);

            log.info("é¢„ç½®ä½è®¾ç½®æˆåŠŸ, deviceId: {}, presetId: {}", deviceId, presetId);

        } catch (Exception e) {
            log.error("è®¾ç½®é¢„ç½®ä½å¤±è´¥", e);
        }
    }

    /**
     * è°ƒç”¨é¢„ç½®ä½
     */
    public PtzControlResult callPreset(Long deviceId, int presetId) {
        try {
            DeviceConnection connection = connectionPool.getConnection(deviceId);

            PtzCommand command = PtzCommand.builder()
                    .action("GOTO_PRESET")
                    .presetId(presetId)
                    .speed(15)
                    .build();

            PtzResponse response = deviceProtocolAdapter.sendPtzCommand(connection, command);

            return response.isSuccess() ?
                    PtzControlResult.success("è°ƒç”¨é¢„ç½®ä½æˆåŠŸ") :
                    PtzControlResult.failed("è°ƒç”¨é¢„ç½®ä½å¤±è´¥");

        } catch (Exception e) {
            log.error("è°ƒç”¨é¢„ç½®ä½å¤±è´¥", e);
            return PtzControlResult.failed("è°ƒç”¨é¢„ç½®ä½å¼‚å¸¸");
        }
    }
}
```

### 2. è®¾å¤‡ç®¡ç†äº¤äº’æ¨¡å—

#### 2.1 è®¾å¤‡çŠ¶æ€ç›‘æ§

**åŠŸèƒ½æè¿°**ï¼šå®æ—¶ç›‘æ§è®¾å¤‡çŠ¶æ€ï¼ŒåŒ…æ‹¬å¿ƒè·³æ£€æµ‹ã€æ€§èƒ½ç›‘æ§ã€ç¦»çº¿å‘Šè­¦

**æŠ€æœ¯å®ç°**ï¼š
```java
@Service
@Slf4j
public class DeviceStatusMonitorService {

    @Resource
    private DeviceHeartbeatService heartbeatService;

    @Resource
    private AlarmService alarmService;

    @Resource
    private DeviceCacheService deviceCacheService;

    @EventListener
    @Async
    public void handleDeviceHeartbeatEvent(DeviceHeartbeatEvent event) {
        try {
            Long deviceId = event.getDeviceId();
            DeviceStatus newStatus = event.getStatus();

            // 1. æ›´æ–°è®¾å¤‡çŠ¶æ€ç¼“å­˜
            deviceCacheService.updateDeviceStatus(deviceId, newStatus);

            // 2. æ£€æŸ¥çŠ¶æ€å˜æ›´
            DeviceStatus oldStatus = deviceCacheService.getDeviceStatus(deviceId);
            if (oldStatus != newStatus) {
                handleStatusChange(deviceId, oldStatus, newStatus);
            }

            // 3. æ›´æ–°åœ¨çº¿ç»Ÿè®¡
            updateOnlineStatistics();

            // 4. æ¨é€çŠ¶æ€å˜æ›´é€šçŸ¥
            pushStatusChangeNotification(deviceId, newStatus);

        } catch (Exception e) {
            log.error("å¤„ç†è®¾å¤‡å¿ƒè·³äº‹ä»¶å¤±è´¥", e);
        }
    }

    /**
     * å¤„ç†è®¾å¤‡çŠ¶æ€å˜æ›´
     */
    private void handleStatusChange(Long deviceId, DeviceStatus oldStatus, DeviceStatus newStatus) {
        try {
            // 1. è®¾å¤‡ä¸Šçº¿
            if (oldStatus == DeviceStatus.OFFLINE && newStatus == DeviceStatus.ONLINE) {
                handleDeviceOnline(deviceId);
            }

            // 2. è®¾å¤‡ç¦»çº¿
            if (oldStatus == DeviceStatus.ONLINE && newStatus == DeviceStatus.OFFLINE) {
                handleDeviceOffline(deviceId);
            }

            // 3. è®¾å¤‡æ•…éšœ
            if (newStatus == DeviceStatus.FAULT) {
                handleDeviceFault(deviceId);
            }

        } catch (Exception e) {
            log.error("å¤„ç†è®¾å¤‡çŠ¶æ€å˜æ›´å¤±è´¥", e);
        }
    }

    /**
     * è®¾å¤‡ç¦»çº¿å‘Šè­¦
     */
    private void handleDeviceOffline(Long deviceId) {
        try {
            // 1. è®°å½•ç¦»çº¿æ—¶é—´
            deviceOfflineService.recordOfflineTime(deviceId);

            // 2. æ£€æŸ¥ç¦»çº¿æ¬¡æ•°
            int offlineCount = deviceOfflineService.getOfflineCount(deviceId);
            int offlineThreshold = getOfflineThreshold(deviceId);

            if (offlineCount >= offlineThreshold) {
                // 3. ç”Ÿæˆç¦»çº¿å‘Šè­¦
                DeviceOfflineAlarm alarm = DeviceOfflineAlarm.builder()
                        .deviceId(deviceId)
                        .alarmLevel(AlarmLevel.MEDIUM)
                        .alarmTime(LocalDateTime.now())
                        .description("è®¾å¤‡ç¦»çº¿æ¬¡æ•°è¶…è¿‡é˜ˆå€¼: " + offlineCount)
                        .offlineCount(offlineCount)
                        .build();

                alarmService.createAlarm(alarm);

                // 4. å‘é€å‘Šè­¦é€šçŸ¥
                notificationService.sendDeviceOfflineAlarm(alarm);
            }

            // 5. è®°å½•çŠ¶æ€å˜æ›´æ—¥å¿—
            deviceStatusLogService.logStatusChange(deviceId, DeviceStatus.ONLINE, DeviceStatus.OFFLINE);

        } catch (Exception e) {
            log.error("å¤„ç†è®¾å¤‡ç¦»çº¿å‘Šè­¦å¤±è´¥", e);
        }
    }

    /**
     * è®¾å¤‡è”åŠ¨æŠ“æ‹
     */
    public void triggerSnapshotCapture(Long deviceId, String triggerEvent) {
        try {
            // 1. è·å–è®¾å¤‡è¿æ¥
            DeviceConnection connection = connectionPool.getConnection(deviceId);
            if (connection == null) {
                log.warn("è®¾å¤‡ç¦»çº¿ï¼Œæ— æ³•æŠ“æ‹: {}", deviceId);
                return;
            }

            // 2. æ£€æŸ¥è”åŠ¨è§„åˆ™
            List<CaptureRule> rules = captureRuleService.getApplicableRules(deviceId, triggerEvent);

            for (CaptureRule rule : rules) {
                if (rule.isMatched(triggerEvent)) {
                    // 3. æ‰§è¡ŒæŠ“æ‹
                    CaptureTask task = CaptureTask.builder()
                            .deviceId(deviceId)
                            .captureType(rule.getCaptureType())
                            .quality(rule.getQuality())
                            .delay(rule.getDelay())
                            .triggerEvent(triggerEvent)
                            .build();

                    captureTaskExecutor.executeTask(task);
                }
            }

        } catch (Exception e) {
            log.error("è®¾å¤‡è”åŠ¨æŠ“æ‹å¤±è´¥", e);
        }
    }
}
```

### 3. å½•åƒå›æ”¾æ¨¡å—

#### 3.1 å½•åƒæŸ¥è¯¢ä¸å›æ”¾

**åŠŸèƒ½æè¿°**ï¼šæ”¯æŒå¤šæ¡ä»¶å½•åƒæŸ¥è¯¢ã€ç²¾å‡†å®šä½ã€å¤šç§æ’­æ”¾æ§åˆ¶

**æŠ€æœ¯å®ç°**ï¼š
```java
@RestController
@RequestMapping("/api/playback")
@SecurityLevel(value = 2)
public class PlaybackController {

    @Resource
    private PlaybackService playbackService;

    @Resource
    private RecordService recordService;

    @GetMapping("/records")
    public ResponseDTO<PageResult<RecordVO>> getRecords(RecordQueryParam param) {
        try {
            // 1. æƒé™éªŒè¯
            Long userId = SmartRequestUtil.getRequestUserId();
            validatePlaybackPermission(userId);

            // 2. æ ¹æ®æƒé™è¿‡æ»¤è®¾å¤‡
            if (userId != null && !isSystemAdmin(userId)) {
                List<Long> accessibleDeviceIds = getAccessibleDeviceIds(userId);
                param.setDeviceIds(accessibleDeviceIds);
            }

            // 3. æŸ¥è¯¢å½•åƒè®°å½•
            PageResult<RecordVO> result = playbackService.getRecords(param);

            return ResponseDTO.ok(result);

        } catch (Exception e) {
            log.error("æŸ¥è¯¢å½•åƒè®°å½•å¤±è´¥", e);
            return ResponseDTO.error("æŸ¥è¯¢å¤±è´¥");
        }
    }

    @GetMapping("/stream/{recordId}")
    public ResponseDTO<Map<String, Object>> getPlaybackStream(@PathVariable Long recordId) {
        try {
            // 1. è·å–å½•åƒè®°å½•
            RecordEntity record = recordService.getById(recordId);
            if (record == null) {
                return ResponseDTO.error("å½•åƒä¸å­˜åœ¨");
            }

            // 2. éªŒè¯è®¿é—®æƒé™
            validateRecordAccessPermission(record);

            // 3. è·å–è§†é¢‘æµä¿¡æ¯
            VideoStreamInfo streamInfo = playbackService.getVideoStreamInfo(record);

            Map<String, Object> result = new HashMap<>();
            result.put("recordId", recordId);
            result.put("streamUrl", streamInfo.getStreamUrl());
            result.put("duration", record.getDuration());
            result.put("fileSize", record.getFileSize());
            result.put("seekEnabled", true);
            result.put("playbackSpeeds", Arrays.asList(0.5, 1.0, 2.0, 4.0, 8.0));

            return ResponseDTO.ok(result);

        } catch (Exception e) {
            log.error("è·å–æ’­æ”¾æµå¤±è´¥", e);
            return ResponseDTO.error("è·å–å¤±è´¥");
        }
    }

    @PostMapping("/download")
    @SecurityLevel(value = 3)
    public ResponseDTO<Long> createDownloadTask(@RequestBody DownloadRequest request) {
        try {
            // 1. éªŒè¯ä¸‹è½½æƒé™
            validateDownloadPermission(request.getRecordIds());

            // 2. åˆ›å»ºä¸‹è½½ä»»åŠ¡
            DownloadTask task = DownloadTask.builder()
                    .taskId(IdGenerator.generateId())
                    .taskName(request.getTaskName())
                    .recordIds(request.getRecordIds())
                    .format(request.getFormat())
                    .watermarkEnabled(request.isWatermarkEnabled())
                    .compressionEnabled(request.isCompressionEnabled())
                    .status(DownloadStatus.PENDING)
                    .createTime(LocalDateTime.now())
                    .createUserId(SmartRequestUtil.getRequestUserId())
                    .build();

            // 3. æ£€æŸ¥å­˜å‚¨ç©ºé—´
            validateStorageSpace(task);

            // 4. ä¿å­˜ä¸‹è½½ä»»åŠ¡
            downloadTaskService.createDownloadTask(task);

            return ResponseDTO.ok(task.getTaskId());

        } catch (Exception e) {
            log.error("åˆ›å»ºä¸‹è½½ä»»åŠ¡å¤±è´¥", e);
            return ResponseDTO.error("åˆ›å»ºå¤±è´¥");
        }
    }
}
```

#### 3.2 å½•åƒå­˜å‚¨ä¸æ£€ç´¢

**åŠŸèƒ½æè¿°**ï¼šæ”¯æŒåˆ†å¸ƒå¼å­˜å‚¨ã€æ™ºèƒ½æ£€ç´¢ã€æ•°æ®å‹ç¼©å’Œç”Ÿå‘½å‘¨æœŸç®¡ç†

**æŠ€æœ¯å®ç°**ï¼š
```java
@Service
@Slf4j
public class VideoStorageService {

    @Resource
    private DistributedStorageService storageService;

    @Resource
    private VideoIndexService videoIndexService;

    @Resource
    private DataCompressionService compressionService;

    /**
     * å­˜å‚¨å½•åƒæ–‡ä»¶
     */
    public String storeVideoFile(VideoFile videoFile, byte[] videoData) {
        try {
            // 1. æ•°æ®å‹ç¼©
            byte[] compressedData = compressionService.compress(videoData, videoFile.getCompressionType());

            // 2. ç”Ÿæˆå­˜å‚¨è·¯å¾„
            String storagePath = generateStoragePath(videoFile);

            // 3. ä¸Šä¼ åˆ°åˆ†å¸ƒå¼å­˜å‚¨
            String fileUrl = storageService.upload(storagePath, compressedData);

            // 4. æ›´æ–°å½•åƒç´¢å¼•
            videoIndexService.updateVideoIndex(videoFile, fileUrl, compressedData.length);

            // 5. è®°å½•å­˜å‚¨æ—¥å¿—
            storageLogService.logStorageOperation(videoFile.getRecordId(), fileUrl, compressedData.length);

            log.info("å½•åƒæ–‡ä»¶å­˜å‚¨æˆåŠŸ, recordId: {}, fileSize: {}KB",
                    videoFile.getRecordId(), compressedData.length / 1024);

            return fileUrl;

        } catch (Exception e) {
            log.error("å­˜å‚¨å½•åƒæ–‡ä»¶å¤±è´¥", e);
            throw new StorageException("å­˜å‚¨å¤±è´¥", e);
        }
    }

    /**
     * å¿«é€Ÿæ£€ç´¢å½•åƒ
     */
    public List<VideoSearchResult> fastSearchVideo(VideoSearchRequest request) {
        try {
            // 1. æ„å»ºæœç´¢å‘é‡
            SearchVector searchVector = buildSearchVector(request);

            // 2. å‘é‡æœç´¢
            List<VideoVector> similarVectors = videoIndexService.vectorSearch(searchVector, request.getLimit());

            // 3. è½¬æ¢ä¸ºæœç´¢ç»“æœ
            return similarVectors.stream()
                    .map(this::convertToSearchResult)
                    .collect(Collectors.toList());

        } catch (Exception e) {
            log.error("è§†é¢‘å¿«é€Ÿæ£€ç´¢å¤±è´¥", e);
            return Collections.emptyList();
        }
    }

    /**
     * æ•°æ®ç”Ÿå‘½å‘¨æœŸç®¡ç†
     */
    @Scheduled(cron = "0 0 2 * * ?")
    public void executeLifecycleManagement() {
        try {
            // 1. æ¸…ç†è¿‡æœŸå½•åƒ
            cleanupExpiredRecordings();

            // 2. è¿ç§»å†·æ•°æ®
            migrateColdData();

            // 3. æ¸…ç†ä¸´æ—¶æ–‡ä»¶
            cleanupTempFiles();

            // 4. æ›´æ–°å­˜å‚¨ç»Ÿè®¡
            updateStorageStatistics();

        } catch (Exception e) {
            log.error("æ‰§è¡Œæ•°æ®ç”Ÿå‘½å‘¨æœŸç®¡ç†å¤±è´¥", e);
        }
    }

    /**
     * æ¸…ç†è¿‡æœŸå½•åƒ
     */
    private void cleanupExpiredRecordings() {
        try {
            LocalDate expireDate = LocalDate.now().minusDays(getRetentionDays());
            List<RecordEntity> expiredRecords = recordService.getExpiredRecords(expireDate);

            for (RecordEntity record : expiredRecords) {
                // åˆ é™¤å­˜å‚¨æ–‡ä»¶
                storageService.delete(record.getFilePath());

                // åˆ é™¤æ•°æ®åº“è®°å½•
                recordService.deleteById(record.getRecordId());

                log.info("æ¸…ç†è¿‡æœŸå½•åƒ: recordId={}, expireDate={}", record.getRecordId(), expireDate);
            }

        } catch (Exception e) {
            log.error("æ¸…ç†è¿‡æœŸå½•åƒå¤±è´¥", e);
        }
    }
}
```

### 4. è¡Œä¸ºåˆ†ææ¨¡å—

#### 4.1 AIæ™ºèƒ½åˆ†æå¼•æ“

**åŠŸèƒ½æè¿°**ï¼šé›†æˆäººè„¸è¯†åˆ«ã€è¡Œä¸ºåˆ†æã€å¼‚å¸¸æ£€æµ‹ç­‰AIç®—æ³•ï¼Œæä¾›æ™ºèƒ½åˆ†æèƒ½åŠ›

**æŠ€æœ¯å®ç°**ï¼š
```java
@Service
@Slf4j
public class BehaviorAnalysisService {

    @Resource
    private FaceRecognitionService faceRecognitionService;

    @Resource
    BehaviorAnalysisEngine behaviorAnalysisEngine;

    @Resource
    AnomalyDetectionEngine anomalyDetectionEngine;

    @Resource
    private AnalysisTaskExecutor analysisTaskExecutor;

    /**
     * äººè„¸è¯†åˆ«åˆ†æ
     */
    public FaceAnalysisResult analyzeFace(VideoFrame frame, List<Long> personIds) {
        try {
            // 1. äººè„¸æ£€æµ‹
            List<FaceDetection> faces = faceDetectionService.detectFaces(frame);

            if (CollectionUtils.isEmpty(faces)) {
                return FaceAnalysisResult.empty();
            }

            // 2. äººè„¸è¯†åˆ«
            List<FaceRecognition> recognitions = new ArrayList<>();
            for (FaceDetection face : faces) {
                List<FaceRecognition> matches = faceRecognitionService.recognizeFace(
                        face.getFaceImage(), personIds);
                recognitions.addAll(matches);
                faces.setRecognitions(matches);
            }

            // 3. æ„å»ºåˆ†æç»“æœ
            return FaceAnalysisResult.builder()
                    .frameId(frame.getFrameId())
                    .faceCount(faces.size())
                    .recognizedCount(recognitions.size())
                    .unrecognizedCount(faces.size() - recognitions.size())
                    .faces(faces)
                    .recognitions(recognitions)
                    .confidence(calculateConfidence(recognitions))
                    .analysisTime(LocalDateTime.now())
                    .build();

        } catch (Exception e) {
            log.error("äººè„¸è¯†åˆ«åˆ†æå¤±è´¥", e);
            return FaceAnalysisResult.failed("äººè„¸è¯†åˆ«åˆ†æå¼‚å¸¸");
        }
    }

    /**
     * è¡Œä¸ºåˆ†æ
     */
    public BehaviorAnalysisResult analyzeBehavior(BehaviorAnalysisRequest request) {
        try {
            // 1. è·å–æ—¶é—´èŒƒå›´å†…çš„è§†é¢‘æ•°æ®
            List<VideoSegment> segments = getVideoSegments(
                    request.getDeviceId(),
                    request.getStartTime(),
                    request.getEndTime());

            // 2. æ‰§è¡Œè¡Œä¸ºåˆ†æ
            List<BehaviorEvent> events = behaviorAnalysisEngine.analyzeSegments(segments);

            // 3. å¼‚å¸¸æ£€æµ‹
            List<AnomalyEvent> anomalies = anomalyDetectionEngine.detectAnomalies(events);

            // 4. æ„å»ºåˆ†æç»“æœ
            return BehaviorAnalysisResult.builder()
                    .deviceId(request.getDeviceId())
                    .analysisType(request.getAnalysisType())
                    .startTime(request.getStartTime())
                    .endTime(request.getEndTime())
                    .events(events)
                    .anomalies(anomalies)
                    .riskLevel(calculateRiskLevel(anomalies))
                    .build();

        } catch (Exception e) {
            log.error("è¡Œä¸ºåˆ†æå¤±è´¥", e);
            return BehaviorAnalysisResult.failed("è¡Œä¸ºåˆ†æå¼‚å¸¸");
        }
    }

    /**
     * å®æ—¶è¡Œä¸ºç›‘æ§
     */
    @EventListener
    @Async
    public void handleRealTimeVideoFrame(RealTimeVideoFrameEvent event) {
        try {
            // 1. å¼‚å¸¸æ£€æµ‹
            if (isAnomalyDetected(event)) {
                handleAnomalyDetection(event);
            }

            // 2. è¡Œä¸ºåˆ†æ
            BehaviorAnalysisRequest request = BehaviorAnalysisRequest.builder()
                    .deviceId(event.getDeviceId())
                    .analysisType("REAL_TIME")
                    .startTime(event.getFrameTimestamp().minusMinutes(1))
                    .endTime(event.getFrameTimestamp())
                    .build();

            behaviorAnalysisService.analyzeBehavior(request);

        } catch (Exception e) {
            log.error("å®æ—¶è¡Œä¸ºåˆ†æå¤±è´¥", e);
        }
    }
}
```

### 5. å‘Šè­¦ç®¡ç†æ¨¡å—

#### 5.1 æ™ºèƒ½å‘Šè­¦ç³»ç»Ÿ

**åŠŸèƒ½æè¿°**ï¼šå®æ—¶å‘Šè­¦æ£€æµ‹ã€è§„åˆ™é…ç½®ã€æ™ºèƒ½è”åŠ¨ã€åˆ†çº§å¤„ç†

**æŠ€æœ¯å®ç°**ï¼š
```java
@Service
@Slf4j
public class IntelligentAlarmService {

    @Resource
    private AlarmRuleEngine alarmRuleEngine;

    @Resource
    AlarmNotificationService notificationService;

    @Resource
    AlarmLinkageService alarmLinkageService;

    /**
     * æ™ºèƒ½å‘Šè­¦æ£€æµ‹
     */
    @EventListener
    @Async
    public void handleEventForAlarm(Event event) {
        try {
            // 1. è·å–é€‚ç”¨çš„å‘Šè­¦è§„åˆ™
            List<AlarmRule> rules = alarmRuleEngine.getApplicableRules(event);

            for (AlarmRule rule : rules) {
                if (rule.evaluate(event)) {
                    // 2. ç”Ÿæˆå‘Šè­¦
                    Alarm alarm = Alarm.builder()
                            .alarmId(IdGenerator.generateId())
                            .ruleId(rule.getRuleId())
                            .eventType(event.getType())
                            .deviceId(event.getDeviceId())
                            .alarmLevel(rule.getAlarmLevel())
                            .alarmTime(LocalDateTime.now())
                            .eventData(event.getData())
                            .build();

                    // 3. å¤„ç†å‘Šè­¦
                    processAlarm(alarm);
                }
            }

        } catch (Exception e) {
            log.error("æ™ºèƒ½å‘Šè­¦æ£€æµ‹å¤±è´¥", e);
        }
    }

    /**
     * å¤„ç†å‘Šè­¦
     */
    @Transactional(rollbackFor = Exception.class)
    public void processAlarm(Alarm alarm) {
        try {
            // 1. å‘Šè­¦å‡çº§æ£€æŸ¥
            checkAlarmEscalation(alarm);

            // 2. è§¦å‘è”åŠ¨
            triggerAlarmLinkage(alarm);

            // 3. å‘é€é€šçŸ¥
            sendAlarmNotifications(alarm);

            // 4. è®°å½•å‘Šè­¦æ—¥å¿—
            alarmLogService.logAlarm(alarm);

            // 5. æ›´æ–°å‘Šè­¦çŠ¶æ€
            alarm.setStatus(AlarmStatus.PENDING);
            alarmService.saveAlarm(alarm);

        } catch (Exception e) {
            log.error("å¤„ç†å‘Šè­¦å¤±è´¥", e);
        }
    }

    /**
     * è§¦å‘å‘Šè­¦è”åŠ¨
     */
    private void triggerAlarmLinkage(Alarm alarm) {
        try {
            List<LinkageRule> linkageRules = linkageRuleEngine.getApplicableRules(alarm);

            for (LinkageRule rule : linkageRules) {
                if (rule.matches(alarm)) {
                    // æ‰§è¡Œè”åŠ¨æ“ä½œ
                    executeLinkageOperation(rule, alarm);
                }
            }

        } catch (Exception e) {
            log.error("è§¦å‘å‘Šè­¦è”åŠ¨å¤±è´¥", e);
        }
    }

    /**
     * æ™ºèƒ½å‘Šè­¦æŠ‘åˆ¶
     */
    @Scheduled(fixedRate = 60)
    public void executeAlarmSuppression() {
        try {
            // 1. è·å–æ´»è·ƒå‘Šè­¦
            List<Alarm> activeAlarms = alarmService.getActiveAlarms();

            // 2. æ£€æŸ¥é‡å¤å‘Šè­¦
            Map<String, List<Alarm>> duplicateAlarms = findDuplicateAlarms(activeAlarms);

            // 3. æŠ‘è­¦åˆå¹¶
            for (Map.Entry<String, List<Alarm>> entry : duplicateAlarms.entrySet()) {
                if (entry.getValue().size() > 1) {
                    mergeAlarms(entry.getValue());
                }
            }

        } catch (Exception e) {
            log.error("æ‰§è¡Œå‘Šè­¦æŠ‘åˆ¶å¤±è´¥", e);
        }
    }
}
```

### 6. è§£ç ä¸Šå¢™æ¨¡å—

#### 6.1 å¤šå±è”åŠ¨æ§åˆ¶

**åŠŸèƒ½æè¿°**ï¼šæ”¯æŒè§£ç å™¨ç®¡ç†ã€å¤šå±å¸ƒå±€ã€å®æ—¶è§†é¢‘ä¸Šå¢™

**æŠ€æœ¯å®ç°**ï¼š
```java
@Service
@Slf4j
public class WallDisplayService {

    @Resource
    private DecoderService decoderService;

    @Resource
    WallLayoutManager layoutManager;

    @Resource
    VideoStreamAggregator streamAggregator;

    /**
     * åˆ›å»ºå¤šå±æ˜¾ç¤º
     */
    public WallDisplay createWallDisplay(WallDisplayConfig config) {
        try {
            // 1. éªŒè¯è§£ç å™¨è¿æ¥
            List<Decoder> decoders = validateDecoderConnections(config.getDecoderIds());

            // 2. åˆ›å»ºå¤§å±å¸ƒå±€
            WallLayout layout = layoutManager.createLayout(config.getLayoutType());

            // 3. é…ç½®æ˜¾ç¤ºçª—å£
            List<DisplayWindow> windows = new ArrayList<>();
            for (int i = 0; i < config.getWindowCount(); i++) {
                Long deviceId = i < config.getDeviceIds().size() ?
                        config.getDeviceIds().get(i) : null;

                DisplayWindow window = DisplayWindow.builder()
                        .windowId(IdGenerator.generateId())
                        .position(layout.getWindowPosition(i))
                        .size(layout.getWindowSize(i))
                        .deviceId(deviceId)
                        .build();
                windows.add(window);
            }

            // 4. åˆ›å»ºæ˜¾ç¤ºé…ç½®
            WallDisplay wallDisplay = WallDisplay.builder()
                    .displayId(IdGenerator.generateId())
                    .displayConfig(config)
                    .layout(layout)
                    .windows(windows)
                    .decoders(decoders)
                    .status(WallStatus.ACTIVE)
                    .createTime(LocalDateTime.now())
                    .build();

            // 5. ä¿å­˜æ˜¾ç¤ºé…ç½®
            wallDisplayService.saveWallDisplay(wallDisplay);

            log.info("å¤§å±æ˜¾ç¤ºåˆ›å»ºæˆåŠŸ, displayId: {}", wallDisplay.getDisplayId());

            return wallDisplay;

        } catch (Exception e) {
            log.error("åˆ›å»ºå¤šå±æ˜¾ç¤ºå¤±è´¥", e);
            throw new WallDisplayException("åˆ›å»ºå¤§å±æ˜¾ç¤ºå¤±è´¥", e);
        }
    }

    /**
     * å®æ—¶è§†é¢‘ä¸Šå¢™
     */
    public void displayRealtimeVideo(Long wallDisplayId, List<Long> deviceIds) {
        try {
            WallDisplay wallDisplay = wallDisplayService.getById(wallDisplayId);
            if (wallDisplay == null) {
                log.warn("å¤§å±ä¸å­˜åœ¨: {}", wallDisplayId);
                return;
            }

            // 1. è·å–è§†é¢‘æµ
            List<VideoStream> streams = deviceIds.stream()
                    .map(this::getVideoStream)
                    .collect(Collectors.toList());

            // 2. èšåˆè§†é¢‘æµ
            VideoStream aggregatedStream = streamAggregator.aggregateStreams(streams);

            // 3. å‘é€åˆ°è§£ç å™¨
            for (Decoder decoder : wallDisplay.getDecoders()) {
                if (decoder.isConnected()) {
                    sendStreamToDecoder(decoder, aggregatedStream);
                }
            }

            // 4. æ›´æ–°æ˜¾ç¤ºçŠ¶æ€
            wallDisplay.setLastUpdateTime(LocalDateTime.now());
            wallDisplayService.updateWallDisplay(wallDisplay);

            log.info("å®æ—¶è§†é¢‘ä¸Šå¢™æˆåŠŸ, wallDisplayId: {}", wallDisplayId);

        } catch (Exception e) {
            log.error("å®æ—¶è§†é¢‘ä¸Šå¢™å¤±è´¥", e);
        }
    }

    /**
     * å‘é€æµåˆ°è§£ç å™¨
     */
    private void sendStreamToDecoder(Decoder decoder, VideoStream stream) {
        try {
            DecoderStreamCommand command = DecoderStreamCommand.builder()
                    .streamUrl(stream.getStreamUrl())
                    .streamType(stream.getStreamType())
                    .quality(stream.getQuality())
                    .build();

            decoderService.sendStreamCommand(decoder.getId(), command);

        } catch (Exception e) {
            log.error("å‘é€æµåˆ°è§£ç å™¨å¤±è´¥", e);
        }
    }
}
```

### 7. æ¶ˆæ¯ä¸­å¿ƒæ¨¡å—

#### 7.1 äº‹ä»¶é©±åŠ¨æ¶ˆæ¯ç³»ç»Ÿ

**åŠŸèƒ½æè¿°**ï¼šåŸºäºäº‹ä»¶é©±åŠ¨çš„æ¶ˆæ¯æ¨é€ã€å¤šæ¸ é“é€šçŸ¥ã€æ™ºèƒ½è·¯ç”±

**æŠ€æœ¯å®ç°**ï¼š
```java
@Service
@Slf4j
public class EventDrivenMessageCenter {

    @Resource
    private EventSubscriptionService subscriptionService;

    @Resource
    private NotificationChannelService notificationChannelService;

    @Resource
    MessageTemplateService messageTemplateService;

    /**
     * å‘å¸ƒäº‹ä»¶
     */
    @EventListener
    @Async
    public void publishEvent(Event event) {
        try {
            // 1. è·å–äº‹ä»¶è®¢é˜…è€…
            List<EventSubscription> subscriptions = subscriptionService.getSubscriptions(event.getType());

            // 2. æ„å»ºæ¶ˆæ¯ä¸Šä¸‹æ–‡
            MessageContext context = MessageContext.builder()
                    .eventType(event.getType())
                    .eventData(event.getData())
                    .timestamp(event.getTimestamp())
                    .source(event.getSource())
                    .build();

            // 3. æ‰¹æ¶ˆæ¯åˆ†å‘
            for (EventSubscription subscription : subscriptions) {
                if (matchesSubscription(subscription, context)) {
                    sendMessage(subscription, context);
                }
            }

            // 4. ç»Ÿè®¡äº‹ä»¶å¤„ç†
            eventStatisticsService.recordEventProcessing(event);

        } catch (Exception e) {
            log.error("å‘å¸ƒäº‹ä»¶å¤±è´¥", e);
        }
    }

    /**
     * å‘é€æ¶ˆæ¯
     */
    private void sendMessage(EventSubscription subscription, MessageContext context) {
        try {
            // 1. é€‰æ‹©æ¶ˆæ¯æ¨¡æ¿
            MessageTemplate template = messageTemplateService.getTemplate(
                    subscription.getTemplateId(),
                    context.getEventType());

            // 2. æ¸²æŸ“æ¶ˆæ¯å†…å®¹
            String content = renderMessage(template, context);

            // 3. æ„å»ºæ¶ˆæ¯å¯¹è±¡
            Message message = Message.builder()
                    .messageId(IdGenerator.generateId())
                    .subscriberId(subscription.getSubscriberId())
                    .channelType(subscription.getChannelType())
                    .messageType(context.getEventType())
                    .subject(template.getSubject())
                    .content(content)
                    .priority(subscription.getPriority())
                    .timestamp(LocalDateTime.now())
                    .build();

            // 4. å‘é€é€šçŸ¥
            for (String channel : subscription.getChannels()) {
                notificationChannelService.sendNotification(channel, message);
            }

            // 5. è®°å½•æ¶ˆæ¯æ—¥å¿—
            messageLogService.logMessage(message);

        } catch (Exception e) {
            log.error("å‘é€æ¶ˆæ¯å¤±è´¥", e);
        }
    }

    /**
     * æ‰¹é‡æ¶ˆæ¯æ¨é€
     */
    @Scheduled(fixedRate = 30)
    public void processBatchMessageQueue() {
        try {
            // 1. è·å–å¾…å‘é€æ¶ˆæ¯
            List<Message> pendingMessages = messageQueueService.getPendingMessages(100);

            if (CollectionUtils.isEmpty(pendingMessages)) {
                return;
            }

            // 2. æ‰¹é‡å¤„ç†
            List<CompletableFuture<Void>> futures = pendingMessages.stream()
                    .map(message -> CompletableFuture.runAsync(() -> {
                        try {
                            sendSingleMessage(message);
                        } catch (Exception e) {
                            log.error("æ‰¹é‡å‘é€æ¶ˆæ¯å¤±è´¥", e);
                        }
                    }))
                    .collect(Collectors.toList());

            // 3. ç­‰å¾…æ‰€æœ‰æ¶ˆæ¯å‘é€å®Œæˆ
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                    .thenRun(() -> {
                        log.info("æ‰¹é‡æ¶ˆæ¯æ¨é€å®Œæˆ, å¤„ç†æ¶ˆæ¯æ•°: {}", pendingMessages.size());
                    })
                    .exceptionally(throwable -> {
                        log.error("æ‰¹é‡æ¶ˆæ¯æ¨é€å¤±è´¥", throwable);
                    });

        } catch (Exception e) {
            log.error("å¤„ç†æ‰¹é‡æ¶ˆæ¯é˜Ÿåˆ—å¤±è´¥", e);
        }
    }

    /**
     * æ¶ˆæ¯é‡è¯•æœºåˆ¶
     */
    @Retryable(value = 3, backoff = @Retry.Backoff(delay = 1000))
    public void sendNotificationWithRetry(Message message) {
        try {
            notificationChannelService.sendNotification(message.getChannelType(), message);

        } catch (Exception e) {
            log.warn("æ¶ˆæ¯é‡è¯•å‘é€å¤±è´¥: {}", message.getMessageId());
            throw e;
        }
    }
}
```

### 8. åœ°å›¾æ˜¾ç¤ºæ¨¡å—

#### 8.1 GISåœ°å›¾é›†æˆ

**åŠŸèƒ½æè¿°**ï¼šGISåœ°å›¾å±•ç¤ºã€è®¾å¤‡å®šä½ã€åŒºåŸŸç®¡ç†ã€è½¨è¿¹å›æ”¾

**æŠ€æœ¯å®ç°**ï¼š
```java
@RestController
@RequestMapping("/api/map")
@SecurityLevel(value = 1)
public class MapController {

    @Resource
    private MapService mapService;

    @Resource
    GISService gisService;

    @Resource
    LocationService locationService;

    @GetMapping("/devices")
    public ResponseDTO<List<DeviceLocationVO>> getDeviceLocations() {
        try {
            // 1. æƒé™éªŒè¯
            Long userId = SmartRequestUtil.getRequestUserId();
            validateMapAccessPermission(userId);

            // 2. è·å–æœ‰ä½ç½®ä¿¡æ¯çš„è®¾å¤‡
            List<DeviceEntity> devices = deviceService.getAllDevices().stream()
                    .filter(device -> device.getLatitude() != null && device.getLongitude() != null)
                    .collect(Collectors.toList());

            // 3. è½¬æ¢ä¸ºä½ç½®VO
            List<DeviceLocationVO> locations = devices.stream()
                    .map(this::convertToDeviceLocationVO)
                    .collect(Collectors.toList());

            return ResponseDTO.ok(locations);

        } catch (Exception e) {
            log.error("è·å–è®¾å¤‡ä½ç½®å¤±è´¥", e);
            return ResponseDTO.error("è·å–å¤±è´¥");
        }
    }

    @GetMapping("/layers")
    public ResponseDTO<List<MapLayerVO>> getMapLayers() {
        try {
            List<MapLayerVO> layers = Arrays.asList(
                    MapLayerVO.builder().layerId("base").name("åŸºç¡€åœ°å›¾").type("base").url("/api/map/base/tile/{z}/{x}/{y}"),
                    MapLayerVO.builder().layerId("device").name("è®¾å¤‡ä½ç½®").type("marker").url("/api/map/devices/locations"),
                    MapLayerVO.builder().layerId("area").name("ç›‘æ§åŒºåŸŸ").type("polygon").url("/api/map/areas"),
                    MapLayerVO.builder().layerId("trajectory").name("è¿åŠ¨è½¨è¿¹").type("polyline").url("/api/map/trajectories")
            );

            return ResponseDTO.ok(layers);

        } catch (Exception e) {
            log.error("è·å–åœ°å›¾å›¾å±‚å¤±è´¥", e);
            return ResponseDTO.error("è·å–å¤±è´¥");
        }
    }

    @GetMapping("/track/{deviceId}/history")
    public ResponseDTO<List<TrajectoryPointVO>> getTrajectoryHistory(
            @PathVariable Long deviceId,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO_DATE_TIME) LocalDateTime startTime,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO_DATE_TIME) LocalDateTime endTime) {
        try {
            // 1. æƒé™éªŒè¯
            validateDeviceAccessPermission(deviceId);

            // 2. è·å–è½¨è¿¹æ•°æ®
            List<TrajectoryPoint> trajectoryPoints = trajectoryService.getTrajectoryHistory(
                    deviceId, startTime, endTime);

            // 3. è½¬æ¢ä¸ºVO
            List<TrajectoryPointVO> trajectoryVOs = trajectoryPoints.stream()
                    .map(this::convertToTrajectoryPointVO)
                    .collect(Collectors.toList());

            return ResponseDTO.ok(trajectoryVOs);

        } catch (Exception e) {
            log.error("è·å–è½¨è¿¹å†å²å¤±è´¥", e);
            return ResponseDTO.error("è·å–å¤±è´¥");
        }
    }

    @PostMapping("/area")
    public ResponseDTO<Long> createMonitoringArea(@RequestBody MonitoringAreaForm form) {
        try {
            // 1. æƒé™éªŒè¯
            validateAreaManagementPermission();

            // 2. åˆ›å»ºç›‘æ§åŒºåŸŸ
            MonitoringArea area = MonitoringArea.builder()
                    .areaId(IdGenerator.generateId())
                    .areaName(form.getAreaName())
                    .areaType(form.getAreaType())
                    .geometry(form.getGeometry())
                    .description(form.getDescription())
                    .createUserId(SmartRequestUtil.getRequestUserId())
                    .createTime(LocalDateTime.now())
                    .build();

            Long areaId = mapService.createArea(area);

            return ResponseDTO.ok(areaId);

        } catch (Exception e) {
            log.error("åˆ›å»ºç›‘æ§åŒºåŸŸå¤±è´¥", e);
            return ResponseDTO.error("åˆ›å»ºå¤±è´¥");
        }
    }
}
```

## ğŸ“Š å…³é”®æ€§èƒ½æŒ‡æ ‡

### å®æ—¶ç›‘æ§æ€§èƒ½è¦æ±‚

| æŒ‡æ ‡ç±»å‹ | æ€§èƒ½è¦æ±‚ | ç›‘æ§æ–¹æ³• |
|---------|---------|---------|
| å•ç”»é¢é¢„è§ˆå»¶è¿Ÿ | â‰¤ 100ms | å®æ—¶å»¶è¿Ÿæµ‹è¯• |
| å¤šç”»é¢é¢„è§ˆå»¶è¿Ÿ | â‰¤ 200ms | å¸ƒå±€åˆ‡æ¢æµ‹è¯• |
| äº‘å°æ§åˆ¶å“åº” | â‰¤ 50ms | PTZæ§åˆ¶å»¶è¿Ÿ |
| æˆªå›¾å“åº”æ—¶é—´ | â‰¤ 200ms | æˆªå›¾æ“ä½œæµ‹è¯• |
| å®æ—¶è¿æ¥æ•° | â‰¥ 1000 | å¹¶å‘è¿æ¥æµ‹è¯• |
| è§†é¢‘æµè´¨é‡ | â‰¥ 1080P | åˆ†è¾¨ç‡æ£€æŸ¥ |
| å†…å­˜å ç”¨ | â‰¤ 2GB | å†…å­˜ç›‘æ§ |
| CPUå ç”¨ç‡ | â‰¤ 80% | CPUæ€§èƒ½ç›‘æ§ |

### AIåˆ†ææ€§èƒ½è¦æ±‚

| æŒ‡æ ‡ç±»å‹ | æ€§èƒ½è¦æ±‚ | ç›‘æ§æ–¹æ³• |
|---------|---------|---------|
| äººè„¸è¯†åˆ«å‡†ç¡®ç‡ | â‰¥ 99% | å‡†ç¡®ç‡æµ‹è¯• |
| è¡Œä¸ºåˆ†æå»¶è¿Ÿ | â‰¤ 3ç§’ | åˆ†æå»¶è¿Ÿæµ‹è¯• |
| å¼‚å¸¸æ£€æµ‹å“åº” | â‰¤ 2ç§’ | æ£€æµ‹å»¶è¿Ÿæµ‹è¯• |
| AIæ¨¡å‹æ¨ç†æ—¶é—´ | â‰¤ 500ms | æ¨ç†æ—¶é—´ç›‘æ§ |
| å¹¶å‘åˆ†ææµæ•° | â‰¥ 50 | å¹¶å‘å¤„ç†èƒ½åŠ› |
| GPUåˆ©ç”¨ç‡ | â‰¤ 90% | GPUæ€§èƒ½ç›‘æ§ |

### ç³»ç»Ÿå®¹é‡æŒ‡æ ‡

| æŒ‡æ ‡ç±»å‹ | è®¾è®¡å®¹é‡ | è¯´æ˜ |
|---------|---------|------|
| å¹¶å‘ç”¨æˆ·æ•° | 500ç”¨æˆ· | åŒæ—¶åœ¨çº¿ç”¨æˆ·æ•° |
| æ”¯æŒè®¾å¤‡æ•° | 10,000å° | ç³»ç»Ÿæ”¯æŒæœ€å¤§è®¾å¤‡æ•° |
| å½•åƒå­˜å‚¨ | 100TB/å¹´ | å¹´åº¦å½•åƒå­˜å‚¨é‡ |
| AIåˆ†æé‡ | 1,000è·¯ | åŒæ—¶AIåˆ†æè§†é¢‘è·¯æ•° |
| å‘Šè­¦å¤„ç†èƒ½åŠ› | 10,000æ¡/å¤© | æ—¥å‡å‘Šè­¦å¤„ç†é‡ |
| å¤§å±æ˜¾ç¤ºæ•° | 16å± | åŒæ—¶ä¸Šå¢™å±å¹•æ•° |
| æ¶ˆæ¯æ¨é€é‡ | 50,000æ¡/å¤© | æ—¥å‡æ¶ˆæ¯æ¨é€é‡ |

## ğŸ”— ç›¸å…³æ–‡æ¡£

### æŠ€æœ¯æ¶æ„æ–‡æ¡£
- [æ™ºèƒ½è§†é¢‘ç›‘æ§ç³»ç»Ÿæ•´ä½“æ¶æ„è®¾è®¡](./ç³»ç»Ÿæ¶æ„è®¾è®¡.md) - å®Œæ•´çš„ç³»ç»Ÿæ¶æ„å’ŒæŠ€æœ¯æ¶æ„
- [æ™ºèƒ½è§†é¢‘æ•°æ®åº“è®¾è®¡](./æ•°æ®åº“è®¾è®¡.md) - æ•°æ®åº“è¡¨ç»“æ„å’Œå…³ç³»è®¾è®¡
- [AIç®—æ³•å¼•æ“è®¾è®¡](./AIç®—æ³•å¼•æ“è®¾è®¡.md) - AIç®—æ³•å¼•æ“æ¶æ„å’Œé›†æˆ

### ä¸šåŠ¡åŠŸèƒ½æ–‡æ¡£
- [å®æ—¶ç›‘æ§æŠ€æœ¯å®ç°](./å®æ—¶ç›‘æ§æŠ€æœ¯å®ç°.md) - å®æ—¶ç›‘æ§è¯¦ç»†æŠ€æœ¯æ–¹æ¡ˆ
- [è¡Œä¸ºåˆ†æç®—æ³•è®¾è®¡](./è¡Œä¸ºåˆ†æç®—æ³•è®¾è®¡.md) - è¡Œä¸ºåˆ†æç®—æ³•è¯¦ç»†è®¾è®¡
- [å‘Šè­¦è§„åˆ™é…ç½®è®¾è®¡](./å‘Šè­¦è§„åˆ™é…ç½®è®¾è®¡.md) - å‘Šè­¦è§„åˆ™é…ç½®å’Œè”åŠ¨è®¾è®¡

### é›†æˆéƒ¨ç½²æ–‡æ¡£
- [ç³»ç»Ÿé›†æˆæ–¹æ¡ˆ](./ç³»ç»Ÿé›†æˆæ–¹æ¡ˆ.md) - ç³»ç»Ÿé›†æˆå’Œéƒ¨ç½²æ–¹æ¡ˆ
- [è¿ç»´æ“ä½œæ‰‹å†Œ](./è¿ç»´æ“ä½œæ‰‹å†Œ.md) - æ—¥å¸¸è¿ç»´æ“ä½œæŒ‡å—
- [æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ](./æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ.md) - ç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–ç­–ç•¥

---

## ğŸ¯ æ ¸å¿ƒåŸåˆ™æ€»ç»“

1. **æ¨¡å—åŒ–è®¾è®¡** - 8å¤§æ ¸å¿ƒæ¨¡å—èŒè´£æ¸…æ™°ï¼Œç›¸äº’åä½œåˆç‹¬ç«‹
2. **AIæ™ºèƒ½åˆ†æ** - é›†æˆå¤šç§AIç®—æ³•ï¼Œæä¾›æ™ºèƒ½åˆ†æèƒ½åŠ›
3. **å®æ—¶å¤„ç†** - åŸºäºäº‹ä»¶çš„å®æ—¶å¤„ç†å’Œå“åº”æœºåˆ¶
4. **äº”çº§æƒé™** - ç»†ç²’åº¦çš„äº”çº§å®‰å…¨æƒé™æ§åˆ¶ä½“ç³»
5. **é«˜å¯ç”¨æ€§** - åˆ†å¸ƒå¼æ¶æ„ï¼Œæ”¯æŒå¤§è§„æ¨¡å¹¶å‘å’Œæ•…éšœæ¢å¤
6. **å¯æ‰©å±•æ€§** - æ¨¡å—åŒ–è®¾è®¡æ”¯æŒçµæ´»çš„åŠŸèƒ½æ‰©å±•

## ğŸ“‹ ç‰ˆæœ¬ä¿¡æ¯

- æœ¬æ–‡æ¡£åŸºäºæ™ºèƒ½è§†é¢‘ç›‘æ§æœ€ä½³å®è·µè®¾è®¡
- åŠŸèƒ½æ¨¡å—è®¾è®¡è´Ÿè´£äººï¼šSmartAdminè§„èŒƒæ²»ç†å§”å‘˜ä¼š
- åˆ›å»ºæ—¥æœŸï¼š2025-11-13
- ä¸‹æ¬¡è¯„å®¡ï¼š2026-02-13

---

**ğŸ¯ IOE-DREAMæ™ºèƒ½è§†é¢‘ç›‘æ§ç³»ç»ŸåŠŸèƒ½æ¨¡å—è¯¦ç»†è®¾è®¡ - AIæ™ºèƒ½åˆ†æã€å®æ—¶ç›‘æ§ã€æ™ºèƒ½è”åŠ¨ã€äº”çº§æƒé™çš„ä¼ä¸šçº§è§†é¢‘ç›‘æ§è§£å†³æ–¹æ¡ˆ**