# é—¨ç¦å®æ—¶ç›‘æ§æ¨¡å—è¯¦ç»†è®¾è®¡

> **ç‰ˆæœ¬**: v1.0
> **æ›´æ–°æ—¶é—´**: 2025-11-13
> **åˆ†ç±»**: æ ¸å¿ƒåŠŸèƒ½æ¨¡å— > ä¼ä¸šOAç³»ç»Ÿ > é—¨ç¦ç®¡ç†ç³»ç»Ÿ
> **æ ‡ç­¾**: ["é—¨ç¦ç³»ç»Ÿ", "å®æ—¶ç›‘æ§", "è§†é¢‘è”åŠ¨", "äººå‘˜è¿½è¸ª", "æ™ºèƒ½å‘Šè­¦"]
> **ä½œè€…**: SmartAdminè§„èŒƒæ²»ç†å§”å‘˜ä¼š
> **æè¿°**: IOE-DREAMæ™ºæ…§å›­åŒºä¸€å¡é€šç®¡ç†å¹³å°é—¨ç¦ç®¡ç†ç³»ç»Ÿçš„å®æ—¶ç›‘æ§ã€è§†é¢‘è”åŠ¨å’Œäººå‘˜è¿½è¸ªæ¨¡å—è¯¦ç»†æŠ€æœ¯è®¾è®¡

## ğŸ“‹ æ¨¡å—æ¦‚è¿°

### æ ¸å¿ƒå®šä½

**é—¨ç¦å®æ—¶ç›‘æ§æ¨¡å—**æ˜¯IOE-DREAMæ™ºæ…§å›­åŒºä¸€å¡é€šç®¡ç†å¹³å°çš„æ ¸å¿ƒç›‘æ§æ¨¡å—ï¼Œæä¾›7Ã—24å°æ—¶å®æ—¶çŠ¶æ€ç›‘æ§ã€æ™ºèƒ½æŠ¥è­¦å¤„ç†ã€è§†é¢‘è”åŠ¨æ§åˆ¶å’Œäººå‘˜è½¨è¿¹è¿½è¸ªåŠŸèƒ½ã€‚æ¨¡å—é‡‡ç”¨äº‹ä»¶é©±åŠ¨æ¶æ„å’Œé«˜æ€§èƒ½æ•°æ®å¤„ç†æŠ€æœ¯ï¼Œç¡®ä¿ç›‘æ§æ•°æ®çš„å®æ—¶æ€§å’Œå‡†ç¡®æ€§ã€‚

### æ ¸å¿ƒç‰¹æ€§

- âœ… **å®æ—¶çŠ¶æ€ç›‘æ§**ï¼šè®¾å¤‡åœ¨çº¿çŠ¶æ€ã€é—¨çŠ¶æ€ã€ç½‘ç»œçŠ¶æ€å®æ—¶ç›‘æ§
- âœ… **æ™ºèƒ½æŠ¥è­¦å¤„ç†**ï¼šå¤šçº§æŠ¥è­¦åˆ†ç±»ã€æ™ºèƒ½åˆ†æå’Œå¿«é€Ÿå“åº”
- âœ… **è§†é¢‘è”åŠ¨æ§åˆ¶**ï¼šé—¨ç¦äº‹ä»¶ä¸è§†é¢‘ç›‘æ§æ— ç¼è”åŠ¨
- âœ… **äººå‘˜è½¨è¿¹è¿½è¸ª**ï¼šå®æ—¶äººå‘˜ä½ç½®è¿½è¸ªå’Œè½¨è¿¹åˆ†æ
- âœ… **å¼‚å¸¸è¡Œä¸ºæ£€æµ‹**ï¼šåŸºäºæœºå™¨å­¦ä¹ çš„å¼‚å¸¸è¡Œä¸ºè¯†åˆ«
- âœ… **é«˜æ€§èƒ½å¤„ç†**ï¼šæ”¯æŒå¤§è§„æ¨¡å¹¶å‘è®¾å¤‡ç›‘æ§
- âœ… **å¤šç»´åº¦å±•ç¤º**ï¼šåœ°å›¾å±•ç¤ºã€æ•°æ®å¯è§†åŒ–ã€çƒ­åŠ›å›¾åˆ†æ

## ğŸ—ï¸ å®æ—¶ç›‘æ§æ¨¡å—æ¶æ„è®¾è®¡

### æ¨¡å—åŠŸèƒ½æ¶æ„å›¾

```mermaid
graph TB
    subgraph "é—¨ç¦å®æ—¶ç›‘æ§æ¨¡å—æ¶æ„"
        subgraph "ç”¨æˆ·äº¤äº’å±‚"
            MON[å®æ—¶ç›‘æ§ç•Œé¢]
            ALARM[æŠ¥è­¦å¤„ç†ç•Œé¢]
            VIDEO[è§†é¢‘è”åŠ¨ç•Œé¢]
            TRACK[äººå‘˜è¿½è¸ªç•Œé¢]
        end

        subgraph "ä¸šåŠ¡é€»è¾‘å±‚"
            subgraph "æ ¸å¿ƒç›‘æ§æœåŠ¡"
                SMS[çŠ¶æ€ç›‘æ§æœåŠ¡]
                AMS[æŠ¥è­¦ç®¡ç†æœåŠ¡]
                VLS[è§†é¢‘è”åŠ¨æœåŠ¡]
                PTS[äººå‘˜è¿½è¸ªæœåŠ¡]
            end

            subgraph "æ•°æ®å¤„ç†å¼•æ“"
                RTE[å®æ—¶äº‹ä»¶å¼•æ“]
                ALE[æŠ¥è­¦åˆ†æå¼•æ“]
                TCE[è½¨è¿¹è®¡ç®—å¼•æ“]
                ADE[å¼‚å¸¸æ£€æµ‹å¼•æ“]
            end
        end

        subgraph "æ•°æ®é€šä¿¡å±‚"
            WS[WebSocketæœåŠ¡]
            MQ[æ¶ˆæ¯é˜Ÿåˆ—]
            CACHE[Redisç¼“å­˜]
            STREAM[æµå¤„ç†å¼•æ“]
        end

        subgraph "å¤–éƒ¨é›†æˆå±‚"
            DEVICE[é—¨ç¦è®¾å¤‡]
            VIDEO_SYS[è§†é¢‘ç›‘æ§ç³»ç»Ÿ]
            BIO_SYS[ç”Ÿç‰©è¯†åˆ«ç³»ç»Ÿ]
            MAP[åœ°å›¾æœåŠ¡]
        end
    end

    MON --> SMS
    ALARM --> AMS
    VIDEO --> VLS
    TRACK --> PTS

    SMS --> RTE
    AMS --> ALE
    VLS --> VIDEO_SYS
    PTS --> TCE

    RTE --> WS
    ALE --> MQ
    TCE --> CACHE
    ADE --> STREAM

    RTE --> DEVICE
    VLS --> VIDEO_SYS
    PTS --> BIO_SYS
    TRACK --> MAP
```

### å®æ—¶ç›‘æ§æ ¸å¿ƒæµç¨‹è®¾è®¡

```mermaid
graph TB
    MonitorStart(å®æ—¶ç›‘æ§å¼€å§‹) --> MonitorChoose{é€‰æ‹©ç›‘æ§ç±»å‹}

    MonitorChoose -->|å®æ—¶çŠ¶æ€ç›‘æ§| StatusMonitor
    MonitorChoose -->|æŠ¥è­¦å¤„ç†| AlarmProcess
    MonitorChoose -->|è§†é¢‘è”åŠ¨| VideoLinkage
    MonitorChoose -->|äººå‘˜è¿½è¸ª| PersonTrack

    subgraph å®æ—¶çŠ¶æ€ç›‘æ§æµç¨‹
        StatusMonitor --> DeviceConnect[è®¾å¤‡è¿æ¥]
        DeviceConnect --> StatusSubscribe[çŠ¶æ€è®¢é˜…]
        StatusSubscribe --> RealtimeUpdate[å®æ—¶æ›´æ–°]
        RealtimeUpdate --> ExceptionCheck{å¼‚å¸¸å¤„ç†}
        ExceptionCheck -->|æ˜¯| ExceptionHandle[å¼‚å¸¸å¤„ç†]
        ExceptionCheck -->|å¦| MonitorContinue[ç»§ç»­ç›‘æ§]
        ExceptionHandle --> MonitorContinue
        MonitorContinue --> StatusEnd[çŠ¶æ€ç›‘æ§å®Œæˆ]
    end

    subgraph æŠ¥è­¦å¤„ç†æµç¨‹
        AlarmProcess --> AlarmReceive[æŠ¥è­¦æ¥æ”¶]
        AlarmReceive --> AlarmAnalysis[æŠ¥è­¦åˆ†æ]
        AlarmAnalysis --> AlarmPush[æŠ¥è­¦æ¨é€]
        AlarmPush --> AlarmHandle[æŠ¥è­¦å¤„ç†]
        AlarmHandle --> AlarmRecord[æŠ¥è­¦è®°å½•]
        AlarmRecord --> AlarmEnd[æŠ¥è­¦å¤„ç†å®Œæˆ]
    end

    subgraph è§†é¢‘è”åŠ¨æµç¨‹
        VideoLinkage --> EventTrigger[äº‹ä»¶è§¦å‘]
        EventTrigger --> CameraSelect[æ‘„åƒå¤´é€‰æ‹©]
        CameraSelect --> VideoStart[å½•åƒå¯åŠ¨]
        VideoStart --> VideoStore[å­˜å‚¨å…³è”]
        VideoStore --> VideoEnd[è§†é¢‘è”åŠ¨å®Œæˆ]
    end

    subgraph äººå‘˜è¿½è¸ªæµç¨‹
        PersonTrack --> TrackCollect[è½¨è¿¹æ”¶é›†]
        TrackCollect --> TrackAnalysis[è½¨è¿¹åˆ†æ]
        TrackAnalysis --> PositionCalc[ä½ç½®è®¡ç®—]
        PositionCalc --> TrackDisplay[è½¨è¿¹å±•ç¤º]
        TrackDisplay --> AbnormalCheck{å¼‚å¸¸æ£€æµ‹}
        AbnormalCheck -->|æ˜¯| AbnormalAlert[å¼‚å¸¸å‘Šè­¦]
        AbnormalCheck -->|å¦| TrackEnd[è¿½è¸ªå®Œæˆ]
        AbnormalAlert --> TrackEnd
    end
```

## ğŸ”§ æ ¸å¿ƒåŠŸèƒ½è¯¦ç»†è®¾è®¡

### 1. å®æ—¶çŠ¶æ€ç›‘æ§æœåŠ¡

#### 1.1 è®¾å¤‡çŠ¶æ€ç›‘æ§

**åŠŸèƒ½æè¿°**ï¼šå®æ—¶ç›‘æ§é—¨ç¦è®¾å¤‡ã€é—¨ã€è¯»å¤´ç­‰ç¡¬ä»¶çŠ¶æ€

**æŠ€æœ¯å®ç°**ï¼š
```java
@Service
@Slf4j
public class RealTimeStatusMonitorService {

    @Resource
    private SimpMessagingTemplate messagingTemplate;

    @Resource
    private RedisTemplate<String, Object> redisTemplate;

    @Resource
    private DeviceConnectionPool connectionPool;

    private final ScheduledExecutorService monitorExecutor =
            Executors.newScheduledThreadPool(10);

    /**
     * å¯åŠ¨è®¾å¤‡çŠ¶æ€ç›‘æ§
     */
    @PostConstruct
    public void startDeviceStatusMonitoring() {
        // æ¯ç§’æ›´æ–°ä¸€æ¬¡è®¾å¤‡çŠ¶æ€
        monitorExecutor.scheduleAtFixedRate(() -> {
            try {
                updateAllDeviceStatus();
            } catch (Exception e) {
                log.error("è®¾å¤‡çŠ¶æ€ç›‘æ§æ›´æ–°å¤±è´¥", e);
            }
        }, 0, 1, TimeUnit.SECONDS);
    }

    /**
     * æ›´æ–°æ‰€æœ‰è®¾å¤‡çŠ¶æ€
     */
    private void updateAllDeviceStatus() {
        try {
            // 1. è·å–æ‰€æœ‰åœ¨çº¿è®¾å¤‡
            List<DeviceConnection> onlineDevices = connectionPool.getOnlineDevices();

            // 2. å¹¶å‘æ›´æ–°è®¾å¤‡çŠ¶æ€
            List<CompletableFuture<DeviceStatus>> futures = onlineDevices.stream()
                    .map(device -> CompletableFuture.supplyAsync(() ->
                            updateDeviceStatus(device), monitorExecutor))
                    .collect(Collectors.toList());

            // 3. ç­‰å¾…æ‰€æœ‰æ›´æ–°å®Œæˆ
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                    .thenApply(v -> futures.stream()
                            .map(CompletableFuture::join)
                            .collect(Collectors.toList()))
                    .thenAccept(this::processStatusUpdates)
                    .exceptionally(throwable -> {
                        log.error("è®¾å¤‡çŠ¶æ€æ‰¹é‡æ›´æ–°å¤±è´¥", throwable);
                        return null;
                    });

        } catch (Exception e) {
            log.error("è®¾å¤‡çŠ¶æ€ç›‘æ§å¼‚å¸¸", e);
        }
    }

    /**
     * æ›´æ–°å•ä¸ªè®¾å¤‡çŠ¶æ€
     */
    private DeviceStatus updateDeviceStatus(DeviceConnection connection) {
        try {
            Long deviceId = connection.getDeviceId();

            // 1. è·å–è®¾å¤‡åŸºæœ¬ä¿¡æ¯
            DeviceInfo deviceInfo = deviceService.getDeviceInfo(deviceId);

            // 2. è·å–è®¾å¤‡å®æ—¶çŠ¶æ€
            DeviceRealTimeStatus status = deviceProtocolAdapter
                    .getDeviceRealTimeStatus(connection);

            // 3. æ„å»ºè®¾å¤‡çŠ¶æ€å¯¹è±¡
            DeviceStatus deviceStatus = DeviceStatus.builder()
                    .deviceId(deviceId)
                    .deviceName(deviceInfo.getDeviceName())
                    .ipAddress(deviceInfo.getIpAddress())
                    .onlineStatus(status.isOnline())
                    .cpuUsage(status.getCpuUsage())
                    .memoryUsage(status.getMemoryUsage())
                    .diskUsage(status.getDiskUsage())
                    .networkStatus(status.getNetworkStatus())
                    .lastUpdateTime(LocalDateTime.now())
                    .build();

            // 4. æ›´æ–°ç¼“å­˜
            String cacheKey = "device:status:" + deviceId;
            redisTemplate.opsForValue().set(cacheKey, deviceStatus, Duration.ofMinutes(5));

            return deviceStatus;

        } catch (Exception e) {
            log.error("æ›´æ–°è®¾å¤‡çŠ¶æ€å¤±è´¥, deviceId: {}", connection.getDeviceId(), e);
            return DeviceStatus.offline(connection.getDeviceId());
        }
    }

    /**
     * å¤„ç†çŠ¶æ€æ›´æ–°
     */
    private void processStatusUpdates(List<DeviceStatus> statusUpdates) {
        try {
            // 1. æ‰¹é‡ä¿å­˜åˆ°æ•°æ®åº“
            deviceStatusService.batchUpdateStatus(statusUpdates);

            // 2. æ¨é€å®æ—¶çŠ¶æ€åˆ°å‰ç«¯
            for (DeviceStatus status : statusUpdates) {
                messagingTemplate.convertAndSend(
                    "/topic/device-status/" + status.getDeviceId(),
                    status
                );
            }

            // 3. æ£€æŸ¥å¼‚å¸¸çŠ¶æ€
            checkAbnormalStatus(statusUpdates);

        } catch (Exception e) {
            log.error("å¤„ç†è®¾å¤‡çŠ¶æ€æ›´æ–°å¤±è´¥", e);
        }
    }

    /**
     * æ£€æŸ¥å¼‚å¸¸çŠ¶æ€
     */
    private void checkAbnormalStatus(List<DeviceStatus> statusUpdates) {
        for (DeviceStatus status : statusUpdates) {
            // 1. æ£€æŸ¥è®¾å¤‡ç¦»çº¿
            if (!status.isOnlineStatus()) {
                DeviceOfflineEvent event = DeviceOfflineEvent.builder()
                        .deviceId(status.getDeviceId())
                        .deviceName(status.getDeviceName())
                        .offlineTime(status.getLastUpdateTime())
                        .build();
                applicationEventPublisher.publishEvent(event);
            }

            // 2. æ£€æŸ¥CPUä½¿ç”¨ç‡è¿‡é«˜
            if (status.getCpuUsage() > 90.0) {
                DeviceHighCpuEvent event = DeviceHighCpuEvent.builder()
                        .deviceId(status.getDeviceId())
                        .cpuUsage(status.getCpuUsage())
                        .build();
                applicationEventPublisher.publishEvent(event);
            }

            // 3. æ£€æŸ¥å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜
            if (status.getMemoryUsage() > 90.0) {
                DeviceHighMemoryEvent event = DeviceHighMemoryEvent.builder()
                        .deviceId(status.getDeviceId())
                        .memoryUsage(status.getMemoryUsage())
                        .build();
                applicationEventPublisher.publishEvent(event);
            }
        }
    }
}
```

#### 1.2 é—¨çŠ¶æ€ç›‘æ§

**åŠŸèƒ½æè¿°**ï¼šå®æ—¶ç›‘æ§é—¨çš„å¼€å…³çŠ¶æ€å’Œå¼‚å¸¸æƒ…å†µ

**æŠ€æœ¯å®ç°**ï¼š
```java
@Service
@Slf4j
public class DoorStatusMonitorService {

    @Resource
    private DeviceProtocolAdapter protocolAdapter;

    @Resource
    private DoorEventService doorEventService;

    @Resource
    private AlarmService alarmService;

    /**
     * ç›‘æ§é—¨çŠ¶æ€å˜åŒ–
     */
    @EventListener
    @Async
    public void handleDoorStatusChangedEvent(DoorStatusChangedEvent event) {
        try {
            Long doorId = event.getDoorId();
            DoorStatus newStatus = event.getNewStatus();
            DoorStatus oldStatus = event.getOldStatus();

            // 1. è®°å½•é—¨çŠ¶æ€å˜åŒ–äº‹ä»¶
            DoorStatusChangeEvent statusChangeEvent = DoorStatusChangeEvent.builder()
                    .doorId(doorId)
                    .oldStatus(oldStatus)
                    .newStatus(newStatus)
                    .changeTime(LocalDateTime.now())
                    .changeReason(event.getChangeReason())
                    .build();

            doorEventService.saveStatusChangeEvent(statusChangeEvent);

            // 2. æ£€æŸ¥å¼‚å¸¸çŠ¶æ€
            checkAbnormalDoorStatus(doorId, newStatus, oldStatus);

            // 3. æ¨é€çŠ¶æ€å˜åŒ–åˆ°å‰ç«¯
            messagingTemplate.convertAndSend(
                "/topic/door-status/" + doorId,
                DoorStatusVO.builder()
                        .doorId(doorId)
                        .status(newStatus)
                        .changeTime(LocalDateTime.now())
                        .build()
            );

            log.info("é—¨çŠ¶æ€å˜åŒ–å¤„ç†å®Œæˆ, doorId: {}, status: {} -> {}",
                    doorId, oldStatus, newStatus);

        } catch (Exception e) {
            log.error("é—¨çŠ¶æ€å˜åŒ–å¤„ç†å¤±è´¥", e);
        }
    }

    /**
     * æ£€æŸ¥å¼‚å¸¸é—¨çŠ¶æ€
     */
    private void checkAbnormalDoorStatus(Long doorId, DoorStatus newStatus,
                                       DoorStatus oldStatus) {
        try {
            // 1. æ£€æŸ¥é—¨å¼ºåˆ¶å¼€é—¨
            if (newStatus == DoorStatus.FORCED_OPEN) {
                DoorForcedOpenAlarm alarm = DoorForcedOpenAlarm.builder()
                        .doorId(doorId)
                        .alarmLevel(AlarmLevel.HIGH)
                        .alarmTime(LocalDateTime.now())
                        .description("æ£€æµ‹åˆ°é—¨è¢«å¼ºåˆ¶æ‰“å¼€")
                        .build();
                alarmService.createAlarm(alarm);
            }

            // 2. æ£€æŸ¥é—¨é•¿æ—¶é—´æœªå…³é—­
            if (newStatus == DoorStatus.OPEN && oldStatus != DoorStatus.OPEN) {
                // å¯åŠ¨é•¿æ—¶é—´å¼€é—¨æ£€æµ‹å®šæ—¶å™¨
                startLongOpenCheckTimer(doorId);
            }

            // 3. æ£€æŸ¥é—¨å¼‚å¸¸çŠ¶æ€
            if (newStatus == DoorStatus.FAULT) {
                DoorFaultAlarm alarm = DoorFaultAlarm.builder()
                        .doorId(doorId)
                        .alarmLevel(AlarmLevel.MEDIUM)
                        .alarmTime(LocalDateTime.now())
                        .description("é—¨è®¾å¤‡æ•…éšœ")
                        .build();
                alarmService.createAlarm(alarm);
            }

        } catch (Exception e) {
            log.error("æ£€æŸ¥å¼‚å¸¸é—¨çŠ¶æ€å¤±è´¥, doorId: {}", doorId, e);
        }
    }

    /**
     * å¯åŠ¨é•¿æ—¶é—´å¼€é—¨æ£€æµ‹å®šæ—¶å™¨
     */
    private void startLongOpenCheckTimer(Long doorId) {
        ScheduledExecutorService timer = Executors.newSingleThreadScheduledExecutor();

        timer.schedule(() -> {
            try {
                DoorStatus currentStatus = doorService.getDoorStatus(doorId);
                if (currentStatus == DoorStatus.OPEN) {
                    // ç”Ÿæˆé•¿æ—¶é—´å¼€é—¨å‘Šè­¦
                    DoorLongOpenAlarm alarm = DoorLongOpenAlarm.builder()
                            .doorId(doorId)
                            .alarmLevel(AlarmLevel.MEDIUM)
                            .alarmTime(LocalDateTime.now())
                            .description("é—¨é•¿æ—¶é—´æœªå…³é—­")
                            .build();
                    alarmService.createAlarm(alarm);
                }
            } catch (Exception e) {
                log.error("é•¿æ—¶é—´å¼€é—¨æ£€æµ‹å¤±è´¥", e);
            }
        }, 30, TimeUnit.SECONDS); // 30ç§’åæ£€æŸ¥
    }
}
```

### 2. æ™ºèƒ½æŠ¥è­¦å¤„ç†æœåŠ¡

#### 2.1 æŠ¥è­¦ç®¡ç†æœåŠ¡

**åŠŸèƒ½æè¿°**ï¼šæ™ºèƒ½æŠ¥è­¦åˆ†æã€åˆ†ç±»å’Œå¤„ç†

**æŠ€æœ¯å®ç°**ï¼š
```java
@Service
@Slf4j
public class IntelligentAlarmProcessService {

    @Resource
    private AlarmAnalysisEngine alarmAnalysisEngine;

    @Resource
    private AlarmNotificationService notificationService;

    @Resource
    private AlarmEscalationService escalationService;

    /**
     * å¤„ç†æŠ¥è­¦äº‹ä»¶
     */
    @EventListener
    @Async
    public void handleAlarmEvent(AlarmEvent event) {
        try {
            // 1. åˆ†ææŠ¥è­¦ç±»å‹å’Œçº§åˆ«
            AlarmAnalysisResult analysisResult = alarmAnalysisEngine
                    .analyzeAlarm(event);

            // 2. åˆ›å»ºæŠ¥è­¦è®°å½•
            AlarmRecord alarmRecord = AlarmRecord.builder()
                    .alarmId(event.getAlarmId())
                    .alarmType(analysisResult.getAlarmType())
                    .alarmLevel(analysisResult.getAlarmLevel())
                    .sourceDeviceId(event.getSourceDeviceId())
                    .sourceAreaId(event.getSourceAreaId())
                    .alarmTitle(analysisResult.getTitle())
                    .alarmContent(analysisResult.getContent())
                    .occurrenceTime(LocalDateTime.now())
                    .status(AlarmStatus.PENDING)
                    .build();

            alarmService.saveAlarm(alarmRecord);

            // 3. å‘é€æŠ¥è­¦é€šçŸ¥
            sendAlarmNotifications(alarmRecord, analysisResult);

            // 4. å¯åŠ¨æŠ¥è­¦å‡çº§å®šæ—¶å™¨
            startAlarmEscalationTimer(alarmRecord);

            log.info("æŠ¥è­¦äº‹ä»¶å¤„ç†å®Œæˆ, alarmId: {}, level: {}",
                    event.getAlarmId(), analysisResult.getAlarmLevel());

        } catch (Exception e) {
            log.error("æŠ¥è­¦äº‹ä»¶å¤„ç†å¤±è´¥", e);
        }
    }

    /**
     * å‘é€æŠ¥è­¦é€šçŸ¥
     */
    private void sendAlarmNotifications(AlarmRecord alarmRecord,
                                       AlarmAnalysisResult analysisResult) {
        try {
            // 1. è·å–æŠ¥è­¦é€šçŸ¥è§„åˆ™
            List<NotificationRule> notificationRules = getNotificationRules(
                    alarmRecord.getAlarmType(), alarmRecord.getAlarmLevel());

            // 2. æ ¹æ®è§„åˆ™å‘é€é€šçŸ¥
            for (NotificationRule rule : notificationRules) {
                switch (rule.getNotificationType()) {
                    case SMS:
                        notificationService.sendSmsNotification(alarmRecord, rule);
                        break;
                    case EMAIL:
                        notificationService.sendEmailNotification(alarmRecord, rule);
                        break;
                    case PUSH:
                        notificationService.sendPushNotification(alarmRecord, rule);
                        break;
                    case WEBHOOK:
                        notificationService.sendWebhookNotification(alarmRecord, rule);
                        break;
                }
            }

        } catch (Exception e) {
            log.error("å‘é€æŠ¥è­¦é€šçŸ¥å¤±è´¥, alarmId: {}", alarmRecord.getAlarmId(), e);
        }
    }

    /**
     * å¯åŠ¨æŠ¥è­¦å‡çº§å®šæ—¶å™¨
     */
    private void startAlarmEscalationTimer(AlarmRecord alarmRecord) {
        ScheduledExecutorService escalationTimer = Executors.newSingleThreadScheduledExecutor();

        // æ ¹æ®æŠ¥è­¦çº§åˆ«è®¾ç½®å‡çº§æ—¶é—´
        int escalationDelay = getEscalationDelay(alarmRecord.getAlarmLevel());

        escalationTimer.schedule(() -> {
            try {
                AlarmRecord currentAlarm = alarmService.getById(alarmRecord.getAlarmId());
                if (currentAlarm.getStatus() == AlarmStatus.PENDING) {
                    // æ‰§è¡ŒæŠ¥è­¦å‡çº§
                    escalationService.escalateAlarm(currentAlarm);
                }
            } catch (Exception e) {
                log.error("æŠ¥è­¦å‡çº§å¤„ç†å¤±è´¥, alarmId: {}", alarmRecord.getAlarmId(), e);
            }
        }, escalationDelay, TimeUnit.SECONDS);
    }

    /**
     * è·å–å‡çº§å»¶è¿Ÿæ—¶é—´ï¼ˆç§’ï¼‰
     */
    private int getEscalationDelay(AlarmLevel alarmLevel) {
        switch (alarmLevel) {
            case CRITICAL:
                return 30; // 30ç§’
            case HIGH:
                return 60; // 1åˆ†é’Ÿ
            case MEDIUM:
                return 300; // 5åˆ†é’Ÿ
            case LOW:
                return 900; // 15åˆ†é’Ÿ
            default:
                return 600; // é»˜è®¤10åˆ†é’Ÿ
        }
    }
}
```

#### 2.2 æŠ¥è­¦åˆ†æå¼•æ“

**åŠŸèƒ½æè¿°**ï¼šåŸºäºè§„åˆ™å’Œæœºå™¨å­¦ä¹ çš„æ™ºèƒ½æŠ¥è­¦åˆ†æ

**æŠ€æœ¯å®ç°**ï¼š
```java
@Component
@Slf4j
public class AlarmAnalysisEngine {

    @Resource
    private AlarmRuleEngine ruleEngine;

    @Resource
    private MachineLearningModel mlModel;

    @Resource
    private AlarmHistoryService historyService;

    /**
     * åˆ†ææŠ¥è­¦äº‹ä»¶
     */
    public AlarmAnalysisResult analyzeAlarm(AlarmEvent event) {
        try {
            // 1. è§„åˆ™åˆ†æ
            RuleAnalysisResult ruleResult = ruleEngine.analyze(event);

            // 2. æœºå™¨å­¦ä¹ åˆ†æ
            MLAnalysisResult mlResult = mlModel.analyze(event);

            // 3. å†å²æ•°æ®åˆ†æ
            HistoryAnalysisResult historyResult = historyService.analyzePattern(event);

            // 4. ç»¼åˆåˆ†æç»“æœ
            AlarmAnalysisResult result = AlarmAnalysisResult.builder()
                    .alarmType(determineAlarmType(ruleResult, mlResult))
                    .alarmLevel(determineAlarmLevel(ruleResult, mlResult, historyResult))
                    .confidence(calculateConfidence(ruleResult, mlResult))
                    .title(generateAlarmTitle(event, ruleResult))
                    .content(generateAlarmContent(event, ruleResult, mlResult))
                    .recommendedActions(generateRecommendedActions(ruleResult, mlResult))
                    .relatedEvents(findRelatedEvents(event))
                    .build();

            log.info("æŠ¥è­¦åˆ†æå®Œæˆ, eventType: {}, alarmLevel: {}, confidence: {}%",
                    event.getEventType(), result.getAlarmLevel(), result.getConfidence());

            return result;

        } catch (Exception e) {
            log.error("æŠ¥è­¦åˆ†æå¤±è´¥", e);
            return AlarmAnalysisResult.defaultResult(event);
        }
    }

    /**
     * ç¡®å®šæŠ¥è­¦ç±»å‹
     */
    private AlarmType determineAlarmType(RuleAnalysisResult ruleResult,
                                       MLAnalysisResult mlResult) {
        // ä¼˜å…ˆä½¿ç”¨è§„åˆ™å¼•æ“ç»“æœ
        if (ruleResult.getAlarmType() != null) {
            return ruleResult.getAlarmType();
        }

        // ä½¿ç”¨æœºå™¨å­¦ä¹ ç»“æœ
        if (mlResult.getAlarmType() != null) {
            return mlResult.getAlarmType();
        }

        // é»˜è®¤ç±»å‹
        return AlarmType.SYSTEM_ERROR;
    }

    /**
     * ç¡®å®šæŠ¥è­¦çº§åˆ«
     */
    private AlarmLevel determineAlarmLevel(RuleAnalysisResult ruleResult,
                                          MLAnalysisResult mlResult,
                                          HistoryAnalysisResult historyResult) {
        // 1. åŸºç¡€çº§åˆ«ä»è§„åˆ™å¼•æ“è·å–
        AlarmLevel baseLevel = ruleResult.getAlarmLevel() != null ?
                ruleResult.getAlarmLevel() : AlarmLevel.LOW;

        // 2. æœºå™¨å­¦ä¹ è°ƒæ•´
        if (mlResult.getRiskScore() > 0.8) {
            baseLevel = increaseAlarmLevel(baseLevel);
        }

        // 3. å†å²æ¨¡å¼è°ƒæ•´
        if (historyResult.isHighFrequencyPattern()) {
            baseLevel = decreaseAlarmLevel(baseLevel); // é«˜é¢‘æ¨¡å¼é™ä½çº§åˆ«
        }

        return baseLevel;
    }

    /**
     * è®¡ç®—åˆ†æç½®ä¿¡åº¦
     */
    private double calculateConfidence(RuleAnalysisResult ruleResult,
                                     MLAnalysisResult mlResult) {
        double ruleConfidence = ruleResult.getConfidence();
        double mlConfidence = mlResult.getConfidence();

        // åŠ æƒå¹³å‡
        return (ruleConfidence * 0.6) + (mlConfidence * 0.4);
    }

    /**
     * ç”ŸæˆæŠ¥è­¦æ ‡é¢˜
     */
    private String generateAlarmTitle(AlarmEvent event, RuleAnalysisResult ruleResult) {
        if (ruleResult.getTitle() != null) {
            return ruleResult.getTitle();
        }

        return String.format("%s - %s", event.getEventType().getDescription(),
                event.getSourceDeviceName());
    }
}
```

### 3. è§†é¢‘è”åŠ¨æœåŠ¡

#### 3.1 è§†é¢‘è”åŠ¨æ§åˆ¶

**åŠŸèƒ½æè¿°**ï¼šé—¨ç¦äº‹ä»¶ä¸è§†é¢‘ç›‘æ§çš„æ™ºèƒ½è”åŠ¨

**æŠ€æœ¯å®ç°**ï¼š
```java
@Service
@Slf4j
public class VideoLinkageService {

    @Resource
    private VideoSystemClient videoSystemClient;

    @Resource
    private CameraMappingService cameraMappingService;

    @Resource
    private VideoStorageService videoStorageService;

    /**
     * å¤„ç†é—¨ç¦äº‹ä»¶è§†é¢‘è”åŠ¨
     */
    @EventListener
    @Async
    public void handleAccessEventVideoLinkage(AccessEvent accessEvent) {
        try {
            Long doorId = accessEvent.getDoorId();
            LocalDateTime eventTime = accessEvent.getEventTime();

            // 1. è·å–é—¨å¯¹åº”çš„æ‘„åƒå¤´
            List<CameraInfo> cameras = cameraMappingService.getDoorCameras(doorId);
            if (CollectionUtils.isEmpty(cameras)) {
                log.info("é—¨{}æœªé…ç½®æ‘„åƒå¤´ï¼Œè·³è¿‡è§†é¢‘è”åŠ¨", doorId);
                return;
            }

            // 2. å¹¶å‘å¯åŠ¨æ‰€æœ‰æ‘„åƒå¤´çš„å½•åƒ
            List<CompletableFuture<VideoRecordResult>> futures = cameras.stream()
                    .map(camera -> CompletableFuture.supplyAsync(() ->
                            startVideoRecording(camera, accessEvent)))
                    .collect(Collectors.toList());

            // 3. ç­‰å¾…æ‰€æœ‰å½•åƒå¯åŠ¨å®Œæˆ
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                    .thenApply(v -> futures.stream()
                            .map(CompletableFuture::join)
                            .collect(Collectors.toList()))
                    .thenAccept(results -> saveVideoLinkageRecords(accessEvent, results))
                    .exceptionally(throwable -> {
                        log.error("è§†é¢‘è”åŠ¨å¤„ç†å¤±è´¥", throwable);
                        return null;
                    });

            log.info("é—¨ç¦äº‹ä»¶è§†é¢‘è”åŠ¨å¤„ç†å®Œæˆ, doorId: {}, cameraCount: {}",
                    doorId, cameras.size());

        } catch (Exception e) {
            log.error("é—¨ç¦äº‹ä»¶è§†é¢‘è”åŠ¨å¤±è´¥", e);
        }
    }

    /**
     * å¯åŠ¨è§†é¢‘å½•åƒ
     */
    private VideoRecordResult startVideoRecording(CameraInfo camera, AccessEvent accessEvent) {
        try {
            // 1. æ„å»ºå½•åƒè¯·æ±‚
            VideoRecordRequest recordRequest = VideoRecordRequest.builder()
                    .cameraId(camera.getCameraId())
                    .recordType(RecordType.EVENT_TRIGGERED)
                    .startTime(accessEvent.getEventTime())
                    .duration(Duration.ofSeconds(30)) // é»˜è®¤å½•åˆ¶30ç§’
                    .quality(VideoQuality.HIGH)
                    .eventInfo(EventInfo.builder()
                            .eventId(accessEvent.getEventId())
                            .eventType(accessEvent.getEventType())
                            .personId(accessEvent.getPersonId())
                            .doorId(accessEvent.getDoorId())
                            .build())
                    .build();

            // 2. è°ƒç”¨è§†é¢‘ç³»ç»Ÿå¯åŠ¨å½•åƒ
            VideoRecordResponse response = videoSystemClient.startRecording(recordRequest);

            // 3. åŒæ—¶æŠ“æ‹å¿«ç…§
            String snapshotUrl = videoSystemClient.captureSnapshot(
                    camera.getCameraId(), accessEvent.getEventTime());

            return VideoRecordResult.builder()
                    .cameraId(camera.getCameraId())
                    .cameraName(camera.getCameraName())
                    .recordId(response.getRecordId())
                    .recordUrl(response.getRecordUrl())
                    .snapshotUrl(snapshotUrl)
                    .startTime(accessEvent.getEventTime())
                    .success(response.isSuccess())
                    .errorMessage(response.getErrorMessage())
                    .build();

        } catch (Exception e) {
            log.error("å¯åŠ¨è§†é¢‘å½•åƒå¤±è´¥, cameraId: {}", camera.getCameraId(), e);
            return VideoRecordResult.failed(camera.getCameraId(), e.getMessage());
        }
    }

    /**
     * ä¿å­˜è§†é¢‘è”åŠ¨è®°å½•
     */
    private void saveVideoLinkageRecords(AccessEvent accessEvent,
                                        List<VideoRecordResult> recordResults) {
        try {
            List<VideoLinkageRecord> linkageRecords = new ArrayList<>();

            for (VideoRecordResult result : recordResults) {
                if (result.isSuccess()) {
                    VideoLinkageRecord record = VideoLinkageRecord.builder()
                            .eventId(accessEvent.getEventId())
                            .cameraId(result.getCameraId())
                            .recordId(result.getRecordId())
                            .recordUrl(result.getRecordUrl())
                            .snapshotUrl(result.getSnapshotUrl())
                            .startTime(result.getStartTime())
                            .createTime(LocalDateTime.now())
                            .build();
                    linkageRecords.add(record);
                }
            }

            // æ‰¹é‡ä¿å­˜è”åŠ¨è®°å½•
            videoStorageService.batchSaveLinkageRecords(linkageRecords);

            // æ›´æ–°é—¨ç¦äº‹ä»¶ï¼Œå…³è”è§†é¢‘ä¿¡æ¯
            accessEventService.updateEventVideoLinks(accessEvent.getEventId(),
                    recordResults.stream()
                            .filter(VideoRecordResult::isSuccess)
                            .collect(Collectors.toList()));

        } catch (Exception e) {
            log.error("ä¿å­˜è§†é¢‘è”åŠ¨è®°å½•å¤±è´¥", e);
        }
    }
}
```

### 4. äººå‘˜è¿½è¸ªæœåŠ¡

#### 4.1 äººå‘˜è½¨è¿¹è¿½è¸ª

**åŠŸèƒ½æè¿°**ï¼šå®æ—¶äººå‘˜ä½ç½®è¿½è¸ªå’Œè½¨è¿¹åˆ†æ

**æŠ€æœ¯å®ç°**ï¼š
```java
@Service
@Slf4j
public class PersonTrackingService {

    @Resource
    private AccessEventService accessEventService;

    @Resource
    private TrajectoryCalculationEngine trajectoryEngine;

    @Resource
    private AbnormalDetectionEngine abnormalEngine;

    @Resource
    private PositionService positionService;

    /**
     * å¤„ç†äººå‘˜è®¿é—®äº‹ä»¶ï¼Œæ›´æ–°è½¨è¿¹
     */
    @EventListener
    @Async
    public void handlePersonAccessEvent(PersonAccessEvent event) {
        try {
            Long personId = event.getPersonId();
            Long doorId = event.getDoorId();
            LocalDateTime eventTime = event.getEventTime();

            // 1. è®°å½•ä½ç½®ç‚¹
            PositionPoint positionPoint = PositionPoint.builder()
                    .personId(personId)
                    .locationId(doorId)
                    .locationType(LocationType.DOOR)
                    .accessType(event.getAccessType())
                    .timestamp(eventTime)
                    .build();

            positionService.recordPositionPoint(positionPoint);

            // 2. æ›´æ–°äººå‘˜è½¨è¿¹
            updatePersonTrajectory(personId, positionPoint);

            // 3. è®¡ç®—å½“å‰ä½ç½®
            PersonPosition currentPosition = calculateCurrentPosition(personId, eventTime);

            // 4. å¼‚å¸¸è¡Œä¸ºæ£€æµ‹
            detectAbnormalBehavior(personId, currentPosition);

            // 5. æ¨é€å®æ—¶ä½ç½®æ›´æ–°
            pushRealTimePositionUpdate(personId, currentPosition);

        } catch (Exception e) {
            log.error("äººå‘˜è®¿é—®äº‹ä»¶å¤„ç†å¤±è´¥", e);
        }
    }

    /**
     * æ›´æ–°äººå‘˜è½¨è¿¹
     */
    private void updatePersonTrajectory(Long personId, PositionPoint newPosition) {
        try {
            // 1. è·å–å†å²è½¨è¿¹ç‚¹
            List<PositionPoint> recentPositions = positionService
                    .getRecentPositions(personId, Duration.ofHours(24));

            // 2. æ·»åŠ æ–°ä½ç½®ç‚¹
            recentPositions.add(newPosition);

            // 3. è®¡ç®—è½¨è¿¹
            PersonTrajectory trajectory = trajectoryEngine
                    .calculateTrajectory(recentPositions);

            // 4. ä¿å­˜è½¨è¿¹
            positionService.saveTrajectory(personId, trajectory);

        } catch (Exception e) {
            log.error("æ›´æ–°äººå‘˜è½¨è¿¹å¤±è´¥, personId: {}", personId, e);
        }
    }

    /**
     * è®¡ç®—å½“å‰ä½ç½®
     */
    private PersonPosition calculateCurrentPosition(Long personId, LocalDateTime eventTime) {
        try {
            // 1. è·å–æœ€è¿‘çš„è®¿é—®è®°å½•
            AccessEvent lastAccessEvent = accessEventService
                    .getLastAccessEvent(personId);

            if (lastAccessEvent == null) {
                return PersonPosition.unknown(personId);
            }

            // 2. è·å–é—¨ä½ç½®ä¿¡æ¯
            DoorLocation doorLocation = positionService
                    .getDoorLocation(lastAccessEvent.getDoorId());

            // 3. æ ¹æ®è®¿é—®ç±»å‹ç¡®å®šä½ç½®
            PersonPosition position;
            if (lastAccessEvent.getAccessType() == AccessType.ENTER) {
                position = PersonPosition.builder()
                        .personId(personId)
                        .areaId(doorLocation.getInsideAreaId())
                        .areaName(doorLocation.getInsideAreaName())
                        .locationType(LocationType.AREA)
                        .coordinate(doorLocation.getCoordinate())
                        .lastUpdateTime(eventTime)
                        .confidence(0.95)
                        .build();
            } else {
                position = PersonPosition.builder()
                        .personId(personId)
                        .areaId(doorLocation.getOutsideAreaId())
                        .areaName(doorLocation.getOutsideAreaName())
                        .locationType(LocationType.AREA)
                        .coordinate(doorLocation.getCoordinate())
                        .lastUpdateTime(eventTime)
                        .confidence(0.95)
                        .build();
            }

            return position;

        } catch (Exception e) {
            log.error("è®¡ç®—äººå‘˜å½“å‰ä½ç½®å¤±è´¥, personId: {}", personId, e);
            return PersonPosition.unknown(personId);
        }
    }

    /**
     * å¼‚å¸¸è¡Œä¸ºæ£€æµ‹
     */
    private void detectAbnormalBehavior(Long personId, PersonPosition position) {
        try {
            // 1. è·å–å†å²è½¨è¿¹æ•°æ®
            List<PersonTrajectory> historicalTrajectories = positionService
                    .getHistoricalTrajectories(personId, Duration.ofDays(30));

            // 2. æ£€æµ‹å¼‚å¸¸æ¨¡å¼
            List<AbnormalBehavior> abnormalBehaviors = abnormalEngine
                    .detectAbnormalBehavior(position, historicalTrajectories);

            // 3. å¤„ç†æ£€æµ‹åˆ°çš„å¼‚å¸¸è¡Œä¸º
            for (AbnormalBehavior abnormal : abnormalBehaviors) {
                handleAbnormalBehavior(abnormal);
            }

        } catch (Exception e) {
            log.error("å¼‚å¸¸è¡Œä¸ºæ£€æµ‹å¤±è´¥, personId: {}", personId, e);
        }
    }

    /**
     * å¤„ç†å¼‚å¸¸è¡Œä¸º
     */
    private void handleAbnormalBehavior(AbnormalBehavior abnormal) {
        try {
            // 1. åˆ›å»ºå¼‚å¸¸è¡Œä¸ºè®°å½•
            AbnormalBehaviorRecord record = AbnormalBehaviorRecord.builder()
                    .personId(abnormal.getPersonId())
                    .behaviorType(abnormal.getBehaviorType())
                    .behaviorLevel(abnormal.getBehaviorLevel())
                    .description(abnormal.getDescription())
                    .occurrenceTime(abnormal.getOccurrenceTime())
                    .location(abnormal.getLocation())
                    .confidence(abnormal.getConfidence())
                    .createTime(LocalDateTime.now())
                    .build();

            abnormalBehaviorService.saveRecord(record);

            // 2. å¦‚æœæ˜¯é«˜å±å¼‚å¸¸ï¼Œå‘é€å‘Šè­¦
            if (abnormal.getBehaviorLevel() == BehaviorLevel.HIGH) {
                AbnormalBehaviorAlarm alarm = AbnormalBehaviorAlarm.builder()
                        .personId(abnormal.getPersonId())
                        .behaviorType(abnormal.getBehaviorType())
                        .alarmLevel(AlarmLevel.HIGH)
                        .alarmTime(LocalDateTime.now())
                        .description("æ£€æµ‹åˆ°é«˜å±å¼‚å¸¸è¡Œä¸º: " + abnormal.getDescription())
                        .build();
                alarmService.createAlarm(alarm);
            }

        } catch (Exception e) {
            log.error("å¤„ç†å¼‚å¸¸è¡Œä¸ºå¤±è´¥", e);
        }
    }
}
```

#### 4.2 è½¨è¿¹è®¡ç®—å¼•æ“

**åŠŸèƒ½æè¿°**ï¼šåŸºäºå†å²æ•°æ®è®¡ç®—å’Œåˆ†æäººå‘˜ç§»åŠ¨è½¨è¿¹

**æŠ€æœ¯å®ç°**ï¼š
```java
@Component
@Slf4j
public class TrajectoryCalculationEngine {

    @Resource
    private PathOptimizationService pathOptimizationService;

    /**
     * è®¡ç®—äººå‘˜è½¨è¿¹
     */
    public PersonTrajectory calculateTrajectory(List<PositionPoint> positionPoints) {
        try {
            if (CollectionUtils.isEmpty(positionPoints)) {
                return PersonTrajectory.empty();
            }

            // 1. æŒ‰æ—¶é—´æ’åº
            positionPoints.sort(Comparator.comparing(PositionPoint::getTimestamp));

            // 2. æ•°æ®æ¸…æ´—å’Œé¢„å¤„ç†
            List<PositionPoint> cleanedPoints = preprocessPositionPoints(positionPoints);

            // 3. è½¨è¿¹æ®µåˆ’åˆ†
            List<TrajectorySegment> segments = segmentTrajectory(cleanedPoints);

            // 4. è·¯å¾„ä¼˜åŒ–
            List<OptimizedPath> optimizedPaths = pathOptimizationService
                    .optimizePaths(segments);

            // 5. æ„å»ºå®Œæ•´è½¨è¿¹
            PersonTrajectory trajectory = PersonTrajectory.builder()
                    .personId(positionPoints.get(0).getPersonId())
                    .startTime(cleanedPoints.get(0).getTimestamp())
                    .endTime(cleanedPoints.get(cleanedPoints.size() - 1).getTimestamp())
                    .totalDistance(calculateTotalDistance(optimizedPaths))
                    .totalDuration(calculateTotalDuration(cleanedPoints))
                    .averageSpeed(calculateAverageSpeed(optimizedPaths, cleanedPoints))
                    .segments(segments)
                    .optimizedPaths(optimizedPaths)
                    .keyPoints(extractKeyPoints(cleanedPoints))
                    .build();

            return trajectory;

        } catch (Exception e) {
            log.error("è®¡ç®—äººå‘˜è½¨è¿¹å¤±è´¥", e);
            return PersonTrajectory.empty();
        }
    }

    /**
     * æ•°æ®é¢„å¤„ç†
     */
    private List<PositionPoint> preprocessPositionPoints(List<PositionPoint> points) {
        return points.stream()
                // 1. è¿‡æ»¤å¼‚å¸¸ç‚¹ï¼ˆæ—¶é—´é—´éš”è¿‡é•¿ã€ä½ç½®è·³è·ƒè¿‡å¤§ï¼‰
                .filter(point -> isValidPositionPoint(point, points))
                // 2. å»é‡ï¼ˆåŒä¸€ä½ç½®çŸ­æ—¶é—´å†…çš„é‡å¤è®°å½•ï¼‰
                .distinct()
                // 3. å¹³æ»‘å¤„ç†
                .collect(Collectors.toList());
    }

    /**
     * è½¨è¿¹æ®µåˆ’åˆ†
     */
    private List<TrajectorySegment> segmentTrajectory(List<PositionPoint> points) {
        List<TrajectorySegment> segments = new ArrayList<>();

        if (points.size() < 2) {
            return segments;
        }

        TrajectorySegment currentSegment = null;

        for (int i = 0; i < points.size() - 1; i++) {
            PositionPoint fromPoint = points.get(i);
            PositionPoint toPoint = points.get(i + 1);

            // è®¡ç®—ç§»åŠ¨ç‰¹å¾
            MovementFeature movement = calculateMovementFeature(fromPoint, toPoint);

            // åˆ¤æ–­æ˜¯å¦éœ€è¦æ–°çš„è½¨è¿¹æ®µ
            if (currentSegment == null || shouldStartNewSegment(currentSegment, movement)) {
                if (currentSegment != null) {
                    segments.add(currentSegment);
                }

                currentSegment = TrajectorySegment.builder()
                        .segmentId(generateSegmentId())
                        .startPoint(fromPoint)
                        .endPoint(toPoint)
                        .movementType(determineMovementType(movement))
                        .startTime(fromPoint.getTimestamp())
                        .endTime(toPoint.getTimestamp())
                        .distance(movement.getDistance())
                        .duration(movement.getDuration())
                        .averageSpeed(movement.getAverageSpeed())
                        .build();
            } else {
                // å»¶é•¿å½“å‰è½¨è¿¹æ®µ
                currentSegment.setEndPoint(toPoint);
                currentSegment.setEndTime(toPoint.getTimestamp());
                currentSegment.setDistance(currentSegment.getDistance() + movement.getDistance());
                currentSegment.setDuration(currentSegment.getDuration() + movement.getDuration());
                currentSegment.setAverageSpeed(calculateAverageSpeed(currentSegment));
            }
        }

        if (currentSegment != null) {
            segments.add(currentSegment);
        }

        return segments;
    }

    /**
     * è®¡ç®—ç§»åŠ¨ç‰¹å¾
     */
    private MovementFeature calculateMovementFeature(PositionPoint from, PositionPoint to) {
        // 1. è®¡ç®—ä½ç½®è·ç¦»
        double distance = calculateDistance(from, to);

        // 2. è®¡ç®—æ—¶é—´å·®
        Duration duration = Duration.between(from.getTimestamp(), to.getTimestamp());

        // 3. è®¡ç®—å¹³å‡é€Ÿåº¦
        double averageSpeed = duration.getSeconds() > 0 ?
                distance / duration.getSeconds() : 0;

        return MovementFeature.builder()
                .distance(distance)
                .duration(duration.getSeconds())
                .averageSpeed(averageSpeed)
                .build();
    }
}
```

## ğŸ“Š å…³é”®æ€§èƒ½æŒ‡æ ‡

### å®æ—¶ç›‘æ§æ€§èƒ½è¦æ±‚

| æŒ‡æ ‡ç±»å‹ | æ€§èƒ½è¦æ±‚ | ç›‘æ§æ–¹æ³• |
|---------|---------|---------|
| è®¾å¤‡çŠ¶æ€æ›´æ–°é¢‘ç‡ | â‰¤ 1ç§’ | å®æ—¶æ—¶é—´æˆ³æ£€æŸ¥ |
| æŠ¥è­¦å“åº”æ—¶é—´ | â‰¤ 30ç§’ | æŠ¥è­¦å¤„ç†å»¶è¿Ÿç›‘æ§ |
| è§†é¢‘è”åŠ¨å“åº”æ—¶é—´ | â‰¤ 2ç§’ | è§†é¢‘ç³»ç»Ÿå“åº”æ—¶é—´ |
| è½¨è¿¹æ•°æ®é‡‡é›†é¢‘ç‡ | â‰¤ 3ç§’ | ä½ç½®æ›´æ–°æ—¶é—´é—´éš” |
| å¼‚å¸¸æ£€æµ‹å‡†ç¡®ç‡ | â‰¥ 95% | æœºå™¨å­¦ä¹ æ¨¡å‹è¯„ä¼° |
| ç³»ç»Ÿå¯ç”¨æ€§ | â‰¥ 99.9% | æœåŠ¡å¥åº·æ£€æŸ¥ |

### ç³»ç»Ÿå®¹é‡æŒ‡æ ‡

| æŒ‡æ ‡ç±»å‹ | è®¾è®¡å®¹é‡ | è¯´æ˜ |
|---------|---------|------|
| å¹¶å‘è®¾å¤‡ç›‘æ§æ•°é‡ | 10,000å° | æ”¯æŒå¤§è§„æ¨¡è®¾å¤‡ç›‘æ§ |
| å¹¶å‘ç”¨æˆ·æ•°é‡ | 1,000ç”¨æˆ· | å®æ—¶ç›‘æ§å¹¶å‘ç”¨æˆ· |
| æŠ¥è­¦å¤„ç†èƒ½åŠ› | 1000æ¡/åˆ†é’Ÿ | æŠ¥è­¦äº‹ä»¶å¤„ç†èƒ½åŠ› |
| è§†é¢‘è”åŠ¨å¹¶å‘æ•° | 500è·¯/ç§’ | åŒæ—¶å¯åŠ¨å½•åƒè·¯æ•° |
| è½¨è¿¹æ•°æ®å­˜å‚¨ | 1TB/æœˆ | è½¨è¿¹æ•°æ®æœˆåº¦å¢é‡ |
| å®æ—¶æ¶ˆæ¯æ¨é€ | 10,000æ¡/ç§’ | WebSocketæ¶ˆæ¯æ¨é€èƒ½åŠ› |

## ğŸ”— ç›¸å…³æ–‡æ¡£

### æŠ€æœ¯å®ç°æ–‡æ¡£
- [é—¨ç¦ç®¡ç†ç³»ç»Ÿæ•´ä½“æ¶æ„è®¾è®¡](./ç³»ç»Ÿæ•´ä½“æ¶æ„è®¾è®¡.md) - å®Œæ•´çš„ç³»ç»Ÿæ¶æ„è®¾è®¡
- [è®¾å¤‡ç®¡ç†æ¨¡å—è¯¦ç»†è®¾è®¡](./è®¾å¤‡ç®¡ç†æ¨¡å—è¯¦ç»†è®¾è®¡.md) - è®¾å¤‡ç®¡ç†åŠŸèƒ½å®ç°
- [åŒºåŸŸç©ºé—´ç®¡ç†æ¨¡å—è¯¦ç»†è®¾è®¡](./åŒºåŸŸç©ºé—´ç®¡ç†æ¨¡å—è¯¦ç»†è®¾è®¡.md) - åŒºåŸŸç®¡ç†åŠŸèƒ½è®¾è®¡

### æ•°æ®å¤„ç†æ–‡æ¡£
- [å®æ—¶æ•°æ®å¤„ç†è®¾è®¡](./å®æ—¶æ•°æ®å¤„ç†è®¾è®¡.md) - å®æ—¶æ•°æ®å¤„ç†æ¶æ„
- [è§†é¢‘è”åŠ¨æŠ€æœ¯æ–¹æ¡ˆ](./è§†é¢‘è”åŠ¨æŠ€æœ¯æ–¹æ¡ˆ.md) - è§†é¢‘è”åŠ¨æŠ€æœ¯å®ç°
- [å¼‚å¸¸æ£€æµ‹ç®—æ³•è®¾è®¡](./å¼‚å¸¸æ£€æµ‹ç®—æ³•è®¾è®¡.md) - å¼‚å¸¸æ£€æµ‹ç®—æ³•å’Œæ¨¡å‹

### éƒ¨ç½²è¿ç»´æ–‡æ¡£
- [å®æ—¶ç›‘æ§éƒ¨ç½²æ–¹æ¡ˆ](./å®æ—¶ç›‘æ§éƒ¨ç½²æ–¹æ¡ˆ.md) - ç›‘æ§ç³»ç»Ÿéƒ¨ç½²æŒ‡å—
- [æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ](./æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ.md) - ç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–ç­–ç•¥
- [è¿ç»´ç›‘æ§æ‰‹å†Œ](./è¿ç»´ç›‘æ§æ‰‹å†Œ.md) - æ—¥å¸¸è¿ç»´æ“ä½œæ‰‹å†Œ

---

## ğŸ¯ æ ¸å¿ƒåŸåˆ™æ€»ç»“

1. **å®æ—¶æ€§ä¼˜å…ˆ** - ç¡®ä¿çŠ¶æ€ç›‘æ§å’ŒæŠ¥è­¦å¤„ç†çš„å®æ—¶å“åº”
2. **æ™ºèƒ½åˆ†æ** - åŸºäºè§„åˆ™å’Œæœºå™¨å­¦ä¹ çš„æ™ºèƒ½æŠ¥è­¦åˆ†æ
3. **è§†é¢‘è”åŠ¨** - é—¨ç¦äº‹ä»¶ä¸è§†é¢‘ç›‘æ§çš„æ— ç¼é›†æˆ
4. **å¼‚å¸¸æ£€æµ‹** - åŸºäºè½¨è¿¹åˆ†æçš„å¼‚å¸¸è¡Œä¸ºè¯†åˆ«
5. **é«˜æ€§èƒ½å¤„ç†** - æ”¯æŒå¤§è§„æ¨¡å¹¶å‘ç›‘æ§å’Œæ•°æ®å¤„ç†

## ğŸ“‹ ç‰ˆæœ¬ä¿¡æ¯

- æœ¬æ–‡æ¡£åŸºäºå®æ—¶ç›‘æ§ç³»ç»Ÿæœ€ä½³å®è·µè®¾è®¡
- å®æ—¶ç›‘æ§æ¨¡å—è®¾è®¡è´Ÿè´£äººï¼šSmartAdminè§„èŒƒæ²»ç†å§”å‘˜ä¼š
- åˆ›å»ºæ—¥æœŸï¼š2025-11-13
- ä¸‹æ¬¡è¯„å®¡ï¼š2026-02-13

---

**ğŸ¯ IOE-DREAMé—¨ç¦å®æ—¶ç›‘æ§æ¨¡å— - å®æ—¶ç›‘æ§ã€æ™ºèƒ½æŠ¥è­¦ã€è§†é¢‘è”åŠ¨ã€äººå‘˜è¿½è¸ªçš„ä¼ä¸šçº§ç›‘æ§è§£å†³æ–¹æ¡ˆ**