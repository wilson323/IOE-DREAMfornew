# é—¨ç¦ç³»ç»Ÿé…ç½®æ¨¡å—è¯¦ç»†è®¾è®¡

> **ç‰ˆæœ¬**: v1.0
> **æ›´æ–°æ—¶é—´**: 2025-11-13
> **åˆ†ç±»**: æ ¸å¿ƒåŠŸèƒ½æ¨¡å— > ä¼ä¸šOAç³»ç»Ÿ > é—¨ç¦ç®¡ç†ç³»ç»Ÿ
> **æ ‡ç­¾**: ["é—¨ç¦ç³»ç»Ÿ", "ç³»ç»Ÿé…ç½®", "ç”¨æˆ·æƒé™", "è®¸å¯è¯ç®¡ç†", "å¤‡ä»½æ¢å¤"]
> **ä½œè€…**: SmartAdminè§„èŒƒæ²»ç†å§”å‘˜ä¼š
> **æè¿°**: IOE-DREAMæ™ºæ…§å›­åŒºä¸€å¡é€šç®¡ç†å¹³å°é—¨ç¦ç®¡ç†ç³»ç»Ÿçš„ç³»ç»Ÿå‚æ•°é…ç½®ã€ç”¨æˆ·æƒé™ç®¡ç†ã€è®¸å¯è¯ç®¡ç†å’Œå¤‡ä»½æ¢å¤æ¨¡å—è¯¦ç»†æŠ€æœ¯è®¾è®¡

## ğŸ“‹ æ¨¡å—æ¦‚è¿°

### æ ¸å¿ƒå®šä½

**é—¨ç¦ç³»ç»Ÿé…ç½®æ¨¡å—**æ˜¯IOE-DREAMæ™ºæ…§å›­åŒºä¸€å¡é€šç®¡ç†å¹³å°çš„ç®¡ç†ä¸­å¿ƒï¼Œè´Ÿè´£ç³»ç»Ÿå‚æ•°é…ç½®ã€ç”¨æˆ·æƒé™ç®¡ç†ã€è®¸å¯è¯ç®¡ç†å’Œæ•°æ®å¤‡ä»½æ¢å¤ã€‚æ¨¡å—æä¾›å®Œæ•´çš„ç³»ç»Ÿç®¡ç†åŠŸèƒ½ï¼Œç¡®ä¿ç³»ç»Ÿçš„å®‰å…¨ã€ç¨³å®šå’Œåˆè§„è¿è¡Œï¼Œæ”¯æŒçµæ´»çš„é…ç½®ç®¡ç†å’Œæƒé™æ§åˆ¶æœºåˆ¶ã€‚

### æ ¸å¿ƒç‰¹æ€§

- âœ… **çµæ´»å‚æ•°é…ç½®**ï¼šç³»ç»ŸåŸºç¡€å‚æ•°ã€è¿è¡Œå‚æ•°ã€æ€§èƒ½å‚æ•°ã€å®‰å…¨å‚æ•°é…ç½®
- âœ… **åˆ†çº§æƒé™ç®¡ç†**ï¼šåŸºäºè§’è‰²çš„ç”¨æˆ·æƒé™ç®¡ç†å’Œç»†ç²’åº¦æƒé™æ§åˆ¶
- âœ… **è®¸å¯è¯å…¨ç”Ÿå‘½å‘¨æœŸ**ï¼šè®¸å¯è¯æ¿€æ´»ã€éªŒè¯ã€ç›‘æ§ã€ç»­æœŸå®Œæ•´ç®¡ç†
- âœ… **æ™ºèƒ½å¤‡ä»½æ¢å¤**ï¼šå¤šç§å¤‡ä»½ç­–ç•¥ã€è‡ªåŠ¨å¤‡ä»½ã€å¿«é€Ÿæ¢å¤æœºåˆ¶
- âœ… **é…ç½®çƒ­æ›´æ–°**ï¼šæ”¯æŒç³»ç»Ÿé…ç½®çš„åŠ¨æ€æ›´æ–°å’Œç”Ÿæ•ˆ
- âœ… **å®¡è®¡æ—¥å¿—è¿½è¸ª**ï¼šå®Œæ•´çš„é…ç½®å˜æ›´å’Œæ“ä½œå®¡è®¡è®°å½•
- âœ… **å®‰å…¨ç­–ç•¥ç®¡ç†**ï¼šå¯†ç ç­–ç•¥ã€ä¼šè¯ç®¡ç†ã€è®¿é—®æ§åˆ¶å®‰å…¨ç­–ç•¥

## ğŸ—ï¸ ç³»ç»Ÿé…ç½®æ¨¡å—æ¶æ„è®¾è®¡

### æ¨¡å—åŠŸèƒ½æ¶æ„å›¾

```mermaid
graph TB
    subgraph "é—¨ç¦ç³»ç»Ÿé…ç½®æ¨¡å—æ¶æ„"
        subgraph "ç”¨æˆ·äº¤äº’å±‚"
            SYSCONF[ç³»ç»Ÿå‚æ•°é…ç½®ç•Œé¢]
            USERMGR[ç”¨æˆ·æƒé™ç®¡ç†ç•Œé¢]
            LICENSEMGR[è®¸å¯è¯ç®¡ç†ç•Œé¢]
            BACKUPMGR[å¤‡ä»½æ¢å¤ç•Œé¢]
            AUDITLOG[å®¡è®¡æ—¥å¿—ç•Œé¢]
        end

        subgraph "ä¸šåŠ¡é€»è¾‘å±‚"
            subgraph "æ ¸å¿ƒé…ç½®æœåŠ¡"
                SYSPARAMS[ç³»ç»Ÿå‚æ•°æœåŠ¡]
                USERPERM[ç”¨æˆ·æƒé™æœåŠ¡]
                LICENSESRV[è®¸å¯è¯æœåŠ¡]
                BACKUPSRV[å¤‡ä»½æ¢å¤æœåŠ¡]
            end

            subgraph "ç®¡ç†å¼•æ“"
                CONFENGINE[é…ç½®å¼•æ“]
                AUTHENGINE[æƒé™å¼•æ“]
                LICENSEENGINE[è®¸å¯è¯å¼•æ“]
                BACKUPENGINE[å¤‡ä»½å¼•æ“]
            end
        end

        subgraph "æ•°æ®è®¿é—®å±‚"
            SYSCONFD[ç³»ç»Ÿé…ç½®æ•°æ®è®¿é—®]
            USERPERMD[ç”¨æˆ·æƒé™æ•°æ®è®¿é—®]
            LICENSED[è®¸å¯è¯æ•°æ®è®¿é—®]
            BACKUPD[å¤‡ä»½æ•°æ®è®¿é—®]
            AUDITD[å®¡è®¡æ—¥å¿—æ•°æ®è®¿é—®]
        end

        subgraph "åŸºç¡€æœåŠ¡å±‚"
            CACHESRV[ç¼“å­˜æœåŠ¡]
            NOTIFYSRV[é€šçŸ¥æœåŠ¡]
            LOGSRV[æ—¥å¿—æœåŠ¡]
            TASKSCHEDULER[ä»»åŠ¡è°ƒåº¦æœåŠ¡]
        end
    end

    SYSCONF --> SYSPARAMS
    USERMGR --> USERPERM
    LICENSEMGR --> LICENSESRV
    BACKUPMGR --> BACKUPSRV
    AUDITLOG --> CONFENGINE

    SYSPARAMS --> CONFENGINE
    USERPERM --> AUTHENGINE
    LICENSESRV --> LICENSEENGINE
    BACKUPSRV --> BACKUPENGINE

    CONFENGINE --> CACHESRV
    AUTHENGINE --> NOTIFYSRV
    LICENSEENGINE --> TASKSCHEDULER
    BACKUPENGINE --> LOGSRV
```

### ç³»ç»Ÿé…ç½®ç®¡ç†æ ¸å¿ƒæµç¨‹è®¾è®¡

```mermaid
graph TB
    ConfigStart(ç³»ç»Ÿé…ç½®å¼€å§‹) --> ConfigChoose{é€‰æ‹©é…ç½®ç±»å‹}

    ConfigChoose -->|ç³»ç»Ÿå‚æ•°| SysParams
    ConfigChoose -->|ç”¨æˆ·æƒé™| UserAuth
    ConfigChoose -->|è®¸å¯è¯ç®¡ç†| LicenseManage
    ConfigChoose -->|å¤‡ä»½æ¢å¤| BackupRecover

    subgraph ç³»ç»Ÿå‚æ•°é…ç½®æµç¨‹
        SysParams --> BasicSet[åŸºç¡€è®¾ç½®]
        BasicSet --> RuntimeParams[è¿è¡Œå‚æ•°]
        RuntimeParams --> PerformanceParams[æ€§èƒ½å‚æ•°]
        PerformanceParams --> SecurityParams[å®‰å…¨å‚æ•°]
        SecurityParams --> ParamsEnd[å‚æ•°é…ç½®å®Œæˆ]
    end

    subgraph ç”¨æˆ·æƒé™ç®¡ç†æµç¨‹
        UserAuth --> UserCreate[ç”¨æˆ·åˆ›å»º]
        UserCreate --> RoleAssign[è§’è‰²åˆ†é…]
        RoleAssign --> AuthConfig[æƒé™é…ç½®]
        AuthConfig --> UserAudit[ç”¨æˆ·å®¡è®¡]
        UserAudit --> AuthEnd[æƒé™ç®¡ç†å®Œæˆ]
    end

    subgraph è®¸å¯è¯ç®¡ç†æµç¨‹
        LicenseManage --> LicenseActivate[è®¸å¯è¯æ¿€æ´»]
        LicenseActivate --> LicenseVerify[è®¸å¯è¯éªŒè¯]
        LicenseVerify --> LicenseMonitor[è®¸å¯è¯ç›‘æ§]
        LicenseMonitor --> LicenseRenew[è®¸å¯è¯ç»­æœŸ]
        LicenseRenew --> LicenseEnd[è®¸å¯è¯ç®¡ç†å®Œæˆ]
    end

    subgraph å¤‡ä»½æ¢å¤æµç¨‹
        BackupRecover --> BackupConfig[å¤‡ä»½é…ç½®]
        BackupConfig --> BackupExec[å¤‡ä»½æ‰§è¡Œ]
        BackupExec --> BackupVerify[å¤‡ä»½éªŒè¯]
        BackupVerify --> RecoverTest[æ¢å¤æµ‹è¯•]
        RecoverTest --> BackupEnd[å¤‡ä»½æ¢å¤å®Œæˆ]
    end
```

## ğŸ”§ æ ¸å¿ƒåŠŸèƒ½è¯¦ç»†è®¾è®¡

### 1. ç³»ç»Ÿå‚æ•°é…ç½®æœåŠ¡

#### 1.1 å‚æ•°é…ç½®ç®¡ç†

**åŠŸèƒ½æè¿°**ï¼šç³»ç»ŸåŸºç¡€å‚æ•°ã€è¿è¡Œå‚æ•°ã€æ€§èƒ½å‚æ•°ã€å®‰å…¨å‚æ•°çš„é…ç½®å’Œç®¡ç†

**æŠ€æœ¯å®ç°**ï¼š
```java
@Service
@Slf4j
public class SystemParameterService {

    @Resource
    private SystemParameterDao systemParameterDao;

    @Resource
    private ConfigValidationService validationService;

    @Resource
    private ConfigurationChangeNotifier changeNotifier;

    /**
     * è·å–ç³»ç»Ÿå‚æ•°é…ç½®
     */
    @Cacheable(value = "systemParams", key = "#category")
    public ResponseDTO<SystemParameterVO> getSystemParameters(String category) {
        try {
            // 1. éªŒè¯å‚æ•°åˆ†ç±»
            validateParameterCategory(category);

            // 2. æŸ¥è¯¢å‚æ•°é…ç½®
            List<SystemParameterEntity> parameters = systemParameterDao.selectList(
                    new LambdaQueryWrapper<SystemParameterEntity>()
                            .eq(SystemParameterEntity::getCategory, category)
                            .eq(SystemParameterEntity::getEnabledFlag, true)
                            .orderByAsc(SystemParameterEntity::getSortOrder));

            // 3. è½¬æ¢ä¸ºVO
            SystemParameterVO parameterVO = SystemParameterVO.builder()
                    .category(category)
                    .parameters(parameters.stream()
                            .map(this::convertToParameterVO)
                            .collect(Collectors.toList()))
                    .lastUpdateTime(getLastUpdateTime(category))
                    .build();

            return ResponseDTO.ok(parameterVO);

        } catch (Exception e) {
            log.error("è·å–ç³»ç»Ÿå‚æ•°å¤±è´¥, category: {}", category, e);
            return ResponseDTO.error("è·å–å¤±è´¥");
        }
    }

    /**
     * æ›´æ–°ç³»ç»Ÿå‚æ•°
     */
    @Transactional(rollbackFor = Exception.class)
    public ResponseDTO<Void> updateSystemParameters(SystemParameterUpdateForm updateForm) {
        try {
            String category = updateForm.getCategory();

            // 1. éªŒè¯æ›´æ–°æƒé™
            validateUpdatePermission(category);

            // 2. éªŒè¯å‚æ•°å€¼
            for (ParameterUpdate param : updateForm.getParameters()) {
                validationService.validateParameterValue(
                        category, param.getParamKey(), param.getParamValue());
            }

            // 3. å¤‡ä»½å½“å‰é…ç½®
            backupCurrentConfiguration(category);

            // 4. æ‰¹é‡æ›´æ–°å‚æ•°
            List<SystemParameterEntity> updateList = new ArrayList<>();
            for (ParameterUpdate param : updateForm.getParameters()) {
                SystemParameterEntity entity = SystemParameterEntity.builder()
                        .category(category)
                        .paramKey(param.getParamKey())
                        .paramValue(param.getParamValue())
                        .paramDesc(param.getParamDesc())
                        .updateUserId(SmartRequestUtil.getRequestUserId())
                        .updateTime(LocalDateTime.now())
                        .build();

                updateList.add(entity);
            }

            systemParameterDao.updateParametersBatch(updateList);

            // 5. æ¸…é™¤ç¼“å­˜
            evictParameterCache(category);

            // 6. å‘é€é…ç½®å˜æ›´é€šçŸ¥
            changeNotifier.notifyConfigurationChange(category, updateForm.getParameters());

            // 7. è®°å½•å˜æ›´æ—¥å¿—
            logConfigurationChange(category, updateForm.getParameters());

            log.info("ç³»ç»Ÿå‚æ•°æ›´æ–°æˆåŠŸ, category: {}, paramCount: {}",
                    category, updateForm.getParameters().size());

            return ResponseDTO.ok();

        } catch (Exception e) {
            log.error("æ›´æ–°ç³»ç»Ÿå‚æ•°å¤±è´¥", e);
            return ResponseDTO.error("æ›´æ–°å¤±è´¥");
        }
    }

    /**
     * é‡ç½®ç³»ç»Ÿå‚æ•°ä¸ºé»˜è®¤å€¼
     */
    @Transactional(rollbackFor = Exception.class)
    public ResponseDTO<Void> resetSystemParametersToDefault(String category) {
        try {
            // 1. éªŒè¯é‡ç½®æƒé™
            validateResetPermission(category);

            // 2. è·å–é»˜è®¤å‚æ•°é…ç½®
            List<SystemParameterEntity> defaultParams = getDefaultParameters(category);

            // 3. æ‰¹é‡æ›´æ–°ä¸ºé»˜è®¤å€¼
            for (SystemParameterEntity defaultParam : defaultParams) {
                SystemParameterEntity updateParam = SystemParameterEntity.builder()
                        .category(category)
                        .paramKey(defaultParam.getParamKey())
                        .paramValue(defaultParam.getDefaultValue())
                        .paramDesc(defaultParam.getParamDesc())
                        .updateUserId(SmartRequestUtil.getRequestUserId())
                        .updateTime(LocalDateTime.now())
                        .build();

                systemParameterDao.updateParameterByKey(updateParam);
            }

            // 4. æ¸…é™¤ç¼“å­˜
            evictParameterCache(category);

            // 5. å‘é€é‡ç½®é€šçŸ¥
            changeNotifier.notifyConfigurationReset(category);

            log.info("ç³»ç»Ÿå‚æ•°é‡ç½®ä¸ºé»˜è®¤å€¼å®Œæˆ, category: {}", category);

            return ResponseDTO.ok();

        } catch (Exception e) {
            log.error("é‡ç½®ç³»ç»Ÿå‚æ•°å¤±è´¥", e);
            return ResponseDTO.error("é‡ç½®å¤±è´¥");
        }
    }

    /**
     * è½¬æ¢ä¸ºå‚æ•°VO
     */
    private SystemParameterVO convertToParameterVO(SystemParameterEntity entity) {
        return SystemParameterVO.builder()
                .paramKey(entity.getParamKey())
                .paramName(entity.getParamName())
                .paramValue(entity.getParamValue())
                .paramType(entity.getParamType())
                .paramDesc(entity.getParamDesc())
                .defaultValue(entity.getDefaultValue())
                .requiredFlag(entity.getRequiredFlag())
                .editableFlag(entity.getEditableFlag())
                .build();
    }
}
```

#### 1.2 é…ç½®çƒ­æ›´æ–°æœºåˆ¶

**åŠŸèƒ½æè¿°**ï¼šç³»ç»Ÿé…ç½®çš„åŠ¨æ€æ›´æ–°å’Œçƒ­ç”Ÿæ•ˆæœºåˆ¶

**æŠ€æœ¯å®ç°**ï¼š
```java
@Component
@Slf4j
public class ConfigurationHotUpdateManager {

    @Resource
    private ApplicationEventPublisher eventPublisher;

    @Resource
    private ConfigChangeExecutor configChangeExecutor;

    private final Map<String, List<ConfigurationChangeListener>> listeners = new ConcurrentHashMap<>();

    /**
     * æ³¨å†Œé…ç½®å˜æ›´ç›‘å¬å™¨
     */
    public void registerListener(String configCategory, ConfigurationChangeListener listener) {
        listeners.computeIfAbsent(configCategory, k -> new CopyOnWriteArrayList<>()).add(listener);
        log.info("æ³¨å†Œé…ç½®å˜æ›´ç›‘å¬å™¨æˆåŠŸ, category: {}, listener: {}", configCategory, listener.getClass().getSimpleName());
    }

    /**
     * å¤„ç†é…ç½®å˜æ›´äº‹ä»¶
     */
    @EventListener
    @Async
    public void handleConfigurationChangeEvent(ConfigurationChangeEvent event) {
        try {
            String category = event.getCategory();
            List<ConfigurationChangeListener> categoryListeners = listeners.get(category);

            if (CollectionUtils.isNotEmpty(categoryListeners)) {
                // å¹¶å‘é€šçŸ¥æ‰€æœ‰ç›‘å¬å™¨
                List<CompletableFuture<Void>> futures = categoryListeners.stream()
                        .map(listener -> CompletableFuture.runAsync(() -> {
                            try {
                                listener.onConfigurationChange(event);
                            } catch (Exception e) {
                                log.error("é…ç½®å˜æ›´ç›‘å¬å™¨æ‰§è¡Œå¤±è´¥, listener: {}", listener.getClass().getSimpleName(), e);
                            }
                        }, configChangeExecutor))
                        .collect(Collectors.toList());

                // ç­‰å¾…æ‰€æœ‰ç›‘å¬å™¨æ‰§è¡Œå®Œæˆ
                CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                        .thenRun(() -> log.info("é…ç½®å˜æ›´é€šçŸ¥å®Œæˆ, category: {}", category))
                        .exceptionally(throwable -> {
                            log.error("é…ç½®å˜æ›´é€šçŸ¥æ‰§è¡Œå¤±è´¥", throwable);
                            return null;
                        });
            }

        } catch (Exception e) {
            log.error("å¤„ç†é…ç½®å˜æ›´äº‹ä»¶å¤±è´¥", e);
        }
    }

    /**
     * æ•°æ®åº“è¿æ¥æ± çƒ­æ›´æ–°
     */
    @ConfigurationChangeListener("database")
    public void updateDatabaseConnectionPool(ConfigurationChangeEvent event) {
        try {
            List<ParameterUpdate> changedParams = event.getChangedParameters();

            for (ParameterUpdate param : changedParams) {
                if (param.getParamKey().startsWith("database.pool.")) {
                    updateDataSourcePool(param.getParamKey(), param.getParamValue());
                }
            }

        } catch (Exception e) {
            log.error("æ•°æ®åº“è¿æ¥æ± çƒ­æ›´æ–°å¤±è´¥", e);
        }
    }

    /**
     * ç¼“å­˜é…ç½®çƒ­æ›´æ–°
     */
    @ConfigurationChangeListener("cache")
    public void updateCacheConfiguration(ConfigurationChangeEvent event) {
        try {
            List<ParameterUpdate> changedParams = event.getChangedParameters();

            for (ParameterUpdate param : changedParams) {
                if (param.getParamKey().startsWith("cache.")) {
                    updateCacheConfig(param.getParamKey(), param.getParamValue());
                }
            }

        } catch (Exception e) {
            log.error("ç¼“å­˜é…ç½®çƒ­æ›´æ–°å¤±è´¥", e);
        }
    }

    /**
     * æ›´æ–°æ•°æ®æºæ± é…ç½®
     */
    private void updateDataSourcePool(String configKey, String configValue) {
        try {
            DataSource dataSource = getDataSource();
            if (dataSource instanceof HikariDataSource) {
                HikariDataSource hikariDataSource = (HikariDataSource) dataSource;

                switch (configKey) {
                    case "database.pool.maximumPoolSize":
                        hikariDataSource.setMaximumPoolSize(Integer.parseInt(configValue));
                        break;
                    case "database.pool.minimumIdle":
                        hikariDataSource.setMinimumIdle(Integer.parseInt(configValue));
                        break;
                    case "database.pool.connectionTimeout":
                        hikariDataSource.setConnectionTimeout(Long.parseLong(configValue));
                        break;
                    case "database.pool.idleTimeout":
                        hikariDataSource.setIdleTimeout(Long.parseLong(configValue));
                        break;
                    default:
                        log.warn("æœªçŸ¥çš„æ•°æ®åº“æ± é…ç½®é¡¹: {}", configKey);
                }

                log.info("æ•°æ®åº“è¿æ¥æ± é…ç½®æ›´æ–°æˆåŠŸ: {} = {}", configKey, configValue);
            }

        } catch (Exception e) {
            log.error("æ›´æ–°æ•°æ®æºæ± é…ç½®å¤±è´¥", e);
        }
    }

    /**
     * æ›´æ–°ç¼“å­˜é…ç½®
     */
    private void updateCacheConfig(String configKey, String configValue) {
        try {
            // æ ¹æ®ç¼“å­˜ç±»å‹æ›´æ–°ç›¸åº”é…ç½®
            if (configKey.startsWith("cache.redis.")) {
                updateRedisConfig(configKey.substring("cache.redis.".length()), configValue);
            } else if (configKey.startsWith("cache.caffeine.")) {
                updateCaffeineConfig(configKey.substring("cache.caffeine.".length()), configValue);
            }

            log.info("ç¼“å­˜é…ç½®æ›´æ–°æˆåŠŸ: {} = {}", configKey, configValue);

        } catch (Exception e) {
            log.error("æ›´æ–°ç¼“å­˜é…ç½®å¤±è´¥", e);
        }
    }
}
```

### 2. ç”¨æˆ·æƒé™ç®¡ç†æœåŠ¡

#### 2.1 ç”¨æˆ·æƒé™ç®¡ç†

**åŠŸèƒ½æè¿°**ï¼šåŸºäºè§’è‰²çš„ç”¨æˆ·æƒé™ç®¡ç†å’Œç»†ç²’åº¦æƒé™æ§åˆ¶

**æŠ€æœ¯å®ç°**ï¼š
```java
@Service
@Slf4j
public class UserPermissionManagementService {

    @Resource
    private UserDao userDao;

    @Resource
    private RoleDao roleDao;

    @Resource
    private PermissionDao permissionDao;

    @Resource
    private UserRoleDao userRoleDao;

    @Resource
    private RolePermissionDao rolePermissionDao;

    /**
     * åˆ›å»ºç”¨æˆ·å¹¶åˆ†é…è§’è‰²
     */
    @Transactional(rollbackFor = Exception.class)
    public ResponseDTO<Long> createUserWithRoles(UserCreateForm createForm) {
        try {
            // 1. éªŒè¯ç”¨æˆ·åˆ›å»ºæƒé™
            validateUserCreationPermission();

            // 2. åˆ›å»ºç”¨æˆ·
            UserEntity user = UserEntity.builder()
                    .userId(IdGenerator.generateId())
                    .username(createForm.getUsername())
                    .realName(createForm.getRealName())
                    .email(createForm.getEmail())
                    .phone(createForm.getPhone())
                    .departmentId(createForm.getDepartmentId())
                    .position(createForm.getPosition())
                    .status(UserStatus.ACTIVE)
                    .createUserId(SmartRequestUtil.getRequestUserId())
                    .createTime(LocalDateTime.now())
                    .build();

            // 3. è®¾ç½®å¯†ç 
            String encodedPassword = passwordEncoder.encode(createForm.getPassword());
            user.setPassword(encodedPassword);

            userDao.insert(user);

            // 4. åˆ†é…è§’è‰²
            if (CollectionUtils.isNotEmpty(createForm.getRoleIds())) {
                assignRolesToUser(user.getUserId(), createForm.getRoleIds());
            }

            // 5. è®°å½•æ“ä½œæ—¥å¿—
            logUserOperation("USER_CREATE", user.getUserId(), "åˆ›å»ºç”¨æˆ·å¹¶åˆ†é…è§’è‰²");

            log.info("ç”¨æˆ·åˆ›å»ºæˆåŠŸ, userId: {}, username: {}", user.getUserId(), user.getUsername());

            return ResponseDTO.ok(user.getUserId());

        } catch (Exception e) {
            log.error("åˆ›å»ºç”¨æˆ·å¤±è´¥", e);
            return ResponseDTO.error("åˆ›å»ºå¤±è´¥");
        }
    }

    /**
     * ä¸ºç”¨æˆ·åˆ†é…è§’è‰²
     */
    @Transactional(rollbackFor = Exception.class)
    public ResponseDTO<Void> assignRolesToUser(Long userId, List<Long> roleIds) {
        try {
            // 1. éªŒè¯ç”¨æˆ·å­˜åœ¨
            UserEntity user = userDao.selectById(userId);
            if (user == null) {
                return ResponseDTO.error("ç”¨æˆ·ä¸å­˜åœ¨");
            }

            // 2. éªŒè¯è§’è‰²å­˜åœ¨å’Œæƒé™
            validateRoles(roleIds);

            // 3. æ¸…é™¤ç°æœ‰è§’è‰²
            userRoleDao.deleteByUserId(userId);

            // 4. åˆ†é…æ–°è§’è‰²
            for (Long roleId : roleIds) {
                UserRoleEntity userRole = UserRoleEntity.builder()
                        .userId(userId)
                        .roleId(roleId)
                        .assignTime(LocalDateTime.now())
                        .assignUserId(SmartRequestUtil.getRequestUserId())
                        .build();
                userRoleDao.insert(userRole);
            }

            // 5. æ›´æ–°ç”¨æˆ·æƒé™ç¼“å­˜
            updateUserPermissionCache(userId);

            // 6. è®°å½•æ“ä½œæ—¥å¿—
            logUserOperation("ROLE_ASSIGN", userId, "åˆ†é…è§’è‰²: " + roleIds);

            log.info("ç”¨æˆ·è§’è‰²åˆ†é…æˆåŠŸ, userId: {}, roleIds: {}", userId, roleIds);

            return ResponseDTO.ok();

        } catch (Exception e) {
            log.error("åˆ†é…ç”¨æˆ·è§’è‰²å¤±è´¥", e);
            return ResponseDTO.error("åˆ†é…å¤±è´¥");
        }
    }

    /**
     * è·å–ç”¨æˆ·æƒé™åˆ—è¡¨
     */
    @Cacheable(value = "userPermissions", key = "#userId")
    public ResponseDTO<UserPermissionVO> getUserPermissions(Long userId) {
        try {
            // 1. éªŒè¯ç”¨æˆ·å­˜åœ¨
            UserEntity user = userDao.selectById(userId);
            if (user == null) {
                return ResponseDTO.error("ç”¨æˆ·ä¸å­˜åœ¨");
            }

            // 2. è·å–ç”¨æˆ·è§’è‰²
            List<RoleEntity> roles = getUserRoles(userId);

            // 3. è·å–ç”¨æˆ·æƒé™
            List<PermissionEntity> permissions = getUserPermissions(userId, roles);

            // 4. æ„å»ºæƒé™VO
            UserPermissionVO permissionVO = UserPermissionVO.builder()
                    .userId(userId)
                    .username(user.getUsername())
                    .realName(user.getRealName())
                    .roles(roles.stream()
                            .map(this::convertToRoleVO)
                            .collect(Collectors.toList()))
                    .permissions(permissions.stream()
                            .map(this::convertToPermissionVO)
                            .collect(Collectors.toList()))
                    .lastUpdateTime(LocalDateTime.now())
                    .build();

            return ResponseDTO.ok(permissionVO);

        } catch (Exception e) {
            log.error("è·å–ç”¨æˆ·æƒé™å¤±è´¥, userId: {}", userId, e);
            return ResponseDTO.error("è·å–å¤±è´¥");
        }
    }

    /**
     * æ£€æŸ¥ç”¨æˆ·æƒé™
     */
    public boolean hasPermission(Long userId, String permissionCode) {
        try {
            // 1. ä»ç¼“å­˜è·å–ç”¨æˆ·æƒé™
            UserPermissionVO userPermissions = getUserPermissionsFromCache(userId);
            if (userPermissions == null) {
                return false;
            }

            // 2. æ£€æŸ¥æƒé™
            return userPermissions.getPermissions().stream()
                    .anyMatch(permission -> permission.getPermissionCode().equals(permissionCode));

        } catch (Exception e) {
            log.error("æ£€æŸ¥ç”¨æˆ·æƒé™å¤±è´¥, userId: {}, permissionCode: {}", userId, permissionCode, e);
            return false;
        }
    }

    /**
     * ç”¨æˆ·æƒé™å®¡è®¡
     */
    public ResponseDTO<PageResult<UserPermissionAuditVO>> auditUserPermissions(UserPermissionAuditForm auditForm) {
        try {
            // 1. éªŒè¯å®¡è®¡æƒé™
            validateAuditPermission();

            // 2. æ„å»ºæŸ¥è¯¢æ¡ä»¶
            LambdaQueryWrapper<UserPermissionAuditEntity> queryWrapper = new LambdaQueryWrapper<>();
            queryWrapper.eq(UserPermissionAuditEntity::getDeletedFlag, false)
                    .orderByDesc(UserPermissionAuditEntity::getAuditTime);

            // 3. æ·»åŠ è¿‡æ»¤æ¡ä»¶
            if (auditForm.getUserId() != null) {
                queryWrapper.eq(UserPermissionAuditEntity::getUserId, auditForm.getUserId());
            }
            if (auditForm.getAuditType() != null) {
                queryWrapper.eq(UserPermissionAuditEntity::getAuditType, auditForm.getAuditType());
            }
            if (auditForm.getStartTime() != null) {
                queryWrapper.ge(UserPermissionAuditEntity::getAuditTime, auditForm.getStartTime());
            }
            if (auditForm.getEndTime() != null) {
                queryWrapper.le(UserPermissionAuditEntity::getAuditTime, auditForm.getEndTime());
            }

            // 4. åˆ†é¡µæŸ¥è¯¢
            IPage<UserPermissionAuditEntity> page = new Page<>(auditForm.getPageNum(), auditForm.getPageSize());
            IPage<UserPermissionAuditEntity> auditPage = userPermissionAuditDao.selectPage(page, queryWrapper);

            // 5. è½¬æ¢ä¸ºVO
            List<UserPermissionAuditVO> voList = auditPage.getRecords().stream()
                    .map(this::convertToAuditVO)
                    .collect(Collectors.toList());

            // 6. æ„å»ºåˆ†é¡µç»“æœ
            PageResult<UserPermissionAuditVO> pageResult = new PageResult<>();
            pageResult.setRows(voList);
            pageResult.setTotal(auditPage.getTotal());
            pageResult.setPageNum(auditForm.getPageNum());
            pageResult.setPageSize(auditForm.getPageSize());

            return ResponseDTO.ok(pageResult);

        } catch (Exception e) {
            log.error("ç”¨æˆ·æƒé™å®¡è®¡å¤±è´¥", e);
            return ResponseDTO.error("å®¡è®¡å¤±è´¥");
        }
    }

    /**
     * è·å–ç”¨æˆ·è§’è‰²
     */
    private List<RoleEntity> getUserRoles(Long userId) {
        return roleDao.selectRolesByUserId(userId);
    }

    /**
     * è·å–ç”¨æˆ·æƒé™
     */
    private List<PermissionEntity> getUserPermissions(Long userId, List<RoleEntity> roles) {
        Set<Long> permissionIds = new HashSet<>();

        // 1. è·å–è§’è‰²æƒé™
        for (RoleEntity role : roles) {
            List<Long> rolePermissionIds = rolePermissionDao.getPermissionIdsByRoleId(role.getRoleId());
            permissionIds.addAll(rolePermissionIds);
        }

        // 2. è·å–æƒé™è¯¦æƒ…
        if (CollectionUtils.isNotEmpty(permissionIds)) {
            return permissionDao.selectBatchIds(permissionIds);
        }

        return Collections.emptyList();
    }
}
```

### 3. è®¸å¯è¯ç®¡ç†æœåŠ¡

#### 3.1 è®¸å¯è¯ç”Ÿå‘½å‘¨æœŸç®¡ç†

**åŠŸèƒ½æè¿°**ï¼šè®¸å¯è¯æ¿€æ´»ã€éªŒè¯ã€ç›‘æ§ã€ç»­æœŸçš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸç®¡ç†

**æŠ€æœ¯å®ç°**ï¼š
```java
@Service
@Slf4j
public class LicenseManagementService {

    @Resource
    private LicenseDao licenseDao;

    @Resource
    private LicenseValidator licenseValidator;

    @Resource
    private LicenseMonitorService licenseMonitorService;

    /**
     * æ¿€æ´»è®¸å¯è¯
     */
    @Transactional(rollbackFor = Exception.class)
    public ResponseDTO<LicenseActivationVO> activateLicense(LicenseActivationForm activationForm) {
        try {
            // 1. éªŒè¯è®¸å¯è¯æ–‡ä»¶
            LicenseFile licenseFile = parseLicenseFile(activationForm.getLicenseFile());

            // 2. éªŒè¯è®¸å¯è¯æœ‰æ•ˆæ€§
            LicenseValidationResult validationResult = licenseValidator.validate(licenseFile);
            if (!validationResult.isValid()) {
                return ResponseDTO.error("è®¸å¯è¯éªŒè¯å¤±è´¥: " + validationResult.getErrorMessage());
            }

            // 3. æ£€æŸ¥æ˜¯å¦å·²æ¿€æ´»
            LicenseEntity existingLicense = licenseDao.selectByLicenseKey(licenseFile.getLicenseKey());
            if (existingLicense != null && existingLicense.getStatus() == LicenseStatus.ACTIVE) {
                return ResponseDTO.error("è®¸å¯è¯å·²æ¿€æ´»");
            }

            // 4. åˆ›å»ºè®¸å¯è¯è®°å½•
            LicenseEntity license = LicenseEntity.builder()
                    .licenseId(IdGenerator.generateId())
                    .licenseKey(licenseFile.getLicenseKey())
                    .licenseType(licenseFile.getLicenseType())
                    .productName(licenseFile.getProductName())
                    .productVersion(licenseFile.getProductVersion())
                    .customerName(licenseFile.getCustomerName())
                    .issueDate(licenseFile.getIssueDate())
                    .expireDate(licenseFile.getExpireDate())
                    .maxDevices(licenseFile.getMaxDevices())
                    .maxUsers(licenseFile.getMaxUsers())
                    .features(licenseFile.getFeatures())
                    .status(LicenseStatus.ACTIVE)
                    .activateTime(LocalDateTime.now())
                    .activateUserId(SmartRequestUtil.getRequestUserId())
                    .machineCode(getMachineCode())
                    .createTime(LocalDateTime.now())
                    .build();

            licenseDao.insert(license);

            // 5. åº”ç”¨è®¸å¯è¯é™åˆ¶
            applyLicenseRestrictions(license);

            // 6. å¯åŠ¨è®¸å¯è¯ç›‘æ§
            licenseMonitorService.startLicenseMonitoring(license);

            // 7. è®¾ç½®ç»­æœŸæé†’
            scheduleRenewalReminder(license);

            // 8. æ„å»ºæ¿€æ´»ç»“æœ
            LicenseActivationVO activationVO = LicenseActivationVO.builder()
                    .licenseId(license.getLicenseId())
                    .licenseKey(license.getLicenseKey())
                    .productName(license.getProductName())
                    .customerName(license.getCustomerName())
                    .expireDate(license.getExpireDate())
                    .features(license.getFeatures())
                    .activationTime(license.getActivateTime())
                    .build();

            log.info("è®¸å¯è¯æ¿€æ´»æˆåŠŸ, licenseId: {}, licenseKey: {}",
                    license.getLicenseId(), license.getLicenseKey());

            return ResponseDTO.ok(activationVO);

        } catch (Exception e) {
            log.error("æ¿€æ´»è®¸å¯è¯å¤±è´¥", e);
            return ResponseDTO.error("æ¿€æ´»å¤±è´¥");
        }
    }

    /**
     * éªŒè¯è®¸å¯è¯çŠ¶æ€
     */
    public ResponseDTO<LicenseStatusVO> verifyLicenseStatus() {
        try {
            // 1. è·å–å½“å‰æ¿€æ´»çš„è®¸å¯è¯
            LicenseEntity license = getCurrentActiveLicense();
            if (license == null) {
                return ResponseDTO.ok(LicenseStatusVO.inactive());
            }

            // 2. éªŒè¯è®¸å¯è¯
            LicenseValidationResult validationResult = licenseValidator.validate(license);

            // 3. æ£€æŸ¥è®¸å¯è¯ä½¿ç”¨æƒ…å†µ
            LicenseUsageInfo usageInfo = getLicenseUsageInfo(license);

            // 4. æ„å»ºçŠ¶æ€VO
            LicenseStatusVO statusVO = LicenseStatusVO.builder()
                    .licenseId(license.getLicenseId())
                    .licenseKey(license.getLicenseKey())
                    .status(license.getStatus())
                    .isValid(validationResult.isValid())
                    .expireDate(license.getExpireDate())
                    .daysUntilExpire(calculateDaysUntilExpire(license.getExpireDate()))
                    .maxDevices(license.getMaxDevices())
                    .usedDevices(usageInfo.getUsedDevices())
                    .maxUsers(license.getMaxUsers())
                    .usedUsers(usageInfo.getUsedUsers())
                    .features(license.getFeatures())
                    .validationMessage(validationResult.getErrorMessage())
                    .lastCheckTime(LocalDateTime.now())
                    .build();

            return ResponseDTO.ok(statusVO);

        } catch (Exception e) {
            log.error("éªŒè¯è®¸å¯è¯çŠ¶æ€å¤±è´¥", e);
            return ResponseDTO.error("éªŒè¯å¤±è´¥");
        }
    }

    /**
     * ç»­æœŸè®¸å¯è¯
     */
    @Transactional(rollbackFor = Exception.class)
    public ResponseDTO<Void> renewLicense(LicenseRenewalForm renewalForm) {
        try {
            // 1. è·å–å½“å‰è®¸å¯è¯
            LicenseEntity currentLicense = getCurrentActiveLicense();
            if (currentLicense == null) {
                return ResponseDTO.error("å½“å‰æ— æ¿€æ´»çš„è®¸å¯è¯");
            }

            // 2. éªŒè¯ç»­æœŸæ–‡ä»¶
            LicenseFile renewalLicenseFile = parseLicenseFile(renewalForm.getRenewalLicenseFile());

            // 3. éªŒè¯ç»­æœŸè®¸å¯è¯
            if (!renewalLicenseFile.getLicenseKey().equals(currentLicense.getLicenseKey())) {
                return ResponseDTO.error("ç»­æœŸè®¸å¯è¯å¯†é’¥ä¸åŒ¹é…");
            }

            LicenseValidationResult validationResult = licenseValidator.validate(renewalLicenseFile);
            if (!validationResult.isValid()) {
                return ResponseDTO.error("ç»­æœŸè®¸å¯è¯éªŒè¯å¤±è´¥: " + validationResult.getErrorMessage());
            }

            // 4. æ›´æ–°è®¸å¯è¯ä¿¡æ¯
            currentLicense.setExpireDate(renewalLicenseFile.getExpireDate());
            currentLicense.setMaxDevices(renewalLicenseFile.getMaxDevices());
            currentLicense.setMaxUsers(renewalLicenseFile.getMaxUsers());
            currentLicense.setFeatures(renewalLicenseFile.getFeatures());
            currentLicense.setRenewTime(LocalDateTime.now());
            currentLicense.setRenewUserId(SmartRequestUtil.getRequestUserId());

            licenseDao.updateById(currentLicense);

            // 5. é‡æ–°åº”ç”¨è®¸å¯è¯é™åˆ¶
            applyLicenseRestrictions(currentLicense);

            // 6. æ›´æ–°ç»­æœŸæé†’
            scheduleRenewalReminder(currentLicense);

            log.info("è®¸å¯è¯ç»­æœŸæˆåŠŸ, licenseId: {}", currentLicense.getLicenseId());

            return ResponseDTO.ok();

        } catch (Exception e) {
            log.error("ç»­æœŸè®¸å¯è¯å¤±è´¥", e);
            return ResponseDTO.error("ç»­æœŸå¤±è´¥");
        }
    }

    /**
     * è·å–è®¸å¯è¯ä½¿ç”¨ä¿¡æ¯
     */
    private LicenseUsageInfo getLicenseUsageInfo(LicenseEntity license) {
        try {
            // 1. ç»Ÿè®¡è®¾å¤‡ä½¿ç”¨æ•°é‡
            long usedDevices = deviceDao.countActiveDevices();

            // 2. ç»Ÿè®¡ç”¨æˆ·ä½¿ç”¨æ•°é‡
            long usedUsers = userDao.countActiveUsers();

            // 3. ç»Ÿè®¡åŠŸèƒ½ä½¿ç”¨æƒ…å†µ
            Map<String, FeatureUsage> featureUsage = new HashMap<>();
            for (String feature : license.getFeatures()) {
                FeatureUsage usage = calculateFeatureUsage(feature);
                featureUsage.put(feature, usage);
            }

            return LicenseUsageInfo.builder()
                    .usedDevices(usedDevices)
                    .usedUsers(usedUsers)
                    .featureUsage(featureUsage)
                    .build();

        } catch (Exception e) {
            log.error("è·å–è®¸å¯è¯ä½¿ç”¨ä¿¡æ¯å¤±è´¥", e);
            return LicenseUsageInfo.empty();
        }
    }

    /**
     * åº”ç”¨è®¸å¯è¯é™åˆ¶
     */
    private void applyLicenseRestrictions(LicenseEntity license) {
        try {
            // 1. åº”ç”¨è®¾å¤‡æ•°é‡é™åˆ¶
            DeviceRestriction deviceRestriction = DeviceRestriction.builder()
                    .maxDevices(license.getMaxDevices())
                    .enforceLimit(true)
                    .build();
            deviceService.applyDeviceRestriction(deviceRestriction);

            // 2. åº”ç”¨ç”¨æˆ·æ•°é‡é™åˆ¶
            UserRestriction userRestriction = UserRestriction.builder()
                    .maxUsers(license.getMaxUsers())
                    .enforceLimit(true)
                    .build();
            userService.applyUserRestriction(userRestriction);

            // 3. å¯ç”¨/ç¦ç”¨åŠŸèƒ½æ¨¡å—
            for (String feature : license.getFeatures()) {
                featureService.enableFeature(feature);
            }

            log.info("è®¸å¯è¯é™åˆ¶åº”ç”¨æˆåŠŸ, licenseId: {}", license.getLicenseId());

        } catch (Exception e) {
            log.error("åº”ç”¨è®¸å¯è¯é™åˆ¶å¤±è´¥", e);
            throw new RuntimeException("è®¸å¯è¯é™åˆ¶åº”ç”¨å¤±è´¥");
        }
    }

    /**
     * è®¾ç½®ç»­æœŸæé†’
     */
    private void scheduleRenewalReminder(LicenseEntity license) {
        try {
            LocalDateTime expireDate = license.getExpireDate();
            LocalDateTime reminderDate = expireDate.minusDays(30); // æå‰30å¤©æé†’

            if (reminderDate.isAfter(LocalDateTime.now())) {
                TaskScheduler scheduler = getTaskScheduler();
                scheduler.schedule(() -> {
                    try {
                        sendRenewalReminder(license);
                    } catch (Exception e) {
                        log.error("å‘é€è®¸å¯è¯ç»­æœŸæé†’å¤±è´¥", e);
                    }
                }, Date.from(reminderDate.atZone(ZoneId.systemDefault()).toInstant()));
            }

        } catch (Exception e) {
            log.error("è®¾ç½®ç»­æœŸæé†’å¤±è´¥", e);
        }
    }
}
```

### 4. å¤‡ä»½æ¢å¤æœåŠ¡

#### 4.1 æ™ºèƒ½å¤‡ä»½æ¢å¤

**åŠŸèƒ½æè¿°**ï¼šå¤šç§å¤‡ä»½ç­–ç•¥ã€è‡ªåŠ¨å¤‡ä»½ã€å¿«é€Ÿæ¢å¤æœºåˆ¶

**æŠ€æœ¯å®ç°**ï¼š
```java
@Service
@Slf4j
public class BackupRestoreService {

    @Resource
    private BackupConfigDao backupConfigDao;

    @Resource
    private BackupTaskDao backupTaskDao;

    @Resource
    private BackupStorageService backupStorageService;

    @Resource
    private TaskScheduler taskScheduler;

    /**
     * é…ç½®å¤‡ä»½ç­–ç•¥
     */
    @Transactional(rollbackFor = Exception.class)
    public ResponseDTO<String> configureBackupPolicy(BackupPolicyConfigForm configForm) {
        try {
            // 1. éªŒè¯å¤‡ä»½ç­–ç•¥é…ç½®
            validateBackupPolicy(configForm);

            // 2. åˆ›å»ºå¤‡ä»½é…ç½®
            BackupConfigEntity backupConfig = BackupConfigEntity.builder()
                    .configId(IdGenerator.generateId())
                    .policyName(configForm.getPolicyName())
                    .backupType(configForm.getBackupType())
                    .backupFrequency(configForm.getBackupFrequency())
                    .backupTime(configForm.getBackupTime())
                    .retentionDays(configForm.getRetentionDays())
                    .compressionEnabled(configForm.getCompressionEnabled())
                    .encryptionEnabled(configForm.getEncryptionEnabled())
                    .storageLocation(configForm.getStorageLocation())
                    .includedTables(configForm.getIncludedTables())
                    .excludedTables(configForm.getExcludedTables())
                    .enabledFlag(true)
                    .createUserId(SmartRequestUtil.getRequestUserId())
                    .createTime(LocalDateTime.now())
                    .build();

            backupConfigDao.insert(backupConfig);

            // 3. è°ƒåº¦å¤‡ä»½ä»»åŠ¡
            scheduleBackupTask(backupConfig);

            log.info("å¤‡ä»½ç­–ç•¥é…ç½®æˆåŠŸ, configId: {}, policyName: {}",
                    backupConfig.getConfigId(), backupConfig.getPolicyName());

            return ResponseDTO.ok(backupConfig.getConfigId());

        } catch (Exception e) {
            log.error("é…ç½®å¤‡ä»½ç­–ç•¥å¤±è´¥", e);
            return ResponseDTO.error("é…ç½®å¤±è´¥");
        }
    }

    /**
     * æ‰§è¡Œæ‰‹åŠ¨å¤‡ä»½
     */
    @Async
    public CompletableFuture<BackupExecutionResult> executeManualBackup(ManualBackupForm backupForm) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                String taskId = IdGenerator.generateId();

                // 1. åˆ›å»ºå¤‡ä»½ä»»åŠ¡è®°å½•
                BackupTaskEntity backupTask = BackupTaskEntity.builder()
                        .taskId(taskId)
                        .taskType(BackupTaskType.MANUAL)
                        .backupType(backupForm.getBackupType())
                        .status(BackupStatus.RUNNING)
                        .startTime(LocalDateTime.now())
                        .createUserId(SmartRequestUtil.getRequestUserId())
                        .build();

                backupTaskDao.insert(backupTask);

                // 2. æ‰§è¡Œå¤‡ä»½
                BackupExecutionResult result = performBackup(taskId, backupForm);

                // 3. æ›´æ–°ä»»åŠ¡çŠ¶æ€
                backupTask.setStatus(result.isSuccess() ? BackupStatus.SUCCESS : BackupStatus.FAILED);
                backupTask.setEndTime(LocalDateTime.now());
                backupTask.setBackupFilePath(result.getBackupFilePath());
                backupTask.setFileSize(result.getFileSize());
                backupTask.setErrorMessage(result.getErrorMessage());

                backupTaskDao.updateById(backupTask);

                // 4. å‘é€å¤‡ä»½å®Œæˆé€šçŸ¥
                if (result.isSuccess()) {
                    notificationService.sendBackupSuccessNotification(backupTask);
                } else {
                    notificationService.sendBackupFailureNotification(backupTask, result.getErrorMessage());
                }

                log.info("æ‰‹åŠ¨å¤‡ä»½æ‰§è¡Œå®Œæˆ, taskId: {}, success: {}", taskId, result.isSuccess());

                return result;

            } catch (Exception e) {
                log.error("æ‰§è¡Œæ‰‹åŠ¨å¤‡ä»½å¤±è´¥", e);
                return BackupExecutionResult.failed("å¤‡ä»½æ‰§è¡Œå¼‚å¸¸: " + e.getMessage());
            }
        });
    }

    /**
     * æ‰§è¡Œå¤‡ä»½æ“ä½œ
     */
    private BackupExecutionResult performBackup(String taskId, BackupForm backupForm) {
        try {
            LocalDateTime startTime = LocalDateTime.now();
            String backupFileName = generateBackupFileName(backupForm.getBackupType(), startTime);

            // 1. å‡†å¤‡å¤‡ä»½
            BackupContext context = BackupContext.builder()
                    .taskId(taskId)
                    .backupType(backupForm.getBackupType())
                    .backupFileName(backupFileName)
                    .compressionEnabled(backupForm.isCompressionEnabled())
                    .encryptionEnabled(backupForm.isEncryptionEnabled())
                    .build();

            // 2. æ‰§è¡Œæ•°æ®å¤‡ä»½
            switch (backupForm.getBackupType()) {
                case FULL:
                    return performFullBackup(context);
                case INCREMENTAL:
                    return performIncrementalBackup(context);
                case DIFFERENTIAL:
                    return performDifferentialBackup(context);
                default:
                    throw new BusinessException("ä¸æ”¯æŒçš„å¤‡ä»½ç±»å‹");
            }

        } catch (Exception e) {
            log.error("æ‰§è¡Œå¤‡ä»½æ“ä½œå¤±è´¥", e);
            return BackupExecutionResult.failed("å¤‡ä»½æ‰§è¡Œå¤±è´¥: " + e.getMessage());
        }
    }

    /**
     * æ‰§è¡Œå…¨é‡å¤‡ä»½
     */
    private BackupExecutionResult performFullBackup(BackupContext context) {
        try {
            String tempBackupPath = createTempBackupPath(context.getBackupFileName());

            // 1. å¤‡ä»½æ•°æ®åº“è¡¨
            List<TableBackupResult> tableResults = new ArrayList<>();
            List<String> tablesToBackup = getTablesToBackup();

            for (String tableName : tablesToBackup) {
                TableBackupResult tableResult = backupTable(tableName, tempBackupPath, context);
                tableResults.add(tableResult);
            }

            // 2. å¤‡ä»½æ–‡ä»¶
            List<FileBackupResult> fileResults = backupFiles(tempBackupPath, context);

            // 3. å‹ç¼©å¤‡ä»½æ–‡ä»¶
            if (context.isCompressionEnabled()) {
                compressBackup(tempBackupPath, context);
            }

            // 4. åŠ å¯†å¤‡ä»½æ–‡ä»¶
            if (context.isEncryptionEnabled()) {
                encryptBackup(tempBackupPath, context);
            }

            // 5. ä¸Šä¼ åˆ°å­˜å‚¨ä½ç½®
            String backupFilePath = backupStorageService.storeBackup(tempBackupPath, context);

            // 6. æ¸…ç†ä¸´æ—¶æ–‡ä»¶
            cleanupTempFiles(tempBackupPath);

            // 7. è®¡ç®—å¤‡ä»½æ–‡ä»¶å¤§å°
            long fileSize = calculateBackupFileSize(backupFilePath);

            // 8. è®°å½•å¤‡ä»½å…ƒæ•°æ®
            BackupMetadata metadata = BackupMetadata.builder()
                    .taskId(context.getTaskId())
                    .backupType(BackupType.FULL)
                    .backupFilePath(backupFilePath)
                    .fileSize(fileSize)
                    .tableCount(tableResults.size())
                    .fileCount(fileResults.size())
                    .backupTime(LocalDateTime.now())
                    .tableResults(tableResults)
                    .fileResults(fileResults)
                    .build();

            saveBackupMetadata(metadata);

            return BackupExecutionResult.success(backupFilePath, fileSize);

        } catch (Exception e) {
            log.error("æ‰§è¡Œå…¨é‡å¤‡ä»½å¤±è´¥", e);
            return BackupExecutionResult.failed("å…¨é‡å¤‡ä»½å¤±è´¥: " + e.getMessage());
        }
    }

    /**
     * æ¢å¤æ•°æ®
     */
    @Transactional(rollbackFor = Exception.class)
    public ResponseDTO<RestoreResultVO> restoreData(RestoreForm restoreForm) {
        try {
            // 1. éªŒè¯æ¢å¤æƒé™
            validateRestorePermission();

            // 2. è·å–å¤‡ä»½æ–‡ä»¶
            String backupFilePath = restoreForm.getBackupFilePath();
            if (!backupStorageService.backupExists(backupFilePath)) {
                return ResponseDTO.error("å¤‡ä»½æ–‡ä»¶ä¸å­˜åœ¨");
            }

            // 3. ä¸‹è½½å¤‡ä»½æ–‡ä»¶
            String localBackupPath = downloadBackupFile(backupFilePath);

            // 4. è§£å¯†å¤‡ä»½æ–‡ä»¶ï¼ˆå¦‚æœéœ€è¦ï¼‰
            if (isEncryptedBackup(backupFilePath)) {
                decryptBackup(localBackupPath, restoreForm.getDecryptPassword());
            }

            // 5. è§£å‹å¤‡ä»½æ–‡ä»¶ï¼ˆå¦‚æœéœ€è¦ï¼‰
            if (isCompressedBackup(backupFilePath)) {
                decompressBackup(localBackupPath);
            }

            // 6. éªŒè¯å¤‡ä»½æ–‡ä»¶
            BackupValidationResult validation = validateBackupFile(localBackupPath);
            if (!validation.isValid()) {
                return ResponseDTO.error("å¤‡ä»½æ–‡ä»¶éªŒè¯å¤±è´¥: " + validation.getErrorMessage());
            }

            // 7. æ‰§è¡Œæ•°æ®æ¢å¤
            RestoreResult restoreResult = performDataRestore(localBackupPath, restoreForm);

            // 8. æ¸…ç†ä¸´æ—¶æ–‡ä»¶
            cleanupTempFiles(localBackupPath);

            // 9. è®°å½•æ¢å¤æ“ä½œ
            logRestoreOperation(backupFilePath, restoreResult);

            // 10. æ„å»ºæ¢å¤ç»“æœ
            RestoreResultVO resultVO = RestoreResultVO.builder()
                    .backupFilePath(backupFilePath)
                    .restoreTime(restoreResult.getRestoreTime())
                    .tablesRestored(restoreResult.getTablesRestored())
                    .recordsRestored(restoreResult.getRecordsRestored())
                    .success(restoreResult.isSuccess())
                    .errorMessage(restoreResult.getErrorMessage())
                    .build();

            log.info("æ•°æ®æ¢å¤å®Œæˆ, backupFilePath: {}, success: {}",
                    backupFilePath, restoreResult.isSuccess());

            return ResponseDTO.ok(resultVO);

        } catch (Exception e) {
            log.error("æ¢å¤æ•°æ®å¤±è´¥", e);
            return ResponseDTO.error("æ¢å¤å¤±è´¥");
        }
    }

    /**
     * å¤‡ä»½å•ä¸ªè¡¨
     */
    private TableBackupResult backupTable(String tableName, String backupPath, BackupContext context) {
        try {
            String tableBackupPath = backupPath + "/tables/" + tableName + ".sql";
            FileUtils.forceMkdir(new File(tableBackupPath).getParentFile());

            // 1. å¯¼å‡ºè¡¨ç»“æ„å’Œæ•°æ®
            ProcessBuilder processBuilder = new ProcessBuilder();
            processBuilder.command("mysqldump",
                    "--single-transaction",
                    "--routines",
                    "--triggers",
                    "--hex-blob",
                    "--default-character-set=utf8mb4",
                    "-h", getDatabaseHost(),
                    "-u", getDatabaseUser(),
                    "-p" + getDatabasePassword(),
                    getDatabaseName(),
                    tableName);

            processBuilder.redirectOutput(new File(tableBackupPath));
            Process process = processBuilder.start();

            int exitCode = process.waitFor();
            if (exitCode != 0) {
                throw new RuntimeException("è¡¨å¯¼å‡ºå¤±è´¥ï¼Œé€€å‡ºç : " + exitCode);
            }

            // 2. è®¡ç®—æ–‡ä»¶å¤§å°
            long fileSize = new File(tableBackupPath).length();

            // 3. è®°å½•å¤‡ä»½ç»“æœ
            return TableBackupResult.builder()
                    .tableName(tableName)
                    .backupPath(tableBackupPath)
                    .fileSize(fileSize)
                    .recordCount(getTableRecordCount(tableName))
                    .backupTime(LocalDateTime.now())
                    .build();

        } catch (Exception e) {
            log.error("å¤‡ä»½è¡¨å¤±è´¥, tableName: {}", tableName, e);
            return TableBackupResult.failed(tableName, e.getMessage());
        }
    }

    /**
     * è°ƒåº¦å¤‡ä»½ä»»åŠ¡
     */
    private void scheduleBackupTask(BackupConfigEntity backupConfig) {
        try {
            CronTrigger trigger = new CronTrigger(backupConfig.getBackupTime());

            taskScheduler.schedule(() -> {
                try {
                    executeScheduledBackup(backupConfig);
                } catch (Exception e) {
                    log.error("æ‰§è¡Œè°ƒåº¦å¤‡ä»½å¤±è´¥", e);
                }
            }, trigger);

            log.info("å¤‡ä»½ä»»åŠ¡è°ƒåº¦æˆåŠŸ, configId: {}, cron: {}",
                    backupConfig.getConfigId(), backupConfig.getBackupTime());

        } catch (Exception e) {
            log.error("è°ƒåº¦å¤‡ä»½ä»»åŠ¡å¤±è´¥", e);
        }
    }
}
```

## ğŸ“Š å…³é”®æ€§èƒ½æŒ‡æ ‡

### ç³»ç»Ÿé…ç½®æ€§èƒ½è¦æ±‚

| æŒ‡æ ‡ç±»å‹ | æ€§èƒ½è¦æ±‚ | ç›‘æ§æ–¹æ³• |
|---------|---------|---------|
| å‚æ•°é…ç½®å“åº”æ—¶é—´ | â‰¤ 1ç§’ | é…ç½®å˜æ›´è€—æ—¶ç›‘æ§ |
| é…ç½®çƒ­æ›´æ–°å»¶è¿Ÿ | â‰¤ 5ç§’ | é…ç½®ç”Ÿæ•ˆæ—¶æ•ˆæ£€æŸ¥ |
| æƒé™éªŒè¯å“åº”æ—¶é—´ | â‰¤ 100æ¯«ç§’ | æƒé™éªŒè¯æ€§èƒ½æµ‹è¯• |
| è®¸å¯è¯éªŒè¯æ—¶é—´ | â‰¤ 1ç§’ | è®¸å¯è¯éªŒè¯æ—¶æ•ˆç›‘æ§ |
| å¤‡ä»½å¤„ç†é€Ÿåº¦ | â‰¥ 100MB/åˆ†é’Ÿ | å¤‡ä»½å¤„ç†æ€§èƒ½ç›‘æ§ |
| æ•°æ®æ¢å¤é€Ÿåº¦ | â‰¥ 50MB/åˆ†é’Ÿ | æ¢å¤å¤„ç†æ€§èƒ½ç›‘æ§ |

### ç³»ç»Ÿå®¹é‡æŒ‡æ ‡

| æŒ‡æ ‡ç±»å‹ | è®¾è®¡å®¹é‡ | è¯´æ˜ |
|---------|---------|------|
| å¹¶å‘é…ç½®ç”¨æˆ·æ•° | 100ç”¨æˆ· | åŒæ—¶è¿›è¡Œç³»ç»Ÿé…ç½®ç”¨æˆ·æ•° |
| å‚æ•°é…ç½®é¡¹æ•°é‡ | 1000é¡¹ | ç³»ç»Ÿå‚æ•°é…ç½®é¡¹æ€»æ•° |
| ç”¨æˆ·è§’è‰²æ•°é‡ | 50ä¸ª | ç³»ç»Ÿç”¨æˆ·è§’è‰²æ€»æ•° |
| æƒé™é¡¹æ•°é‡ | 500ä¸ª | ç³»ç»Ÿæƒé™é¡¹æ€»æ•° |
| å¤‡ä»½æ–‡ä»¶å­˜å‚¨ | 1TB | å¤‡ä»½æ–‡ä»¶å¹´åº¦å­˜å‚¨é‡ |
| é…ç½®å˜æ›´æ—¥å¿— | 10ä¸‡æ¡/æœˆ | é…ç½®å˜æ›´æ—¥å¿—æœˆåº¦å¢é‡ |

## ğŸ”— ç›¸å…³æ–‡æ¡£

### æŠ€æœ¯å®ç°æ–‡æ¡£
- [é—¨ç¦ç®¡ç†ç³»ç»Ÿæ•´ä½“æ¶æ„è®¾è®¡](./ç³»ç»Ÿæ•´ä½“æ¶æ„è®¾è®¡.md) - å®Œæ•´çš„ç³»ç»Ÿæ¶æ„è®¾è®¡
- [ç”¨æˆ·æƒé™ç®¡ç†æ¨¡å—è®¾è®¡](./ç”¨æˆ·æƒé™ç®¡ç†æ¨¡å—è®¾è®¡.md) - æƒé™ç®¡ç†è¯¦ç»†å®ç°
- [ç³»ç»Ÿå®‰å…¨è§„èŒƒè®¾è®¡](./ç³»ç»Ÿå®‰å…¨è§„èŒƒè®¾è®¡.md) - å®‰å…¨ç­–ç•¥å’Œè§„èŒƒ

### é…ç½®ç®¡ç†æ–‡æ¡£
- [é…ç½®çƒ­æ›´æ–°æœºåˆ¶è®¾è®¡](./é…ç½®çƒ­æ›´æ–°æœºåˆ¶è®¾è®¡.md) - é…ç½®çƒ­æ›´æ–°æŠ€æœ¯å®ç°
- [è®¸å¯è¯ç®¡ç†è§„èŒƒ](./è®¸å¯è¯ç®¡ç†è§„èŒƒ.md) - è®¸å¯è¯ç®¡ç†è§„èŒƒå’Œæµç¨‹
- [å¤‡ä»½æ¢å¤ç­–ç•¥è®¾è®¡](./å¤‡ä»½æ¢å¤ç­–ç•¥è®¾è®¡.md) - å¤‡ä»½æ¢å¤ç­–ç•¥è®¾è®¡

### è¿ç»´ç®¡ç†æ–‡æ¡£
- [ç³»ç»Ÿç›‘æ§æ–¹æ¡ˆ](./ç³»ç»Ÿç›‘æ§æ–¹æ¡ˆ.md) - ç³»ç»Ÿç›‘æ§å’Œå‘Šè­¦æ–¹æ¡ˆ
- [è¿ç»´æ“ä½œæ‰‹å†Œ](./è¿ç»´æ“ä½œæ‰‹å†Œ.md) - æ—¥å¸¸è¿ç»´æ“ä½œæŒ‡å—
- [æ•…éšœå¤„ç†æŒ‡å—](./æ•…éšœå¤„ç†æŒ‡å—.md) - å¸¸è§æ•…éšœå¤„ç†æµç¨‹

---

## ğŸ¯ æ ¸å¿ƒåŸåˆ™æ€»ç»“

1. **é…ç½®é›†ä¸­ç®¡ç†** - ç»Ÿä¸€çš„ç³»ç»Ÿå‚æ•°é…ç½®å’Œç®¡ç†æœºåˆ¶
2. **æƒé™åˆ†çº§æ§åˆ¶** - åŸºäºè§’è‰²çš„ç»†ç²’åº¦æƒé™ç®¡ç†
3. **è®¸å¯è¯åˆè§„ç®¡ç†** - å®Œæ•´çš„è®¸å¯è¯ç”Ÿå‘½å‘¨æœŸç®¡ç†
4. **æ•°æ®å®‰å…¨ä¿éšœ** - å¤šé‡å¤‡ä»½å’Œå¿«é€Ÿæ¢å¤æœºåˆ¶
5. **å˜æ›´å¯è¿½æº¯** - å®Œæ•´çš„é…ç½®å˜æ›´å®¡è®¡æ—¥å¿—

## ğŸ“‹ ç‰ˆæœ¬ä¿¡æ¯

- æœ¬æ–‡æ¡£åŸºäºç³»ç»Ÿç®¡ç†æœ€ä½³å®è·µè®¾è®¡
- ç³»ç»Ÿé…ç½®æ¨¡å—è®¾è®¡è´Ÿè´£äººï¼šSmartAdminè§„èŒƒæ²»ç†å§”å‘˜ä¼š
- åˆ›å»ºæ—¥æœŸï¼š2025-11-13
- ä¸‹æ¬¡è¯„å®¡ï¼š2026-02-13

---

**ğŸ¯ IOE-DREAMé—¨ç¦ç³»ç»Ÿé…ç½®æ¨¡å— - é›†ä¸­é…ç½®ã€æƒé™ç®¡ç†ã€è®¸å¯è¯æ§åˆ¶ã€æ•°æ®å¤‡ä»½çš„ä¼ä¸šçº§ç³»ç»Ÿç®¡ç†è§£å†³æ–¹æ¡ˆ**