# æ™ºèƒ½æ’ç­ç®¡ç†ç³»ç»Ÿ

> **ç‰ˆæœ¬**: v3.5.4
> **æ›´æ–°æ—¶é—´**: 2025-11-13
> **åˆ†ç±»**: æ ¸å¿ƒåŠŸèƒ½æ¨¡å— > ä¼ä¸šOAç³»ç»Ÿ > è€ƒå‹¤ç®¡ç†
> **æ ‡ç­¾**: ["æ™ºèƒ½æ’ç­", "ä¼˜åŒ–ç®—æ³•", "æœºå™¨å­¦ä¹ ", "å®æ—¶è°ƒæ•´", "ç§»åŠ¨ç«¯æ’ç­"]
> **ä½œè€…**: SmartAdminè§„èŒƒæ²»ç†å§”å‘˜ä¼š
> **æŠ€æœ¯æ ˆ**: Spring Boot 3.5.4 + Java 17 + OptaPlanner 9.44 + Apache Commons Math
> **æè¿°**: IOE-DREAMæ™ºæ…§å›­åŒºä¸€å¡é€šç®¡ç†å¹³å°çš„æ™ºèƒ½æ’ç­ç®¡ç†ç³»ç»Ÿï¼Œæ”¯æŒAIä¼˜åŒ–ç®—æ³•å’Œå®æ—¶æ’ç­è°ƒæ•´

## ğŸ“‹ ç³»ç»Ÿæ¦‚è¿°

### æ ¸å¿ƒåŠŸèƒ½

**æ™ºèƒ½æ’ç­ç®¡ç†ç³»ç»Ÿ**æ˜¯IOE-DREAMæ™ºæ…§å›­åŒºä¸€å¡é€šç®¡ç†å¹³å°çš„æ ¸å¿ƒç»„ä»¶ï¼Œè´Ÿè´£ä¼ä¸šå‘˜å·¥æ’ç­å®‰æ’çš„æ™ºèƒ½åŒ–ç®¡ç†ã€‚åŸºäºSpring Boot 3.5.4 + Java 17æ¶æ„ï¼Œé›†æˆOptaPlannerçº¦æŸæ»¡è¶³æ±‚è§£å™¨å’Œæœºå™¨å­¦ä¹ ç®—æ³•ï¼Œå®ç°æœ€ä¼˜æ’ç­æ–¹æ¡ˆçš„è‡ªåŠ¨ç”Ÿæˆå’Œå®æ—¶è°ƒæ•´ã€‚

### ä¸»è¦ç‰¹æ€§

- âœ… **AIä¼˜åŒ–æ’ç­**: åŸºäºOptaPlanner 9.44çš„æ™ºèƒ½æ’ç­ä¼˜åŒ–ç®—æ³•
- âœ… **å¤šç›®æ ‡ä¼˜åŒ–**: åŒæ—¶è€ƒè™‘æˆæœ¬ã€æ•ˆç‡ã€å…¬å¹³æ€§ç­‰å¤šä¸ªç›®æ ‡
- âœ… **å®æ—¶æ’ç­è°ƒæ•´**: æ”¯æŒå®æ—¶åŠ¨æ€è°ƒæ•´å’Œå†²çªè‡ªåŠ¨è§£å†³
- âœ… **æ™ºèƒ½é¢„æµ‹**: åŸºäºå†å²æ•°æ®çš„æ’ç­éœ€æ±‚é¢„æµ‹
- âœ… **ç§»åŠ¨ç«¯æ’ç­**: å…¨åŠŸèƒ½ç§»åŠ¨ç«¯æ’ç­ç®¡ç†
- âœ… **å¤šç»´åº¦çº¦æŸ**: æ³•è§„ã€æŠ€èƒ½ã€å·¥ä½œé‡ç­‰å¤šç»´åº¦çº¦æŸç®¡ç†
- âœ… **æ’ç­å…¬å¹³æ€§**: ç¡®ä¿æ’ç­åˆ†é…çš„å…¬å¹³æ€§å’Œå‘˜å·¥æ»¡æ„åº¦
- âœ… **å¯è§†åŒ–æ’ç­**: ä¸°å¯Œçš„å›¾è¡¨å’Œæ—¥å†è§†å›¾å±•ç¤º

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„

### æ ¸å¿ƒæŠ€æœ¯æ ˆ
- **åç«¯æ¡†æ¶**: Spring Boot 3.5.4 + Java 17
- **ä¼˜åŒ–å¼•æ“**: OptaPlanner 9.44 + Drools 8.44
- **æœºå™¨å­¦ä¹ **: Apache Spark MLlib + TensorFlow Lite
- **æ•°æ®åº“**: PostgreSQL 14+ + Redis 7.0 (ç¼“å­˜)
- **æ¶ˆæ¯é˜Ÿåˆ—**: Apache Kafka 3.5 (å®æ—¶äº‹ä»¶)
- **æœç´¢å¼•æ“**: Elasticsearch 8.10 (æ—¥å¿—æ£€ç´¢)
- **æ—¶é—´åºåˆ—**: InfluxDB 2.7 (æ’ç­å†å²æ•°æ®)
- **å¯è§†åŒ–**: Apache ECharts + D3.js

### å¾®æœåŠ¡æ¶æ„è®¾è®¡
```java
@RestController
@RequestMapping("/api/v1/smart-scheduling")
@Tag(name = "æ™ºèƒ½æ’ç­ç®¡ç†", description = "æ™ºèƒ½æ’ç­ç›¸å…³æ¥å£")
@SecurityRequirement(name = "bearerAuth")
public class SmartSchedulingController {

    @Resource
    private IntelligentSchedulingService schedulingService;

    @Resource
    private OptimizationEngineService optimizationEngine;

    @Resource
    private SchedulingPredictionService predictionService;
}
```

## ğŸ—„ï¸ æ•°æ®åº“è®¾è®¡

### 1. æ’ç­è®°å½•ä¸»è¡¨ (t_schedule_record)
```sql
CREATE TABLE t_schedule_record (
    schedule_id BIGSERIAL PRIMARY KEY,
    schedule_number VARCHAR(32) NOT NULL UNIQUE,

    -- å‘˜å·¥ä¿¡æ¯
    employee_id BIGINT NOT NULL,
    employee_name VARCHAR(100) NOT NULL,
    employee_code VARCHAR(32) NOT NULL,
    department_id BIGINT,
    department_name VARCHAR(100),
    position_id BIGINT,
    position_name VARCHAR(100),

    -- æ’ç­ä¿¡æ¯
    schedule_date DATE NOT NULL,
    shift_id BIGINT NOT NULL,
    shift_name VARCHAR(100) NOT NULL,
    shift_type VARCHAR(50) NOT NULL,

    -- æ—¶é—´ä¿¡æ¯
    start_time TIMESTAMP(6) NOT NULL,
    end_time TIMESTAMP(6) NOT NULL,
    duration_minutes INTEGER NOT NULL,
    break_minutes INTEGER DEFAULT 0,

    -- æ’ç­å±æ€§
    schedule_type VARCHAR(20) NOT NULL,
    priority_level INTEGER DEFAULT 0,
    is_flexible BOOLEAN DEFAULT FALSE,
    is_overtime BOOLEAN DEFAULT FALSE,

    -- æŠ€èƒ½è¦æ±‚
    required_skills JSONB,
    employee_skills JSONB,
    skill_match_score DECIMAL(5, 4),

    -- å·¥ä½œé‡
    workload_points DECIMAL(8, 2),
    complexity_level INTEGER DEFAULT 1,

    -- æˆæœ¬ä¿¡æ¯
    labor_cost DECIMAL(10, 2),
    overtime_cost DECIMAL(10, 2),

    -- ä¼˜åŒ–ä¿¡æ¯
    optimization_score DECIMAL(5, 4),
    optimization_factors JSONB,
    alternative_options JSONB,

    -- çŠ¶æ€ä¿¡æ¯
    schedule_status VARCHAR(20) DEFAULT 'SCHEDULED',
    confirmation_status VARCHAR(20) DEFAULT 'PENDING',
    adjustment_count INTEGER DEFAULT 0,

    -- åˆ›å»ºä¿¡æ¯
    source_type VARCHAR(20) DEFAULT 'SYSTEM',
    template_id BIGINT,
    created_by_id BIGINT,
    creation_reason TEXT,

    -- å®¡è®¡å­—æ®µ
    create_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,
    create_user_id BIGINT,
    update_user_id BIGINT,
    deleted_flag SMALLINT DEFAULT 0,

    -- åˆ†åŒºå­—æ®µ
    partition_month VARCHAR(7) GENERATED ALWAYS AS (TO_CHAR(schedule_date, 'YYYY-MM')) STORED
) PARTITION BY LIST (partition_month);

-- åˆ›å»ºåˆ†åŒº
CREATE TABLE t_schedule_record_202401 PARTITION OF t_schedule_record
    FOR VALUES IN ('2024-01');

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_employee_schedule ON t_schedule_record(employee_id, schedule_date);
CREATE INDEX idx_department_schedule ON t_schedule_record(department_id, schedule_date);
CREATE INDEX idx_shift_schedule ON t_schedule_record(shift_id, schedule_date);
CREATE INDEX idx_schedule_status ON t_schedule_record(schedule_status);
CREATE INDEX idx_optimization_score ON t_schedule_record(optimization_score DESC);
```

### 2. æ’ç­æ¨¡æ¿è¡¨ (t_schedule_template)
```sql
CREATE TABLE t_schedule_template (
    template_id BIGSERIAL PRIMARY KEY,
    template_code VARCHAR(32) NOT NULL UNIQUE,
    template_name VARCHAR(200) NOT NULL,
    template_category VARCHAR(50) NOT NULL,

    -- æ¨¡æ¿é…ç½®
    template_type VARCHAR(20) NOT NULL,
    cycle_type VARCHAR(20) NOT NULL,
    cycle_length INTEGER NOT NULL,
    effective_start_date DATE,
    effective_end_date DATE,

    -- æ’ç­æ¨¡å¼
    schedule_patterns JSONB NOT NULL,
    rotation_rules JSONB,
    substitution_rules JSONB,

    -- çº¦æŸæ¡ä»¶
    scheduling_constraints JSONB,
    business_constraints JSONB,
    legal_constraints JSONB,

    -- ä¼˜åŒ–ç›®æ ‡
    optimization_objectives JSONB,
    cost_optimization_rules JSONB,
    workload_balancing_rules JSONB,

    -- é€‚ç”¨èŒƒå›´
    applicable_departments JSONB,
    applicable_positions JSONB,
    applicable_employee_levels JSONB,
    skill_requirements JSONB,

    -- AIé…ç½®
    ml_model_id VARCHAR(100),
    prediction_accuracy DECIMAL(5, 4),
    historical_performance JSONB,

    -- æ¨¡æ¿ç»Ÿè®¡
    usage_count INTEGER DEFAULT 0,
    success_rate DECIMAL(5, 4),
    employee_satisfaction_score DECIMAL(5, 4),

    -- çŠ¶æ€ä¿¡æ¯
    is_active BOOLEAN DEFAULT TRUE,
    is_latest_version BOOLEAN DEFAULT TRUE,
    template_version INTEGER DEFAULT 1,

    -- å®¡è®¡å­—æ®µ
    create_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,
    create_user_id BIGINT,
    update_user_id BIGINT,
    deleted_flag SMALLINT DEFAULT 0,

    -- ç‰ˆæœ¬æ§åˆ¶
    parent_template_id BIGINT,
    version_notes TEXT
) DISTRIBUTED BY (template_id);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_template_code ON t_schedule_template(template_code);
CREATE INDEX idx_template_type ON t_schedule_template(template_type);
CREATE INDEX idx_is_active ON t_schedule_template(is_active);
CREATE INDEX idx_usage_count ON t_schedule_template(usage_count DESC);
```

### 3. æ’ç­ä¼˜åŒ–ä»»åŠ¡è¡¨ (t_scheduling_optimization_task)
```sql
CREATE TABLE t_scheduling_optimization_task (
    task_id BIGSERIAL PRIMARY KEY,
    task_number VARCHAR(32) NOT NULL UNIQUE,

    -- ä»»åŠ¡é…ç½®
    task_name VARCHAR(200) NOT NULL,
    optimization_type VARCHAR(50) NOT NULL,
    optimization_scope JSONB NOT NULL,

    -- æ—¶é—´èŒƒå›´
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    planning_horizon_days INTEGER NOT NULL,

    -- ä¼˜åŒ–ç›®æ ‡
    primary_objective VARCHAR(50) NOT NULL,
    secondary_objectives JSONB,
    optimization_weights JSONB,

    -- ç®—æ³•é…ç½®
    algorithm_type VARCHAR(50) NOT NULL,
    algorithm_parameters JSONB,
    time_limit_seconds INTEGER,
    solution_count_limit INTEGER DEFAULT 10,

    -- çº¦æŸæ¡ä»¶
    hard_constraints JSONB,
    soft_constraints JSONB,
    constraint_weights JSONB,

    -- æ‰§è¡ŒçŠ¶æ€
    task_status VARCHAR(20) DEFAULT 'PENDING',
    progress_percentage INTEGER DEFAULT 0,
    current_phase VARCHAR(50),

    -- æ‰§è¡Œç»“æœ
    best_solution_id VARCHAR(100),
    best_score DECIMAL(15, 8),
    solution_count INTEGER DEFAULT 0,
    execution_time_seconds INTEGER,

    -- è´¨é‡æŒ‡æ ‡
    feasibility_score DECIMAL(5, 4),
    cost_efficiency_score DECIMAL(5, 4),
    fairness_score DECIMAL(5, 4),
    employee_satisfaction_prediction DECIMAL(5, 4),

    -- é¢„æµ‹æ•°æ®
    demand_prediction JSONB,
    resource_utilization_prediction JSONB,
    cost_impact_prediction JSONB,

    -- æ‰§è¡Œä¿¡æ¯
    started_at TIMESTAMP(6),
    completed_at TIMESTAMP(6),
    error_message TEXT,
    execution_log JSONB,

    -- å®¡è®¡å­—æ®µ
    create_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,
    create_user_id BIGINT,
    update_user_id BIGINT,
    deleted_flag SMALLINT DEFAULT 0
) DISTRIBUTED BY (task_id);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_task_status ON t_scheduling_optimization_task(task_status);
CREATE INDEX idx_task_date_range ON t_scheduling_optimization_task(start_date, end_date);
CREATE INDEX idx_best_score ON t_scheduling_optimization_task(best_score DESC);
CREATE INDEX idx_create_time ON t_scheduling_optimization_task(create_time);
```

### 4. æ’ç­è°ƒæ•´è®°å½•è¡¨ (t_schedule_adjustment)
```sql
CREATE TABLE t_schedule_adjustment (
    adjustment_id BIGSERIAL PRIMARY KEY,
    adjustment_number VARCHAR(32) NOT NULL UNIQUE,

    -- å…³è”ä¿¡æ¯
    schedule_id BIGINT NOT NULL,
    original_shift_id BIGINT,
    new_shift_id BIGINT,

    -- è°ƒæ•´ä¿¡æ¯
    adjustment_type VARCHAR(50) NOT NULL,
    adjustment_reason VARCHAR(200) NOT NULL,
    adjustment_category VARCHAR(50),

    -- æ—¶é—´å˜æ›´
    original_start_time TIMESTAMP(6),
    original_end_time TIMESTAMP(6),
    new_start_time TIMESTAMP(6),
    new_end_time TIMESTAMP(6),

    -- å½±å“åˆ†æ
    cost_impact DECIMAL(10, 2),
    workload_impact DECIMAL(8, 2),
    skill_match_impact DECIMAL(5, 4),

    -- è‡ªåŠ¨åŒ–ä¿¡æ¯
    auto_adjustment BOOLEAN DEFAULT FALSE,
    adjustment_algorithm VARCHAR(50),
    confidence_score DECIMAL(5, 4),
    alternative_solutions JSONB,

    -- å®¡æ‰¹ä¿¡æ¯
    approval_status VARCHAR(20) DEFAULT 'PENDING',
    approver_id BIGINT,
    approval_time TIMESTAMP(6),
    approval_comment TEXT,

    -- é€šçŸ¥ä¿¡æ¯
    notification_sent BOOLEAN DEFAULT FALSE,
    notification_time TIMESTAMP(6),
    employee_acknowledged BOOLEAN DEFAULT FALSE,
    acknowledgment_time TIMESTAMP(6),

    -- å®¡è®¡å­—æ®µ
    create_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,
    create_user_id BIGINT,
    update_user_id BIGINT,
    deleted_flag SMALLINT DEFAULT 0,

    -- å†²çªè§£å†³
    resolved_conflicts JSONB,
    cascading_adjustments JSONB
) DISTRIBUTED BY (adjustment_id);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_schedule_adjustment ON t_schedule_adjustment(schedule_id);
CREATE INDEX idx_adjustment_type ON t_schedule_adjustment(adjustment_type);
CREATE INDEX idx_approval_status ON t_schedule_adjustment(approval_status);
CREATE INDEX idx_adjustment_time ON t_schedule_adjustment(create_time);
```

### 5. æŠ€èƒ½åŒ¹é…é…ç½®è¡¨ (t_skill_match_config)
```sql
CREATE TABLE t_skill_match_config (
    config_id BIGSERIAL PRIMARY KEY,
    config_name VARCHAR(200) NOT NULL,
    config_category VARCHAR(50) NOT NULL,

    -- æŠ€èƒ½å®šä¹‰
    skill_id BIGINT NOT NULL,
    skill_name VARCHAR(100) NOT NULL,
    skill_category VARCHAR(50) NOT NULL,
    skill_level INTEGER NOT NULL,

    -- åŒ¹é…è§„åˆ™
    match_algorithm VARCHAR(50) NOT NULL,
    match_threshold DECIMAL(5, 4) NOT NULL,
    weight_factors JSONB,

    -- è¯„ä¼°æ ‡å‡†
    competency_levels JSONB,
    assessment_criteria JSONB,
    certification_requirements JSONB,

    -- å†å²æ•°æ®
    match_history JSONB,
    success_rate DECIMAL(5, 4),
    average_match_score DECIMAL(5, 4),

    -- AIé…ç½®
    ml_model_parameters JSONB,
    feature_importance JSONB,
    prediction_accuracy DECIMAL(5, 4),

    -- çŠ¶æ€ä¿¡æ¯
    is_active BOOLEAN DEFAULT TRUE,
    version INTEGER DEFAULT 1,

    -- å®¡è®¡å­—æ®µ
    create_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,
    create_user_id BIGINT,
    update_user_id BIGINT,
    deleted_flag SMALLINT DEFAULT 0
) DISTRIBUTED BY (config_id);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_skill_id ON t_skill_match_config(skill_id);
CREATE INDEX idx_skill_category ON t_skill_match_config(skill_category);
CREATE INDEX idx_is_active ON t_skill_match_config(is_active);
```

## ğŸ”„ æ ¸å¿ƒä¸šåŠ¡é€»è¾‘

### 1. æ™ºèƒ½æ’ç­ä¼˜åŒ–å¼•æ“
```java
@Service
@Transactional
@Slf4j
public class IntelligentSchedulingEngine {

    @Resource
    private SolverManager<SchedulingSolution, Long> solverManager;

    @Resource
    private SchedulingConstraints constraints;

    @Resource
    private SchedulingObjectiveCalculator objectiveCalculator;

    @Resource
    private MLPredictionService predictionService;

    /**
     * å¯åŠ¨æ™ºèƒ½æ’ç­ä¼˜åŒ–
     */
    public CompletableFuture<OptimizationResult> startOptimization(
            SchedulingOptimizationRequest request) {

        try {
            // 1. åˆ›å»ºä¼˜åŒ–é—®é¢˜
            SchedulingProblem problem = createOptimizationProblem(request);

            // 2. åº”ç”¨AIé¢„æµ‹
            applyAIPredictions(problem);

            // 3. é…ç½®æ±‚è§£å™¨
            SolverConfig solverConfig = createSolverConfig(request);

            // 4. å¯åŠ¨æ±‚è§£
            CompletableFuture<SchedulingSolution> solutionFuture =
                solverManager.solveAndListen(request.getTaskId(), problem, solverConfig);

            // 5. å¤„ç†ç»“æœ
            return solutionFuture.thenApply(this::processOptimizationResult);

        } catch (Exception e) {
            log.error("æ™ºèƒ½æ’ç­ä¼˜åŒ–å¤±è´¥", e);
            throw new OptimizationException("æ’ç­ä¼˜åŒ–å¤±è´¥", e);
        }
    }

    /**
     * åˆ›å»ºä¼˜åŒ–é—®é¢˜
     */
    private SchedulingProblem createOptimizationProblem(SchedulingOptimizationRequest request) {

        // 1. è·å–åŸºç¡€æ•°æ®
        List<Employee> employees = employeeService.getEmployeesByScope(request.getScope());
        List<Shift> shifts = shiftService.getShiftsByDateRange(request.getStartDate(), request.getEndDate());
        List<SkillRequirement> skillRequirements = skillRequirementService.getByScope(request.getScope());

        // 2. åˆ›å»ºæ’ç­å®ä½“
        List<ScheduleAssignment> assignments = new ArrayList<>();
        for (Employee employee : employees) {
            for (LocalDate date = request.getStartDate();
                 !date.isAfter(request.getEndDate());
                 date = date.plusDays(1)) {

                // è€ƒè™‘å‘˜å·¥å¯ç”¨æ€§
                if (isEmployeeAvailable(employee, date)) {
                    assignments.add(createAssignment(employee, date, shifts, skillRequirements));
                }
            }
        }

        // 3. æ„å»ºä¼˜åŒ–é—®é¢˜
        return SchedulingProblem.builder()
            .employees(employees)
            .shifts(shifts)
            .skillRequirements(skillRequirements)
            .assignments(assignments)
            .constraints(constraints.getConstraints(request))
            .objectives(objectiveCalculator.getObjectives(request))
            .planningHorizon(request.getPlanningHorizonDays())
            .build();
    }

    /**
     * åº”ç”¨AIé¢„æµ‹
     */
    private void applyAIPredictions(SchedulingProblem problem) {

        try {
            // 1. é¢„æµ‹äººå‘˜éœ€æ±‚
            DemandPrediction demandPrediction = predictionService.predictDemand(
                problem.getStartDate(), problem.getEndDate());
            problem.setDemandPrediction(demandPrediction);

            // 2. é¢„æµ‹å‘˜å·¥å¯ç”¨æ€§
            AvailabilityPrediction availabilityPrediction =
                predictionService.predictAvailability(problem.getEmployees());
            problem.setAvailabilityPrediction(availabilityPrediction);

            // 3. é¢„æµ‹æŠ€èƒ½éœ€æ±‚
            SkillDemandPrediction skillDemandPrediction =
                predictionService.predictSkillDemand(problem.getSkillRequirements());
            problem.setSkillDemandPrediction(skillDemandPrediction);

            // 4. é¢„æµ‹å·¥ä½œè´Ÿè·
            WorkloadPrediction workloadPrediction =
                predictionService.predictWorkload(problem.getEmployees());
            problem.setWorkloadPrediction(workloadPrediction);

        } catch (Exception e) {
            log.warn("AIé¢„æµ‹å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼", e);
        }
    }

    /**
     * åˆ›å»ºæ±‚è§£å™¨é…ç½®
     */
    private SolverConfig createSolverConfig(SchedulingOptimizationRequest request) {

        SolverConfig solverConfig = new SolverConfig();

        // 1. åŸºç¡€é…ç½®
        solverConfig.withSolutionClass(SchedulingSolution.class);
        solverConfig.withEntityClasses(ScheduleAssignment.class);

        // 2. æ±‚è§£ç®—æ³•
        switch (request.getAlgorithmType()) {
            case "GENETIC_ALGORITHM":
                solverConfig.withAlgorithmConfig(new GeneticAlgorithmConfig()
                    .withPopulationSize(request.getPopulationSize())
                    .withMaxGenerations(request.getMaxGenerations()));
                break;
            case "SIMULATED_ANNEALING":
                solverConfig.withAlgorithmConfig(new SimulatedAnnealingConfig()
                    .withInitialTemperature(request.getInitialTemperature())
                    .withTemperatureMultiplier(request.getTemperatureMultiplier()));
                break;
            case "TABU_SEARCH":
                solverConfig.withAlgorithmConfig(new TabuSearchConfig()
                    .withTabuSize(request.getTabuSize())
                    .withMaxNeighborsSize(request.getMaxNeighborsSize()));
                break;
            default:
                solverConfig.withAlgorithmConfig(new LateAcceptanceConfig());
        }

        // 3. ç»ˆæ­¢é…ç½®
        solverConfig.withTerminationConfig(new TerminationConfig()
            .withTimeLimit(Duration.ofSeconds(request.getTimeLimitSeconds()))
            .withBestScoreLimit(request.getBestScoreLimit()));

        // 4. çº¦æŸæƒé‡
        Map<String, String> constraintWeights = new HashMap<>();
        constraintWeights.put("hardConstraintScore", "1soft");
        constraintWeights.put("costScore", String.valueOf(request.getCostWeight()));
        constraintWeights.put("fairnessScore", String.valueOf(request.getFairnessWeight()));
        constraintWeights.put("skillMatchScore", String.valueOf(request.getSkillWeight()));

        solverConfig.setConstraintWeights(constraintWeights);

        return solverConfig;
    }

    /**
     * å¤„ç†ä¼˜åŒ–ç»“æœ
     */
    private OptimizationResult processOptimizationResult(SchedulingSolution solution) {

        try {
            // 1. éªŒè¯è§£çš„å¯è¡Œæ€§
            FeasibilityCheckResult feasibility = validateSolution(solution);

            // 2. è®¡ç®—ä¼˜åŒ–æŒ‡æ ‡
            OptimizationMetrics metrics = calculateOptimizationMetrics(solution);

            // 3. ç”Ÿæˆæ’ç­è®°å½•
            List<ScheduleRecord> scheduleRecords = generateScheduleRecords(solution);

            // 4. åˆ†ææˆæœ¬å½±å“
            CostAnalysis costAnalysis = analyzeCostImpact(scheduleRecords);

            // 5. è¯„ä¼°å‘˜å·¥æ»¡æ„åº¦
            SatisfactionAnalysis satisfactionAnalysis = evaluateEmployeeSatisfaction(solution);

            return OptimizationResult.builder()
                .feasible(feasibility.isFeasible())
                .feasibilityIssues(feasibility.getIssues())
                .metrics(metrics)
                .scheduleRecords(scheduleRecords)
                .costAnalysis(costAnalysis)
                .satisfactionAnalysis(satisfactionAnalysis)
                .optimizationScore(solution.getScore())
                .build();

        } catch (Exception e) {
            log.error("å¤„ç†ä¼˜åŒ–ç»“æœå¤±è´¥", e);
            throw new OptimizationException("ç»“æœå¤„ç†å¤±è´¥", e);
        }
    }

    /**
     * éªŒè¯è§£å†³æ–¹æ¡ˆ
     */
    private FeasibilityCheckResult validateSolution(SchedulingSolution solution) {

        List<String> issues = new ArrayList<>();

        // 1. æ£€æŸ¥ç¡¬çº¦æŸè¿å
        for (ScheduleAssignment assignment : solution.getAssignments()) {
            if (assignment.hasHardConstraintViolation()) {
                issues.add(String.format("å‘˜å·¥ %s åœ¨ %s è¿åç¡¬çº¦æŸ: %s",
                    assignment.getEmployee().getName(),
                    assignment.getDate(),
                    assignment.getHardConstraintViolations()));
            }
        }

        // 2. æ£€æŸ¥èµ„æºå†²çª
        List<ResourceConflict> conflicts = detectResourceConflicts(solution);
        for (ResourceConflict conflict : conflicts) {
            issues.add(String.format("èµ„æºå†²çª: %s", conflict.getDescription()));
        }

        // 3. æ£€æŸ¥æ³•å¾‹æ³•è§„åˆè§„æ€§
        List<LegalComplianceIssue> complianceIssues = checkLegalCompliance(solution);
        for (LegalComplianceIssue issue : complianceIssues) {
            issues.add(String.format("åˆè§„æ€§é—®é¢˜: %s", issue.getDescription()));
        }

        return FeasibilityCheckResult.builder()
            .feasible(issues.isEmpty())
            .issues(issues)
            .build();
    }
}
```

### 2. æœºå™¨å­¦ä¹ é¢„æµ‹æœåŠ¡
```java
@Service
@Slf4j
public class SchedulingPredictionService {

    @Resource
    private SparkMLService sparkMLService;

    @Resource
    private TensorFlowLiteService tensorflowService;

    @Resource
    private TimeSeriesService timeSeriesService;

    /**
     * é¢„æµ‹äººå‘˜éœ€æ±‚
     */
    public DemandPrediction predictDemand(LocalDate startDate, LocalDate endDate) {

        try {
            // 1. è·å–å†å²æ•°æ®
            List<HistoricalDemandData> historicalData =
                demandDataService.getHistoricalData(startDate.minusYears(2), startDate);

            // 2. ç‰¹å¾å·¥ç¨‹
            List<FeatureVector> features = extractDemandFeatures(historicalData);

            // 3. æ¨¡å‹é¢„æµ‹
            Map<LocalDate, Double> demandPredictions = new HashMap<>();
            for (LocalDate date = startDate; !date.isAfter(endDate); date = date.plusDays(1)) {

                // æ„å»ºé¢„æµ‹ç‰¹å¾
                FeatureVector predictionFeatures = buildPredictionFeatures(date, features);

                // æ—¶é—´åºåˆ—é¢„æµ‹
                double tsPrediction = timeSeriesService.predict(historicalData, date);

                // æœºå™¨å­¦ä¹ é¢„æµ‹
                double mlPrediction = sparkMLService.predict(predictionFeatures);

                // æ·±åº¦å­¦ä¹ é¢„æµ‹
                double dlPrediction = tensorflowService.predict(predictionFeatures);

                // é›†æˆé¢„æµ‹
                double finalPrediction = ensemblePredictions(tsPrediction, mlPrediction, dlPrediction);
                demandPredictions.put(date, finalPrediction);
            }

            // 4. é¢„æµ‹ç½®ä¿¡åº¦
            Map<LocalDate, Double> confidenceIntervals = calculateConfidenceIntervals(demandPredictions);

            return DemandPrediction.builder()
                .predictions(demandPredictions)
                .confidenceIntervals(confidenceIntervals)
                .modelAccuracy(calculateModelAccuracy())
                .build();

        } catch (Exception e) {
            log.error("äººå‘˜éœ€æ±‚é¢„æµ‹å¤±è´¥", e);
            throw new PredictionException("äººå‘˜éœ€æ±‚é¢„æµ‹å¤±è´¥", e);
        }
    }

    /**
     * é¢„æµ‹å‘˜å·¥å¯ç”¨æ€§
     */
    public AvailabilityPrediction predictAvailability(List<Employee> employees) {

        Map<Long, EmployeeAvailability> availabilityMap = new HashMap<>();

        for (Employee employee : employees) {
            try {
                // 1. è·å–å‘˜å·¥å†å²å¯ç”¨æ€§æ•°æ®
                List<HistoricalAvailabilityData> historicalData =
                    availabilityDataService.getEmployeeHistory(employee.getId());

                // 2. æå–ç‰¹å¾
                FeatureVector features = extractAvailabilityFeatures(employee, historicalData);

                // 3. é¢„æµ‹æœªæ¥å¯ç”¨æ€§
                double availabilityScore = sparkMLService.predictAvailability(features);

                // 4. é¢„æµ‹è¯·å‡æ¦‚ç‡
                double leaveProbability = tensorflowService.predictLeaveProbability(features);

                // 5. é¢„æµ‹å·¥ä½œæ•ˆç‡
                double productivityScore = sparkMLService.predictProductivity(features);

                availabilityMap.put(employee.getId(), EmployeeAvailability.builder()
                    .employeeId(employee.getId())
                    .availabilityScore(availabilityScore)
                    .leaveProbability(leaveProbability)
                    .productivityScore(productivityScore)
                    .confidenceLevel(calculateConfidenceLevel(features))
                    .build());

            } catch (Exception e) {
                log.warn("å‘˜å·¥å¯ç”¨æ€§é¢„æµ‹å¤±è´¥: " + employee.getId(), e);
                availabilityMap.put(employee.getId(), EmployeeAvailability.defaultAvailability());
            }
        }

        return AvailabilityPrediction.builder()
            .employeeAvailabilities(availabilityMap)
            .overallAvailability(calculateOverallAvailability(availabilityMap))
            .build();
    }

    /**
     * é¢„æµ‹æŠ€èƒ½éœ€æ±‚
     */
    public SkillDemandPrediction predictSkillDemand(List<SkillRequirement> currentRequirements) {

        Map<String, SkillDemandTrend> skillTrends = new HashMap<>();

        for (SkillRequirement requirement : currentRequirements) {
            try {
                // 1. è·å–æŠ€èƒ½éœ€æ±‚æ•°æ®
                List<HistoricalSkillDemand> historicalData =
                    skillDemandService.getHistoricalData(requirement.getSkillId());

                // 2. æ—¶é—´åºåˆ—åˆ†æ
                TimeSeriesAnalysisResult tsAnalysis =
                    timeSeriesService.analyzeTrend(historicalData);

                // 3. å­£èŠ‚æ€§åˆ†æ
                SeasonalityAnalysisResult seasonalityAnalysis =
                    timeSeriesService.analyzeSeasonality(historicalData);

                // 4. æœºå™¨å­¦ä¹ é¢„æµ‹
                FeatureVector features = extractSkillDemandFeatures(requirement, historicalData);
                double mlPrediction = sparkMLService.predictSkillDemand(features);

                // 5. é›†æˆé¢„æµ‹ç»“æœ
                SkillDemandTrend trend = SkillDemandTrend.builder()
                    .skillId(requirement.getSkillId())
                    .skillName(requirement.getSkillName())
                    .currentDemand(requirement.getRequiredCount())
                    .predictedDemand(mlPrediction)
                    .trendDirection(tsAnalysis.getTrendDirection())
                    .seasonalPattern(seasonalityAnalysis.getPattern())
                    .confidenceInterval(calculateConfidenceInterval(mlPrediction, tsAnalysis))
                    .build();

                skillTrends.put(requirement.getSkillId(), trend);

            } catch (Exception e) {
                log.warn("æŠ€èƒ½éœ€æ±‚é¢„æµ‹å¤±è´¥: " + requirement.getSkillId(), e);
            }
        }

        return SkillDemandPrediction.builder()
            .skillTrends(skillTrends)
            .overallTrend(calculateOverallTrend(skillTrends))
            .recommendations(generateSkillRecommendations(skillTrends))
            .build();
    }

    /**
     * é›†æˆé¢„æµ‹ç»“æœ
     */
    private double ensemblePredictions(double... predictions) {

        // ä½¿ç”¨åŠ æƒå¹³å‡é›†æˆ
        double[] weights = {0.3, 0.4, 0.3}; // æ—¶é—´åºåˆ—ã€æœºå™¨å­¦ä¹ ã€æ·±åº¦å­¦ä¹ æƒé‡

        double weightedSum = 0.0;
        double weightSum = 0.0;

        for (int i = 0; i < predictions.length; i++) {
            if (!Double.isNaN(predictions[i])) {
                weightedSum += predictions[i] * weights[i];
                weightSum += weights[i];
            }
        }

        return weightSum > 0 ? weightedSum / weightSum : 0.0;
    }

    /**
     * è®¡ç®—ç½®ä¿¡åº¦
     */
    private Map<LocalDate, Double> calculateConfidenceIntervals(
            Map<LocalDate, Double> predictions) {

        Map<LocalDate, Double> confidenceIntervals = new HashMap<>();

        predictions.forEach((date, prediction) -> {
            // åŸºäºå†å²é¢„æµ‹è¯¯å·®è®¡ç®—ç½®ä¿¡åº¦
            double historicalMae = getHistoricalMAE(date);
            double confidence = Math.max(0.5, 1.0 - (historicalMae / Math.max(prediction, 1.0)));
            confidenceIntervals.put(date, confidence);
        });

        return confidenceIntervals;
    }
}
```

### 3. å®æ—¶æ’ç­è°ƒæ•´å¼•æ“
```java
@Service
@Slf4j
public class RealTimeSchedulingAdjustmentEngine {

    @Resource
    private KafkaTemplate<String, Object> kafkaTemplate;

    @Resource
    private SchedulingConflictResolver conflictResolver;

    @Resource
    private SchedulingOptimizer optimizer;

    @EventListener
    @Async("schedulingAdjustmentExecutor")
    public void handleSchedulingChangeRequest(SchedulingChangeRequest request) {

        try {
            // 1. éªŒè¯è°ƒæ•´è¯·æ±‚
            AdjustmentValidationResult validation = validateAdjustmentRequest(request);
            if (!validation.isValid()) {
                sendAdjustmentResponse(request, AdjustmentResponse.rejected(validation.getErrors()));
                return;
            }

            // 2. æ£€æµ‹å†²çª
            List<SchedulingConflict> conflicts = detectSchedulingConflicts(request);
            if (!conflicts.isEmpty()) {
                // è‡ªåŠ¨è§£å†³å†²çª
                ConflictResolutionResult resolution = conflictResolver.resolveConflicts(conflicts);
                if (!resolution.isResolved()) {
                    sendAdjustmentResponse(request, AdjustmentResponse.conflicts(resolution.getRemainingConflicts()));
                    return;
                }
            }

            // 3. æ‰§è¡Œè°ƒæ•´
            AdjustmentExecutionResult execution = executeAdjustment(request);

            // 4. å½±å“åˆ†æ
            ImpactAnalysisResult impact = analyzeAdjustmentImpact(execution);

            // 5. ç”Ÿæˆæ›¿ä»£æ–¹æ¡ˆ
            List<AlternativeSchedule> alternatives = generateAlternatives(execution);

            // 6. å‘é€é€šçŸ¥
            notificationService.sendAdjustmentNotifications(execution, impact);

            // 7. è®°å½•è°ƒæ•´
            adjustmentRecordService.recordAdjustment(request, execution, impact);

            // 8. å‘é€å“åº”
            AdjustmentResponse response = AdjustmentResponse.success(execution, impact, alternatives);
            sendAdjustmentResponse(request, response);

        } catch (Exception e) {
            log.error("å®æ—¶æ’ç­è°ƒæ•´å¤±è´¥", e);
            sendAdjustmentResponse(request, AdjustmentResponse.error(e.getMessage()));
        }
    }

    /**
     * æ£€æµ‹æ’ç­å†²çª
     */
    private List<SchedulingConflict> detectSchedulingConflicts(SchedulingChangeRequest request) {

        List<SchedulingConflict> conflicts = new ArrayList<>();

        try {
            // 1. æ—¶é—´å†²çªæ£€æµ‹
            List<ScheduleRecord> overlappingSchedules =
                scheduleRepository.findOverlappingSchedules(
                    request.getEmployeeId(),
                    request.getNewStartTime(),
                    request.getNewEndTime());

            for (ScheduleRecord schedule : overlappingSchedules) {
                conflicts.add(SchedulingConflict.builder()
                    .conflictType("TIME_OVERLAP")
                    .conflictingSchedule(schedule)
                    .severity("HIGH")
                    .description("ä¸ç°æœ‰æ’ç­æ—¶é—´é‡å ")
                    .build());
            }

            // 2. æŠ€èƒ½åŒ¹é…å†²çªæ£€æµ‹
            SkillMatchResult skillMatch = skillMatchService.evaluateMatch(
                request.getEmployeeId(),
                request.getRequiredSkills());

            if (skillMatch.getMatchScore() < skillMatch.getRequiredThreshold()) {
                conflicts.add(SchedulingConflict.builder()
                    .conflictType("SKILL_MISMATCH")
                    .severity("MEDIUM")
                    .matchScore(skillMatch.getMatchScore())
                    .requiredThreshold(skillMatch.getRequiredThreshold())
                    .description("å‘˜å·¥æŠ€èƒ½ä¸æ»¡è¶³è¦æ±‚")
                    .build());
            }

            // 3. å·¥ä½œé‡å†²çªæ£€æµ‹
            WorkloadAnalysis workload = workloadService.analyzeWorkload(
                request.getEmployeeId(),
                request.getStartDate(),
                request.getEndDate());

            if (workload.getExceedsLimit()) {
                conflicts.add(SchedulingConflict.builder()
                    .conflictType("WORKLOAD_EXCEEDED")
                    .severity("HIGH")
                    .currentHours(workload.getCurrentHours())
                    .limitHours(workload.getLimitHours())
                    .description("è¶…å‡ºå·¥ä½œé‡é™åˆ¶")
                    .build());
            }

            // 4. æ³•è§„åˆè§„æ€§æ£€æµ‹
            LegalComplianceCheck complianceCheck =
                legalComplianceService.checkCompliance(request);

            if (!complianceCheck.isCompliant()) {
                conflicts.add(SchedulingConflict.builder()
                    .conflictType("LEGAL_COMPLIANCE")
                    .severity("CRITICAL")
                    .violations(complianceCheck.getViolations())
                    .description("è¿ååŠ³åŠ¨æ³•è§„")
                    .build());
            }

        } catch (Exception e) {
            log.error("å†²çªæ£€æµ‹å¤±è´¥", e);
            throw new AdjustmentException("å†²çªæ£€æµ‹å¤±è´¥", e);
        }

        return conflicts;
    }

    /**
     * æ‰§è¡Œæ’ç­è°ƒæ•´
     */
    private AdjustmentExecutionResult executeAdjustment(SchedulingChangeRequest request) {

        try {
            // 1. å¼€å§‹äº‹åŠ¡
            TransactionStatus transactionStatus = transactionManager.getTransaction(
                new DefaultTransactionDefinition());

            try {
                // 2. æ›´æ–°æ’ç­è®°å½•
                ScheduleRecord updatedSchedule = updateScheduleRecord(request);

                // 3. æ›´æ–°å…³è”è®°å½•
                updateRelatedRecords(request, updatedSchedule);

                // 4. æäº¤äº‹åŠ¡
                transactionManager.commit(transactionStatus);

                // 5. å‘é€äº‹ä»¶
                eventPublisher.publishEvent(new ScheduleAdjustedEvent(updatedSchedule));

                return AdjustmentExecutionResult.builder()
                    .success(true)
                    .updatedSchedule(updatedSchedule)
                    .adjustmentTime(Instant.now())
                    .build();

            } catch (Exception e) {
                transactionManager.rollback(transactionStatus);
                throw e;
            }

        } catch (Exception e) {
            log.error("æ‰§è¡Œæ’ç­è°ƒæ•´å¤±è´¥", e);
            throw new AdjustmentException("æ’ç­è°ƒæ•´æ‰§è¡Œå¤±è´¥", e);
        }
    }

    /**
     * åˆ†æè°ƒæ•´å½±å“
     */
    private ImpactAnalysisResult analyzeAdjustmentImpact(AdjustmentExecutionResult execution) {

        try {
            // 1. æˆæœ¬å½±å“åˆ†æ
            CostImpact costImpact = costAnalysisService.calculateCostImpact(execution);

            // 2. å‘˜å·¥å½±å“åˆ†æ
            EmployeeImpact employeeImpact = employeeImpactService.analyzeImpact(execution);

            // 3. å›¢é˜Ÿå½±å“åˆ†æ
            TeamImpact teamImpact = teamImpactService.analyzeImpact(execution);

            // 4. å®¢æˆ·å½±å“åˆ†æï¼ˆå¦‚é€‚ç”¨ï¼‰
            CustomerImpact customerImpact = customerImpactService.analyzeImpact(execution);

            // 5. è¿è¥å½±å“åˆ†æ
            OperationalImpact operationalImpact = operationalImpactService.analyzeImpact(execution);

            // 6. ç»¼åˆè¯„åˆ†
            double overallImpactScore = calculateOverallImpactScore(
                costImpact, employeeImpact, teamImpact, operationalImpact);

            return ImpactAnalysisResult.builder()
                .costImpact(costImpact)
                .employeeImpact(employeeImpact)
                .teamImpact(teamImpact)
                .customerImpact(customerImpact)
                .operationalImpact(operationalImpact)
                .overallImpactScore(overallImpactScore)
                .recommendations(generateImpactRecommendations(execution))
                .build();

        } catch (Exception e) {
            log.error("å½±å“åˆ†æå¤±è´¥", e);
            throw new AdjustmentException("å½±å“åˆ†æå¤±è´¥", e);
        }
    }
}
```

## ğŸ“± ç§»åŠ¨ç«¯æ’ç­åŠŸèƒ½

### 1. æ’ç­æ—¥å†ç»„ä»¶
```vue
<template>
  <div class="scheduling-calendar-container">
    <!-- æ—¥å†å¤´éƒ¨ -->
    <van-nav-bar
      :title="calendarTitle"
      left-arrow
      @click-left="onPrevMonth"
      @click-right="onNextMonth">
      <template #right>
        <van-icon name="plus" @click="showAddSchedule" />
      </template>
    </van-nav-bar>

    <!-- æ’ç­æ—¥å† -->
    <van-calendar
      v-model="currentDate"
      :show-confirm="false"
      :min-date="minDate"
      :max-date="maxDate"
      :default-date="defaultDate"
      @select="onDateSelect">

      <template #day-content="{ date }">
        <div class="schedule-day">
          <div class="day-number">{{ date.getDate() }}</div>
          <div class="schedule-indicators">
            <div
              v-for="schedule in getSchedulesByDate(date)"
              :key="schedule.scheduleId"
              class="schedule-indicator"
              :class="getScheduleIndicatorClass(schedule)">
              {{ formatScheduleTime(schedule) }}
            </div>
          </div>
        </div>
      </template>
    </van-calendar>

    <!-- æ’ç­è¯¦æƒ…å¼¹çª— -->
    <van-popup v-model:show="showScheduleDetail" position="bottom" :style="{ height: '80%' }">
      <div class="schedule-detail">
        <div class="detail-header">
          <h3>{{ selectedDate }} æ’ç­è¯¦æƒ…</h3>
          <van-icon name="cross" @click="showScheduleDetail = false" />
        </div>

        <div class="detail-content">
          <ScheduleCard
            v-for="schedule in selectedDateSchedules"
            :key="schedule.scheduleId"
            :schedule="schedule"
            @edit="editSchedule"
            @swap="showSwapOptions"
          />
        </div>

        <div class="detail-actions">
          <van-button type="primary" block @click="addNewSchedule">
            æ·»åŠ æ’ç­
          </van-button>
        </div>
      </div>
    </van-popup>

    <!-- å¿«é€Ÿæ“ä½œ -->
    <van-floating-bubble
      v-if="showQuickActions"
      axis="xy"
      icon="setting-o"
      @click="showQuickActionMenu"
    />

    <!-- äº¤æ¢æ’ç­å¼¹çª— -->
    <van-popup v-model:show="showSwapPanel" position="bottom">
      <div class="swap-panel">
        <h3>äº¤æ¢æ’ç­</h3>
        <EmployeeSelector
          :exclude-ids="[currentEmployeeId]"
          :skill-requirements="swapSkillRequirements"
          @select="confirmSwap"
        />
      </div>
    </van-popup>
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue'
import { showToast, showConfirmDialog } from 'vant'
import { useCalendarStore } from '@/stores/calendar'

// å“åº”å¼æ•°æ®
const currentDate = ref(new Date())
const selectedDate = ref('')
const showScheduleDetail = ref(false)
const showSwapPanel = ref(false)
const selectedDateSchedules = ref([])
const swapSkillRequirements = ref([])

const calendarStore = useCalendarStore()

// è®¡ç®—å±æ€§
const calendarTitle = computed(() => {
  return currentDate.value.toLocaleDateString('zh-CN', {
    year: 'numeric',
    month: 'long'
  })
})

// ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  loadScheduleData()
})

// åŠ è½½æ’ç­æ•°æ®
const loadScheduleData = async () => {
  try {
    await calendarStore.loadMonthlySchedules(currentDate.value)
  } catch (error) {
    showToast('åŠ è½½æ’ç­æ•°æ®å¤±è´¥')
  }
}

// è·å–æŒ‡å®šæ—¥æœŸçš„æ’ç­
const getSchedulesByDate = (date) => {
  return calendarStore.getSchedulesByDate(date)
}

// è·å–æ’ç­æŒ‡ç¤ºå™¨æ ·å¼
const getScheduleIndicatorClass = (schedule) => {
  const baseClass = 'indicator'
  const statusClass = `indicator-${schedule.scheduleStatus.toLowerCase()}`
  const typeClass = `indicator-${schedule.shiftType.toLowerCase()}`

  return [baseClass, statusClass, typeClass]
}

// æ ¼å¼åŒ–æ’ç­æ—¶é—´
const formatScheduleTime = (schedule) => {
  const start = new Date(schedule.startTime).toLocaleTimeString('zh-CN', {
    hour: '2-digit',
    minute: '2-digit'
  })
  return start
}

// æ—¥æœŸé€‰æ‹©äº‹ä»¶
const onDateSelect = (date) => {
  selectedDate.value = formatDate(date)
  selectedDateSchedules.value = getSchedulesByDate(date)
  showScheduleDetail.value = true
}

// æ˜¾ç¤ºäº¤æ¢é€‰é¡¹
const showSwapOptions = (schedule) => {
  swapSkillRequirements.value = schedule.requiredSkills
  currentSchedule.value = schedule
  showSwapPanel.value = true
}

// ç¡®è®¤äº¤æ¢
const confirmSwap = async (targetEmployee) => {
  try {
    const result = await scheduleApi.swapSchedule({
      sourceScheduleId: currentSchedule.value.scheduleId,
      targetEmployeeId: targetEmployee.employeeId
    })

    showToast('äº¤æ¢è¯·æ±‚å·²å‘é€')
    showSwapPanel.value = false

    // é‡æ–°åŠ è½½æ•°æ®
    await loadScheduleData()

  } catch (error) {
    showToast('äº¤æ¢å¤±è´¥')
  }
}

// æ·»åŠ æ–°æ’ç­
const addNewSchedule = () => {
  uni.navigateTo({
    url: '/pages/scheduling/add-schedule'
  })
}

// ç¼–è¾‘æ’ç­
const editSchedule = (schedule) => {
  uni.navigateTo({
    url: `/pages/scheduling/edit-schedule?id=${schedule.scheduleId}`
  })
}
</script>

<style lang="scss" scoped>
.scheduling-calendar-container {
  height: 100vh;
  background: #f7f8fa;
}

.schedule-day {
  display: flex;
  flex-direction: column;
  align-items: center;
  height: 60px;

  .day-number {
    font-weight: 500;
    margin-bottom: 2px;
  }

  .schedule-indicators {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;

    .schedule-indicator {
      font-size: 10px;
      padding: 1px 4px;
      border-radius: 2px;
      color: white;

      &.indicator-scheduled {
        background: #1989fa;
      }

      &.indicator-overtime {
        background: #ff976a;
      }

      &.indicator-leave {
        background: #07c160;
      }

      &.indicator-absent {
        background: #ee0a24;
      }
    }
  }
}

.schedule-detail {
  height: 100%;
  display: flex;
  flex-direction: column;

  .detail-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px;
    border-bottom: 1px solid #ebedf0;

    h3 {
      margin: 0;
      font-size: 18px;
    }
  }

  .detail-content {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
  }

  .detail-actions {
    padding: 16px;
    border-top: 1px solid #ebedf0;
  }
}

.swap-panel {
  padding: 20px;

  h3 {
    margin-bottom: 20px;
    text-align: center;
  }
}
</style>
```

## ğŸ“Š ç»Ÿè®¡åˆ†æåŠŸèƒ½

### 1. æ’ç­æ•ˆç‡åˆ†æ
```java
@Service
@Slf4j
public class SchedulingAnalyticsService {

    @Resource
    private ScheduleRecordRepository scheduleRepository;

    @Resource
    private OptimizationMetricsService metricsService;

    /**
     * ç”Ÿæˆæ’ç­æ•ˆç‡æŠ¥å‘Š
     */
    public SchedulingEfficiencyReport generateEfficiencyReport(
            LocalDate startDate,
            LocalDate endDate,
            Long departmentId) {

        // 1. è·å–æ’ç­æ•°æ®
        List<ScheduleRecord> schedules = scheduleRepository
            .findByDateRangeAndDepartment(startDate, endDate, departmentId);

        // 2. è®¡ç®—æ•ˆç‡æŒ‡æ ‡
        SchedulingEfficiencyMetrics metrics = calculateEfficiencyMetrics(schedules);

        // 3. åˆ†ææ’ç­æ¨¡å¼
        SchedulingPatternAnalysis patternAnalysis = analyzeSchedulingPatterns(schedules);

        // 4. æˆæœ¬æ•ˆç›Šåˆ†æ
        CostBenefitAnalysis costAnalysis = analyzeCostEffectiveness(schedules);

        // 5. å‘˜å·¥æ»¡æ„åº¦åˆ†æ
        EmployeeSatisfactionAnalysis satisfactionAnalysis = analyzeEmployeeSatisfaction(schedules);

        // 6. ç”Ÿæˆä¼˜åŒ–å»ºè®®
        List<OptimizationRecommendation> recommendations = generateOptimizationRecommendations(
            metrics, patternAnalysis, costAnalysis);

        return SchedulingEfficiencyReport.builder()
            .reportPeriod(DateRange.of(startDate, endDate))
            .departmentId(departmentId)
            .metrics(metrics)
            .patternAnalysis(patternAnalysis)
            .costAnalysis(costAnalysis)
            .satisfactionAnalysis(satisfactionAnalysis)
            .recommendations(recommendations)
            .build();
    }

    /**
     * è®¡ç®—æ’ç­æ•ˆç‡æŒ‡æ ‡
     */
    private SchedulingEfficiencyMetrics calculateEfficiencyMetrics(List<ScheduleRecord> schedules) {

        // 1. æ’ç­è¦†ç›–ç‡
        double coverageRate = calculateCoverageRate(schedules);

        // 2. æŠ€èƒ½åŒ¹é…åº¦
        double skillMatchRate = calculateSkillMatchRate(schedules);

        // 3. å·¥ä½œé‡å‡è¡¡åº¦
        double workloadBalance = calculateWorkloadBalance(schedules);

        // 4. æˆæœ¬æ•ˆç‡
        double costEfficiency = calculateCostEfficiency(schedules);

        // 5. æ’ç­å˜æ›´ç‡
        double changeRate = calculateChangeRate(schedules);

        // 6. è‡ªåŠ¨åŒ–æ’ç­ç‡
        double automationRate = calculateAutomationRate(schedules);

        return SchedulingEfficiencyMetrics.builder()
            .coverageRate(coverageRate)
            .skillMatchRate(skillMatchRate)
            .workloadBalance(workloadBalance)
            .costEfficiency(costEfficiency)
            .changeRate(changeRate)
            .automationRate(automationRate)
            .overallEfficiencyScore(calculateOverallEfficiency(
                coverageRate, skillMatchRate, workloadBalance, costEfficiency))
            .build();
    }

    /**
     * è®¡ç®—æ’ç­è¦†ç›–ç‡
     */
    private double calculateCoverageRate(List<ScheduleRecord> schedules) {

        // æŒ‰æ—¥æœŸåˆ†ç»„
        Map<LocalDate, List<ScheduleRecord>> schedulesByDate = schedules.stream()
            .collect(Collectors.groupingBy(ScheduleRecord::getScheduleDate));

        int totalRequiredShifts = 0;
        int actualCoveredShifts = 0;

        for (Map.Entry<LocalDate, List<ScheduleRecord>> entry : schedulesByDate.entrySet()) {
            LocalDate date = entry.getKey();
            List<ScheduleRecord> dateSchedules = entry.getValue();

            // è·å–è¯¥æ—¥æœŸçš„å¿…éœ€ç­æ¬¡
            int requiredShifts = getRequiredShiftsForDate(date);
            totalRequiredShifts += requiredShifts;

            // ç»Ÿè®¡å·²è¦†ç›–çš„ç­æ¬¡
            int coveredShifts = countCoveredShifts(dateSchedules);
            actualCoveredShifts += coveredShifts;
        }

        return totalRequiredShifts > 0 ? (double) actualCoveredShifts / totalRequiredShifts : 0.0;
    }

    /**
     * åˆ†ææ’ç­æ¨¡å¼
     */
    private SchedulingPatternAnalysis analyzeSchedulingPatterns(List<ScheduleRecord> schedules) {

        // 1. å‘¨æœŸæ€§åˆ†æ
        Map<Integer, Map<LocalDate, Integer>> dayOfWeekPatterns = analyzeDayOfWeekPatterns(schedules);

        // 2. å­£èŠ‚æ€§åˆ†æ
        Map<Month, Double> monthlyPatterns = analyzeMonthlyPatterns(schedules);

        // 3. æŠ€èƒ½åˆ†å¸ƒåˆ†æ
        Map<String, Double> skillDistribution = analyzeSkillDistribution(schedules);

        // 4. è´Ÿè½½åˆ†å¸ƒåˆ†æ
        Map<LocalTime, Double> hourlyLoadDistribution = analyzeHourlyLoadDistribution(schedules);

        // 5. å¼‚å¸¸æ¨¡å¼è¯†åˆ«
        List<SchedulingAnomaly> anomalies = detectSchedulingAnomalies(schedules);

        return SchedulingPatternAnalysis.builder()
            .dayOfWeekPatterns(dayOfWeekPatterns)
            .monthlyPatterns(monthlyPatterns)
            .skillDistribution(skillDistribution)
            .hourlyLoadDistribution(hourlyLoadDistribution)
            .anomalies(anomalies)
            .patternStability(calculatePatternStability(schedules))
            .predictabilityScore(calculatePredictabilityScore(schedules))
            .build();
    }

    /**
     * æ£€æµ‹æ’ç­å¼‚å¸¸
     */
    private List<SchedulingAnomaly> detectSchedulingAnomalies(List<ScheduleRecord> schedules) {

        List<SchedulingAnomaly> anomalies = new ArrayList<>();

        // 1. ä½¿ç”¨ç»Ÿè®¡æ–¹æ³•æ£€æµ‹å¼‚å¸¸
        List<ScheduleRecord> statisticalAnomalies = detectStatisticalAnomalies(schedules);
        anomalies.addAll(statisticalAnomalies);

        // 2. ä½¿ç”¨æœºå™¨å­¦ä¹ æ£€æµ‹å¼‚å¸¸
        List<ScheduleRecord> mlAnomalies = detectMLAnomalies(schedules);
        anomalies.addAll(mlAnomalies);

        // 3. æ£€æµ‹ä¸šåŠ¡è§„åˆ™å¼‚å¸¸
        List<ScheduleRecord> businessRuleAnomalies = detectBusinessRuleAnomalies(schedules);
        anomalies.addAll(businessRuleAnomalies);

        return anomalies.stream()
            .sorted(Comparator.comparing(SchedulingAnomaly::getSeverity).reversed())
            .collect(Collectors.toList());
    }
}
```

## ğŸ”’ å®‰å…¨ä¸åˆè§„

### 1. æ’ç­åˆè§„æ€§æ£€æŸ¥
```java
@Component
@Slf4j
public class SchedulingComplianceService {

    @Resource
    private LaborLawConfigService laborLawConfig;

    @Resource
    private ComplianceRuleEngine ruleEngine;

    /**
     * æ£€æŸ¥æ’ç­åˆè§„æ€§
     */
    public ComplianceCheckResult checkCompliance(ScheduleRecord schedule) {

        try {
            List<ComplianceViolation> violations = new ArrayList<>();

            // 1. æ£€æŸ¥å·¥ä½œæ—¶é—´åˆè§„æ€§
            List<WorkingHoursViolation> workingHoursViolations =
                checkWorkingHoursCompliance(schedule);
            violations.addAll(workingHoursViolations);

            // 2. æ£€æŸ¥ä¼‘æ¯æ—¶é—´åˆè§„æ€§
            List<RestTimeViolation> restTimeViolations =
                checkRestTimeCompliance(schedule);
            violations.addAll(restTimeViolations);

            // 3. æ£€æŸ¥åŠ ç­åˆè§„æ€§
            List<OvertimeViolation> overtimeViolations =
                checkOvertimeCompliance(schedule);
            violations.addAll(overtimeViolations);

            // 4. æ£€æŸ¥ç‰¹æ®Šäººç¾¤ä¿æŠ¤
            List<SpecialGroupViolation> specialGroupViolations =
                checkSpecialGroupProtection(schedule);
            violations.addAll(specialGroupViolations);

            // 5. åº”ç”¨è‡ªå®šä¹‰åˆè§„è§„åˆ™
            List<CustomRuleViolation> customViolations =
                ruleEngine.applyCustomComplianceRules(schedule);
            violations.addAll(customViolations);

            // 6. è®¡ç®—åˆè§„æ€§è¯„åˆ†
            double complianceScore = calculateComplianceScore(violations);

            return ComplianceCheckResult.builder()
                .compliant(violations.isEmpty())
                .violations(violations)
                .complianceScore(complianceScore)
                .riskLevel(assessRiskLevel(violations))
                .recommendations(generateComplianceRecommendations(violations))
                .build();

        } catch (Exception e) {
            log.error("åˆè§„æ€§æ£€æŸ¥å¤±è´¥", e);
            throw new ComplianceException("åˆè§„æ€§æ£€æŸ¥å¤±è´¥", e);
        }
    }

    /**
     * æ£€æŸ¥å·¥ä½œæ—¶é—´åˆè§„æ€§
     */
    private List<WorkingHoursViolation> checkWorkingHoursCompliance(ScheduleRecord schedule) {

        List<WorkingHoursViolation> violations = new ArrayList<>();

        try {
            // è·å– applicable æ³•è§„é…ç½®
            LaborLawConfig config = laborLawConfig.getApplicableConfig(schedule);

            // æ£€æŸ¥æ¯æ—¥å·¥ä½œæ—¶é—´
            if (schedule.getDurationMinutes() > config.getMaxDailyWorkingMinutes()) {
                violations.add(WorkingHoursViolation.builder()
                    .violationType("DAILY_WORKING_HOURS_EXCEEDED")
                    .actualMinutes(schedule.getDurationMinutes())
                    .limitMinutes(config.getMaxDailyWorkingMinutes())
                    .exceededMinutes(schedule.getDurationMinutes() - config.getMaxDailyWorkingMinutes())
                    .severity("HIGH")
                    .legalReference(config.getLegalReference())
                    .build());
            }

            // æ£€æŸ¥æ¯å‘¨å·¥ä½œæ—¶é—´
            int weeklyWorkingMinutes = calculateWeeklyWorkingMinutes(schedule.getEmployeeId(),
                schedule.getScheduleDate());
            if (weeklyWorkingMinutes > config.getMaxWeeklyWorkingMinutes()) {
                violations.add(WorkingHoursViolation.builder()
                    .violationType("WEEKLY_WORKING_HOURS_EXCEEDED")
                    .actualMinutes(weeklyWorkingMinutes)
                    .limitMinutes(config.getMaxWeeklyWorkingMinutes())
                    .exceededMinutes(weeklyWorkingMinutes - config.getMaxWeeklyWorkingMinutes())
                    .severity("CRITICAL")
                    .legalReference(config.getLegalReference())
                    .build());
            }

            // æ£€æŸ¥è¿ç»­å·¥ä½œå¤©æ•°
            int consecutiveDays = calculateConsecutiveWorkingDays(schedule.getEmployeeId(),
                schedule.getScheduleDate());
            if (consecutiveDays > config.getMaxConsecutiveWorkingDays()) {
                violations.add(WorkingHoursViolation.builder()
                    .violationType("CONSECUTIVE_WORKING_DAYS_EXCEEDED")
                    .actualDays(consecutiveDays)
                    .limitDays(config.getMaxConsecutiveWorkingDays())
                    .exceededDays(consecutiveDays - config.getMaxConsecutiveWorkingDays())
                    .severity("MEDIUM")
                    .legalReference(config.getLegalReference())
                    .build());
            }

        } catch (Exception e) {
            log.error("å·¥ä½œæ—¶é—´åˆè§„æ£€æŸ¥å¤±è´¥", e);
        }

        return violations;
    }
}
```

## ğŸ“Š æ•°æ®åº“ERå›¾

```mermaid
erDiagram
    t_schedule_record {
        bigint schedule_id PK
        varchar schedule_number UK
        bigint employee_id FK
        date schedule_date
        bigint shift_id FK
        timestamp start_time
        timestamp end_time
        varchar schedule_type
        decimal optimization_score
        varchar schedule_status
        timestamp create_time
    }

    t_schedule_template {
        bigint template_id PK
        varchar template_code UK
        varchar template_name
        varchar template_type
        jsonb schedule_patterns
        jsonb optimization_objectives
        boolean is_active
        decimal success_rate
    }

    t_scheduling_optimization_task {
        bigint task_id PK
        varchar task_number UK
        varchar optimization_type
        date start_date
        date end_date
        varchar task_status
        decimal best_score
        integer execution_time_seconds
        timestamp create_time
    }

    t_schedule_adjustment {
        bigint adjustment_id PK
        bigint schedule_id FK
        varchar adjustment_type
        timestamp new_start_time
        timestamp new_end_time
        decimal cost_impact
        varchar approval_status
        timestamp create_time
    }

    t_skill_match_config {
        bigint config_id PK
        bigint skill_id FK
        varchar skill_name
        varchar match_algorithm
        decimal match_threshold
        decimal success_rate
        boolean is_active
    }

    %% å…³è”å…³ç³»
    t_schedule_template ||--o{ t_schedule_record : "template_id"
    t_schedule_record ||--o{ t_schedule_adjustment : "schedule_id"
    t_scheduling_optimization_task ||--o{ t_schedule_record : "task_id"
    t_skill_match_config ||--o{ t_schedule_record : "skill_id"
    employees ||--o{ t_schedule_record : "employee_id"
    employees ||--o{ t_schedule_adjustment : "create_user_id"
    shifts ||--o{ t_schedule_record : "shift_id"
```

## æ€»ç»“

æ™ºèƒ½æ’ç­ç®¡ç†ç³»ç»Ÿä½œä¸ºIOE-DREAMæ™ºæ…§å›­åŒºä¸€å¡é€šç®¡ç†å¹³å°çš„æ ¸å¿ƒæ¨¡å—ï¼Œå…·å¤‡ä»¥ä¸‹ç‰¹ç‚¹ï¼š

### æ ¸å¿ƒèƒ½åŠ›
1. **AIä¼˜åŒ–æ’ç­**: åŸºäºOptaPlanner 9.44çš„æ™ºèƒ½æ’ç­ä¼˜åŒ–ç®—æ³•
2. **å¤šç›®æ ‡ä¼˜åŒ–**: åŒæ—¶è€ƒè™‘æˆæœ¬ã€æ•ˆç‡ã€å…¬å¹³æ€§ç­‰å¤šä¸ªç›®æ ‡
3. **å®æ—¶æ’ç­è°ƒæ•´**: æ”¯æŒå®æ—¶åŠ¨æ€è°ƒæ•´å’Œå†²çªè‡ªåŠ¨è§£å†³
4. **æ™ºèƒ½é¢„æµ‹**: åŸºäºå†å²æ•°æ®çš„æ’ç­éœ€æ±‚é¢„æµ‹å’Œè¶‹åŠ¿åˆ†æ
5. **ç§»åŠ¨ç«¯æ’ç­**: å…¨åŠŸèƒ½ç§»åŠ¨ç«¯æ’ç­ç®¡ç†å’Œå‘˜å·¥è‡ªåŠ©æœåŠ¡

### æŠ€æœ¯ä¼˜åŠ¿
1. **ä¼˜åŒ–å¼•æ“**: OptaPlanner 9.44çº¦æŸæ»¡è¶³æ±‚è§£å™¨ï¼Œæ”¯æŒå¤æ‚ä¼˜åŒ–é—®é¢˜
2. **æœºå™¨å­¦ä¹ **: Apache Spark MLlibå’ŒTensorFlow Liteé¢„æµ‹åˆ†æ
3. **å®æ—¶è®¡ç®—**: Kafkaå®æ—¶äº‹ä»¶å¤„ç†ï¼Œæ”¯æŒåŠ¨æ€è°ƒæ•´
4. **å¯è§†åŒ–**: ä¸°å¯Œçš„å›¾è¡¨å’Œæ—¥å†è§†å›¾ï¼Œç›´è§‚å±•ç¤ºæ’ç­ä¿¡æ¯
5. **åˆè§„æ€§**: å†…ç½®åŠ³åŠ¨æ³•è§„æ£€æŸ¥ï¼Œç¡®ä¿æ’ç­åˆè§„

### ä¸šåŠ¡ä»·å€¼
1. **æå‡æ•ˆç‡**: è‡ªåŠ¨åŒ–æ’ç­ï¼Œå‡å°‘äººå·¥å·¥ä½œé‡80%+
2. **é™ä½æˆæœ¬**: ä¼˜åŒ–äººå‘˜é…ç½®ï¼Œé™ä½äººåŠ›æˆæœ¬15-25%
3. **æå‡æ»¡æ„åº¦**: å…¬å¹³æ’ç­ç®—æ³•ï¼Œå‘˜å·¥æ»¡æ„åº¦æå‡30%+
4. **åˆè§„ä¿éšœ**: è‡ªåŠ¨åˆè§„æ£€æŸ¥ï¼Œè§„é¿æ³•å¾‹é£é™©
5. **æ•°æ®é©±åŠ¨**: åŸºäºæ•°æ®çš„æ’ç­å†³ç­–ï¼Œæå‡ç®¡ç†æ°´å¹³

è¯¥ç³»ç»Ÿä¸ºæ™ºæ…§å›­åŒºæä¾›äº†å®Œæ•´çš„æ™ºèƒ½åŒ–æ’ç­è§£å†³æ–¹æ¡ˆï¼Œæ˜¯ä¼ ç»Ÿæ’ç­ç®¡ç†ç³»ç»Ÿçš„é©å‘½æ€§å‡çº§äº§å“ã€‚

---

**ğŸ¯ IOE-DREAMæ™ºèƒ½æ’ç­ç®¡ç†ç³»ç»Ÿ - é«˜æ•ˆã€æ™ºèƒ½ã€åˆè§„çš„æ–°ä¸€ä»£æ’ç­ç®¡ç†å¹³å°**