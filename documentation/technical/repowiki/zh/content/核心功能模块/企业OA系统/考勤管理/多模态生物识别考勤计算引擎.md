# å¤šæ¨¡æ€ç”Ÿç‰©è¯†åˆ«è€ƒå‹¤è®¡ç®—å¼•æ“

> **ç‰ˆæœ¬**: v3.5.4
> **æ›´æ–°æ—¶é—´**: 2025-11-13
> **åˆ†ç±»**: æ ¸å¿ƒåŠŸèƒ½æ¨¡å— > ä¼ä¸šOAç³»ç»Ÿ > è€ƒå‹¤ç®¡ç†
> **æ ‡ç­¾**: ["è€ƒå‹¤å¼•æ“", "å¤šæ¨¡æ€ç”Ÿç‰©è¯†åˆ«", "å®æ—¶è®¡ç®—", "å¼‚å¸¸æ£€æµ‹", "å›½å¯†ç®—æ³•"]
> **ä½œè€…**: SmartAdminè§„èŒƒæ²»ç†å§”å‘˜ä¼š
> **æŠ€æœ¯æ ˆ**: Spring Boot 3.5.4 + Java 17 + PostgreSQL 14+ + Redis 7.0
> **æè¿°**: IOE-DREAMæ™ºæ…§å›­åŒºä¸€å¡é€šç®¡ç†å¹³å°çš„é«˜æ€§èƒ½å¤šæ¨¡æ€ç”Ÿç‰©è¯†åˆ«è€ƒå‹¤è®¡ç®—å¼•æ“

## ğŸ“‹ ç³»ç»Ÿæ¦‚è¿°

### æ ¸å¿ƒåŠŸèƒ½

**å¤šæ¨¡æ€ç”Ÿç‰©è¯†åˆ«è€ƒå‹¤è®¡ç®—å¼•æ“**æ˜¯IOE-DREAMæ™ºæ…§å›­åŒºä¸€å¡é€šç®¡ç†å¹³å°çš„æ ¸å¿ƒæ•°æ®å¤„ç†æ¨¡å—ï¼Œè´Ÿè´£å¤šæ¨¡æ€ç”Ÿç‰©è¯†åˆ«æ‰“å¡æ•°æ®çš„å®æ—¶é‡‡é›†ã€æ™ºèƒ½éªŒè¯ã€ç²¾ç¡®è®¡ç®—å’Œå¼‚å¸¸æ£€æµ‹ã€‚åŸºäºSpring Boot 3.5.4 + Java 17æ¶æ„ï¼Œæ”¯æŒç™¾ä¸‡çº§å‘˜å·¥çš„é«˜å¹¶å‘æ‰“å¡å¤„ç†ï¼Œæä¾›æ¯«ç§’çº§å“åº”çš„å®æ—¶è®¡ç®—å¼•æ“ã€‚

### ä¸»è¦ç‰¹æ€§

- âœ… **å¤šæ¨¡æ€ç”Ÿç‰©è¯†åˆ«**ï¼šæ”¯æŒäººè„¸ã€æŒ‡çº¹ã€æŒçº¹ã€è™¹è†œã€å£°çº¹èåˆéªŒè¯
- âœ… **å®æ—¶è®¡ç®—å¼•æ“**ï¼šæ¯«ç§’çº§å“åº”çš„è€ƒå‹¤è®¡ç®—èƒ½åŠ›
- âœ… **æ™ºèƒ½å¼‚å¸¸æ£€æµ‹**ï¼šåŸºäºæœºå™¨å­¦ä¹ å’Œè¡Œä¸ºæ¨¡å¼çš„å¼‚å¸¸è¯†åˆ«
- âœ… **é«˜å¹¶å‘å¤„ç†**ï¼šæ”¯æŒç™¾ä¸‡çº§å‘˜å·¥åŒæ—¶æ‰“å¡
- âœ… **å›½å¯†å®‰å…¨ä¿æŠ¤**ï¼šSM2/SM3/SM4å…¨é“¾è·¯æ•°æ®åŠ å¯†
- âœ… **åˆ†å¸ƒå¼æ¶æ„**ï¼šå¾®æœåŠ¡æ¶æ„æ”¯æŒæ°´å¹³æ‰©å±•
- âœ… **AIç®—æ³•é›†æˆ**ï¼šTensorFlow Liteæœ¬åœ°åŒ–æ¨ç†
- âœ… **è‡ªåŠ¨è¿ç»´ç›‘æ§**ï¼šå®Œå–„çš„ç›‘æ§ã€å‘Šè­¦ã€è‡ªæ„ˆæœºåˆ¶

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„

### æ ¸å¿ƒæŠ€æœ¯æ ˆ
- **åç«¯æ¡†æ¶**: Spring Boot 3.5.4 + Java 17
- **æ•°æ®åº“**: PostgreSQL 14+ (ä¸»åº“) + Redis 7.0 (ç¼“å­˜)
- **æ¶ˆæ¯é˜Ÿåˆ—**: Apache Kafka 3.5 (å®æ—¶äº‹ä»¶æµ)
- **æœç´¢å¼•æ“**: Elasticsearch 8.10 (æ—¥å¿—æ£€ç´¢)
- **æœºå™¨å­¦ä¹ **: TensorFlow Lite (ç”Ÿç‰©è¯†åˆ«ç®—æ³•)
- **åˆ†å¸ƒå¼è®¡ç®—**: Apache Flink (å®æ—¶æµå¤„ç†)
- **å›½å¯†ç®—æ³•**: SM2/SM3/SM4 (æ•°æ®åŠ å¯†)

### å¾®æœåŠ¡æ¶æ„è®¾è®¡
```java
@RestController
@RequestMapping("/api/v1/attendance")
@Tag(name = "è€ƒå‹¤è®¡ç®—å¼•æ“", description = "åŸå§‹è®°å½•ä¸è€ƒå‹¤è®¡ç®—ç›¸å…³æ¥å£")
@SecurityRequirement(name = "bearerAuth")
public class AttendanceCalculationController {

    @Resource
    private AttendanceCalculationService calculationService;

    @Resource
    private BiometricVerificationService biometricService;

    @Resource
    private RealTimeCalculationEngine realTimeEngine;
}
```

## ğŸ—„ï¸ æ•°æ®åº“è®¾è®¡

### 1. æ‰“å¡è®°å½•ä¸»è¡¨ (t_attendance_clock_record)
```sql
CREATE TABLE t_attendance_clock_record (
    record_id BIGSERIAL PRIMARY KEY,
    employee_id BIGINT NOT NULL,
    device_id BIGINT NOT NULL,
    clock_time TIMESTAMP(6) NOT NULL,
    clock_type VARCHAR(20) NOT NULL CHECK (clock_type IN ('IN', 'OUT', 'FIELD_OUT', 'FIELD_BACK')),
    clock_location VARCHAR(200),
    longitude DECIMAL(10, 7),
    latitude DECIMAL(10, 7),
    accuracy_radius INTEGER,

    -- ç”Ÿç‰©è¯†åˆ«ç›¸å…³å­—æ®µ
    biometric_type VARCHAR(20) NOT NULL,
    biometric_data JSONB,
    confidence_score DECIMAL(5, 4),
    livenessæ£€æµ‹ç»“æœ BOOLEAN DEFAULT TRUE,
    anti_spoofing_score DECIMAL(5, 4),

    -- å¤šæ¨¡æ€èåˆéªŒè¯
    verification_method VARCHAR(50),
    multi_factor_score DECIMAL(5, 4),

    -- å®‰å…¨å®¡è®¡å­—æ®µ
    client_ip INET,
    user_agent TEXT,
    device_fingerprint VARCHAR(100),
    security_level SMALLINT DEFAULT 1,

    -- çŠ¶æ€å­—æ®µ
    verification_status VARCHAR(20) DEFAULT 'PENDING',
    process_status VARCHAR(20) DEFAULT 'PENDING',
    exception_reason TEXT,

    -- å›½å¯†åŠ å¯†å­—æ®µ
    encrypted_data TEXT,
    digital_signature TEXT,

    -- å®¡è®¡å­—æ®µ
    create_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,
    create_user_id BIGINT,
    update_user_id BIGINT,
    deleted_flag SMALLINT DEFAULT 0,

    -- åˆ†åŒºå­—æ®µ
    partition_date DATE GENERATED ALWAYS AS (clock_time::DATE) STORED
) PARTITION BY RANGE (partition_date);

-- åˆ›å»ºåˆ†åŒºè¡¨ï¼ˆæŒ‰æœˆåˆ†åŒºï¼‰
CREATE TABLE t_attendance_clock_record_202401 PARTITION OF t_attendance_clock_record
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
```

### 2. è€ƒå‹¤è®¡ç®—ç»“æœè¡¨ (t_attendance_result)
```sql
CREATE TABLE t_attendance_result (
    result_id BIGSERIAL PRIMARY KEY,
    employee_id BIGINT NOT NULL,
    attendance_date DATE NOT NULL,
    shift_id BIGINT,

    -- æ—¶é—´ä¿¡æ¯
    scheduled_start_time TIMESTAMP(6),
    scheduled_end_time TIMESTAMP(6),
    actual_start_time TIMESTAMP(6),
    actual_end_time TIMESTAMP(6),
    first_clock_time TIMESTAMP(6),
    last_clock_time TIMESTAMP(6),

    -- æ—¶é•¿è®¡ç®—ï¼ˆç²¾ç¡®åˆ°ç§’ï¼‰
    scheduled_work_seconds INTEGER,
    actual_work_seconds INTEGER,
    overtime_seconds INTEGER DEFAULT 0,
    weekend_overtime_seconds INTEGER DEFAULT 0,
    holiday_overtime_seconds INTEGER DEFAULT 0,
    break_seconds INTEGER DEFAULT 0,

    -- å¼‚å¸¸ç»Ÿè®¡
    late_seconds INTEGER DEFAULT 0,
    early_leave_seconds INTEGER DEFAULT 0,
    absent_seconds INTEGER DEFAULT 0,

    -- å¤šç­æ¬¡æ”¯æŒ
    shift_count INTEGER DEFAULT 1,
    break_count INTEGER DEFAULT 0,
    field_work_count INTEGER DEFAULT 0,

    -- çŠ¶æ€æ ‡è¯†
    attendance_status VARCHAR(20) NOT NULL,
    exception_count INTEGER DEFAULT 0,
    need_review BOOLEAN DEFAULT FALSE,

    -- è®¡ç®—å¼•æ“ä¿¡æ¯
    calculation_version VARCHAR(20),
    calculation_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,
    calculation_source VARCHAR(20) DEFAULT 'AUTO',

    -- å®¡è®¡å­—æ®µ
    create_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,
    create_user_id BIGINT,
    update_user_id BIGINT,
    deleted_flag SMALLINT DEFAULT 0,

    -- åˆ†åŒºå­—æ®µ
    partition_month VARCHAR(7) GENERATED ALWAYS AS (TO_CHAR(attendance_date, 'YYYY-MM')) STORED
) PARTITION BY LIST (partition_month);

-- åˆ›å»ºåˆ†åŒºè¡¨
CREATE TABLE t_attendance_result_202401 PARTITION OF t_attendance_result
    FOR VALUES IN ('2024-01');
```

### 3. è€ƒå‹¤é¢„è­¦è®°å½•è¡¨ (t_attendance_warning)
```sql
CREATE TABLE t_attendance_warning (
    warning_id BIGSERIAL PRIMARY KEY,
    employee_id BIGINT NOT NULL,
    rule_id BIGINT NOT NULL,

    -- é¢„è­¦åˆ†ç±»
    warning_type VARCHAR(30) NOT NULL,
    warning_code VARCHAR(20) NOT NULL,
    warning_level VARCHAR(10) NOT NULL CHECK (warning_level IN ('CRITICAL', 'HIGH', 'MEDIUM', 'LOW')),

    -- æ—¶é—´ç»´åº¦
    warning_date DATE NOT NULL,
    warning_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,
    period_start_date DATE,
    period_end_date DATE,

    -- ç»Ÿè®¡æŒ‡æ ‡
    consecutive_days INTEGER DEFAULT 1,
    total_count INTEGER DEFAULT 1,
    violation_count INTEGER DEFAULT 1,
    percentage DECIMAL(5, 2),

    -- é¢„è­¦å†…å®¹
    warning_title VARCHAR(200) NOT NULL,
    warning_content TEXT NOT NULL,
    suggestion TEXT,

    -- å¤„ç†çŠ¶æ€
    notification_status VARCHAR(20) DEFAULT 'PENDING',
    notification_count INTEGER DEFAULT 0,
    last_notification_time TIMESTAMP(6),

    -- å¤„ç†ä¿¡æ¯
    handle_status VARCHAR(20) DEFAULT 'PENDING',
    handle_result VARCHAR(50),
    handle_comment TEXT,
    handle_time TIMESTAMP(6),
    handler_id BIGINT,

    -- è‡ªåŠ¨å¤„ç†
    auto_handle_enabled BOOLEAN DEFAULT FALSE,
    auto_handle_rule JSONB,
    auto_handle_time TIMESTAMP(6),

    -- å›½å¯†ç­¾å
    digital_signature TEXT,

    -- å®¡è®¡å­—æ®µ
    create_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,
    deleted_flag SMALLINT DEFAULT 0
) DISTRIBUTED BY (warning_id);
```

### 4. ç”Ÿç‰©è¯†åˆ«éªŒè¯è®°å½•è¡¨ (t_biometric_verification)
```sql
CREATE TABLE t_biometric_verification (
    verification_id BIGSERIAL PRIMARY KEY,
    clock_record_id BIGINT NOT NULL,
    employee_id BIGINT NOT NULL,

    -- ç”Ÿç‰©è¯†åˆ«ç±»å‹
    biometric_type VARCHAR(20) NOT NULL CHECK (biometric_type IN ('FACE', 'FINGERPRINT', 'PALM', 'IRIS', 'VOICE')),

    -- åŸå§‹æ•°æ®ï¼ˆå›½å¯†åŠ å¯†ï¼‰
    template_data BYTEA NOT NULL,
    sample_data BYTEA NOT NULL,

    -- éªŒè¯ç»“æœ
    match_score DECIMAL(5, 4) NOT NULL,
    match_threshold DECIMAL(5, 4) NOT NULL,
    verification_result BOOLEAN NOT NULL,

    -- æ´»ä½“æ£€æµ‹
    liveness_score DECIMAL(5, 4),
    liveness_threshold DECIMAL(5, 4),
    liveness_result BOOLEAN,

    -- é˜²æ”»å‡»æ£€æµ‹
    anti_spoofing_score DECIMAL(5, 4),
    anti_spoofing_result BOOLEAN,
    attack_type VARCHAR(50),

    -- è´¨é‡è¯„ä¼°
    image_quality_score DECIMAL(5, 4),
    signal_to_noise_ratio DECIMAL(5, 2),

    -- ç®—æ³•ä¿¡æ¯
    algorithm_version VARCHAR(20),
    model_version VARCHAR(20),
    processing_time_ms INTEGER,

    -- å…ƒæ•°æ®
    device_type VARCHAR(50),
    device_info JSONB,
    environmental_factors JSONB,

    -- å®¡è®¡å­—æ®µ
    create_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,

    -- å®‰å…¨å­—æ®µ
    encrypted_session_key TEXT,
    digital_signature TEXT
) DISTRIBUTED BY (verification_id);
```

## ğŸ”„ æ ¸å¿ƒä¸šåŠ¡é€»è¾‘

### 1. å¤šæ¨¡æ€ç”Ÿç‰©è¯†åˆ«æ‰“å¡å¼•æ“
```java
@Service
@Validated
public class BiometricClockInService {

    @Resource
    private BiometricVerificationEngine verificationEngine;

    @Resource
    private LivenessDetectionService livenessService;

    @Resource
    private AntiSpoofingService antiSpoofingService;

    /**
     * å¤šæ¨¡æ€ç”Ÿç‰©è¯†åˆ«æ‰“å¡
     * æ”¯æŒäººè„¸ã€æŒ‡çº¹ã€æŒçº¹ã€è™¹è†œã€å£°çº¹èåˆéªŒè¯
     */
    @Async("attendanceCalculationExecutor")
    public CompletableFuture<ClockInResult> multiModalClockIn(
            @Valid @RequestBody MultiModalClockInRequest request) {

        // 1. å®‰å…¨éªŒè¯
        securityValidationService.validateRequest(request);

        // 2. å¤šæ¨¡æ€éªŒè¯æµæ°´çº¿
        List<CompletableFuture<BiometricVerificationResult>> futures =
            request.getBiometricData().stream()
                .map(this::processBiometricVerification)
                .collect(Collectors.toList());

        // 3. ç­‰å¾…æ‰€æœ‰éªŒè¯å®Œæˆ
        List<BiometricVerificationResult> results =
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenApply(v -> futures.stream()
                    .map(CompletableFuture::join)
                    .collect(Collectors.toList()))
                .join();

        // 4. èåˆå†³ç­–
        FusionDecision fusionDecision = fusionDecisionEngine.makeDecision(results);

        // 5. åˆ›å»ºæ‰“å¡è®°å½•
        ClockRecord clockRecord = createClockRecord(request, fusionDecision);

        // 6. è§¦å‘å®æ—¶è®¡ç®—
        realTimeCalculationEngine.processClockIn(clockRecord);

        return CompletableFuture.completedFuture(
            ClockInResult.builder()
                .success(fusionDecision.isApproved())
                .clockRecordId(clockRecord.getRecordId())
                .verificationResults(results)
                .processingTimeMs(fusionDecision.getTotalProcessingTime())
                .build()
        );
    }

    /**
     * ç”Ÿç‰©è¯†åˆ«éªŒè¯å¤„ç†
     */
    private CompletableFuture<BiometricVerificationResult> processBiometricVerification(
            BiometricData biometricData) {

        return CompletableFuture.supplyAsync(() -> {

            // 1. æ•°æ®é¢„å¤„ç†
            PreprocessedData preprocessedData =
                dataPreprocessor.preprocess(biometricData);

            // 2. ç‰¹å¾æå–
            FeatureVector featureVector =
                featureExtractor.extract(preprocessedData);

            // 3. æ¨¡æ¿åŒ¹é…
            TemplateMatchResult matchResult =
                templateMatcher.match(featureVector, biometricData.getEmployeeId());

            // 4. æ´»ä½“æ£€æµ‹
            LivenessResult livenessResult =
                livenessService.detect(preprocessedData);

            // 5. é˜²æ”»å‡»æ£€æµ‹
            AntiSpoofingResult antiSpoofingResult =
                antiSpoofingService.detect(preprocessedData);

            // 6. ç»¼åˆè¯„åˆ†
            double finalScore = calculateFinalScore(
                matchResult, livenessResult, antiSpoofingResult);

            return BiometricVerificationResult.builder()
                .biometricType(biometricData.getType())
                .matchScore(matchResult.getScore())
                .livenessScore(livenessResult.getScore())
                .antiSpoofingScore(antiSpoofingResult.getScore())
                .finalScore(finalScore)
                .verificationResult(finalScore >= getThreshold(biometricData.getType()))
                .build();
        });
    }

    /**
     * è®¡ç®—æœ€ç»ˆéªŒè¯åˆ†æ•°
     */
    private double calculateFinalScore(
            TemplateMatchResult matchResult,
            LivenessResult livenessResult,
            AntiSpoofingResult antiSpoofingResult) {

        // åŠ æƒè®¡ç®—å…¬å¼ï¼šæœ€ç»ˆåˆ†æ•° = åŒ¹é…åˆ†æ•° Ã— 0.6 + æ´»ä½“åˆ†æ•° Ã— 0.3 + é˜²æ”»å‡»åˆ†æ•° Ã— 0.1
        return matchResult.getScore() * 0.6
             + livenessResult.getScore() * 0.3
             + antiSpoofingResult.getScore() * 0.1;
    }
}
```

### 2. å®æ—¶è€ƒå‹¤è®¡ç®—å¼•æ“
```java
@Service
@Slf4j
public class RealTimeCalculationEngine {

    @Resource
    private AttendanceRuleEngine ruleEngine;

    @Resource
    private ShiftManagementService shiftService;

    @Resource
    private OvertimeCalculationService overtimeService;

    @EventListener
    @Async("realTimeCalculationExecutor")
    public void processClockInEvent(ClockInEvent event) {

        try {
            // 1. è·å–å‘˜å·¥æ’ç­ä¿¡æ¯
            EmployeeShift shift = shiftService.getEmployeeShift(
                event.getEmployeeId(), event.getClockTime());

            // 2. æŸ¥æ‰¾ä»Šæ—¥è€ƒå‹¤ç»“æœ
            AttendanceResult todayResult = getOrCreateTodayResult(
                event.getEmployeeId(), event.getClockTime());

            // 3. å®æ—¶è®¡ç®—
            CalculationContext context = CalculationContext.builder()
                .clockEvent(event)
                .shift(shift)
                .existingResult(todayResult)
                .rules(ruleEngine.getApplicableRules(event.getEmployeeId()))
                .build();

            AttendanceResult updatedResult = calculateAttendance(context);

            // 4. ä¿å­˜ç»“æœ
            attendanceResultService.save(updatedResult);

            // 5. å¼‚å¸¸æ£€æµ‹
            detectAndCreateWarnings(updatedResult);

            // 6. å‘é€é€šçŸ¥
            notificationService.sendRealTimeNotification(updatedResult);

        } catch (Exception e) {
            log.error("å®æ—¶è€ƒå‹¤è®¡ç®—å¤±è´¥", e);
            // å¼‚å¸¸å¤„ç†ï¼šåŠ å…¥é‡è¯•é˜Ÿåˆ—
            retryQueueService.offer(event);
        }
    }

    /**
     * ç²¾ç¡®è€ƒå‹¤è®¡ç®—
     */
    public AttendanceResult calculateAttendance(CalculationContext context) {

        ClockInEvent event = context.getClockEvent();
        EmployeeShift shift = context.getShift();
        AttendanceResult existingResult = context.getExistingResult();

        // 1. æ—¶é—´åŒ¹é…ç®—æ³•
        TimeMatchResult timeMatch = matchClockTimeToShift(event, shift);

        // 2. å·¥ä½œæ—¶é•¿ç²¾ç¡®è®¡ç®—
        WorkDurationCalculation durationCalculation =
            calculateWorkDuration(existingResult, event, shift);

        // 3. å¼‚å¸¸åˆ¤å®š
        ExceptionDetectionResult exceptionDetection =
            detectExceptions(timeMatch, durationCalculation, context.getRules());

        // 4. åŠ ç­è®¡ç®—
        OvertimeCalculation overtimeCalculation =
            overtimeService.calculateOvertime(
                durationCalculation, shift, context.getRules());

        // 5. æ„å»ºç»“æœ
        return AttendanceResult.builder()
            .employeeId(event.getEmployeeId())
            .attendanceDate(event.getClockTime().toLocalDate())
            .shiftId(shift.getShiftId())

            // æ—¶é—´ä¿¡æ¯
            .scheduledStartTime(shift.getStartTime())
            .scheduledEndTime(shift.getEndTime())
            .actualStartTime(durationCalculation.getActualStartTime())
            .actualEndTime(durationCalculation.getActualEndTime())

            // æ—¶é•¿ä¿¡æ¯ï¼ˆç²¾ç¡®åˆ°ç§’ï¼‰
            .scheduledWorkSeconds(durationCalculation.getScheduledWorkSeconds())
            .actualWorkSeconds(durationCalculation.getActualWorkSeconds())
            .breakSeconds(durationCalculation.getBreakSeconds())
            .overtimeSeconds(overtimeCalculation.getRegularOvertimeSeconds())
            .weekendOvertimeSeconds(overtimeCalculation.getWeekendOvertimeSeconds())
            .holidayOvertimeSeconds(overtimeCalculation.getHolidayOvertimeSeconds())

            // å¼‚å¸¸ä¿¡æ¯
            .lateSeconds(exceptionDetection.getLateSeconds())
            .earlyLeaveSeconds(exceptionDetection.getEarlyLeaveSeconds())
            .absentSeconds(exceptionDetection.getAbsentSeconds())
            .exceptionCount(exceptionDetection.getExceptionCount())

            // çŠ¶æ€ä¿¡æ¯
            .attendanceStatus(determineAttendanceStatus(exceptionDetection))
            .needReview(exceptionDetection.hasCriticalExceptions())

            // è®¡ç®—å¼•æ“ä¿¡æ¯
            .calculationVersion("v3.5.4")
            .calculationTime(Instant.now())
            .calculationSource("REAL_TIME")
            .build();
    }

    /**
     * å·¥ä½œæ—¶é•¿ç²¾ç¡®è®¡ç®—
     */
    private WorkDurationCalculation calculateWorkDuration(
            AttendanceResult existingResult,
            ClockInEvent newEvent,
            EmployeeShift shift) {

        LocalTime newClockTime = newEvent.getClockTime().toLocalTime();
        LocalDate attendanceDate = newEvent.getClockTime().toLocalDate();

        if ("IN".equals(newEvent.getClockType())) {
            // ä¸Šç­æ‰“å¡é€»è¾‘
            return calculateForClockIn(existingResult, newClockTime, attendanceDate, shift);
        } else {
            // ä¸‹ç­æ‰“å¡é€»è¾‘
            return calculateForClockOut(existingResult, newClockTime, attendanceDate, shift);
        }
    }

    /**
     * ä¸Šç­æ‰“å¡æ—¶é•¿è®¡ç®—
     */
    private WorkDurationCalculation calculateForClockIn(
            AttendanceResult existingResult,
            LocalTime clockInTime,
            LocalDate attendanceDate,
            EmployeeShift shift) {

        // è®¡ç®—è¿Ÿåˆ°æ—¶é—´
        int lateSeconds = 0;
        if (clockInTime.isAfter(shift.getStartTime().plusMinutes(shift.getGracePeriod()))) {
            lateSeconds = (int) Duration.between(
                shift.getStartTime().plusMinutes(shift.getGracePeriod()),
                clockInTime).getSeconds();
        }

        return WorkDurationCalculation.builder()
            .actualStartTime(clockInTime)
            .actualEndTime(existingResult != null ? existingResult.getActualEndTime() : null)
            .lateSeconds(lateSeconds)
            .build();
    }

    /**
     * ä¸‹ç­æ‰“å¡æ—¶é•¿è®¡ç®—
     */
    private WorkDurationCalculation calculateForClockOut(
            AttendanceResult existingResult,
            LocalTime clockOutTime,
            LocalDate attendanceDate,
            EmployeeShift shift) {

        if (existingResult == null || existingResult.getActualStartTime() == null) {
            // æ²¡æœ‰ä¸Šç­æ‰“å¡è®°å½•ï¼Œå¼‚å¸¸å¤„ç†
            throw new AttendanceCalculationException("ç¼ºå°‘ä¸Šç­æ‰“å¡è®°å½•");
        }

        LocalTime clockInTime = existingResult.getActualStartTime();

        // è®¡ç®—æ—©é€€æ—¶é—´
        int earlyLeaveSeconds = 0;
        if (clockOutTime.isBefore(shift.getEndTime().minusMinutes(shift.getGracePeriod()))) {
            earlyLeaveSeconds = (int) Duration.between(
                clockOutTime,
                shift.getEndTime().minusMinutes(shift.getGracePeriod())).getSeconds();
        }

        // è®¡ç®—å®é™…å·¥ä½œæ—¶é•¿ï¼ˆç§’ï¼‰
        int actualWorkSeconds = (int) Duration.between(clockInTime, clockOutTime).getSeconds();

        // å‡å»ä¼‘æ¯æ—¶é—´
        int breakSeconds = calculateBreakDuration(clockInTime, clockOutTime, shift);

        return WorkDurationCalculation.builder()
            .actualStartTime(clockInTime)
            .actualEndTime(clockOutTime)
            .actualWorkSeconds(actualWorkSeconds - breakSeconds)
            .breakSeconds(breakSeconds)
            .earlyLeaveSeconds(earlyLeaveSeconds)
            .build();
    }
}
```

### 3. æ™ºèƒ½å¼‚å¸¸æ£€æµ‹ç³»ç»Ÿ
```java
@Service
@Slf4j
public class IntelligentAnomalyDetectionService {

    @Resource
    private MachineLearningService mlService;

    @Resource
    private AttendanceRuleEngine ruleEngine;

    /**
     * æ™ºèƒ½å¼‚å¸¸æ£€æµ‹
     */
    public List<AttendanceWarning> detectAnomalies(AttendanceResult result) {

        List<AttendanceWarning> warnings = new ArrayList<>();

        // 1. åŸºäºè§„åˆ™çš„å¼‚å¸¸æ£€æµ‹
        warnings.addAll(detectRuleBasedAnomalies(result));

        // 2. åŸºäºæœºå™¨å­¦ä¹ çš„å¼‚å¸¸æ£€æµ‹
        warnings.addAll(detectMLBasedAnomalies(result));

        // 3. åŸºäºç»Ÿè®¡çš„å¼‚å¸¸æ£€æµ‹
        warnings.addAll(detectStatisticalAnomalies(result));

        // 4. åŸºäºè¡Œä¸ºæ¨¡å¼çš„å¼‚å¸¸æ£€æµ‹
        warnings.addAll(detectBehavioralAnomalies(result));

        // 5. é¢„è­¦çº§åˆ«è¯„ä¼°
        warnings.forEach(this::assessWarningLevel);

        return warnings;
    }

    /**
     * åŸºäºæœºå™¨å­¦ä¹ çš„å¼‚å¸¸æ£€æµ‹
     */
    private List<AttendanceWarning> detectMLBasedAnomalies(AttendanceResult result) {

        try {
            // 1. å‡†å¤‡ç‰¹å¾æ•°æ®
            FeatureVector features = featureExtractionService.extractFeatures(result);

            // 2. æ¨¡å‹é¢„æµ‹
            AnomalyPrediction prediction = mlService.predictAnomaly(features);

            // 3. ç”Ÿæˆé¢„è­¦
            if (prediction.isAnomaly()) {
                return Arrays.asList(
                    AttendanceWarning.builder()
                        .employeeId(result.getEmployeeId())
                        .warningType("ML_ANOMALY")
                        .warningCode("ML_001")
                        .warningTitle("æœºå™¨å­¦ä¹ æ£€æµ‹åˆ°å¼‚å¸¸è€ƒå‹¤æ¨¡å¼")
                        .warningContent(String.format(
                            "AIæ¨¡å‹æ£€æµ‹åˆ°å¼‚å¸¸è€ƒå‹¤æ¨¡å¼ï¼Œå¼‚å¸¸åˆ†æ•°ï¼š%.4fï¼ŒåŸå› ï¼š%s",
                            prediction.getAnomalyScore(),
                            prediction.getReason()))
                        .warningDate(result.getAttendanceDate())
                        .warningLevel(assessMLWarningLevel(prediction.getAnomalyScore()))
                        .needReview(true)
                        .build()
                );
            }

        } catch (Exception e) {
            log.error("æœºå™¨å­¦ä¹ å¼‚å¸¸æ£€æµ‹å¤±è´¥", e);
        }

        return Collections.emptyList();
    }

    /**
     * åŸºäºè¡Œä¸ºæ¨¡å¼çš„å¼‚å¸¸æ£€æµ‹
     */
    private List<AttendanceWarning> detectBehavioralAnomalies(AttendanceResult result) {

        List<AttendanceWarning> warnings = new ArrayList<>();

        // 1. è·å–å†å²è¡Œä¸ºæ•°æ®
        List<AttendanceResult> historicalData =
            attendanceResultService.getEmployeeHistory(
                result.getEmployeeId(),
                LocalDate.now().minusMonths(3),
                LocalDate.now());

        // 2. è¡Œä¸ºæ¨¡å¼åˆ†æ
        BehavioralPattern pattern = behavioralAnalysisService.analyze(historicalData);

        // 3. å¼‚å¸¸æ£€æµ‹
        if (isBehavioralAnomaly(result, pattern)) {
            warnings.add(
                AttendanceWarning.builder()
                    .employeeId(result.getEmployeeId())
                    .warningType("BEHAVIORAL_ANOMALY")
                    .warningCode("BHV_001")
                    .warningTitle("è€ƒå‹¤è¡Œä¸ºæ¨¡å¼å¼‚å¸¸")
                    .warningContent(String.format(
                        "æ£€æµ‹åˆ°è€ƒå‹¤è¡Œä¸ºæ¨¡å¼å¼‚å¸¸ï¼Œä¸å†å²æ¨¡å¼åå·®%.2f%%",
                        calculateBehavioralDeviation(result, pattern) * 100))
                    .warningDate(result.getAttendanceDate())
                    .warningLevel("MEDIUM")
                    .needReview(false)
                    .build()
            );
        }

        return warnings;
    }
}
```

## ç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–

### 1. æ•°æ®åˆ†åŒºç­–ç•¥
```sql
-- æ™ºèƒ½åˆ†åŒºç®¡ç†å‡½æ•°
CREATE OR REPLACE FUNCTION manage_attendance_partitions()
RETURNS void AS $$
DECLARE
    current_month TEXT;
    next_month TEXT;
    partition_name TEXT;
BEGIN
    current_month := TO_CHAR(NOW(), 'YYYY-MM');
    next_month := TO_CHAR(NOW() + INTERVAL '1 month', 'YYYY-MM');

    -- ä¸ºä¸‹ä¸ªæœˆåˆ›å»ºåˆ†åŒº
    partition_name := 't_attendance_result_' || next_month;

    EXECUTE format('CREATE TABLE IF NOT EXISTS %I PARTITION OF t_attendance_result
                    FOR VALUES IN (%L)', partition_name, next_month);

    -- æ¸…ç†è¿‡æœŸåˆ†åŒºï¼ˆä¿ç•™2å¹´ï¼‰
    DELETE FROM t_attendance_result
    WHERE partition_month < TO_CHAR(NOW() - INTERVAL '2 years', 'YYYY-MM');
END;
$$ LANGUAGE plpgsql;

-- è‡ªåŠ¨æ‰§è¡Œåˆ†åŒºç®¡ç†
SELECT cron.schedule('manage-attendance-partitions', '0 0 1 * *', 'SELECT manage_attendance_partitions();');
```

### 2. å®æ—¶è®¡ç®—å¼•æ“é…ç½®
```java
@Configuration
@EnableAsync
public class AsyncCalculationConfig {

    /**
     * å®æ—¶è®¡ç®—çº¿ç¨‹æ± 
     */
    @Bean("realTimeCalculationExecutor")
    public Executor realTimeCalculationExecutor() {

        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();

        // æ ¸å¿ƒçº¿ç¨‹æ•°ï¼šCPUæ ¸å¿ƒæ•° * 2
        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors() * 2);

        // æœ€å¤§çº¿ç¨‹æ•°ï¼šæ ¸å¿ƒçº¿ç¨‹æ•° * 4
        executor.setMaxPoolSize(Runtime.getRuntime().availableProcessors() * 8);

        // é˜Ÿåˆ—å®¹é‡ï¼š10000
        executor.setQueueCapacity(10000);

        // çº¿ç¨‹åå‰ç¼€
        executor.setThreadNamePrefix("realtime-calc-");

        // æ‹’ç»ç­–ç•¥ï¼šè°ƒç”¨è€…è¿è¡Œ
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());

        // å…³é—­ç­‰å¾…æ—¶é—´
        executor.setAwaitTerminationSeconds(60);
        executor.setWaitForTasksToCompleteOnShutdown(true);

        return executor;
    }

    /**
     * æ‰¹é‡è®¡ç®—çº¿ç¨‹æ± 
     */
    @Bean("batchCalculationExecutor")
    public Executor batchCalculationExecutor() {

        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();

        // æ‰¹é‡è®¡ç®—éœ€è¦è¾ƒå°‘çš„çº¿ç¨‹
        executor.setCorePoolSize(4);
        executor.setMaxPoolSize(8);
        executor.setQueueCapacity(1000);
        executor.setThreadNamePrefix("batch-calc-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());

        return executor;
    }
}
```

## å®‰å…¨ä¸åŠ å¯†

### 1. å›½å¯†ç®—æ³•é›†æˆ
```java
@Component
@Slf4j
public class SMEncryptionService {

    private final SM4Cipher sm4Cipher;
    private final SM2KeyPair sm2KeyPair;

    public SMEncryptionService() {
        this.sm4Cipher = new SM4Cipher();
        this.sm2KeyPair = SM2KeyGenerator.generateKeyPair();
    }

    /**
     * SM4åŠ å¯†ç”Ÿç‰©è¯†åˆ«æ•°æ®
     */
    public String encryptBiometricData(String rawData) {

        try {
            // ç”ŸæˆéšæœºIV
            byte[] iv = generateRandomIV();

            // SM4åŠ å¯†
            byte[] encryptedData = sm4Cipher.encrypt(
                rawData.getBytes(StandardCharsets.UTF_8),
                iv);

            // ç»„åˆIVå’ŒåŠ å¯†æ•°æ®
            byte[] combined = new byte[iv.length + encryptedData.length];
            System.arraycopy(iv, 0, combined, 0, iv.length);
            System.arraycopy(encryptedData, 0, combined, iv.length, encryptedData.length);

            return Base64.getEncoder().encodeToString(combined);

        } catch (Exception e) {
            log.error("ç”Ÿç‰©è¯†åˆ«æ•°æ®åŠ å¯†å¤±è´¥", e);
            throw new SecurityException("æ•°æ®åŠ å¯†å¤±è´¥");
        }
    }

    /**
     * SM2æ•°å­—ç­¾å
     */
    public String signData(String data) {

        try {
            // SM3å“ˆå¸Œ
            byte[] hash = SM3.hash(data.getBytes(StandardCharsets.UTF_8));

            // SM2ç­¾å
            return sm2KeyPair.sign(hash);

        } catch (Exception e) {
            log.error("æ•°æ®ç­¾åå¤±è´¥", e);
            throw new SecurityException("æ•°æ®ç­¾åå¤±è´¥");
        }
    }
}
```

## APIæ¥å£è®¾è®¡

### 1. RESTful APIè§„èŒƒ
```java
@RestController
@RequestMapping("/api/v1/attendance/calculation")
@Tag(name = "è€ƒå‹¤è®¡ç®—å¼•æ“", description = "åŸå§‹è®°å½•ä¸è€ƒå‹¤è®¡ç®—ç›¸å…³æ¥å£")
@SecurityRequirement(name = "bearerAuth")
public class AttendanceCalculationController {

    /**
     * è§¦å‘è€ƒå‹¤é‡æ–°è®¡ç®—
     */
    @PostMapping("/recalculate")
    @Operation(summary = "è§¦å‘è€ƒå‹¤é‡æ–°è®¡ç®—")
    @PreAuthorize("hasRole('ATTENDANCE_ADMIN')")
    public ResponseDTO<RecalculationResult> triggerRecalculation(
            @Valid @RequestBody RecalculationRequest request) {

        RecalculationResult result = calculationService.triggerRecalculation(request);
        return ResponseDTO.ok(result);
    }

    /**
     * è·å–è€ƒå‹¤è®¡ç®—ç»“æœ
     */
    @GetMapping("/results")
    @Operation(summary = "è·å–è€ƒå‹¤è®¡ç®—ç»“æœ")
    @PreAuthorize("hasRole('EMPLOYEE') or hasRole('ATTENDANCE_ADMIN')")
    public ResponseDTO<PageResult<AttendanceResultVO>> getAttendanceResults(
            @ParameterObject @Valid AttendanceResultQueryRequest request) {

        PageResult<AttendanceResultVO> results =
            calculationService.getAttendanceResults(request);
        return ResponseDTO.ok(results);
    }

    /**
     * è·å–è€ƒå‹¤å¼‚å¸¸é¢„è­¦
     */
    @GetMapping("/warnings")
    @Operation(summary = "è·å–è€ƒå‹¤å¼‚å¸¸é¢„è­¦")
    @PreAuthorize("hasRole('ATTENDANCE_ADMIN')")
    public ResponseDTO<PageResult<AttendanceWarningVO>> getAttendanceWarnings(
            @ParameterObject @Valid AttendanceWarningQueryRequest request) {

        PageResult<AttendanceWarningVO> warnings =
            calculationService.getAttendanceWarnings(request);
        return ResponseDTO.ok(warnings);
    }
}
```

### 2. å®æ—¶äº‹ä»¶API
```java
@RestController
@RequestMapping("/api/v1/attendance/realtime")
@Tag(name = "å®æ—¶è€ƒå‹¤äº‹ä»¶", description = "å®æ—¶è€ƒå‹¤äº‹ä»¶å¤„ç†æ¥å£")
public class RealTimeAttendanceController {

    /**
     * WebSocketè¿æ¥å»ºç«‹
     */
    @GetMapping("/ws/employee/{employeeId}")
    public String connectEmployeeWebSocket(
            @PathVariable Long employeeId,
            Principal principal) {

        // éªŒè¯æƒé™
        if (!securityService.canAccessEmployee(principal, employeeId)) {
            throw new AccessDeniedException("æ— æƒé™è®¿é—®è¯¥å‘˜å·¥è€ƒå‹¤æ•°æ®");
        }

        return "websocket/attendance-employee";
    }

    /**
     * å®æ—¶æ¨é€è€ƒå‹¤æ›´æ–°
     */
    @EventListener
    public void handleAttendanceUpdate(AttendanceUpdateEvent event) {

        // æ¨é€ç»™å‘˜å·¥
        messagingTemplate.convertAndSendToUser(
            event.getEmployeeId().toString(),
            "/queue/attendance-updates",
            event
        );

        // æ¨é€ç»™ç®¡ç†å‘˜
        messagingTemplate.convertAndSend(
            "/topic/attendance-admin-updates",
            event
        );
    }
}
```

## ç›‘æ§ä¸è¿ç»´

### 1. æ€§èƒ½ç›‘æ§æŒ‡æ ‡
```java
@Component
@Slf4j
public class AttendanceCalculationMetrics {

    private final MeterRegistry meterRegistry;
    private final Counter clockInCounter;
    private final Timer calculationTimer;
    private final Gauge calculationQueueSize;

    public AttendanceCalculationMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;

        this.clockInCounter = Counter.builder("attendance.clock.in.total")
            .description("æ‰“å¡æ€»æ•°")
            .tag("type", "total")
            .register(meterRegistry);

        this.calculationTimer = Timer.builder("attendance.calculation.time")
            .description("è€ƒå‹¤è®¡ç®—è€—æ—¶")
            .register(meterRegistry);

        this.calculationQueueSize = Gauge.builder("attendance.calculation.queue.size")
            .description("è®¡ç®—é˜Ÿåˆ—å¤§å°")
            .register(meterRegistry, this, AttendanceCalculationMetrics::getQueueSize);
    }

    public void recordClockIn(String clockType, boolean success) {
        clockInCounter.increment(
            Tags.of(
                Tag.of("type", clockType),
                Tag.of("result", success ? "success" : "failure")
            )
        );
    }

    public void recordCalculationTime(Duration duration) {
        calculationTimer.record(duration);
    }

    private double getQueueSize() {
        return taskExecutor.getThreadPoolExecutor().getQueue().size();
    }
}
```

### 2. å¥åº·æ£€æŸ¥ç«¯ç‚¹
```java
@Component
public class AttendanceCalculationHealthIndicator implements HealthIndicator {

    @Resource
    private RealTimeCalculationEngine calculationEngine;

    @Override
    public Health health() {

        try {
            // æ£€æŸ¥è®¡ç®—å¼•æ“çŠ¶æ€
            CalculationEngineStatus status = calculationEngine.getStatus();

            if (status.isHealthy()) {
                return Health.up()
                    .withDetail("status", "healthy")
                    .withDetail("queueSize", status.getQueueSize())
                    .withDetail("activeThreads", status.getActiveThreads())
                    .withDetail("avgCalculationTime", status.getAvgCalculationTime())
                    .build();
            } else {
                return Health.down()
                    .withDetail("status", "unhealthy")
                    .withDetail("error", status.getLastError())
                    .build();
            }

        } catch (Exception e) {
            return Health.down(e).build();
        }
    }
}
```

## ğŸ“Š æ•°æ®åº“ERå›¾

```mermaid
erDiagram
    t_attendance_clock_record {
        bigint record_id PK
        bigint employee_id FK
        bigint device_id FK
        timestamp clock_time
        varchar clock_type
        varchar biometric_type
        decimal confidence_score
        varchar verification_status
        timestamp create_time
    }

    t_attendance_result {
        bigint result_id PK
        bigint employee_id FK
        date attendance_date
        bigint shift_id FK
        timestamp actual_start_time
        timestamp actual_end_time
        integer actual_work_seconds
        integer overtime_seconds
        varchar attendance_status
        timestamp calculation_time
    }

    t_attendance_warning {
        bigint warning_id PK
        bigint employee_id FK
        bigint rule_id FK
        varchar warning_type
        varchar warning_level
        date warning_date
        varchar handle_status
        timestamp create_time
    }

    t_biometric_verification {
        bigint verification_id PK
        bigint clock_record_id FK
        bigint employee_id FK
        varchar biometric_type
        decimal match_score
        boolean verification_result
        decimal liveness_score
        timestamp create_time
    }

    %% å…³è”å…³ç³»
    t_attendance_clock_record ||--o{ t_biometric_verification : "clock_record_id"
    t_attendance_clock_record ||--|| t_attendance_result : "employee_id, date"
    t_attendance_result ||--o{ t_attendance_warning : "employee_id, date"
    employees ||--o{ t_attendance_clock_record : "employee_id"
    employees ||--o{ t_attendance_result : "employee_id"
    employees ||--o{ t_attendance_warning : "employee_id"
    employees ||--o{ t_biometric_verification : "employee_id"
    devices ||--o{ t_attendance_clock_record : "device_id"
    shifts ||--o{ t_attendance_result : "shift_id"
    attendance_rules ||--o{ t_attendance_warning : "rule_id"
```

## æ€»ç»“

å¤šæ¨¡æ€ç”Ÿç‰©è¯†åˆ«è€ƒå‹¤è®¡ç®—å¼•æ“ä½œä¸ºIOE-DREAMæ™ºæ…§å›­åŒºä¸€å¡é€šç®¡ç†å¹³å°çš„æ ¸å¿ƒæ¨¡å—ï¼Œå…·å¤‡ä»¥ä¸‹ç‰¹ç‚¹ï¼š

### æ ¸å¿ƒèƒ½åŠ›
1. **å¤šæ¨¡æ€ç”Ÿç‰©è¯†åˆ«**: æ”¯æŒäººè„¸ã€æŒ‡çº¹ã€æŒçº¹ã€è™¹è†œã€å£°çº¹èåˆéªŒè¯
2. **å®æ—¶è®¡ç®—å¼•æ“**: æ¯«ç§’çº§å“åº”çš„è€ƒå‹¤è®¡ç®—èƒ½åŠ›
3. **æ™ºèƒ½å¼‚å¸¸æ£€æµ‹**: åŸºäºæœºå™¨å­¦ä¹ å’Œè¡Œä¸ºæ¨¡å¼çš„å¼‚å¸¸è¯†åˆ«
4. **é«˜å¹¶å‘å¤„ç†**: æ”¯æŒç™¾ä¸‡çº§å‘˜å·¥åŒæ—¶æ‰“å¡
5. **å›½å¯†å®‰å…¨ä¿æŠ¤**: SM2/SM3/SM4å…¨é“¾è·¯æ•°æ®åŠ å¯†

### æŠ€æœ¯ä¼˜åŠ¿
1. **å¾®æœåŠ¡æ¶æ„**: Spring Boot 3.5.4 + Java 17ç°ä»£åŒ–æ¶æ„
2. **åˆ†å¸ƒå¼å­˜å‚¨**: PostgreSQLé›†ç¾¤ + Redisåˆ†å¸ƒå¼ç¼“å­˜
3. **å®æ—¶æµå¤„ç†**: Kafka + Flinkå®æ—¶æ•°æ®ç®¡é“
4. **AIç®—æ³•é›†æˆ**: TensorFlow Liteæœ¬åœ°åŒ–æ¨ç†
5. **è‡ªåŠ¨è¿ç»´**: å®Œå–„çš„ç›‘æ§ã€å‘Šè­¦ã€è‡ªæ„ˆæœºåˆ¶

### ä¸šåŠ¡ä»·å€¼
1. **æå‡æ•ˆç‡**: è‡ªåŠ¨åŒ–è€ƒå‹¤è®¡ç®—ï¼Œå‡å°‘äººå·¥å¹²é¢„
2. **å¢å¼ºå®‰å…¨**: å¤šé‡ç”Ÿç‰©è¯†åˆ«éªŒè¯ï¼Œæœç»ä»£æ‰“å¡
3. **æ™ºèƒ½åˆ†æ**: å¼‚å¸¸è¡Œä¸ºæ£€æµ‹ï¼Œé£é™©é¢„è­¦
4. **åˆè§„ç®¡ç†**: ç¬¦åˆåŠ³åŠ¨æ³•è§„çš„è€ƒå‹¤è§„åˆ™å¼•æ“
5. **ç”¨æˆ·ä½“éªŒ**: ç§»åŠ¨ç«¯å®æ—¶è€ƒå‹¤ï¼Œä¾¿æ·é«˜æ•ˆ

è¯¥æ¨¡å—ä¸ºæ™ºæ…§å›­åŒºæä¾›äº†å®Œæ•´çš„è€ƒå‹¤ç®¡ç†è§£å†³æ–¹æ¡ˆï¼Œæ˜¯ä¼ ç»Ÿè€ƒå‹¤ç³»ç»Ÿçš„æ™ºèƒ½åŒ–å‡çº§æ›¿ä»£äº§å“ã€‚

---

**ğŸ¯ IOE-DREAMå¤šæ¨¡æ€ç”Ÿç‰©è¯†åˆ«è€ƒå‹¤è®¡ç®—å¼•æ“ - å®‰å…¨ã€æ™ºèƒ½ã€é«˜æ•ˆçš„æ–°ä¸€ä»£è€ƒå‹¤ç®¡ç†ç³»ç»Ÿ**