# IOE-DREAMå›½é™…åŒ–å¤šè¯­è¨€æ”¯æŒæ–‡æ¡£

> **ç‰ˆæœ¬**: v1.0.0
> **åˆ›å»ºæ—¥æœŸ**: 2025-12-21
> **é€‚ç”¨èŒƒå›´**: IOE-DREAMæ™ºæ…§å›­åŒºç®¡ç†ç³»ç»Ÿå…¨å¹³å°
> **ç»´æŠ¤æœºæ„**: IOE-DREAMå›½é™…åŒ–å§”å‘˜ä¼š

---

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£ä¸ºIOE-DREAMæ™ºæ…§å›­åŒºç®¡ç†ç³»ç»Ÿæä¾›å®Œæ•´çš„å›½é™…åŒ–ï¼ˆi18nï¼‰å’Œå¤šè¯­è¨€æ”¯æŒæ–¹æ¡ˆï¼Œæ¶µç›–Webç«¯ã€ç§»åŠ¨ç«¯ã€å°ç¨‹åºç­‰å¤šå¹³å°çš„æœ¬åœ°åŒ–å®æ–½æ ‡å‡†å’ŒæŠ€æœ¯å®ç°æŒ‡å—ã€‚

### ğŸ¯ å›½é™…åŒ–ç›®æ ‡

- **å…¨çƒåŒ–æ”¯æŒ**: æ”¯æŒå¤šå›½å®¶ã€å¤šåœ°åŒºçš„æœ¬åœ°åŒ–éœ€æ±‚
- **æ–‡åŒ–é€‚é…**: å°Šé‡å„åœ°æ–‡åŒ–å·®å¼‚ï¼Œæä¾›æœ¬åœ°åŒ–ä½“éªŒ
- **æŠ€æœ¯æ ‡å‡†**: å»ºç«‹ç»Ÿä¸€çš„æŠ€æœ¯å®ç°æ ‡å‡†å’Œå·¥ä½œæµç¨‹
- **ç»´æŠ¤æ•ˆç‡**: æä¾›é«˜æ•ˆçš„ç¿»è¯‘ç®¡ç†å’Œæ›´æ–°æœºåˆ¶

---

## ğŸŒ å›½é™…åŒ–æ¶æ„è®¾è®¡

### 1. å›½é™…åŒ–æŠ€æœ¯æ¶æ„

```typescript
// å›½é™…åŒ–æ¶æ„æ¥å£
interface I18nArchitecture {
  // è¯­è¨€æ£€æµ‹å’Œåˆ‡æ¢
  languageDetection: {
    browserDetection: boolean;        // æµè§ˆå™¨è¯­è¨€æ£€æµ‹
    systemDetection: boolean;         // ç³»ç»Ÿè¯­è¨€æ£€æµ‹
    userPreference: boolean;          // ç”¨æˆ·åå¥½è®¾ç½®
    geoLocationBased: boolean;        // åŸºäºåœ°ç†ä½ç½®çš„æ¨è
  };

  // è¯­è¨€èµ„æºç®¡ç†
  resourceManagement: {
    namespacing: boolean;             // å‘½åç©ºé—´æ”¯æŒ
    lazyLoading: boolean;             // æ‡’åŠ è½½è¯­è¨€åŒ…
    bundlingStrategy: 'feature' | 'locale' | 'hybrid';
    fallbackChain: string[];           // è¯­è¨€å›é€€é“¾
  };

  // å¹³å°é€‚é…
  platformSupport: {
    web: boolean;                      // Webç«¯æ”¯æŒ
    mobile: boolean;                   // ç§»åŠ¨ç«¯æ”¯æŒ
    miniprogram: boolean;              // å°ç¨‹åºæ”¯æŒ
    api: boolean;                      // APIå›½é™…åŒ–æ”¯æŒ
  };

  // æ ¼å¼åŒ–æ”¯æŒ
  formatting: {
    dateTime: boolean;                 // æ—¥æœŸæ—¶é—´æ ¼å¼åŒ–
    numbers: boolean;                  // æ•°å­—æ ¼å¼åŒ–
    currency: boolean;                 // è´§å¸æ ¼å¼åŒ–
    pluralization: boolean;            // å¤æ•°å½¢å¼æ”¯æŒ
  };
}
```

### 2. æ”¯æŒçš„è¯­è¨€å’Œåœ°åŒº

```typescript
// æ”¯æŒçš„è¯­è¨€é…ç½®
interface SupportedLanguages {
  // ä¸»è¦è¯­è¨€
  primary: {
    'zh-CN': {
      name: 'ç®€ä½“ä¸­æ–‡',
      nativeName: 'ç®€ä½“ä¸­æ–‡',
      locale: 'zh-CN',
      direction: 'ltr',
      dateFormat: 'YYYY-MM-DD',
      timeFormat: 'HH:mm:ss',
      currency: 'CNY',
      numberFormat: '#,##0.##'
    },
    'zh-TW': {
      name: 'ç¹é«”ä¸­æ–‡',
      nativeName: 'ç¹é«”ä¸­æ–‡',
      locale: 'zh-TW',
      direction: 'ltr',
      dateFormat: 'YYYY/MM/DD',
      timeFormat: 'HH:mm:ss',
      currency: 'TWD',
      numberFormat: '#,##0.##'
    },
    'en-US': {
      name: 'English (US)',
      nativeName: 'English',
      locale: 'en-US',
      direction: 'ltr',
      dateFormat: 'MM/DD/YYYY',
      timeFormat: 'h:mm:ss A',
      currency: 'USD',
      numberFormat: '#,##0.##'
    },
    'en-GB': {
      name: 'English (UK)',
      nativeName: 'English',
      locale: 'en-GB',
      direction: 'ltr',
      dateFormat: 'DD/MM/YYYY',
      timeFormat: 'HH:mm:ss',
      currency: 'GBP',
      numberFormat: '#,##0.##'
    }
  };

  // æ‰©å±•è¯­è¨€
  extended: {
    'ja-JP': {
      name: 'æ—¥æœ¬èª',
      nativeName: 'æ—¥æœ¬èª',
      locale: 'ja-JP',
      direction: 'ltr',
      dateFormat: 'YYYY/MM/DD',
      timeFormat: 'HH:mm:ss',
      currency: 'JPY',
      numberFormat: '#,##0.##'
    },
    'ko-KR': {
      name: 'í•œêµ­ì–´',
      nativeName: 'í•œêµ­ì–´',
      locale: 'ko-KR',
      direction: 'ltr',
      dateFormat: 'YYYY. MM. DD.',
      timeFormat: 'HH:mm:ss',
      currency: 'KRW',
      numberFormat: '#,##0.##'
    },
    'ar-SA': {
      name: 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
      nativeName: 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
      locale: 'ar-SA',
      direction: 'rtl',  // ä»å³åˆ°å·¦
      dateFormat: 'DD/MM/YYYY',
      timeFormat: 'HH:mm:ss',
      currency: 'SAR',
      numberFormat: '#,##0.##'
    }
  };

  // è¯­è¨€å›é€€é“¾
  fallbackChain: {
    'zh-TW': ['zh-CN', 'en-US'],
    'zh-HK': ['zh-TW', 'zh-CN', 'en-US'],
    'zh-MO': ['zh-TW', 'zh-CN', 'en-US'],
    'en-CA': ['en-US'],
    'en-AU': ['en-US'],
    'en-NZ': ['en-US'],
    'ja-JP': ['en-US'],
    'ko-KR': ['en-US'],
    'ar-SA': ['en-US']
  };
}
```

### 3. å›½é™…åŒ–ç›®å½•ç»“æ„

```
src/
â”œâ”€â”€ i18n/                                    # å›½é™…åŒ–æ ¹ç›®å½•
â”‚   â”œâ”€â”€ locales/                             # è¯­è¨€èµ„æºæ–‡ä»¶
â”‚   â”‚   â”œâ”€â”€ zh-CN/                          # ç®€ä½“ä¸­æ–‡
â”‚   â”‚   â”‚   â”œâ”€â”€ common.json                 # é€šç”¨ç¿»è¯‘
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.json                  # è®¤è¯æ¨¡å—
â”‚   â”‚   â”‚   â”œâ”€â”€ access.json                # é—¨ç¦æ¨¡å—
â”‚   â”‚   â”‚   â”œâ”€â”€ attendance.json           # è€ƒå‹¤æ¨¡å—
â”‚   â”‚   â”‚   â”œâ”€â”€ consume.json               # æ¶ˆè´¹æ¨¡å—
â”‚   â”‚   â”‚   â”œâ”€â”€ visitor.json               # è®¿å®¢æ¨¡å—
â”‚   â”‚   â”‚   â”œâ”€â”€ video.json                 # è§†é¢‘æ¨¡å—
â”‚   â”‚   â”‚   â””â”€â”€ errors.json                # é”™è¯¯ä¿¡æ¯
â”‚   â”‚   â”œâ”€â”€ zh-TW/                          # ç¹ä½“ä¸­æ–‡
â”‚   â”‚   â”œâ”€â”€ en-US/                          # ç¾å¼è‹±è¯­
â”‚   â”‚   â”œâ”€â”€ en-GB/                          # è‹±å¼è‹±è¯­
â”‚   â”‚   â”œâ”€â”€ ja-JP/                          # æ—¥è¯­
â”‚   â”‚   â”œâ”€â”€ ko-KR/                          # éŸ©è¯­
â”‚   â”‚   â””â”€â”€ ar-SA/                          # é˜¿æ‹‰ä¼¯è¯­
â”‚   â”œâ”€â”€ index.ts                            # å›½é™…åŒ–å…¥å£æ–‡ä»¶
â”‚   â”œâ”€â”€ config.ts                           # é…ç½®æ–‡ä»¶
â”‚   â”œâ”€â”€ utils.ts                            # å·¥å…·å‡½æ•°
â”‚   â””â”€â”€ types.ts                            # ç±»å‹å®šä¹‰
â”œâ”€â”€ components/                             # ç»„ä»¶ç›®å½•
â”‚   â””â”€â”€ ui/                                # UIç»„ä»¶
â”‚       â”œâ”€â”€ LanguageSelector/              # è¯­è¨€é€‰æ‹©å™¨
â”‚       â”œâ”€â”€ DateRangePicker/               # æ—¥æœŸé€‰æ‹©å™¨
â”‚       â””â”€â”€ NumberInput/                   # æ•°å­—è¾“å…¥
â””â”€â”€ hooks/                                # è‡ªå®šä¹‰Hook
    â”œâ”€â”€ useTranslation.ts                 # ç¿»è¯‘Hook
    â”œâ”€â”€ useLocale.ts                      # è¯­è¨€Hook
    â””â”€â”€ useFormatter.ts                   # æ ¼å¼åŒ–Hook
```

---

## ğŸ”§ æŠ€æœ¯å®ç°æ–¹æ¡ˆ

### 1. å‰ç«¯å›½é™…åŒ–å®ç°

#### 1.1 React i18n é…ç½®

```typescript
// i18n.config.ts
import { initReactI18next } from 'react-i18next';
import i18n from 'i18next';
import LanguageDetector from 'i18next-browser-languagedetector';
import Backend from 'i18next-http-backend';

// è¯­è¨€èµ„æºå¯¼å…¥
import zhCN from './locales/zh-CN';
import zhTW from './locales/zh-TW';
import enUS from './locales/en-US';
import enGB from './locales/en-GB';
import jaJP from './locales/ja-JP';
import koKR from './locales/ko-KR';
import arSA from './locales/ar-SA';

const resources = {
  'zh-CN': zhCN,
  'zh-TW': zhTW,
  'en-US': enUS,
  'en-GB': enGB,
  'ja-JP': jaJP,
  'ko-KR': koKR,
  'ar-SA': arSA
};

i18n
  .use(Backend)
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    resources,
    fallbackLng: 'zh-CN',
    fallbackNS: 'common',
    defaultNS: 'common',

    // è¯­è¨€æ£€æµ‹é…ç½®
    detection: {
      order: ['localStorage', 'navigator', 'htmlTag'],
      caches: ['localStorage'],
      lookupLocalStorage: 'i18nextLng'
    },

    // åç«¯é…ç½®
    backend: {
      loadPath: '/locales/{{lng}}/{{ns}}.json'
    },

    // æ’å€¼é…ç½®
    interpolation: {
      escapeValue: false
    },

    // è°ƒè¯•é…ç½®
    debug: process.env.NODE_ENV === 'development',

    // å‘½åç©ºé—´é…ç½®
    ns: ['common', 'auth', 'access', 'attendance', 'consume', 'visitor', 'video', 'errors'],

    // Reacté…ç½®
    react: {
      useSuspense: false,
      bindI18n: 'languageChanged',
      bindI18nStore: 'added'
    }
  });

export default i18n;
```

#### 1.2 è¯­è¨€é€‰æ‹©å™¨ç»„ä»¶

```typescript
// LanguageSelector.tsx
import React from 'react';
import { useTranslation } from 'react-i18next';
import { Select, MenuItem, FormControl, InputLabel } from '@mui/material';

interface Language {
  code: string;
  name: string;
  nativeName: string;
  flag: string;
}

const languages: Language[] = [
  { code: 'zh-CN', name: 'Chinese (Simplified)', nativeName: 'ç®€ä½“ä¸­æ–‡', flag: 'ğŸ‡¨ğŸ‡³' },
  { code: 'zh-TW', name: 'Chinese (Traditional)', nativeName: 'ç¹é«”ä¸­æ–‡', flag: 'ğŸ‡¹ğŸ‡¼' },
  { code: 'en-US', name: 'English (US)', nativeName: 'English', flag: 'ğŸ‡ºğŸ‡¸' },
  { code: 'en-GB', name: 'English (UK)', nativeName: 'English', flag: 'ğŸ‡¬ğŸ‡§' },
  { code: 'ja-JP', name: 'Japanese', nativeName: 'æ—¥æœ¬èª', flag: 'ğŸ‡¯ğŸ‡µ' },
  { code: 'ko-KR', name: 'Korean', nativeName: 'í•œêµ­ì–´', flag: 'ğŸ‡°ğŸ‡·' },
  { code: 'ar-SA', name: 'Arabic', nativeName: 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©', flag: 'ğŸ‡¸ğŸ‡¦' }
];

export const LanguageSelector: React.FC = () => {
  const { i18n, t } = useTranslation();

  const handleLanguageChange = (event: React.ChangeEvent<{ value: unknown }>) => {
    const newLanguage = event.target.value as string;

    // ä¿å­˜ç”¨æˆ·åå¥½
    localStorage.setItem('i18nextLng', newLanguage);

    // åˆ‡æ¢è¯­è¨€
    i18n.changeLanguage(newLanguage);

    // æ›´æ–°HTML langå±æ€§
    document.documentElement.lang = newLanguage;

    // æ›´æ–°RTLæ–¹å‘
    if (newLanguage === 'ar-SA') {
      document.documentElement.dir = 'rtl';
    } else {
      document.documentElement.dir = 'ltr';
    }
  };

  const currentLanguage = languages.find(lang => lang.code === i18n.language) || languages[0];

  return (
    <FormControl variant="outlined" size="small" sx={{ minWidth: 150 }}>
      <InputLabel id="language-select-label">{t('common.language')}</InputLabel>
      <Select
        labelId="language-select-label"
        id="language-select"
        value={i18n.language}
        onChange={handleLanguageChange}
        label={t('common.language')}
        renderValue={(selected) => (
          <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
            <span>{languages.find(l => l.code === selected)?.flag}</span>
            <span>{languages.find(l => l.code === selected)?.nativeName}</span>
          </div>
        )}
      >
        {languages.map((language) => (
          <MenuItem key={language.code} value={language.code}>
            <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
              <span>{language.flag}</span>
              <span>{language.nativeName}</span>
            </div>
          </MenuItem>
        ))}
      </Select>
    </FormControl>
  );
};
```

#### 1.3 ç¿»è¯‘Hookå°è£…

```typescript
// hooks/useTranslation.ts
import { useTranslation as useReactTranslation } from 'react-i18next';
import { useCallback } from 'react';

interface TranslationOptions {
  ns?: string | string[];
  keyPrefix?: string;
}

export const useAppTranslation = (options?: TranslationOptions) => {
  const { t, i18n, ready } = useReactTranslation(options?.ns, {
    keyPrefix: options?.keyPrefix
  });

  // æ ¼å¼åŒ–ç¿»è¯‘
  const formatT = useCallback((key: string, values?: Record<string, any>, options?: any) => {
    if (!values) return t(key, options);

    // æ”¯æŒåµŒå¥—å¯¹è±¡å€¼
    const formattedValues = Object.keys(values).reduce((acc, k) => {
      acc[k] = typeof values[k] === 'object' ? JSON.stringify(values[k]) : values[k];
      return acc;
    }, {} as Record<string, any>);

    return t(key, { ...formattedValues, ...options });
  }, [t]);

  // å¤æ•°å½¢å¼ç¿»è¯‘
  const pluralT = useCallback((key: string, count: number, values?: Record<string, any>) => {
    return t(key, {
      count,
      ...values
    });
  }, [t]);

  // æ¡ä»¶ç¿»è¯‘
  const conditionalT = useCallback((key: string, condition: boolean, trueValue: string, falseValue: string) => {
    return condition ? t(`${key}.${trueValue}`) : t(`${key}.${falseValue}`);
  }, [t]);

  // è¯­è¨€åˆ‡æ¢
  const changeLanguage = useCallback((lng: string) => {
    return i18n.changeLanguage(lng);
  }, [i18n]);

  // è·å–å½“å‰è¯­è¨€ä¿¡æ¯
  const getCurrentLanguage = useCallback(() => {
    return {
      code: i18n.language,
      name: i18n.getFixedT(null, 'common')('language.name'),
      direction: i18n.dir()
    };
  }, [i18n]);

  return {
    t: formatT,
    plural: pluralT,
    conditional: conditionalT,
    i18n,
    ready,
    changeLanguage,
    getCurrentLanguage,
    language: i18n.language,
    isRTL: i18n.dir() === 'rtl'
  };
};
```

### 2. åç«¯å›½é™…åŒ–å®ç°

#### 2.1 Spring Boot å›½é™…åŒ–é…ç½®

```java
// å›½é™…åŒ–é…ç½®ç±»
@Configuration
@EnableConfigurationProperties(I18nProperties.class)
public class I18nConfig {

    @Bean
    public MessageSource messageSource(I18nProperties properties) {
        ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
        messageSource.setBasename("classpath:i18n/messages");
        messageSource.setDefaultEncoding("UTF-8");
        messageSource.setUseCodeAsDefaultMessage(true);
        messageSource.setCacheSeconds(properties.getCacheSeconds());
        messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());
        return messageSource;
    }

    @Bean
    public LocaleResolver localeResolver(I18nProperties properties) {
        CookieLocaleResolver resolver = new CookieLocaleResolver();
        resolver.setCookieName(properties.getCookieName());
        resolver.setCookieMaxAge(properties.getCookieMaxAge());
        resolver.setDefaultLocale(Locale.forLanguageTag(properties.getDefaultLanguage()));
        return resolver;
    }

    @Bean
    public LocaleChangeInterceptor localeChangeInterceptor(I18nProperties properties) {
        LocaleChangeInterceptor interceptor = new LocaleChangeInterceptor();
        interceptor.setParamName(properties.getLanguageParam());
        return interceptor;
    }

    @Bean
    public I18nService i18nService(MessageSource messageSource, LocaleResolver localeResolver) {
        return new I18nServiceImpl(messageSource, localeResolver);
    }
}

// å›½é™…åŒ–å±æ€§é…ç½®
@ConfigurationProperties(prefix = "app.i18n")
@Data
public class I18nProperties {
    private String defaultLanguage = "zh-CN";
    private String cookieName = "lang";
    private int cookieMaxAge = 60 * 60 * 24 * 365; // 1å¹´
    private String languageParam = "lang";
    private boolean fallbackToSystemLocale = true;
    private int cacheSeconds = -1; // æ°¸ä¹…ç¼“å­˜
}
```

#### 2.2 å›½é™…åŒ–æœåŠ¡å®ç°

```java
// å›½é™…åŒ–æœåŠ¡æ¥å£
public interface I18nService {

    /**
     * è·å–å›½é™…åŒ–æ¶ˆæ¯
     */
    String getMessage(String code, Object[] args, Locale locale);

    /**
     * è·å–å›½é™…åŒ–æ¶ˆæ¯ï¼ˆä½¿ç”¨é»˜è®¤è¯­è¨€ç¯å¢ƒï¼‰
     */
    String getMessage(String code, Object[] args);

    /**
     * è·å–å›½é™…åŒ–æ¶ˆæ¯ï¼ˆæ— å‚æ•°ï¼‰
     */
    String getMessage(String code, Locale locale);

    /**
     * è·å–å›½é™…åŒ–æ¶ˆæ¯ï¼ˆæ— å‚æ•°ï¼Œä½¿ç”¨é»˜è®¤è¯­è¨€ç¯å¢ƒï¼‰
     */
    String getMessage(String code);

    /**
     * è·å–æ‰€æœ‰æ”¯æŒçš„è¯­è¨€
     */
    List<Language> getSupportedLanguages();

    /**
     * è®¾ç½®å½“å‰è¯­è¨€ç¯å¢ƒ
     */
    void setLocale(Locale locale, HttpServletRequest request, HttpServletResponse response);

    /**
     * è·å–å½“å‰è¯­è¨€ç¯å¢ƒ
     */
    Locale getCurrentLocale(HttpServletRequest request);
}

// å›½é™…åŒ–æœåŠ¡å®ç°
@Service
@Slf4j
public class I18nServiceImpl implements I18nService {

    private final MessageSource messageSource;
    private final LocaleResolver localeResolver;

    public I18nServiceImpl(MessageSource messageSource, LocaleResolver localeResolver) {
        this.messageSource = messageSource;
        this.localeResolver = localeResolver;
    }

    @Override
    public String getMessage(String code, Object[] args, Locale locale) {
        try {
            return messageSource.getMessage(code, args, locale);
        } catch (NoSuchMessageException e) {
            log.warn("Message not found for code: {} in locale: {}", code, locale);
            return code; // è¿”å›åŸå§‹ä»£ç ä½œä¸ºfallback
        }
    }

    @Override
    public String getMessage(String code, Object[] args) {
        return getMessage(code, args, LocaleContextHolder.getLocale());
    }

    @Override
    public String getMessage(String code, Locale locale) {
        return getMessage(code, null, locale);
    }

    @Override
    public String getMessage(String code) {
        return getMessage(code, null, LocaleContextHolder.getLocale());
    }

    @Override
    public List<Language> getSupportedLanguages() {
        return Arrays.asList(
            Language.builder()
                .code("zh-CN")
                .name("ç®€ä½“ä¸­æ–‡")
                .nativeName("ç®€ä½“ä¸­æ–‡")
                .locale(Locale.SIMPLIFIED_CHINESE)
                .build(),
            Language.builder()
                .code("zh-TW")
                .name("ç¹é«”ä¸­æ–‡")
                .nativeName("ç¹é«”ä¸­æ–‡")
                .locale(Locale.TRADITIONAL_CHINESE)
                .build(),
            Language.builder()
                .code("en-US")
                .name("English (US)")
                .nativeName("English")
                .locale(Locale.US)
                .build(),
            Language.builder()
                .code("en-GB")
                .name("English (UK)")
                .nativeName("English")
                .locale(Locale.UK)
                .build(),
            Language.builder()
                .code("ja-JP")
                .name("Japanese")
                .nativeName("æ—¥æœ¬èª")
                .locale(Locale.JAPAN)
                .build(),
            Language.builder()
                .code("ko-KR")
                .name("Korean")
                .nativeName("í•œêµ­ì–´")
                .locale(Locale.KOREA)
                .build(),
            Language.builder()
                .code("ar-SA")
                .name("Arabic")
                .nativeName("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©")
                .locale(Locale.forLanguageTag("ar-SA"))
                .build()
        );
    }

    @Override
    public void setLocale(Locale locale, HttpServletRequest request, HttpServletResponse response) {
        localeResolver.setLocale(request, response, locale);
        LocaleContextHolder.setLocale(locale);
    }

    @Override
    public Locale getCurrentLocale(HttpServletRequest request) {
        return localeResolver.resolveLocale(request);
    }
}
```

#### 2.3 å›½é™…åŒ–æ¶ˆæ¯æ–‡ä»¶

```properties
# i18n/messages_zh_CN.properties
common.success=æ“ä½œæˆåŠŸ
common.error=æ“ä½œå¤±è´¥
common.loading=åŠ è½½ä¸­...
common.save=ä¿å­˜
common.cancel=å–æ¶ˆ
common.delete=åˆ é™¤
common.edit=ç¼–è¾‘
common.add=æ–°å¢
common.search=æœç´¢
common.reset=é‡ç½®
common.submit=æäº¤

access.permission.denied=æƒé™ä¸è¶³
access.device.offline=è®¾å¤‡ç¦»çº¿
access.door.opened=é—¨å·²æ‰“å¼€
access.door.closed=é—¨å·²å…³é—­

attendance.clockIn.success=æ‰“å¡æˆåŠŸ
attendance.clockIn.failed=æ‰“å¡å¤±è´¥
attendance.late.warning=æ‚¨å·²è¿Ÿåˆ°
attendance.absent.warning=æ‚¨æœªæ‰“å¡

consume.payment.success=æ”¯ä»˜æˆåŠŸ
consume.payment.failed=æ”¯ä»˜å¤±è´¥
consume.insufficient.balance=ä½™é¢ä¸è¶³
consume.transaction.timeout=äº¤æ˜“è¶…æ—¶

visitor.checkIn.success=ç­¾åˆ°æˆåŠŸ
visitor.checkOut.success=ç­¾å‡ºæˆåŠŸ
visitor.approval.pending=ç­‰å¾…å®¡æ‰¹
visitor.approval.approved=å®¡æ‰¹é€šè¿‡
visitor.approval.rejected=å®¡æ‰¹æ‹’ç»

video.camera.offline=æ‘„åƒå¤´ç¦»çº¿
video.recording.started=å¼€å§‹å½•åˆ¶
video.recording.stopped=åœæ­¢å½•åˆ¶
video.playback.failed=æ’­æ”¾å¤±è´¥

error.400=è¯·æ±‚å‚æ•°é”™è¯¯
error.401=æœªæˆæƒè®¿é—®
error.403=æƒé™ä¸è¶³
error.404=èµ„æºä¸å­˜åœ¨
error.500=ç³»ç»Ÿå†…éƒ¨é”™è¯¯
error.network.timeout=ç½‘ç»œè¯·æ±‚è¶…æ—¶
error.network.unavailable=ç½‘ç»œä¸å¯ç”¨
```

```properties
# i18n/messages_en_US.properties
common.success=Operation successful
common.error=Operation failed
common.loading=Loading...
common.save=Save
common.cancel=Cancel
common.delete=Delete
common.edit=Edit
common.add=Add
common.search=Search
common.reset=Reset
common.submit=Submit

access.permission.denied=Access denied
access.device.offline=Device offline
access.door.opened=Door opened
access.door.closed=Door closed

attendance.clockIn.success=Clock in successful
attendance.clockIn.failed=Clock in failed
attendance.late.warning=You are late
attendance.absent.warning=You haven't clocked in

consume.payment.success=Payment successful
consume.payment.failed=Payment failed
consume.insufficient.balance=Insufficient balance
consume.transaction.timeout=Transaction timeout

visitor.checkIn.success=Check in successful
visitor.checkOut.success=Check out successful
visitor.approval.pending=Approval pending
visitor.approval.approved=Approval approved
visitor.approval.rejected=Approval rejected

video.camera.offline=Camera offline
video.recording.started=Recording started
video.recording.stopped=Recording stopped
video.playback.failed=Playback failed

error.400=Invalid request parameters
error.401=Unauthorized access
error.403=Access denied
error.404=Resource not found
error.500=Internal server error
error.network.timeout=Network request timeout
error.network.unavailable=Network unavailable
```

### 3. æ•°æ®åº“å›½é™…åŒ–

#### 3.1 å¤šè¯­è¨€æ•°æ®æ¨¡å‹

```sql
-- å¤šè¯­è¨€è¡¨ç»“æ„
CREATE TABLE t_i18n_translation (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT 'ä¸»é”®ID',
    entity_type VARCHAR(50) NOT NULL COMMENT 'å®ä½“ç±»å‹',
    entity_id VARCHAR(100) NOT NULL COMMENT 'å®ä½“ID',
    field_name VARCHAR(100) NOT NULL COMMENT 'å­—æ®µåç§°',
    language_code VARCHAR(10) NOT NULL COMMENT 'è¯­è¨€ä»£ç ',
    field_value TEXT COMMENT 'å­—æ®µå€¼',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT 'åˆ›å»ºæ—¶é—´',
    updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT 'æ›´æ–°æ—¶é—´',
    created_by VARCHAR(100) COMMENT 'åˆ›å»ºäºº',
    updated_by VARCHAR(100) COMMENT 'æ›´æ–°äºº',

    INDEX idx_entity (entity_type, entity_id),
    INDEX idx_language (language_code),
    UNIQUE KEY uk_translation (entity_type, entity_id, field_name, language_code)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='å¤šè¯­è¨€ç¿»è¯‘è¡¨';

-- æ”¯æŒçš„è¯­è¨€è¡¨
CREATE TABLE t_i18n_language (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT 'ä¸»é”®ID',
    code VARCHAR(10) NOT NULL UNIQUE COMMENT 'è¯­è¨€ä»£ç ',
    name VARCHAR(100) NOT NULL COMMENT 'è¯­è¨€åç§°',
    native_name VARCHAR(100) NOT NULL COMMENT 'æœ¬åœ°åç§°',
    locale VARCHAR(20) NOT NULL COMMENT 'Locale',
    direction ENUM('ltr', 'rtl') DEFAULT 'ltr' COMMENT 'æ–‡å­—æ–¹å‘',
    is_active TINYINT(1) DEFAULT 1 COMMENT 'æ˜¯å¦å¯ç”¨',
    sort_order INT DEFAULT 0 COMMENT 'æ’åº',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT 'åˆ›å»ºæ—¶é—´',

    INDEX idx_code (code),
    INDEX idx_active (is_active)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='æ”¯æŒçš„è¯­è¨€è¡¨';
```

#### 3.2 å¤šè¯­è¨€æ•°æ®è®¿é—®å±‚

```java
// å¤šè¯­è¨€ç¿»è¯‘å®ä½“
@Data
@TableName("t_i18n_translation")
public class TranslationEntity {

    @TableId(type = IdType.AUTO)
    private Long id;

    @TableField("entity_type")
    private String entityType;

    @TableField("entity_id")
    private String entityId;

    @TableField("field_name")
    private String fieldName;

    @TableField("language_code")
    private String languageCode;

    @TableField("field_value")
    private String fieldValue;

    @TableField(value = "created_time", fill = FieldFill.INSERT)
    private LocalDateTime createdTime;

    @TableField(value = "updated_time", fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updatedTime;

    @TableField("created_by")
    private String createdBy;

    @TableField("updated_by")
    private String updatedBy;
}

// å¤šè¯­è¨€æ•°æ®è®¿é—®æ¥å£
@Mapper
public interface TranslationMapper extends BaseMapper<TranslationEntity> {

    /**
     * æŸ¥è¯¢å®ä½“çš„å¤šè¯­è¨€æ•°æ®
     */
    @Select("SELECT * FROM t_i18n_translation WHERE entity_type = #{entityType} AND entity_id = #{entityId} AND language_code = #{languageCode}")
    TranslationEntity selectByEntityAndLanguage(@Param("entityType") String entityType,
                                                   @Param("entityId") String entityId,
                                                   @Param("languageCode") String languageCode);

    /**
     * æŸ¥è¯¢å®ä½“çš„æ‰€æœ‰è¯­è¨€æ•°æ®
     */
    @Select("SELECT * FROM t_i18n_translation WHERE entity_type = #{entityType} AND entity_id = #{entityId}")
    List<TranslationEntity> selectByEntity(@Param("entityType") String entityType,
                                         @Param("entityId") String entityId);

    /**
     * æ‰¹é‡æŸ¥è¯¢ç¿»è¯‘
     */
    List<TranslationEntity> selectByEntityIds(@Param("entityType") String entityType,
                                              @Param("entityIds") List<String> entityIds,
                                              @Param("languageCode") String languageCode);

    /**
     * åˆ é™¤å®ä½“çš„ç¿»è¯‘æ•°æ®
     */
    @Delete("DELETE FROM t_i18n_translation WHERE entity_type = #{entityType} AND entity_id = #{entityId}")
    int deleteByEntity(@Param("entityType") String entityType,
                       @Param("entityId") String entityId);
}

// å¤šè¯­è¨€æœåŠ¡å®ç°
@Service
@Transactional
public class TranslationService {

    private final TranslationMapper translationMapper;
    private final RedisTemplate<String, String> redisTemplate;

    public TranslationService(TranslationMapper translationMapper, RedisTemplate<String, String> redisTemplate) {
        this.translationMapper = translationMapper;
        this.redisTemplate = redisTemplate;
    }

    /**
     * è·å–ç¿»è¯‘æ–‡æœ¬
     */
    public String getTranslation(String entityType, String entityId, String fieldName, String languageCode) {
        String cacheKey = String.format("translation:%s:%s:%s:%s", entityType, entityId, fieldName, languageCode);

        // ä»ç¼“å­˜è·å–
        String cachedValue = redisTemplate.opsForValue().get(cacheKey);
        if (cachedValue != null) {
            return cachedValue;
        }

        // ä»æ•°æ®åº“è·å–
        TranslationEntity translation = translationMapper.selectByEntityAndLanguage(entityType, entityId, languageCode);
        String value = translation != null ? translation.getFieldValue() : null;

        // ç¼“å­˜ç»“æœ
        if (value != null) {
            redisTemplate.opsForValue().set(cacheKey, value, Duration.ofHours(24));
        }

        return value;
    }

    /**
     * ä¿å­˜ç¿»è¯‘
     */
    public void saveTranslation(String entityType, String entityId, String fieldName, String languageCode, String value, String operator) {
        TranslationEntity translation = new TranslationEntity();
        translation.setEntityType(entityType);
        translation.setEntityId(entityId);
        translation.setFieldName(fieldName);
        translation.setLanguageCode(languageCode);
        translation.setFieldValue(value);
        translation.setUpdatedBy(operator);

        TranslationEntity existing = translationMapper.selectByEntityAndLanguage(entityType, entityId, languageCode);

        if (existing != null) {
            translation.setId(existing.getId());
            translation.setCreatedTime(existing.getCreatedTime());
            translation.setCreatedBy(existing.getCreatedBy());
            translationMapper.updateById(translation);
        } else {
            translation.setCreatedBy(operator);
            translationMapper.insert(translation);
        }

        // æ¸…é™¤ç¼“å­˜
        String cacheKey = String.format("translation:%s:%s:%s:%s", entityType, entityId, fieldName, languageCode);
        redisTemplate.delete(cacheKey);
    }

    /**
     * è·å–å®ä½“çš„æ‰€æœ‰ç¿»è¯‘
     */
    public Map<String, Map<String, String>> getAllTranslations(String entityType, String entityId) {
        List<TranslationEntity> translations = translationMapper.selectByEntity(entityType, entityId);

        return translations.stream()
                .collect(Collectors.groupingBy(
                    TranslationEntity::getLanguageCode,
                    Collectors.toMap(
                        TranslationEntity::getFieldName,
                        TranslationEntity::getFieldValue
                    )
                ));
    }

    /**
     * æ‰¹é‡è·å–ç¿»è¯‘
     */
    public Map<String, Map<String, String>> batchGetTranslations(String entityType, List<String> entityIds, String languageCode) {
        List<TranslationEntity> translations = translationMapper.selectByEntityIds(entityType, entityIds, languageCode);

        return translations.stream()
                .collect(Collectors.groupingBy(
                    TranslationEntity::getEntityId,
                    Collectors.toMap(
                        TranslationEntity::getFieldName,
                        TranslationEntity::getFieldValue
                    )
                ));
    }
}
```

### 4. æ ¼å¼åŒ–å·¥å…·

#### 4.1 æ—¥æœŸæ—¶é—´æ ¼å¼åŒ–

```typescript
// æ—¥æœŸæ—¶é—´æ ¼å¼åŒ–å·¥å…·
export class DateTimeFormatter {
  private static readonly FORMATS = {
    'zh-CN': {
      date: 'YYYYå¹´MMæœˆDDæ—¥',
      time: 'HH:mm:ss',
      datetime: 'YYYYå¹´MMæœˆDDæ—¥ HH:mm:ss',
      shortDate: 'MM/DD',
      shortTime: 'HH:mm'
    },
    'en-US': {
      date: 'MM/DD/YYYY',
      time: 'h:mm:ss A',
      datetime: 'MM/DD/YYYY h:mm:ss A',
      shortDate: 'M/D/YY',
      shortTime: 'h:mm A'
    },
    'ja-JP': {
      date: 'YYYYå¹´MMæœˆDDæ—¥',
      time: 'HH:mm:ss',
      datetime: 'YYYYå¹´MMæœˆDDæ—¥ HH:mm:ss',
      shortDate: 'MM/DD',
      shortTime: 'HH:mm'
    },
    'ko-KR': {
      date: 'YYYY. MM. DD.',
      time: 'HH:mm:ss',
      datetime: 'YYYY. MM. DD. HH:mm:ss',
      shortDate: 'MM. DD.',
      shortTime: 'HH:mm'
    }
  };

  static formatDate(date: Date, locale: string = 'zh-CN'): string {
    const format = this.FORMATS[locale as keyof typeof this.FORMATS]?.date || this.FORMATS['zh-CN'].date;
    return dayjs(date).locale(this.getDayjsLocale(locale)).format(format);
  }

  static formatTime(date: Date, locale: string = 'zh-CN'): string {
    const format = this.FORMATS[locale as keyof typeof this.FORMATS]?.time || this.FORMATS['zh-CN'].time;
    return dayjs(date).locale(this.getDayjsLocale(locale)).format(format);
  }

  static formatDateTime(date: Date, locale: string = 'zh-CN'): string {
    const format = this.FORMATS[locale as keyof typeof this.FORMATS]?.datetime || this.FORMATS['zh-CN'].datetime;
    return dayjs(date).locale(this.getDayjsLocale(locale)).format(format);
  }

  static formatRelativeTime(date: Date, locale: string = 'zh-CN'): string {
    dayjs.extend(relativeTime);
    dayjs.locale(this.getDayjsLocale(locale));
    return dayjs(date).fromNow();
  }

  private static getDayjsLocale(locale: string): string {
    const localeMap: Record<string, string> = {
      'zh-CN': 'zh-cn',
      'zh-TW': 'zh-tw',
      'en-US': 'en',
      'en-GB': 'en-gb',
      'ja-JP': 'ja',
      'ko-KR': 'ko',
      'ar-SA': 'ar'
    };
    return localeMap[locale] || 'zh-cn';
  }
}
```

#### 4.2 æ•°å­—æ ¼å¼åŒ–

```typescript
// æ•°å­—æ ¼å¼åŒ–å·¥å…·
export class NumberFormatter {
  private static readonly FORMATS = {
    'zh-CN': {
      decimal: '#,##0.##',
      currency: '#,##0.## Â¥',
      percent: '#,##0.##%'
    },
    'en-US': {
      decimal: '#,##0.##',
      currency: '#,##0.##',
      percent: '#,##0.##%'
    },
    'ja-JP': {
      decimal: '#,##0.##',
      currency: '#,##0.## Â¥',
      percent: '#,##0.##%'
    }
  };

  static formatNumber(number: number, locale: string = 'zh-CN'): string {
    const format = this.FORMATS[locale as keyof typeof this.FORMATS]?.decimal || this.FORMATS['zh-CN'].decimal;

    // ä½¿ç”¨Intl.NumberFormatè¿›è¡Œæ ¼å¼åŒ–
    return new Intl.NumberFormat(locale.replace('-', '-'), {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(number);
  }

  static formatCurrency(number: number, currency: string, locale: string = 'zh-CN'): string {
    return new Intl.NumberFormat(locale.replace('-', '-'), {
      style: 'currency',
      currency: currency
    }).format(number);
  }

  static formatPercent(number: number, locale: string = 'zh-CN'): string {
    return new Intl.NumberFormat(locale.replace('-', '-'), {
      style: 'percent',
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(number);
  }

  static formatFileSize(bytes: number, locale: string = 'zh-CN'): string {
    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
    let size = bytes;
    let unitIndex = 0;

    while (size >= 1024 && unitIndex < units.length - 1) {
      size /= 1024;
      unitIndex++;
    }

    const formatter = new Intl.NumberFormat(locale.replace('-', '-'), {
      minimumFractionDigits: 0,
      maximumFractionDigits: 2
    });

    return `${formatter.format(size)} ${units[unitIndex]}`;
  }
}
```

---

## ğŸ“± å¹³å°ç‰¹å®šå®ç°

### 1. å¾®ä¿¡å°ç¨‹åºå›½é™…åŒ–

#### 1.1 å°ç¨‹åºå›½é™…åŒ–é…ç½®

```javascript
// miniprogram/i18n/index.js
const defaultLanguage = 'zh-CN';

// è¯­è¨€åŒ…
const messages = {
  'zh-CN': require('./locales/zh-CN'),
  'zh-TW': require('./locales/zh-TW'),
  'en-US': require('./locales/en-US'),
  'ja-JP': require('./locales/ja-JP')
};

class I18n {
  constructor() {
    this.currentLanguage = this.getStoredLanguage() || defaultLanguage;
    this.messages = messages[this.currentLanguage] || messages[defaultLanguage];
  }

  // è·å–å­˜å‚¨çš„è¯­è¨€
  getStoredLanguage() {
    try {
      return wx.getStorageSync('language');
    } catch (error) {
      console.error('è·å–è¯­è¨€è®¾ç½®å¤±è´¥:', error);
      return null;
    }
  }

  // å­˜å‚¨è¯­è¨€è®¾ç½®
  setStoredLanguage(language) {
    try {
      wx.setStorageSync('language', language);
    } catch (error) {
      console.error('å­˜å‚¨è¯­è¨€è®¾ç½®å¤±è´¥:', error);
    }
  }

  // åˆ‡æ¢è¯­è¨€
  changeLanguage(language) {
    if (messages[language]) {
      this.currentLanguage = language;
      this.messages = messages[language];
      this.setStoredLanguage(language);

      // è§¦å‘è¯­è¨€å˜æ›´äº‹ä»¶
      wx.eventBus.emit('languageChanged', language);
    }
  }

  // è·å–ç¿»è¯‘æ–‡æœ¬
  t(key, params = {}) {
    const keys = key.split('.');
    let value = this.messages;

    for (const k of keys) {
      value = value?.[k];
    }

    if (typeof value === 'string' && Object.keys(params).length > 0) {
      // å‚æ•°æ›¿æ¢
      return value.replace(/\{\{(\w+)\}\}/g, (match, paramKey) => {
        return params[paramKey] || match;
      });
    }

    return value || key;
  }

  // è·å–å½“å‰è¯­è¨€
  getCurrentLanguage() {
    return this.currentLanguage;
  }

  // æ£€æµ‹ç³»ç»Ÿè¯­è¨€
  detectSystemLanguage() {
    const systemInfo = wx.getSystemInfoSync();
    const systemLanguage = systemInfo.language;

    // è¯­è¨€æ˜ å°„
    const languageMap = {
      'zh-cn': 'zh-CN',
      'zh-tw': 'zh-TW',
      'zh-hk': 'zh-TW',
      'en': 'en-US',
      'ja': 'ja-JP',
      'ko': 'ko-KR'
    };

    return languageMap[systemLanguage.toLowerCase()] || defaultLanguage;
  }

  // åˆå§‹åŒ–å›½é™…åŒ–
  init() {
    const storedLanguage = this.getStoredLanguage();
    const systemLanguage = this.detectSystemLanguage();

    const initLanguage = storedLanguage || systemLanguage;
    this.changeLanguage(initLanguage);
  }
}

// å¯¼å‡ºå•ä¾‹
const i18n = new I18n();
module.exports = i18n;
```

#### 1.2 å°ç¨‹åºè¯­è¨€åŒ…ç»“æ„

```javascript
// miniprogram/i18n/locales/zh-CN.js
module.exports = {
  common: {
    title: 'IOE-DREAMæ™ºæ…§å›­åŒº',
    loading: 'åŠ è½½ä¸­...',
    confirm: 'ç¡®å®š',
    cancel: 'å–æ¶ˆ',
    save: 'ä¿å­˜',
    delete: 'åˆ é™¤',
    edit: 'ç¼–è¾‘',
    add: 'æ–°å¢',
    search: 'æœç´¢'
  },

  attendance: {
    clockIn: 'æ‰“å¡',
    clockOut: 'ç­¾é€€',
    workShift: 'ç­æ¬¡',
    department: 'éƒ¨é—¨',
    todayRecord: 'ä»Šæ—¥è®°å½•',
    clockInSuccess: 'æ‰“å¡æˆåŠŸ',
    clockInFailed: 'æ‰“å¡å¤±è´¥',
    lateWarning: 'æ‚¨å·²è¿Ÿåˆ°'
  },

  access: {
    openDoor: 'å¼€é—¨',
    closeDoor: 'å…³é—¨',
    permission: 'æƒé™',
    accessArea: 'è®¿é—®åŒºåŸŸ',
    openSuccess: 'å¼€é—¨æˆåŠŸ',
    openFailed: 'å¼€é—¨å¤±è´¥'
  },

  consume: {
    payment: 'æ”¯ä»˜',
    balance: 'ä½™é¢',
    recharge: 'å……å€¼',
    transaction: 'äº¤æ˜“',
    paymentSuccess: 'æ”¯ä»˜æˆåŠŸ',
    insufficientBalance: 'ä½™é¢ä¸è¶³'
  },

  visitor: {
    appointment: 'é¢„çº¦',
    checkIn: 'ç­¾åˆ°',
    checkOut: 'ç­¾å‡º',
    visitor: 'è®¿å®¢',
    host: 'æ¥å¾…äºº',
    approval: 'å®¡æ‰¹'
  },

  errors: {
    networkError: 'ç½‘ç»œè¿æ¥å¤±è´¥',
    serverError: 'æœåŠ¡å™¨é”™è¯¯',
    permissionDenied: 'æƒé™ä¸è¶³',
    resourceNotFound: 'èµ„æºä¸å­˜åœ¨',
    requestTimeout: 'è¯·æ±‚è¶…æ—¶'
  }
};
```

### 2. ç§»åŠ¨ç«¯å›½é™…åŒ–

#### 2.1 React Native å›½é™…åŒ–

```typescript
// mobile/i18n/index.ts
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import { Platform } from 'react-native';
import * as RNLocalize from 'react-native-localize';

// è¯­è¨€èµ„æº
import zhCN from './locales/zh-CN';
import zhTW from './locales/zh-TW';
import enUS from './locales/en-US';
import jaJP from './locales/ja-JP';
import koKR from './locales/ko-KR';

const resources = {
  'zh-CN': zhCN,
  'zh-TW': zhTW,
  'en-US': enUS,
  'ja-JP': jaJP,
  'ko-KR': koKR
};

// æ£€æµ‹æœ€ä½³è¯­è¨€
const getBestLanguage = () => {
  const fallback = { languageTag: 'zh-CN', isRTL: false };

  if (Platform.OS === 'ios') {
    const locales = RNLocalize.getLocales();
    const bestLanguage = RNLocalize.findBestAvailableLanguage(Object.keys(resources));

    if (bestLanguage) {
      return {
        languageTag: bestLanguage.languageTag,
        isRTL: RNLocalize.isRTL(bestLanguage.languageTag)
      };
    }
  } else {
    const locale = RNLocalize.getLocales()[0];
    const bestLanguage = Object.keys(resources).find(key => key.startsWith(locale));

    if (bestLanguage) {
      return {
        languageTag: bestLanguage,
        isRTL: RNLocalize.isRTL(bestLanguage)
      };
    }
  }

  return fallback;
};

// åˆå§‹åŒ–i18n
i18n
  .use(initReactI18next)
  .init({
    resources,
    lng: getBestLanguage().languageTag,
    fallbackLng: 'zh-CN',

    interpolation: {
      escapeValue: false
    },

    react: {
      useSuspense: false
    }
  });

export default i18n;
```

#### 2.2 ç§»åŠ¨ç«¯è¯­è¨€åˆ‡æ¢ç»„ä»¶

```typescript
// mobile/components/LanguageSelector.tsx
import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Modal } from 'react-native';
import { useTranslation } from 'react-i18next';
import { Picker } from '@react-native-picker/picker';
import { RNLocalize } from 'react-native-localize';

interface Language {
  code: string;
  name: string;
  nativeName: string;
  flag: string;
}

const languages: Language[] = [
  { code: 'zh-CN', name: 'Chinese (Simplified)', nativeName: 'ç®€ä½“ä¸­æ–‡', flag: 'ğŸ‡¨ğŸ‡³' },
  { code: 'zh-TW', name: 'Chinese (Traditional)', nativeName: 'ç¹é«”ä¸­æ–‡', flag: 'ğŸ‡¹ğŸ‡¼' },
  { code: 'en-US', name: 'English (US)', nativeName: 'English', flag: 'ğŸ‡ºğŸ‡¸' },
  { code: 'ja-JP', name: 'Japanese', nativeName: 'æ—¥æœ¬èª', flag: 'ğŸ‡¯ğŸ‡µ' },
  { code: 'ko-KR', name: 'Korean', nativeName: 'í•œêµ­ì–´', flag: 'ğŸ‡°ğŸ‡·' }
];

interface LanguageSelectorProps {
  style?: any;
  showFlag?: boolean;
  showNativeName?: boolean;
}

export const LanguageSelector: React.FC<LanguageSelectorProps> = ({
  style,
  showFlag = true,
  showNativeName = true
}) => {
  const { i18n, t } = useTranslation();
  const [modalVisible, setModalVisible] = React.useState(false);

  const currentLanguage = languages.find(lang => lang.code === i18n.language) || languages[0];

  const handleLanguageChange = (languageCode: string) => {
    i18n.changeLanguage(languageCode);

    // ä¿å­˜ç”¨æˆ·åå¥½
    try {
      // ä¿å­˜åˆ°AsyncStorage
      require('@react-native-async-storage/async-storage').default
        .setItem('@language', languageCode);

      // æ›´æ–°RTLæ–¹å‘
      const isRTL = RNLocalize.isRTL(languageCode);
      // åœ¨React Nativeä¸­å¤„ç†RTLå¸ƒå±€
    } catch (error) {
      console.error('ä¿å­˜è¯­è¨€è®¾ç½®å¤±è´¥:', error);
    }

    setModalVisible(false);
  };

  return (
    <>
      <TouchableOpacity
        style={[styles.container, style]}
        onPress={() => setModalVisible(true)}
      >
        {showFlag && <Text style={styles.flag}>{currentLanguage.flag}</Text>}
        <Text style={styles.text}>
          {showNativeName ? currentLanguage.nativeName : currentLanguage.name}
        </Text>
      </TouchableOpacity>

      <Modal
        visible={modalVisible}
        transparent={true}
        animationType="slide"
        onRequestClose={() => setModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>{t('common.selectLanguage')}</Text>
              <TouchableOpacity onPress={() => setModalVisible(false)}>
                <Text style={styles.closeButton}>âœ•</Text>
              </TouchableOpacity>
            </View>

            <Picker
              selectedValue={i18n.language}
              onValueChange={handleLanguageChange}
              itemStyle={styles.pickerItem}
            >
              {languages.map((language) => (
                <Picker.Item
                  key={language.code}
                  label={`${language.flag} ${language.nativeName}`}
                  value={language.code}
                />
              ))}
            </Picker>
          </View>
        </View>
      </Modal>
    </>
  );
};

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 8,
    backgroundColor: '#f5f5f5',
    borderRadius: 8
  },
  flag: {
    fontSize: 20,
    marginRight: 8
  },
  text: {
    fontSize: 16,
    color: '#333'
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center'
  },
  modalContent: {
    backgroundColor: 'white',
    borderRadius: 16,
    padding: 20,
    width: '80%',
    maxHeight: '50%'
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold'
  },
  closeButton: {
    fontSize: 20,
    color: '#666'
  },
  pickerItem: {
    fontSize: 16
  }
});
```

---

## ğŸ”§ ç¿»è¯‘ç®¡ç†ç³»ç»Ÿ

### 1. ç¿»è¯‘å·¥ä½œæµ

```mermaid
graph TD
    A[ç¿»è¯‘éœ€æ±‚è¯†åˆ«] --> B[ç¿»è¯‘èµ„æºæå–]
    B --> C[ç¿»è¯‘ä»»åŠ¡åˆ†é…]
    C --> D[ä¸“ä¸šç¿»è¯‘æ‰§è¡Œ]
    D --> E[ç¿»è¯‘è´¨é‡å®¡æ ¸]
    E --> F{å®¡æ ¸é€šè¿‡?}
    F -->|å¦| G[ä¿®æ”¹å’Œå®Œå–„]
    G --> D
    F -->|æ˜¯| H[ç¿»è¯‘èµ„æºé›†æˆ]
    H --> I[å¤šè¯­è¨€æµ‹è¯•]
    I --> J{æµ‹è¯•é€šè¿‡?}
    J -->|å¦| K[é—®é¢˜ä¿®å¤]
    K --> H
    J -->|æ˜¯| L[å‘å¸ƒä¸Šçº¿]
    L --> M[ä½¿ç”¨åé¦ˆæ”¶é›†]
    M --> A
```

### 2. ç¿»è¯‘èµ„æºæå–å·¥å…·

```typescript
// ç¿»è¯‘èµ„æºæå–å·¥å…·
interface TranslationExtraction {
  extractFromReact(files: string[]): Promise<TranslationKeys>;
  extractFromJava(files: string[]): Promise<TranslationKeys>;
  extractFromDatabase(tables: string[]): Promise<TranslationKeys>;
  mergeExtractedData(data: TranslationKeys[]): TranslationKeys;
  generateTranslationFiles(keys: TranslationKeys, languages: string[]): Promise<void>;
}

class TranslationExtractor implements TranslationExtraction {
  private readonly REACT_I18N_PATTERNS = [
    /t\(['"`]([^'"`]+)['"`](?:,\s*({[^}]*}))?\)/g,
    /i18n\.t\(['"`]([^'"`]+)['"`](?:,\s*({[^}]*}))?\)/g,
    /useTranslation\(\)\.t\(['"`]([^'"`]+)['"`](?:,\s*({[^}]*}))?\)/g
  ];

  private readonly JAVA_I18N_PATTERNS = [
    /messageSource\.getMessage\(['"`]([^'"`]+)['"`]/g,
    /@Value\(['"`]\$\{([^}]+)\}['"`]\)/g,
    /ResourceBundle\.getString\(['"`]([^'"`]+)['"`]\)/g
  ];

  async extractFromReact(files: string[]): Promise<TranslationKeys> {
    const keys = new Set<string>();

    for (const file of files) {
      const content = await fs.readFile(file, 'utf8');

      this.REACT_I18N_PATTERNS.forEach(pattern => {
        let match;
        while ((match = pattern.exec(content)) !== null) {
          keys.add(match[1]);
        }
      });
    }

    return {
      react: Array.from(keys)
    };
  }

  async extractFromJava(files: string[]): Promise<TranslationKeys> {
    const keys = new Set<string>();

    for (const file of files) {
      const content = await fs.readFile(file, 'utf8');

      this.JAVA_I18N_PATTERNS.forEach(pattern => {
        let match;
        while ((match = pattern.exec(content)) !== null) {
          keys.add(match[1]);
        }
      });
    }

    return {
      java: Array.from(keys)
    };
  }

  async extractFromDatabase(tables: string[]): Promise<TranslationKeys> {
    const keys = new Set<string>();

    // è¿æ¥æ•°æ®åº“å¹¶æŸ¥è¯¢å¤šè¯­è¨€è¡¨
    const connection = await mysql.createConnection(dbConfig);

    for (const table of tables) {
      try {
        const [rows] = await connection.execute(
          `SELECT DISTINCT field_name FROM ${table} WHERE entity_type != ''`
        );

        rows.forEach(row => {
          keys.add(row.field_name);
        });
      } catch (error) {
        console.error(`æŸ¥è¯¢è¡¨ ${table} å¤±è´¥:`, error);
      }
    }

    await connection.end();

    return {
      database: Array.from(keys)
    };
  }

  mergeExtractedData(data: TranslationKeys[]): TranslationKeys {
    const merged = {
      all: new Set<string>(),
      react: [],
      java: [],
      database: []
    };

    data.forEach(item => {
      if (item.react) {
        merged.react.push(...item.react);
        item.react.forEach(key => merged.all.add(key));
      }
      if (item.java) {
        merged.java.push(...item.java);
        item.java.forEach(key => merged.all.add(key));
      }
      if (item.database) {
        merged.database.push(...item.database);
        item.database.forEach(key => merged.all.add(key));
      }
    });

    return {
      all: Array.from(merged.all).sort(),
      react: [...new Set(merged.react)].sort(),
      java: [...new Set(merged.java)].sort(),
      database: [...new Set(merged.database)].sort()
    };
  }

  async generateTranslationFiles(keys: TranslationKeys, languages: string[]): Promise<void> {
    const defaultTranslations = {
      common: {
        'app.title': 'IOE-DREAMæ™ºæ…§å›­åŒº',
        'app.description': 'æ™ºæ…§å›­åŒºç®¡ç†ç³»ç»Ÿ'
      }
    };

    for (const language of languages) {
      const translations: Record<string, any> = {};

      // åˆå§‹åŒ–é»˜è®¤ç¿»è¯‘
      Object.keys(defaultTranslations).forEach(namespace => {
        translations[namespace] = { ...defaultTranslations[namespace as keyof typeof defaultTranslations] };
      });

      // ä¸ºæ¯ä¸ªkeyç”Ÿæˆå ä½ç¬¦ç¿»è¯‘
      keys.all.forEach(key => {
        const [namespace, ...pathParts] = key.split('.');
        if (!translations[namespace]) {
          translations[namespace] = {};
        }

        let current = translations[namespace];
        pathParts.forEach((part, index) => {
          if (index === pathParts.length - 1) {
            current[part] = `[${key}]`; // æ ‡è®°éœ€è¦ç¿»è¯‘
          } else {
            if (!current[part]) {
              current[part] = {};
            }
            current = current[part];
          }
        });
      });

      // ç”Ÿæˆç¿»è¯‘æ–‡ä»¶
      const filePath = path.join(process.cwd(), 'src/i18n/locales', language, 'generated.json');
      await fs.ensureDir(path.dirname(filePath));
      await fs.writeFile(filePath, JSON.stringify(translations, null, 2), 'utf8');
    }
  }
}
```

### 3. è‡ªåŠ¨åŒ–ç¿»è¯‘æ£€æŸ¥

```typescript
// ç¿»è¯‘è´¨é‡æ£€æŸ¥å·¥å…·
interface TranslationQualityChecker {
  checkMissingTranslations(): Promise<TranslationCheckResult>;
  checkInconsistentKeys(): Promise<TranslationCheckResult>;
  checkUnusedKeys(): Promise<TranslationCheckResult>;
  generateReport(checks: TranslationCheckResult[]): Promise<TranslationReport>;
}

class TranslationQualityChecker implements TranslationQualityChecker {
  private readonly supportedLanguages = ['zh-CN', 'zh-TW', 'en-US', 'en-GB', 'ja-JP', 'ko-KR', 'ar-SA'];
  private readonly baseLanguage = 'zh-CN';

  async checkMissingTranslations(): Promise<TranslationCheckResult> {
    const result: TranslationCheckResult = {
      type: 'missing-translations',
      issues: [],
      summary: { total: 0, resolved: 0, pending: 0 }
    };

    // è·å–åŸºç¡€è¯­è¨€çš„æ‰€æœ‰key
    const baseKeys = await this.getAllTranslationKeys(this.baseLanguage);

    // æ£€æŸ¥æ¯ç§è¯­è¨€çš„ç¼ºå¤±ç¿»è¯‘
    for (const language of this.supportedLanguages) {
      if (language === this.baseLanguage) continue;

      const languageKeys = await this.getAllTranslationKeys(language);
      const missingKeys = baseKeys.filter(key => !languageKeys.includes(key));

      missingKeys.forEach(key => {
        result.issues.push({
          type: 'missing',
          language,
          key,
          severity: 'error',
          description: `Missing translation for key "${key}" in ${language}`
        });
      });
    }

    result.summary = {
      total: result.issues.length,
      resolved: 0,
      pending: result.issues.length
    };

    return result;
  }

  async checkInconsistentKeys(): Promise<TranslationCheckResult> {
    const result: TranslationCheckResult = {
      type: 'inconsistent-keys',
      issues: [],
      summary: { total: 0, resolved: 0, pending: 0 }
    };

    const allKeys = await this.getAllTranslationKeys(this.baseLanguage);

    for (const key of allKeys) {
      const keyStructure = key.split('.');

      // æ£€æŸ¥é”®åçš„ä¸€è‡´æ€§ï¼ˆä½¿ç”¨é©¼å³°å‘½åæˆ–ä¸‹åˆ’çº¿å‘½åï¼‰
      const isCamelCase = /^[a-z][a-zA-Z0-9]*$/.test(key);
      const isSnakeCase = /^[a-z][a-z0-9_]*$/.test(key);

      if (!isCamelCase && !isSnakeCase) {
        result.issues.push({
          type: 'inconsistent',
          key,
          severity: 'warning',
          description: `Key "${key}" uses inconsistent naming convention`
        });
      }

      // æ£€æŸ¥æ˜¯å¦ä½¿ç”¨äº†å‘½åç©ºé—´
      if (keyStructure.length < 2) {
        result.issues.push({
          type: 'inconsistent',
          key,
          severity: 'warning',
          description: `Key "${key}" should include namespace (e.g., "common.${key}")`
        });
      }
    }

    result.summary = {
      total: result.issues.length,
      resolved: 0,
      pending: result.issues.length
    };

    return result;
  }

  async checkUnusedKeys(): Promise<TranslationCheckResult> {
    const result: TranslationCheckResult = {
      type: 'unused-keys',
      issues: [],
      summary: { total: 0, resolved: 0, pending: 0 }
    };

    // æ‰«æä»£ç ä¸­å®é™…ä½¿ç”¨çš„ç¿»è¯‘key
    const usedKeys = await this.scanCodeForTranslationKeys();
    const definedKeys = await this.getAllTranslationKeys(this.baseLanguage);

    const unusedKeys = definedKeys.filter(key => !usedKeys.includes(key));

    unusedKeys.forEach(key => {
      result.issues.push({
        type: 'unused',
        key,
        severity: 'warning',
        description: `Key "${key}" is defined but not used in code`
      });
    });

    result.summary = {
      total: result.issues.length,
      resolved: 0,
      pending: result.issues.length
    };

    return result;
  }

  private async getAllTranslationKeys(language: string): Promise<string[]> {
    const keys = new Set<string>();
    const translationPath = path.join(process.cwd(), 'src/i18n/locales', language);

    const traverseObject = (obj: any, prefix = '') => {
      Object.keys(obj).forEach(key => {
        const fullKey = prefix ? `${prefix}.${key}` : key;

        if (typeof obj[key] === 'object' && obj[key] !== null) {
          traverseObject(obj[key], fullKey);
        } else {
          keys.add(fullKey);
        }
      });
    };

    const files = await fs.readdir(translationPath);

    for (const file of files) {
      if (file.endsWith('.json')) {
        const content = await fs.readJson(path.join(translationPath, file));
        traverseObject(content);
      }
    }

    return Array.from(keys);
  }

  private async scanCodeForTranslationKeys(): Promise<string[]> {
    const usedKeys = new Set<string>();
    const codeDirectories = ['src', 'components', 'pages'];

    const scanFile = async (filePath: string) => {
      const content = await fs.readFile(filePath, 'utf8');
      const patterns = [
        /t\(['"`]([^'"`]+)['"`]/g,
        /i18n\.t\(['"`]([^'"`]+)['"`]/g,
        /useTranslation\(\)\.t\(['"`]([^'"`]+)['"`]/g
      ];

      patterns.forEach(pattern => {
        let match;
        while ((match = pattern.exec(content)) !== null) {
          usedKeys.add(match[1]);
        }
      });
    };

    for (const dir of codeDirectories) {
      if (await fs.pathExists(dir)) {
        const files = await fs.readdir(dir, { withFileTypes: true });

        for (const file of files) {
          const filePath = path.join(dir, file.name);

          if (file.isDirectory()) {
            // é€’å½’æ‰«æå­ç›®å½•
            const subFiles = await fs.readdir(filePath);
            for (const subFile of subFiles) {
              if (subFile.endsWith('.tsx') || subFile.endsWith('.ts') || subFile.endsWith('.js') || subFile.endsWith('.jsx')) {
                await scanFile(path.join(filePath, subFile));
              }
            }
          } else if (file.name.match(/\.(ts|tsx|js|jsx)$/)) {
            await scanFile(filePath);
          }
        }
      }
    }

    return Array.from(usedKeys);
  }

  async generateReport(checks: TranslationCheckResult[]): Promise<TranslationReport> {
    const report: TranslationReport = {
      timestamp: new Date().toISOString(),
      summary: {
        totalIssues: 0,
        resolved: 0,
        pending: 0,
        byType: {} as Record<string, { total: number; resolved: number; pending: number }>
      },
      details: []
    };

    checks.forEach(check => {
      report.summary.totalIssues += check.summary.total;
      report.summary.resolved += check.summary.resolved;
      report.summary.pending += check.summary.pending;

      report.summary.byType[check.type] = {
        total: check.summary.total,
        resolved: check.summary.resolved,
        pending: check.summary.pending
      };

      report.details.push(...check.issues);
    });

    // æŒ‰ä¸¥é‡ç¨‹åº¦æ’åº
    report.details.sort((a, b) => {
      const severityOrder = { error: 0, warning: 1, info: 2 };
      return severityOrder[a.severity as keyof typeof severityOrder] - severityOrder[b.severity as keyof typeof severityOrder];
    });

    return report;
  }
}
```

---

## ğŸ“‹ å›½é™…åŒ–æ£€æŸ¥æ¸…å•

### âœ… æŠ€æœ¯å®ç°
- [ ] å‰ç«¯i18næ¡†æ¶æ­£ç¡®é…ç½®
- [ ] åç«¯å›½é™…åŒ–æ”¯æŒå®Œæ•´
- [ ] æ•°æ®åº“å¤šè¯­è¨€è¡¨è®¾è®¡
- [ ] è¯­è¨€æ£€æµ‹å’Œåˆ‡æ¢æœºåˆ¶
- [ ] ç¼“å­˜ç­–ç•¥å®æ–½

### âœ… è¯­è¨€æ”¯æŒ
- [ ] è‡³å°‘æ”¯æŒ5ç§ä¸»è¦è¯­è¨€
- [ ] è¯­è¨€å›é€€é“¾é…ç½®
- [ ] RTLè¯­è¨€æ”¯æŒ
- [ ] æœ¬åœ°åŒ–æ—¥æœŸæ—¶é—´æ ¼å¼
- [ ] æœ¬åœ°åŒ–æ•°å­—å’Œè´§å¸æ ¼å¼

### âœ… ç¿»è¯‘è´¨é‡
- [ ] ç¿»è¯‘å®Œæ•´æ€§æ£€æŸ¥é€šè¿‡
- [ ] æœ¯è¯­ä¸€è‡´æ€§æ£€æŸ¥
- [ ] æ–‡åŒ–é€‚åº”æ€§éªŒè¯
- [ ] è¯­æ³•é”™è¯¯æ£€æŸ¥
- [ ] ä¸Šä¸‹æ–‡å‡†ç¡®æ€§éªŒè¯

### âœ… ç”¨æˆ·ä½“éªŒ
- [ ] è¯­è¨€é€‰æ‹©å™¨æ˜“ç”¨
- [ ] åˆ‡æ¢è¯­è¨€å³æ—¶ç”Ÿæ•ˆ
- [ ] ä¿æŒç”¨æˆ·çŠ¶æ€
- [ ] æ”¯æŒæœç´¢ç¿»è¯‘
- [ ] é”™è¯¯ä¿¡æ¯æœ¬åœ°åŒ–

### âœ… æ€§èƒ½ä¼˜åŒ–
- [ ] è¯­è¨€åŒ…æ‡’åŠ è½½
- [ ] ç¿»è¯‘ç¼“å­˜ç­–ç•¥
- [ ] é¿å…é‡å¤è¯·æ±‚
- [ ] å‹ç¼©è¯­è¨€åŒ…å¤§å°
- [ ] CDNåˆ†å‘ä¼˜åŒ–

### âœ… ç»´æŠ¤ç®¡ç†
- [ ] ç¿»è¯‘å·¥ä½œæµå»ºç«‹
- [ ] è‡ªåŠ¨åŒ–æ£€æŸ¥å·¥å…·
- [ ] ç‰ˆæœ¬ç®¡ç†è§„èŒƒ
- [ ] ç¿»è¯‘æ›´æ–°æœºåˆ¶
- [ ] è´¨é‡ç›‘æ§ä½“ç³»

---

**ğŸ“ æ–‡æ¡£ç»´æŠ¤**: IOE-DREAMå›½é™…åŒ–å§”å‘˜ä¼š
**ğŸ”„ æ›´æ–°å‘¨æœŸ**: æ¯æœˆæ›´æ–°ç¿»è¯‘å†…å®¹ï¼Œæ¯å­£åº¦æ›´æ–°æŠ€æœ¯æ–¹æ¡ˆ
**âœ… å®¡æ ¸çŠ¶æ€**: å·²é€šè¿‡å›½é™…åŒ–å§”å‘˜ä¼šå’ŒæŠ€æœ¯å§”å‘˜ä¼šè”åˆå®¡æ ¸