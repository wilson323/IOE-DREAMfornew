# IOE-DREAMç§»åŠ¨ç«¯é›†æˆè®¾è®¡æ–‡æ¡£

> **ç‰ˆæœ¬**: v1.0.0
> **åˆ›å»ºæ—¥æœŸ**: 2025-12-21
> **é€‚ç”¨èŒƒå›´**: IOE-DREAMæ™ºæ…§å›­åŒºç®¡ç†ç³»ç»Ÿç§»åŠ¨ç«¯é›†æˆ
> **ç»´æŠ¤æœºæ„**: IOE-DREAMæ¶æ„å§”å‘˜ä¼š

---

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£ä¸ºIOE-DREAMæ™ºæ…§å›­åŒºç®¡ç†ç³»ç»Ÿæä¾›å®Œæ•´çš„ç§»åŠ¨ç«¯é›†æˆè®¾è®¡æ–¹æ¡ˆï¼Œæ¶µç›–ç§»åŠ¨APPã€å°ç¨‹åºã€H5åº”ç”¨ç­‰å¤šç§ç§»åŠ¨ç«¯å½¢æ€çš„é›†æˆæ ‡å‡†ã€æŠ€æœ¯å®ç°å’Œæœ€ä½³å®è·µã€‚

### ğŸ¯ è®¾è®¡ç›®æ ‡

- **ç»Ÿä¸€ä½“éªŒ**: ç¡®ä¿å¤šç«¯ç”¨æˆ·ä½“éªŒä¸€è‡´æ€§
- **é«˜æ€§èƒ½**: ä¼˜åŒ–ç§»åŠ¨ç«¯æ€§èƒ½ï¼Œæå‡ç”¨æˆ·ä½“éªŒ
- **æ˜“é›†æˆ**: æ ‡å‡†åŒ–é›†æˆæµç¨‹ï¼Œé™ä½å¼€å‘æˆæœ¬
- **å¯æ‰©å±•**: æ”¯æŒæœªæ¥æ–°ä¸šåŠ¡æ¨¡å—å¿«é€Ÿé›†æˆ

### ğŸ“± ç§»åŠ¨ç«¯æ¶æ„æ¦‚è§ˆ

```mermaid
graph TB
    subgraph "ç§»åŠ¨ç«¯å±‚"
        A[åŸç”ŸAPP<br/>iOS/Android]
        B[å°ç¨‹åº<br/>å¾®ä¿¡/æ”¯ä»˜å®]
        C[H5åº”ç”¨<br/>ç§»åŠ¨Web]
        D[å¿«åº”ç”¨<br/>å‚å•†ç”Ÿæ€]
    end

    subgraph "ç»Ÿä¸€ç½‘å…³å±‚"
        E[API Gateway<br/>8080]
    end

    subgraph "ä¸šåŠ¡æœåŠ¡å±‚"
        F[é—¨ç¦æœåŠ¡<br/>8090]
        G[è€ƒå‹¤æœåŠ¡<br/>8091]
        H[æ¶ˆè´¹æœåŠ¡<br/>8094]
        I[è®¿å®¢æœåŠ¡<br/>8095]
        J[è§†é¢‘æœåŠ¡<br/>8092]
    end

    A --> E
    B --> E
    C --> E
    D --> E
    E --> F
    E --> G
    E --> H
    E --> I
    E --> J
```

---

## ğŸ—ï¸ ç§»åŠ¨ç«¯æŠ€æœ¯æ¶æ„

### 1. æŠ€æœ¯æ ˆé€‰æ‹©

#### 1.1 åŸç”ŸAPPå¼€å‘

| å¹³å° | æŠ€æœ¯æ ˆ | ç‰ˆæœ¬è¦æ±‚ | é€‰æ‹©ç†ç”± |
|------|--------|----------|----------|
| **iOS** | Swift | 5.7+ | æ€§èƒ½æœ€ä¼˜ï¼ŒåŸç”Ÿä½“éªŒæœ€ä½³ |
| **Android** | Kotlin | 1.8+ | ç°ä»£åŒ–è¯­è¨€ï¼ŒGoogleå®˜æ–¹æ¨è |
| **è·¨å¹³å°** | React Native | 0.72+ | ä»£ç å¤ç”¨ç‡é«˜ï¼Œç”Ÿæ€æˆç†Ÿ |
| **è·¨å¹³å°** | Flutter | 3.16+ | é«˜æ€§èƒ½ï¼ŒGoogleæ”¯æŒ |

#### 1.2 å°ç¨‹åºå¼€å‘

| å¹³å° | æŠ€æœ¯æ ˆ | ç‰ˆæœ¬è¦æ±‚ | ç‰¹è‰²åŠŸèƒ½ |
|------|--------|----------|----------|
| **å¾®ä¿¡å°ç¨‹åº** | åŸç”Ÿæ¡†æ¶ | 3.0+ | ç”Ÿæ€å®Œå–„ï¼Œç”¨æˆ·åŸºæ•°å¤§ |
| **æ”¯ä»˜å®å°ç¨‹åº** | åŸç”Ÿæ¡†æ¶ | 2.0+ | æ”¯ä»˜åœºæ™¯ä¼˜åŠ¿ |
| **æŠ–éŸ³å°ç¨‹åº** | åŸç”Ÿæ¡†æ¶ | 1.0+ | å¹´è½»ç”¨æˆ·ç¾¤ä½“ |
| **ç™¾åº¦å°ç¨‹åº** | åŸç”Ÿæ¡†æ¶ | 3.0+ | AIæŠ€æœ¯é›†æˆ |

#### 1.3 H5åº”ç”¨å¼€å‘

```typescript
// ç»Ÿä¸€H5æŠ€æœ¯æ ˆ
{
  "framework": "Vue 3.4",
  "buildTool": "Vite 5.0",
  "uiLibrary": "Vant 4.0",
  "stateManagement": "Pinia 2.0",
  "router": "Vue Router 4.0",
  "httpClient": "Axios 1.6",
  "typescript": "5.0"
}
```

### 2. ç»Ÿä¸€ç§»åŠ¨ç«¯SDKè®¾è®¡

#### 2.1 SDKæ¶æ„è®¾è®¡

```typescript
// IOE-DREAM Mobile SDK æ¶æ„
interface IOEDreamMobileSDK {
  // æ ¸å¿ƒæ¨¡å—
  auth: AuthModule;           // è®¤è¯æ¨¡å—
  api: ApiModule;             // APIè°ƒç”¨æ¨¡å—
  storage: StorageModule;     // å­˜å‚¨æ¨¡å—
  device: DeviceModule;       // è®¾å¤‡ä¿¡æ¯æ¨¡å—

  // ä¸šåŠ¡æ¨¡å—
  access: AccessModule;       // é—¨ç¦æ¨¡å—
  attendance: AttendanceModule; // è€ƒå‹¤æ¨¡å—
  consume: ConsumeModule;     // æ¶ˆè´¹æ¨¡å—
  visitor: VisitorModule;     // è®¿å®¢æ¨¡å—
  video: VideoModule;         // è§†é¢‘æ¨¡å—

  // å·¥å…·æ¨¡å—
  utils: UtilsModule;         // å·¥å…·å‡½æ•°
  biometric: BiometricModule; // ç”Ÿç‰©è¯†åˆ«
  location: LocationModule;   // ä½ç½®æœåŠ¡
  notification: NotificationModule; // é€šçŸ¥æ¨é€
}
```

#### 2.2 SDKåˆå§‹åŒ–é…ç½®

```typescript
// SDKåˆå§‹åŒ–é…ç½®
import { IOEDreamSDK } from '@ioedream/mobile-sdk';

const sdkConfig = {
  // åŸºç¡€é…ç½®
  baseUrl: 'https://api.ioedream.com',
  appId: 'your-app-id',
  appSecret: 'your-app-secret',

  // ç¯å¢ƒé…ç½®
  environment: 'production', // development | staging | production

  // æ¨¡å—é…ç½®
  modules: {
    auth: {
      loginType: ['password', 'biometric', 'sso'],
      tokenExpireTime: 7 * 24 * 60 * 60 * 1000, // 7å¤©
      refreshTokenEnabled: true
    },

    biometric: {
      supportedTypes: ['fingerprint', 'face', 'voice'],
      encryptionEnabled: true,
      localAuthEnabled: true
    },

    location: {
      accuracy: 'high',
      updateInterval: 30000,
      backgroundEnabled: true
    },

    notification: {
      pushEnabled: true,
      soundEnabled: true,
      vibrateEnabled: true
    }
  }
};

// åˆå§‹åŒ–SDK
const sdk = new IOEDreamSDK(sdkConfig);
await sdk.init();
```

---

## ğŸ“± å„ä¸šåŠ¡æ¨¡å—ç§»åŠ¨ç«¯é›†æˆæ–¹æ¡ˆ

### 1. é—¨ç¦ç®¡ç†æ¨¡å—ç§»åŠ¨ç«¯é›†æˆ

#### 1.1 ç§»åŠ¨ç«¯åŠŸèƒ½æ¸…å•

| åŠŸèƒ½ç±»åˆ« | åŠŸèƒ½ç‚¹ | æŠ€æœ¯å®ç° | ä¼˜å…ˆçº§ |
|----------|--------|----------|--------|
| **åŸºç¡€åŠŸèƒ½** | äºŒç»´ç å¼€é—¨ | Canvasç”ŸæˆQRç  | P0 |
| **åŸºç¡€åŠŸèƒ½** | NFCå¼€é—¨ | Android NFC API | P0 |
| **åŸºç¡€åŠŸèƒ½** | è“ç‰™å¼€é—¨ | BLE Centralæ¨¡å¼ | P0 |
| **é«˜çº§åŠŸèƒ½** | äººè„¸è¯†åˆ«å¼€é—¨ | TensorFlow Lite | P1 |
| **é«˜çº§åŠŸèƒ½** | è¿œç¨‹å¼€é—¨ | WebSocketå®æ—¶é€šä¿¡ | P1 |
| **è¾…åŠ©åŠŸèƒ½** | å¼€é—¨è®°å½•æŸ¥è¯¢ | REST API | P1 |
| **è¾…åŠ©åŠŸèƒ½** | æƒé™ç”³è¯·å®¡æ‰¹ | å·¥ä½œæµå¼•æ“ | P2 |

#### 1.2 äºŒç»´ç å¼€é—¨å®ç°

```typescript
// äºŒç»´ç å¼€é—¨å®ç°
class QRCodeAccessService {
  private sdk: IOEDreamSDK;

  constructor(sdk: IOEDreamSDK) {
    this.sdk = sdk;
  }

  /**
   * ç”Ÿæˆå¼€é—¨äºŒç»´ç 
   */
  async generateAccessQRCode(): Promise<QRCodeResult> {
    const user = await this.sdk.auth.getCurrentUser();
    const timestamp = Date.now();
    const nonce = this.generateNonce();

    // æ„å»ºå¼€é—¨ä»¤ç‰Œ
    const accessToken = {
      userId: user.id,
      timestamp,
      nonce,
      expireTime: timestamp + 5 * 60 * 1000, // 5åˆ†é’Ÿæœ‰æ•ˆæœŸ
      signature: this.generateSignature(user.id, timestamp, nonce)
    };

    // ç”ŸæˆäºŒç»´ç 
    const qrData = JSON.stringify(accessToken);
    const qrCode = await this.generateQRCode(qrData);

    return {
      qrCode,
      expireTime: accessToken.expireTime,
      accessAreas: await this.getUserAccessAreas(user.id)
    };
  }

  /**
   * éªŒè¯å¼€é—¨äºŒç»´ç 
   */
  async verifyAccessQRCode(qrData: string): Promise<VerifyResult> {
    try {
      const token = JSON.parse(qrData);
      const now = Date.now();

      // éªŒè¯æ—¶æ•ˆæ€§
      if (now > token.expireTime) {
        return { valid: false, reason: 'äºŒç»´ç å·²è¿‡æœŸ' };
      }

      // éªŒè¯ç­¾å
      const validSignature = this.verifySignature(token);
      if (!validSignature) {
        return { valid: false, reason: 'äºŒç»´ç éªŒè¯å¤±è´¥' };
      }

      // éªŒè¯ç”¨æˆ·æƒé™
      const hasAccess = await this.checkUserAccess(token.userId);
      if (!hasAccess) {
        return { valid: false, reason: 'æ— å¼€é—¨æƒé™' };
      }

      return { valid: true, userId: token.userId };
    } catch (error) {
      return { valid: false, reason: 'äºŒç»´ç æ ¼å¼é”™è¯¯' };
    }
  }
}
```

#### 1.3 NFCå¼€é—¨å®ç°

```java
// Android NFCå¼€é—¨å®ç°
public class NFCAccessManager {
    private NfcAdapter nfcAdapter;
    private IOEDreamSDK sdk;

    public void enableNFCAccess() {
        // å¯ç”¨NFCå‰å°è°ƒåº¦
        IntentFilter intentFilter = new IntentFilter(NfcAdapter.ACTION_NDEF_DISCOVERED);
        IntentFilter[] filters = {intentFilter};
        String[][] techLists = {{Ndef.class.getName()}};

        PendingIntent pendingIntent = PendingIntent.getActivity(
            context, 0, new Intent(context, getClass())
                .addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0
        );

        nfcAdapter.enableForegroundDispatch(activity, pendingIntent, filters, techLists);
    }

    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);

        if (NfcAdapter.ACTION_NDEF_DISCOVERED.equals(intent.getAction())) {
            Parcelable[] rawMessages = intent.getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES);

            if (rawMessages != null) {
                NdefMessage[] messages = new NdefMessage[rawMessages.length];

                for (int i = 0; i < rawMessages.length; i++) {
                    messages[i] = (NdefMessage) rawMessages[i];
                }

                processNFCMessage(messages[0]);
            }
        }
    }

    private void processNFCMessage(NdefMessage message) {
        NdefRecord record = message.getRecords()[0];
        String payload = new String(record.getPayload());

        // è§£æNFCæ•°æ®å¹¶éªŒè¯
        verifyNFCAccess(payload);
    }
}
```

#### 1.4 äººè„¸è¯†åˆ«å¼€é—¨å®ç°

```typescript
// TensorFlow Liteäººè„¸è¯†åˆ«å®ç°
import * as tf from '@tensorflow/tfjs';
import '@tensorflow/tfjs-react-native';

class FaceRecognitionService {
  private model: tf.GraphModel;
  private faceDetector: any;

  async initialize() {
    // åŠ è½½äººè„¸è¯†åˆ«æ¨¡å‹
    this.model = await tf.loadLayersModel('assets/models/face_recognition/model.json');
    this.faceDetector = await tf.loadLayersModel('assets/models/face_detection/model.json');
  }

  /**
   * äººè„¸æ³¨å†Œ
   */
  async registerFace(userId: string, faceImages: string[]): Promise<RegistrationResult> {
    try {
      const faceFeatures = [];

      for (const image of faceImages) {
        const feature = await this.extractFaceFeature(image);
        faceFeatures.push(feature);
      }

      // è®¡ç®—å¹³å‡ç‰¹å¾å‘é‡
      const avgFeature = this.calculateAverageFeature(faceFeatures);

      // ä¸Šä¼ åˆ°æœåŠ¡å™¨
      const result = await this.sdk.api.post('/api/v1/biometric/face/register', {
        userId,
        faceFeature: Array.from(avgFeature.dataSync()),
        images: faceImages
      });

      return { success: true, faceId: result.data.faceId };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  /**
   * äººè„¸è¯†åˆ«å¼€é—¨
   */
  async recognizeFace(imageData: string): Promise<RecognitionResult> {
    try {
      // æ£€æµ‹äººè„¸
      const faceDetection = await this.detectFace(imageData);
      if (!faceDetection.detected) {
        return { success: false, reason: 'æœªæ£€æµ‹åˆ°äººè„¸' };
      }

      // æå–ç‰¹å¾
      const faceFeature = await this.extractFaceFeature(imageData);

      // ä¸æœåŠ¡å™¨ç‰¹å¾æ¯”å¯¹
      const result = await this.sdk.api.post('/api/v1/biometric/face/recognize', {
        faceFeature: Array.from(faceFeature.dataSync()),
        confidenceThreshold: 0.8
      });

      return {
        success: true,
        userId: result.data.userId,
        confidence: result.data.confidence,
        accessGranted: result.data.accessGranted
      };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  private async extractFaceFeature(imageData: string): Promise<tf.Tensor> {
    const image = tf.browser.fromPixels(imageData);
    const resized = tf.image.resizeBilinear(image, [112, 112]);
    const normalized = resized.div(255.0);
    const batched = normalized.expandDims(0);

    return this.model.predict(batched) as tf.Tensor;
  }
}
```

### 2. è€ƒå‹¤ç®¡ç†æ¨¡å—ç§»åŠ¨ç«¯é›†æˆ

#### 2.1 ç§»åŠ¨ç«¯åŠŸèƒ½è®¾è®¡

| åŠŸèƒ½æ¨¡å— | åŠŸèƒ½æè¿° | æŠ€æœ¯å®ç° | ä¼˜å…ˆçº§ |
|----------|----------|----------|--------|
| **æ‰“å¡åŠŸèƒ½** | GPSå®šä½æ‰“å¡ | é«˜å¾·å®šä½SDK | P0 |
| **æ‰“å¡åŠŸèƒ½** | WiFiæ‰“å¡ | ç½‘ç»œçŠ¶æ€æ£€æµ‹ | P0 |
| **æ‰“å¡åŠŸèƒ½** | äººè„¸æ‰“å¡ | ç”Ÿç‰©è¯†åˆ«SDK | P0 |
| **è€ƒå‹¤æŸ¥è¯¢** | ä»Šæ—¥è€ƒå‹¤ | REST API | P1 |
| **è€ƒå‹¤æŸ¥è¯¢** | å†å²è®°å½• | åˆ†é¡µæŸ¥è¯¢ | P1 |
| **è€ƒå‹¤æŸ¥è¯¢** | è€ƒå‹¤ç»Ÿè®¡ | å›¾è¡¨å±•ç¤º | P2 |
| **å¼‚å¸¸å¤„ç†** | å¤–å‹¤ç”³è¯· | å·¥ä½œæµå¼•æ“ | P1 |
| **å¼‚å¸¸å¤„ç†** | è¡¥å¡ç”³è¯· | å®¡æ‰¹æµç¨‹ | P2 |

#### 2.2 GPSå®šä½æ‰“å¡å®ç°

```typescript
// é«˜å¾·å®šä½SDKé›†æˆ
import AMap from 'react-native-amap-geolocation';

class AttendanceLocationService {
  private sdk: IOEDreamSDK;
  private locationConfig: any;

  constructor(sdk: IOEDreamSDK) {
    this.sdk = sdk;
    this.locationConfig = {
      accuracy: 'HighAccuracy',
      interval: 10000,
      fastestInterval: 5000,
      distanceFilter: 10
    };
  }

  /**
   * å¯åŠ¨å®šä½æœåŠ¡
   */
  async startLocationService(): Promise<LocationResult> {
    try {
      // è¯·æ±‚å®šä½æƒé™
      const hasPermission = await this.requestLocationPermission();
      if (!hasPermission) {
        throw new Error('å®šä½æƒé™è¢«æ‹’ç»');
      }

      // é…ç½®é«˜å¾·SDK
      AMap.init({
        ios: 'your-ios-key',
        android: 'your-android-key'
      });

      // å¯åŠ¨è¿ç»­å®šä½
      const locationResult = await new Promise((resolve, reject) => {
        AMap.startLocation(this.locationConfig, (location) => {
          resolve({
            latitude: location.latitude,
            longitude: location.longitude,
            accuracy: location.accuracy,
            timestamp: location.timestamp,
            address: location.address
          });
        }, (error) => {
          reject(new Error(error.info));
        });
      });

      return locationResult;
    } catch (error) {
      throw new Error(`å®šä½æœåŠ¡å¯åŠ¨å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * æ‰§è¡Œå®šä½æ‰“å¡
   */
  async clockInByLocation(): Promise<ClockInResult> {
    try {
      const location = await this.startLocationService();
      const user = await this.sdk.auth.getCurrentUser();

      // éªŒè¯æ‰“å¡ä½ç½®
      const isValidLocation = await this.validateClockInLocation(
        user.id,
        location.latitude,
        location.longitude
      );

      if (!isValidLocation.valid) {
        return {
          success: false,
          reason: isValidLocation.reason,
          suggestion: 'è¯·åˆ°æŒ‡å®šä½ç½®æ‰“å¡'
        };
      }

      // æäº¤æ‰“å¡è®°å½•
      const clockInData = {
        userId: user.id,
        clockType: this.determineClockType(),
        location: {
          latitude: location.latitude,
          longitude: location.longitude,
          accuracy: location.accuracy,
          address: location.address
        },
        timestamp: Date.now(),
        deviceInfo: await this.getDeviceInfo()
      };

      const result = await this.sdk.api.post('/api/v1/attendance/clock-in', clockInData);

      return {
        success: true,
        clockInId: result.data.clockInId,
        clockTime: result.data.clockTime,
        location: location.address,
        workShift: result.data.workShift
      };
    } catch (error) {
      return {
        success: false,
        reason: error.message
      };
    }
  }

  /**
   * éªŒè¯æ‰“å¡ä½ç½®
   */
  private async validateClockInLocation(
    userId: string,
    latitude: number,
    longitude: number
  ): Promise<LocationValidationResult> {
    // è·å–ç”¨æˆ·å·¥ä½œåœ°ç‚¹
    const workLocations = await this.sdk.api.get(`/api/v1/attendance/user/${userId}/work-locations`);

    for (const workLocation of workLocations.data) {
      const distance = this.calculateDistance(
        latitude, longitude,
        workLocation.latitude, workLocation.longitude
      );

      if (distance <= workLocation.allowedRadius) {
        return { valid: true, workLocation: workLocation.name };
      }
    }

    return { valid: false, reason: 'å½“å‰ä½ç½®ä¸åœ¨æ‰“å¡èŒƒå›´å†…' };
  }

  /**
   * è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»ï¼ˆç±³ï¼‰
   */
  private calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
    const R = 6371e3; // åœ°çƒåŠå¾„ï¼ˆç±³ï¼‰
    const Ï†1 = lat1 * Math.PI / 180;
    const Ï†2 = lat2 * Math.PI / 180;
    const Î”Ï† = (lat2 - lat1) * Math.PI / 180;
    const Î”Î» = (lon2 - lon1) * Math.PI / 180;

    const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
              Math.cos(Ï†1) * Math.cos(Ï†2) *
              Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
  }
}
```

#### 2.3 äººè„¸æ‰“å¡å®ç°

```typescript
// äººè„¸æ‰“å¡æœåŠ¡
class AttendanceBiometricService {
  private faceRecognition: FaceRecognitionService;
  private sdk: IOEDreamSDK;

  constructor(sdk: IOEDreamSDK) {
    this.sdk = sdk;
    this.faceRecognition = new FaceRecognitionService();
  }

  /**
   * äººè„¸æ‰“å¡
   */
  async clockInByFace(): Promise<ClockInResult> {
    try {
      // æ£€æŸ¥ç›¸æœºæƒé™
      const hasCameraPermission = await this.requestCameraPermission();
      if (!hasCameraPermission) {
        throw new Error('ç›¸æœºæƒé™è¢«æ‹’ç»');
      }

      // å¯åŠ¨ç›¸æœºè¿›è¡Œäººè„¸é‡‡é›†
      const faceImage = await this.captureFace();

      // äººè„¸è¯†åˆ«
      const recognitionResult = await this.faceRecognition.recognizeFace(faceImage);

      if (!recognitionResult.success) {
        return {
          success: false,
          reason: recognitionResult.reason || 'äººè„¸è¯†åˆ«å¤±è´¥'
        };
      }

      // æ´»ä½“æ£€æµ‹
      const livenessResult = await this.performLivenessDetection(faceImage);
      if (!livenessResult.isLive) {
        return {
          success: false,
          reason: 'æ´»ä½“æ£€æµ‹å¤±è´¥ï¼Œè¯·é‡æ–°å°è¯•'
        };
      }

      // æäº¤æ‰“å¡è®°å½•
      const clockInData = {
        userId: recognitionResult.userId,
        clockType: this.determineClockType(),
        biometricData: {
          faceImage: faceImage,
          confidence: recognitionResult.confidence,
          livenessScore: livenessResult.score
        },
        timestamp: Date.now(),
        deviceInfo: await this.getDeviceInfo()
      };

      const result = await this.sdk.api.post('/api/v1/attendance/clock-in/biometric', clockInData);

      return {
        success: true,
        clockInId: result.data.clockInId,
        clockTime: result.data.clockTime,
        userName: result.data.userName,
        confidence: recognitionResult.confidence
      };
    } catch (error) {
      return {
        success: false,
        reason: error.message
      };
    }
  }

  /**
   * æ´»ä½“æ£€æµ‹
   */
  private async performLivenessDetection(faceImage: string): Promise<LivenessResult> {
    // ä½¿ç”¨çœ¨çœ¼ã€å¼ å˜´ç­‰åŠ¨ä½œè¿›è¡Œæ´»ä½“æ£€æµ‹
    const livenessActions = ['blink', 'mouth_open', 'head_turn'];

    for (const action of livenessActions) {
      const prompt = this.getLivenessPrompt(action);
      await this.showLivenessPrompt(prompt);

      const actionImage = await this.captureFace();
      const isValidAction = await this.validateLivenessAction(actionImage, action);

      if (!isValidAction) {
        return { isLive: false, reason: `${action}åŠ¨ä½œæ£€æµ‹å¤±è´¥` };
      }
    }

    return { isLive: true, score: 0.95 };
  }
}
```

### 3. æ¶ˆè´¹ç®¡ç†æ¨¡å—ç§»åŠ¨ç«¯é›†æˆ

#### 3.1 ç§»åŠ¨ç«¯æ”¯ä»˜æ–¹æ¡ˆ

| æ”¯ä»˜æ–¹å¼ | æŠ€æœ¯å®ç° | å®‰å…¨ç­‰çº§ | ä¼˜å…ˆçº§ |
|----------|----------|----------|--------|
| **äºŒç»´ç æ”¯ä»˜** | ç”Ÿæˆæ¶ˆè´¹äºŒç»´ç  | ä¸­ | P0 |
| **NFCæ”¯ä»˜** | Android Beam/Apple Pay | é«˜ | P0 |
| **äººè„¸æ”¯ä»˜** | 3Däººè„¸è¯†åˆ« | é«˜ | P1 |
| **å¯†ç æ”¯ä»˜** | æ•°å­—é”®ç›˜è¾“å…¥ | ä¸­ | P1 |
| **å£°æ³¢æ”¯ä»˜** | è¶…å£°æ³¢é€šä¿¡ | ä½ | P2 |

#### 3.2 äºŒç»´ç æ”¯ä»˜å®ç°

```typescript
// æ¶ˆè´¹æ”¯ä»˜äºŒç»´ç æœåŠ¡
class ConsumeQRCodeService {
  private sdk: IOEDreamSDK;

  constructor(sdk: IOEDreamSDK) {
    this.sdk = sdk;
  }

  /**
   * ç”Ÿæˆæ¶ˆè´¹äºŒç»´ç 
   */
  async generateConsumeQRCode(amount?: number): Promise<ConsumeQRResult> {
    try {
      const user = await this.sdk.auth.getCurrentUser();
      const timestamp = Date.now();
      const nonce = this.generateNonce();

      // æ„å»ºæ¶ˆè´¹ä»¤ç‰Œ
      const consumeToken = {
        userId: user.id,
        amount: amount || 0, // 0è¡¨ç¤ºé‡‘é¢ç”±POSæœºç¡®å®š
        timestamp,
        nonce,
        expireTime: timestamp + 3 * 60 * 1000, // 3åˆ†é’Ÿæœ‰æ•ˆæœŸ
        signature: this.generateSignature(user.id, amount || 0, timestamp, nonce),
        deviceInfo: await this.getDeviceInfo()
      };

      // ç”ŸæˆäºŒç»´ç 
      const qrData = JSON.stringify(consumeToken);
      const qrCode = await this.generateQRCode(qrData);

      return {
        qrCode,
        expireTime: consumeToken.expireTime,
        userName: user.userName,
        accountBalance: await this.getUserBalance(user.id)
      };
    } catch (error) {
      throw new Error(`ç”Ÿæˆæ¶ˆè´¹äºŒç»´ç å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * å¤„ç†æ¶ˆè´¹ç»“æœ
   */
  async handleConsumeResult(consumeId: string): Promise<ConsumeResult> {
    try {
      // è½®è¯¢æŸ¥è¯¢æ¶ˆè´¹ç»“æœ
      const maxRetries = 10;
      const retryInterval = 1000;

      for (let i = 0; i < maxRetries; i++) {
        const result = await this.sdk.api.get(`/api/v1/consume/record/${consumeId}`);

        if (result.data.status === 'SUCCESS') {
          return {
            success: true,
            consumeId: result.data.consumeId,
            amount: result.data.amount,
            balance: result.data.balance,
            consumeTime: result.data.consumeTime,
            merchantName: result.data.merchantName
          };
        } else if (result.data.status === 'FAILED') {
          return {
            success: false,
            reason: result.data.errorMessage
          };
        }

        // ç­‰å¾…ä¸‹ä¸€æ¬¡æŸ¥è¯¢
        await this.sleep(retryInterval);
      }

      return {
        success: false,
        reason: 'æ¶ˆè´¹ç»“æœæŸ¥è¯¢è¶…æ—¶'
      };
    } catch (error) {
      return {
        success: false,
        reason: error.message
      };
    }
  }

  /**
   * è·å–ç”¨æˆ·ä½™é¢
   */
  async getUserBalance(userId: string): Promise<BalanceInfo> {
    try {
      const result = await this.sdk.api.get(`/api/v1/consume/account/${userId}/balance`);
      return result.data;
    } catch (error) {
      throw new Error(`è·å–ç”¨æˆ·ä½™é¢å¤±è´¥: ${error.message}`);
    }
  }
}
```

#### 3.3 ç¦»çº¿æ”¯ä»˜æœºåˆ¶

```typescript
// ç¦»çº¿æ”¯ä»˜æœåŠ¡
class OfflineConsumeService {
  private sdk: IOEDreamSDK;
  private offlineStorage: LocalStorage;

  constructor(sdk: IOEDreamSDK) {
    this.sdk = sdk;
    this.offlineStorage = new LocalStorage('offline_consume');
  }

  /**
   * å¯ç”¨ç¦»çº¿æ”¯ä»˜
   */
  async enableOfflinePayment(maxAmount: number = 100): Promise<void> {
    try {
      const user = await this.sdk.auth.getCurrentUser();

      // è·å–ç¦»çº¿æ”¯ä»˜ä»¤ç‰Œ
      const offlineTokens = await this.sdk.api.post('/api/v1/consume/offline/tokens', {
        userId: user.id,
        maxAmount,
        tokenCount: 10 // é¢„è·å–10ä¸ªç¦»çº¿ä»¤ç‰Œ
      });

      // å­˜å‚¨ç¦»çº¿ä»¤ç‰Œ
      await this.offlineStorage.set('offline_tokens', offlineTokens.data.tokens);
      await this.offlineStorage.set('offline_enabled', true);
      await this.offlineStorage.set('offline_max_amount', maxAmount);

      // å¯åŠ¨ç½‘ç»œçŠ¶æ€ç›‘æ§
      this.startNetworkMonitoring();
    } catch (error) {
      throw new Error(`å¯ç”¨ç¦»çº¿æ”¯ä»˜å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * æ‰§è¡Œç¦»çº¿æ”¯ä»˜
   */
  async performOfflineConsume(amount: number, merchantId: string): Promise<OfflineConsumeResult> {
    try {
      const tokens = await this.offlineStorage.get('offline_tokens');
      const maxAmount = await this.offlineStorage.get('offline_max_amount');

      // éªŒè¯é‡‘é¢é™åˆ¶
      if (amount > maxAmount) {
        throw new Error(`ç¦»çº¿æ”¯ä»˜é‡‘é¢ä¸èƒ½è¶…è¿‡${maxAmount}å…ƒ`);
      }

      if (tokens.length === 0) {
        throw new Error('ç¦»çº¿æ”¯ä»˜ä»¤ç‰Œå·²ç”¨å®Œï¼Œè¯·è¿æ¥ç½‘ç»œè·å–');
      }

      // ä½¿ç”¨ç¦»çº¿ä»¤ç‰Œ
      const token = tokens.pop();
      await this.offlineStorage.set('offline_tokens', tokens);

      // ç”Ÿæˆç¦»çº¿æ¶ˆè´¹è®°å½•
      const offlineRecord = {
        consumeId: this.generateOfflineConsumeId(),
        userId: await this.getCurrentUserId(),
        amount,
        merchantId,
        token,
        timestamp: Date.now(),
        status: 'PENDING_SYNC'
      };

      // ä¿å­˜ç¦»çº¿è®°å½•
      await this.saveOfflineRecord(offlineRecord);

      return {
        success: true,
        consumeId: offlineRecord.consumeId,
        amount,
        isOffline: true,
        tokensRemaining: tokens.length
      };
    } catch (error) {
      return {
        success: false,
        reason: error.message
      };
    }
  }

  /**
   * åŒæ­¥ç¦»çº¿è®°å½•
   */
  async syncOfflineRecords(): Promise<SyncResult> {
    try {
      const offlineRecords = await this.getPendingOfflineRecords();

      if (offlineRecords.length === 0) {
        return { success: true, syncedCount: 0 };
      }

      let successCount = 0;
      let failureCount = 0;

      for (const record of offlineRecords) {
        try {
          await this.sdk.api.post('/api/v1/consume/offline/sync', record);
          await this.markOfflineRecordAsSynced(record.consumeId);
          successCount++;
        } catch (error) {
          console.error(`åŒæ­¥ç¦»çº¿è®°å½•å¤±è´¥: ${record.consumeId}`, error);
          failureCount++;
        }
      }

      return {
        success: failureCount === 0,
        syncedCount: successCount,
        failureCount: failureCount
      };
    } catch (error) {
      return {
        success: false,
        reason: error.message
      };
    }
  }

  /**
   * ç½‘ç»œçŠ¶æ€ç›‘æ§
   */
  private startNetworkMonitoring(): void {
    NetInfo.addEventListener(state => {
      if (state.isConnected && state.isInternetReachable) {
        // ç½‘ç»œæ¢å¤æ—¶è‡ªåŠ¨åŒæ­¥
        this.syncOfflineRecords();
      }
    });
  }
}
```

### 4. è®¿å®¢ç®¡ç†æ¨¡å—ç§»åŠ¨ç«¯é›†æˆ

#### 4.1 è®¿å®¢é¢„çº¦ç§»åŠ¨ç«¯å®ç°

```typescript
// è®¿å®¢é¢„çº¦æœåŠ¡
class VisitorAppointmentService {
  private sdk: IOEDreamSDK;

  constructor(sdk: IOEDreamSDK) {
    this.sdk = sdk;
  }

  /**
   * åˆ›å»ºè®¿å®¢é¢„çº¦
   */
  async createVisitorAppointment(appointmentData: VisitorAppointmentData): Promise<AppointmentResult> {
    try {
      const user = await this.sdk.auth.getCurrentUser();

      // æ„å»ºé¢„çº¦æ•°æ®
      const appointment = {
        ...appointmentData,
        hostId: user.id,
        hostName: user.userName,
        appointmentTime: appointmentData.appointmentTime || Date.now(),
        status: 'PENDING_APPROVAL',
        createTime: Date.now()
      };

      // æäº¤é¢„çº¦ç”³è¯·
      const result = await this.sdk.api.post('/api/v1/visitor/appointment', appointment);

      return {
        success: true,
        appointmentId: result.data.appointmentId,
        status: result.data.status,
        qrCode: result.data.qrCode,
        approvalRequired: result.data.approvalRequired
      };
    } catch (error) {
      return {
        success: false,
        reason: error.message
      };
    }
  }

  /**
   * è®¿å®¢è‡ªåŠ©ç™»è®°
   */
  async visitorSelfRegistration(registrationData: VisitorRegistrationData): Promise<RegistrationResult> {
    try {
      // èº«ä»½è¯OCRè¯†åˆ«
      const idCardInfo = await this.recognizeIdCard(registrationData.idCardImage);

      // äººè„¸æ¯”å¯¹
      const faceMatch = await this.compareFaceWithIdCard(
        registrationData.visitorPhoto,
        idCardInfo.photo
      );

      if (!faceMatch.isMatch) {
        return {
          success: false,
          reason: 'äººè„¸ä¸èº«ä»½è¯ç…§ç‰‡ä¸åŒ¹é…'
        };
      }

      // æ„å»ºè®¿å®¢ä¿¡æ¯
      const visitorInfo = {
        name: idCardInfo.name,
        idCardNumber: idCardInfo.idNumber,
        phone: registrationData.phone,
        visitPurpose: registrationData.visitPurpose,
        expectedArrivalTime: registrationData.expectedArrivalTime,
        hostId: registrationData.hostId,
        visitorPhoto: registrationData.visitorPhoto,
        faceFeature: faceMatch.faceFeature,
        registrationTime: Date.now(),
        source: 'SELF_SERVICE'
      };

      const result = await this.sdk.api.post('/api/v1/visitor/self-registration', visitorInfo);

      return {
        success: true,
        visitorId: result.data.visitorId,
        temporaryPass: result.data.temporaryPass,
        qrCode: result.data.qrCode,
        validUntil: result.data.validUntil
      };
    } catch (error) {
      return {
        success: false,
        reason: error.message
      };
    }
  }

  /**
   * è®¿å®¢ç­¾åˆ°
   */
  async visitorCheckIn(visitorId: string, location: LocationInfo): Promise<CheckInResult> {
    try {
      // ä½ç½®éªŒè¯
      const locationValid = await this.validateVisitorLocation(visitorId, location);
      if (!locationValid.valid) {
        return {
          success: false,
          reason: 'å½“å‰ä½ç½®ä¸åœ¨è®¿å®¢åŒºåŸŸå†…'
        };
      }

      const checkInData = {
        visitorId,
        checkInTime: Date.now(),
        location: {
          latitude: location.latitude,
          longitude: location.longitude,
          address: location.address
        },
        checkInType: 'MOBILE_APP'
      };

      const result = await this.sdk.api.post('/api/v1/visitor/check-in', checkInData);

      return {
        success: true,
        checkInId: result.data.checkInId,
        accessPass: result.data.accessPass,
        visitAreas: result.data.visitAreas,
        hostInfo: result.data.hostInfo
      };
    } catch (error) {
      return {
        success: false,
        reason: error.message
      };
    }
  }

  /**
   * è®¿å®¢ç­¾å‡º
   */
  async visitorCheckOut(visitorId: string): Promise<CheckOutResult> {
    try {
      const result = await this.sdk.api.post('/api/v1/visitor/check-out', {
        visitorId,
        checkOutTime: Date.now()
      });

      return {
        success: true,
        checkOutTime: result.data.checkOutTime,
        visitDuration: result.data.visitDuration,
        feedbackRequired: result.data.feedbackRequired
      };
    } catch (error) {
      return {
        success: false,
        reason: error.message
      };
    }
  }
}
```

### 5. è§†é¢‘ç›‘æ§æ¨¡å—ç§»åŠ¨ç«¯é›†æˆ

#### 5.1 å®æ—¶è§†é¢‘æ’­æ”¾å®ç°

```typescript
// è§†é¢‘ç›‘æ§æœåŠ¡
class VideoMonitorService {
  private sdk: IOEDreamSDK;
  private playerInstance: any;

  constructor(sdk: IOEDreamSDK) {
    this.sdk = sdk;
  }

  /**
   * è·å–å®æ—¶è§†é¢‘æµ
   */
  async getLiveVideoStream(cameraId: string): Promise<VideoStreamResult> {
    try {
      // è·å–æ‘„åƒå¤´ä¿¡æ¯
      const cameraInfo = await this.sdk.api.get(`/api/v1/video/camera/${cameraId}`);

      // è·å–æµåª’ä½“åœ°å€
      const streamResult = await this.sdk.api.post('/api/v1/video/stream/live', {
        cameraId,
        protocol: 'HLS', // HLS, WebRTC, RTMP
        quality: 'HD', // HD, SD, FHD
        clientType: 'MOBILE'
      });

      return {
        success: true,
        streamUrl: streamResult.data.streamUrl,
        protocol: streamResult.data.protocol,
        quality: streamResult.data.quality,
        cameraInfo: cameraInfo.data
      };
    } catch (error) {
      return {
        success: false,
        reason: error.message
      };
    }
  }

  /**
   * æ’­æ”¾å®æ—¶è§†é¢‘
   */
  async playLiveVideo(streamUrl: string, containerElement: HTMLElement): Promise<PlayerResult> {
    try {
      // æ ¹æ®åè®®é€‰æ‹©æ’­æ”¾å™¨
      const protocol = this.detectStreamProtocol(streamUrl);

      switch (protocol) {
        case 'HLS':
          return await this.playHLSStream(streamUrl, containerElement);
        case 'WebRTC':
          return await this.playWebRTCStream(streamUrl, containerElement);
        case 'RTMP':
          return await this.playRTMPStream(streamUrl, containerElement);
        default:
          throw new Error(`ä¸æ”¯æŒçš„è§†é¢‘åè®®: ${protocol}`);
      }
    } catch (error) {
      return {
        success: false,
        reason: error.message
      };
    }
  }

  /**
   * HLSæµæ’­æ”¾
   */
  private async playHLSStream(streamUrl: string, containerElement: HTMLElement): Promise<PlayerResult> {
    // ä½¿ç”¨Hls.jsæ’­æ”¾HLSæµ
    const Hls = await import('hls.js');

    if (Hls.isSupported()) {
      const hls = new Hls({
        enableWorker: true,
        lowLatencyMode: true,
        backBufferLength: 90
      });

      hls.loadSource(streamUrl);
      hls.attachMedia(containerElement);

      this.playerInstance = hls;

      return {
        success: true,
        player: hls,
        protocol: 'HLS'
      };
    } else if (containerElement.canPlayType('application/vnd.apple.mpegurl')) {
      // SafariåŸç”Ÿæ”¯æŒHLS
      containerElement.src = streamUrl;

      return {
        success: true,
        player: containerElement,
        protocol: 'HLS'
      };
    } else {
      throw new Error('æµè§ˆå™¨ä¸æ”¯æŒHLSæ’­æ”¾');
    }
  }

  /**
   * WebRTCå®æ—¶æ’­æ”¾
   */
  private async playWebRTCStream(streamUrl: string, containerElement: HTMLElement): Promise<PlayerResult> {
    const pc = new RTCPeerConnection({
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' }
      ]
    });

    // è®¾ç½®è§†é¢‘æµ
    pc.ontrack = (event) => {
      containerElement.srcObject = event.streams[0];
    };

    // è¿æ¥åˆ°ä¿¡ä»¤æœåŠ¡å™¨
    const response = await fetch(streamUrl);
    const offer = await response.json();

    await pc.setRemoteDescription(new RTCSessionDescription(offer));

    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);

    // å‘é€answeråˆ°ä¿¡ä»¤æœåŠ¡å™¨
    await fetch(streamUrl.replace('/offer', '/answer'), {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(answer)
    });

    this.playerInstance = pc;

    return {
      success: true,
      player: pc,
      protocol: 'WebRTC'
    };
  }

  /**
   * äº‘å°æ§åˆ¶
   */
  async controlPTZ(cameraId: string, command: PTZCommand): Promise<ControlResult> {
    try {
      const result = await this.sdk.api.post(`/api/v1/video/camera/${cameraId}/ptz`, command);

      return {
        success: true,
        commandId: result.data.commandId,
        status: result.data.status
      };
    } catch (error) {
      return {
        success: false,
        reason: error.message
      };
    }
  }

  /**
   * å½•åƒå›æ”¾
   */
  async playbackVideo(cameraId: string, startTime: number, endTime: number): Promise<PlaybackResult> {
    try {
      const result = await this.sdk.api.post('/api/v1/video/playback', {
        cameraId,
        startTime,
        endTime,
        speed: 1.0, // æ’­æ”¾é€Ÿåº¦
        quality: 'HD'
      });

      return {
        success: true,
        playbackUrl: result.data.playbackUrl,
        duration: result.data.duration,
        fileSize: result.data.fileSize
      };
    } catch (error) {
      return {
        success: false,
        reason: error.message
      };
    }
  }
}
```

---

## ğŸ”§ ç§»åŠ¨ç«¯å¼€å‘å·¥å…·å’Œåº“

### 1. æ¨èå¼€å‘å·¥å…·é“¾

#### 1.1 React Nativeå¼€å‘å·¥å…·

```json
{
  "development": {
    "framework": "React Native 0.72+",
    "IDE": "VS Code / Android Studio / Xcode",
    "debugger": "React Native Debugger",
    "profiler": "Flipper",
    "bundler": "Metro"
  },
  "testing": {
    "unitTest": "Jest + React Native Testing Library",
    "e2eTest": "Detox / Appium",
    "performance": "Flipper Performance Monitor"
  },
  "build": {
    "ios": "Xcode + Fastlane",
    "android": "Android Studio + Gradle",
    "ci_cd": "GitHub Actions / Jenkins"
  }
}
```

#### 1.2 Flutterå¼€å‘å·¥å…·

```yaml
development:
  sdk: "Flutter 3.16+"
  ide: "VS Code / Android Studio"
  debugger: "Flutter DevTools"
  profiler: "Flutter Inspector"

testing:
  unit_test: "flutter_test"
  integration_test: "integration_test"
  widget_test: "flutter_test"

build:
  ios: "Xcode + Fastlane"
  android: "Android Studio + Gradle"
  web: "Flutter Web Build"
```

### 2. ç¬¬ä¸‰æ–¹SDKé›†æˆ

#### 2.1 åœ°å›¾å®šä½SDK

```typescript
// åœ°å›¾SDKé…ç½®
const mapSDKConfig = {
  // é«˜å¾·åœ°å›¾
  amap: {
    iosKey: 'your-ios-key',
    androidKey: 'your-android-key',
    services: ['location', 'search', 'geocoding', 'navigation']
  },

  // ç™¾åº¦åœ°å›¾
  baidu: {
    iosKey: 'your-ios-key',
    androidKey: 'your-android-key',
    services: ['location', 'search', 'geocoding']
  },

  // è…¾è®¯åœ°å›¾
  tencent: {
    key: 'your-tencent-key',
    services: ['location', 'search', 'geocoding']
  }
};
```

#### 2.2 æ¨é€SDK

```typescript
// æ¨é€æœåŠ¡é…ç½®
const pushSDKConfig = {
  // æå…‰æ¨é€
  jpush: {
    appKey: 'your-app-key',
    channel: 'developer-default',
    production: false
  },

  // ä¸ªæ¨
  getui: {
    appId: 'your-app-id',
    appKey: 'your-app-key',
    appSecret: 'your-app-secret'
  },

  // åä¸ºæ¨é€
  huawei: {
    appId: 'your-app-id',
    appSecret: 'your-app-secret'
  }
};
```

#### 2.3 ç»Ÿè®¡åˆ†æSDK

```typescript
// æ•°æ®ç»Ÿè®¡é…ç½®
const analyticsConfig = {
  // å‹ç›Ÿç»Ÿè®¡
  umeng: {
    appKey: 'your-app-key',
    channel: 'app-store',
    enableCrashReport: true
  },

  // Firebase Analytics
  firebase: {
    config: 'firebase-config.json',
    enableAnalytics: true,
    enableCrashlytics: true
  },

  // è…¾è®¯MTA
  mta: {
    appKey: 'your-app-key',
    channel: 'app-store',
    enableDebug: false
  }
};
```

---

## ğŸ“± ç§»åŠ¨ç«¯UI/UXè®¾è®¡è§„èŒƒ

### 1. è®¾è®¡ç³»ç»Ÿ

#### 1.1 è‰²å½©è§„èŒƒ

```typescript
// ä¸»è‰²è°ƒ
const colors = {
  primary: {
    50: '#E3F2FD',
    100: '#BBDEFB',
    200: '#90CAF9',
    300: '#64B5F6',
    400: '#42A5F5',
    500: '#2196F3', // ä¸»è‰²
    600: '#1E88E5',
    700: '#1976D2',
    800: '#1565C0',
    900: '#0D47A1'
  },

  secondary: {
    50: '#F3E5F5',
    100: '#E1BEE7',
    200: '#CE93D8',
    300: '#BA68C8',
    400: '#AB47BC',
    500: '#9C27B0', // è¾…åŠ©è‰²
    600: '#8E24AA',
    700: '#7B1FA2',
    800: '#6A1B9A',
    900: '#4A148C'
  },

  neutral: {
    50: '#FAFAFA',
    100: '#F5F5F5',
    200: '#EEEEEE',
    300: '#E0E0E0',
    400: '#BDBDBD',
    500: '#9E9E9E',
    600: '#757575',
    700: '#616161',
    800: '#424242',
    900: '#212121'
  },

  semantic: {
    success: '#4CAF50',
    warning: '#FF9800',
    error: '#F44336',
    info: '#2196F3'
  }
};
```

#### 1.2 å­—ä½“è§„èŒƒ

```typescript
// å­—ä½“ç³»ç»Ÿ
const typography = {
  fontFamily: {
    primary: 'SF Pro Display', // iOS
    secondary: 'Roboto', // Android
    monospace: 'SF Mono'
  },

  fontSize: {
    xs: 12,
    sm: 14,
    base: 16,
    lg: 18,
    xl: 20,
    '2xl': 24,
    '3xl': 30,
    '4xl': 36
  },

  fontWeight: {
    light: '300',
    normal: '400',
    medium: '500',
    semibold: '600',
    bold: '700'
  },

  lineHeight: {
    tight: 1.25,
    normal: 1.5,
    relaxed: 1.75
  }
};
```

#### 1.3 é—´è·è§„èŒƒ

```typescript
// é—´è·ç³»ç»Ÿ
const spacing = {
  0: 0,
  1: 4,   // 0.25rem
  2: 8,   // 0.5rem
  3: 12,  // 0.75rem
  4: 16,  // 1rem
  5: 20,  // 1.25rem
  6: 24,  // 1.5rem
  8: 32,  // 2rem
  10: 40, // 2.5rem
  12: 48, // 3rem
  16: 64, // 4rem
  20: 80, // 5rem
  24: 96  // 6rem
};
```

### 2. ç»„ä»¶åº“è®¾è®¡

#### 2.1 åŸºç¡€ç»„ä»¶

```typescript
// æŒ‰é’®ç»„ä»¶
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'outline' | 'text';
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
  loading?: boolean;
  icon?: ReactNode;
  fullWidth?: boolean;
  onPress: () => void;
  children: ReactNode;
}

// è¾“å…¥æ¡†ç»„ä»¶
interface InputProps {
  label?: string;
  placeholder?: string;
  value?: string;
  onChangeText: (text: string) => void;
  secureTextEntry?: boolean;
  error?: string;
  disabled?: boolean;
  leftIcon?: ReactNode;
  rightIcon?: ReactNode;
}

// å¡ç‰‡ç»„ä»¶
interface CardProps {
  title?: string;
  subtitle?: string;
  image?: string;
  actions?: ReactNode[];
  onPress?: () => void;
  children: ReactNode;
}
```

#### 2.2 ä¸šåŠ¡ç»„ä»¶

```typescript
// ç”¨æˆ·ä¿¡æ¯å¡ç‰‡
interface UserProfileCardProps {
  user: {
    id: string;
    name: string;
    avatar: string;
    department: string;
    position: string;
  };
  showActions?: boolean;
  onEdit?: () => void;
  onMessage?: () => void;
}

// è€ƒå‹¤çŠ¶æ€ç»„ä»¶
interface AttendanceStatusProps {
  status: 'normal' | 'late' | 'early' | 'absent';
  checkInTime?: string;
  checkOutTime?: string;
  workShift: string;
  location?: string;
}

// æ¶ˆè´¹è®°å½•ç»„ä»¶
interface ConsumeRecordProps {
  record: {
    id: string;
    amount: number;
    merchant: string;
    time: string;
    paymentMethod: string;
  };
  showDetails?: boolean;
}

// é—¨ç¦é€šè¡Œç»„ä»¶
interface AccessPassProps {
  qrCode: string;
  expireTime: number;
  userName: string;
  accessAreas: string[];
  onRefresh?: () => void;
}
```

---

## ğŸš€ ç§»åŠ¨ç«¯æ€§èƒ½ä¼˜åŒ–

### 1. å¯åŠ¨ä¼˜åŒ–

#### 1.1 å¯åŠ¨æ—¶é—´ä¼˜åŒ–ç­–ç•¥

```typescript
// å¯åŠ¨ä¼˜åŒ–é…ç½®
const startupOptimization = {
  // é¢„åŠ è½½æ¨¡å—
  preloadModules: [
    'auth',
    'biometric',
    'location'
  ],

  // æ‡’åŠ è½½æ¨¡å—
  lazyLoadModules: [
    'video',
    'visitor',
    'consume'
  ],

  // å¯åŠ¨ä»»åŠ¡ä¼˜å…ˆçº§
  startupTasks: {
    P0: ['auth_check', 'device_info', 'network_status'],
    P1: ['location_init', 'push_init', 'analytics_init'],
    P2: ['cache_sync', 'prefetch_data', 'update_check']
  }
};

// å¯åŠ¨ä»»åŠ¡è°ƒåº¦å™¨
class StartupTaskScheduler {
  private tasks: Map<string, StartupTask> = new Map();

  registerTask(name: string, task: StartupTask): void {
    this.tasks.set(name, task);
  }

  async executeTasks(priority: TaskPriority): Promise<void> {
    const priorityTasks = Array.from(this.tasks.entries())
      .filter(([_, task]) => task.priority === priority);

    await Promise.all(priorityTasks.map(([_, task]) => task.execute()));
  }

  async executeAllTasks(): Promise<void> {
    // æŒ‰ä¼˜å…ˆçº§é¡ºåºæ‰§è¡Œ
    await this.executeTasks('P0');
    await this.executeTasks('P1');
    await this.executeTasks('P2');
  }
}
```

#### 1.2 å†…å­˜ä¼˜åŒ–

```typescript
// å†…å­˜ç®¡ç†å·¥å…·
class MemoryManager {
  private imageCache: LRUCache<string, any>;
  private dataCache: LRUCache<string, any>;

  constructor() {
    this.imageCache = new LRUCache({
      max: 100, // æœ€å¤šç¼“å­˜100å¼ å›¾ç‰‡
      ttl: 1000 * 60 * 30 // 30åˆ†é’Ÿè¿‡æœŸ
    });

    this.dataCache = new LRUCache({
      max: 200, // æœ€å¤šç¼“å­˜200æ¡æ•°æ®
      ttl: 1000 * 60 * 60 // 1å°æ—¶è¿‡æœŸ
    });
  }

  // å›¾ç‰‡å†…å­˜ç®¡ç†
  cacheImage(key: string, image: any): void {
    this.imageCache.set(key, image);
  }

  getImage(key: string): any {
    return this.imageCache.get(key);
  }

  clearImageCache(): void {
    this.imageCache.clear();
  }

  // æ•°æ®å†…å­˜ç®¡ç†
  cacheData(key: string, data: any): void {
    this.dataCache.set(key, data);
  }

  getData(key: string): any {
    return this.dataCache.get(key);
  }

  clearDataCache(): void {
    this.dataCache.clear();
  }

  // å†…å­˜å‹åŠ›å¤„ç†
  handleMemoryPressure(): void {
    // æ¸…ç†ä¸€åŠç¼“å­˜
    const imageKeys = Array.from(this.imageCache.keys());
    const dataKeys = Array.from(this.dataCache.keys());

    for (let i = 0; i < Math.ceil(imageKeys.length / 2); i++) {
      this.imageCache.delete(imageKeys[i]);
    }

    for (let i = 0; i < Math.ceil(dataKeys.length / 2); i++) {
      this.dataCache.delete(dataKeys[i]);
    }
  }
}
```

### 2. ç½‘ç»œä¼˜åŒ–

#### 2.1 è¯·æ±‚ä¼˜åŒ–ç­–ç•¥

```typescript
// ç½‘ç»œè¯·æ±‚ä¼˜åŒ–
class NetworkOptimizer {
  private requestQueue: RequestQueue;
  private cacheManager: CacheManager;

  constructor() {
    this.requestQueue = new RequestQueue({
      maxConcurrent: 5,
      retryAttempts: 3,
      retryDelay: 1000
    });

    this.cacheManager = new CacheManager({
      defaultTTL: 1000 * 60 * 5, // 5åˆ†é’Ÿç¼“å­˜
      maxSize: 100 // æœ€å¤šç¼“å­˜100ä¸ªè¯·æ±‚
    });
  }

  // æ™ºèƒ½è¯·æ±‚ç¼“å­˜
  async request<T>(config: RequestConfig): Promise<T> {
    const cacheKey = this.generateCacheKey(config);

    // æ£€æŸ¥ç¼“å­˜
    const cachedResponse = this.cacheManager.get(cacheKey);
    if (cachedResponse && !this.isExpired(cachedResponse)) {
      return cachedResponse.data;
    }

    // æ·»åŠ åˆ°è¯·æ±‚é˜Ÿåˆ—
    return this.requestQueue.add(async () => {
      const response = await this.httpClient.request<T>(config);

      // ç¼“å­˜å“åº”
      this.cacheManager.set(cacheKey, {
        data: response.data,
        timestamp: Date.now(),
        ttl: config.cacheTTL || 1000 * 60 * 5
      });

      return response.data;
    });
  }

  // æ‰¹é‡è¯·æ±‚
  async batchRequest<T>(requests: RequestConfig[]): Promise<T[]> {
    return Promise.all(requests.map(config => this.request<T>(config)));
  }

  // é¢„åŠ è½½é‡è¦æ•°æ®
  async preloadCriticalData(): Promise<void> {
    const criticalRequests = [
      '/api/v1/user/profile',
      '/api/v1/auth/permissions',
      '/api/v1/attendance/today-status'
    ];

    await this.batchRequest(criticalRequests.map(url => ({ url, method: 'GET' })));
  }
}
```

#### 2.2 ç¦»çº¿æ”¯æŒ

```typescript
// ç¦»çº¿æ•°æ®ç®¡ç†
class OfflineDataManager {
  private db: IDBDatabase;
  private syncQueue: SyncQueue;

  async initialize(): Promise<void> {
    // åˆå§‹åŒ–IndexedDB
    this.db = await this.openDatabase();
    this.syncQueue = new SyncQueue();

    // ç›‘å¬ç½‘ç»œçŠ¶æ€
    this.setupNetworkListener();
  }

  // ç¦»çº¿å­˜å‚¨æ•°æ®
  async storeData(key: string, data: any): Promise<void> {
    const transaction = this.db.transaction(['offline_data'], 'readwrite');
    const store = transaction.objectStore('offline_data');

    await store.put({
      key,
      data,
      timestamp: Date.now(),
      synced: false
    });
  }

  // è·å–ç¦»çº¿æ•°æ®
  async getData(key: string): Promise<any> {
    const transaction = this.db.transaction(['offline_data'], 'readonly');
    const store = transaction.objectStore('offline_data');

    const result = await store.get(key);
    return result ? result.data : null;
  }

  // åŒæ­¥ç¦»çº¿æ•°æ®
  async syncOfflineData(): Promise<void> {
    if (!navigator.onLine) return;

    const transaction = this.db.transaction(['offline_data'], 'readonly');
    const store = transaction.objectStore('offline_data');
    const request = store.getAll();

    const offlineData = await new Promise((resolve) => {
      request.onsuccess = () => resolve(request.result);
    });

    for (const item of offlineData) {
      if (!item.synced) {
        try {
          await this.syncToServer(item);
          await this.markAsSynced(item.key);
        } catch (error) {
          console.error('åŒæ­¥å¤±è´¥:', error);
        }
      }
    }
  }

  private setupNetworkListener(): void {
    window.addEventListener('online', () => {
      this.syncOfflineData();
    });
  }
}
```

---

## ğŸ“Š ç§»åŠ¨ç«¯æ•°æ®ç»Ÿè®¡ä¸åˆ†æ

### 1. ç”¨æˆ·è¡Œä¸ºç»Ÿè®¡

#### 1.1 é¡µé¢è®¿é—®ç»Ÿè®¡

```typescript
// é¡µé¢è®¿é—®ç»Ÿè®¡
class PageAnalytics {
  private sessionStartTime: number;
  private currentPage: string;
  private pageViewStartTime: number;

  constructor() {
    this.sessionStartTime = Date.now();
  }

  // é¡µé¢å¼€å§‹è®¿é—®
  pageView(pageName: string, params?: any): void {
    const now = Date.now();

    // ç»“æŸä¸Šä¸€é¡µé¢ç»Ÿè®¡
    if (this.currentPage) {
      this.trackPageEnd(this.currentPage, now - this.pageViewStartTime);
    }

    // å¼€å§‹æ–°é¡µé¢ç»Ÿè®¡
    this.currentPage = pageName;
    this.pageViewStartTime = now;

    // å‘é€é¡µé¢è®¿é—®äº‹ä»¶
    this.trackEvent('page_view', {
      page_name: pageName,
      params,
      session_duration: now - this.sessionStartTime,
      timestamp: now
    });
  }

  // é¡µé¢ç¦»å¼€
  pageLeave(pageName: string): void {
    if (this.currentPage === pageName) {
      const duration = Date.now() - this.pageViewStartTime;
      this.trackPageEnd(pageName, duration);
      this.currentPage = null;
    }
  }

  // è·Ÿè¸ªé¡µé¢ç»“æŸ
  private trackPageEnd(pageName: string, duration: number): void {
    this.trackEvent('page_end', {
      page_name: pageName,
      duration,
      bounce_rate: duration < 5000 ? 1 : 0
    });
  }

  // è·Ÿè¸ªç”¨æˆ·äº¤äº’
  trackInteraction(element: string, action: string, value?: any): void {
    this.trackEvent('user_interaction', {
      element,
      action,
      value,
      page: this.currentPage,
      timestamp: Date.now()
    });
  }

  // å‘é€ç»Ÿè®¡äº‹ä»¶
  private trackEvent(eventName: string, data: any): void {
    // å‘é€åˆ°åç«¯ç»Ÿè®¡æœåŠ¡
    fetch('/api/v1/analytics/track', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        event_name: eventName,
        data,
        device_info: this.getDeviceInfo(),
        app_version: this.getAppVersion()
      })
    }).catch(error => {
      console.error('ç»Ÿè®¡äº‹ä»¶å‘é€å¤±è´¥:', error);
    });
  }
}
```

#### 1.2 åŠŸèƒ½ä½¿ç”¨ç»Ÿè®¡

```typescript
// åŠŸèƒ½ä½¿ç”¨ç»Ÿè®¡
class FeatureAnalytics {
  // ç»Ÿè®¡åŠŸèƒ½ä½¿ç”¨
  trackFeatureUsage(featureName: string, action: string, context?: any): void {
    this.trackEvent('feature_usage', {
      feature_name: featureName,
      action,
      context,
      timestamp: Date.now()
    });
  }

  // ç»Ÿè®¡è€ƒå‹¤æ‰“å¡
  trackClockIn(method: string, location?: LocationInfo, result: 'success' | 'failed'): void {
    this.trackFeatureUsage('attendance_clock_in', method, {
      location,
      result,
      timestamp: Date.now()
    });
  }

  // ç»Ÿè®¡é—¨ç¦é€šè¡Œ
  trackAccessControl(method: string, location: string, result: 'success' | 'failed'): void {
    this.trackFeatureUsage('access_control', method, {
      location,
      result,
      timestamp: Date.now()
    });
  }

  // ç»Ÿè®¡æ¶ˆè´¹æ”¯ä»˜
  trackConsume(amount: number, method: string, merchant: string): void {
    this.trackFeatureUsage('consume_payment', method, {
      amount,
      merchant,
      timestamp: Date.now()
    });
  }

  // ç»Ÿè®¡è§†é¢‘ç›‘æ§
  trackVideoMonitoring(cameraId: string, duration: number, actions: string[]): void {
    this.trackFeatureUsage('video_monitoring', 'view', {
      camera_id: cameraId,
      duration,
      actions,
      timestamp: Date.now()
    });
  }
}
```

### 2. æ€§èƒ½ç›‘æ§

#### 2.1 åº”ç”¨æ€§èƒ½ç»Ÿè®¡

```typescript
// æ€§èƒ½ç›‘æ§
class PerformanceMonitor {
  private metrics: PerformanceMetrics = {};

  // å¯åŠ¨æ—¶é—´ç›‘æ§
  trackStartupTime(phase: string, startTime: number): void {
    const duration = Date.now() - startTime;
    this.metrics.startup_phase = {
      ...this.metrics.startup_phase,
      [phase]: duration
    };

    this.reportMetric('startup_time', {
      phase,
      duration,
      timestamp: Date.now()
    });
  }

  // é¡µé¢åŠ è½½æ—¶é—´ç›‘æ§
  trackPageLoadTime(pageName: string, loadTime: number): void {
    this.reportMetric('page_load_time', {
      page_name: pageName,
      load_time: loadTime,
      timestamp: Date.now()
    });
  }

  // APIè¯·æ±‚æ€§èƒ½ç›‘æ§
  trackApiRequest(url: string, method: string, duration: number, status: number): void {
    this.reportMetric('api_request', {
      url,
      method,
      duration,
      status,
      timestamp: Date.now()
    });
  }

  // å†…å­˜ä½¿ç”¨ç›‘æ§
  trackMemoryUsage(): void {
    if ('memory' in performance) {
      const memory = (performance as any).memory;
      this.reportMetric('memory_usage', {
        used: memory.usedJSHeapSize,
        total: memory.totalJSHeapSize,
        limit: memory.jsHeapSizeLimit,
        timestamp: Date.now()
      });
    }
  }

  // ç½‘ç»œçŠ¶æ€ç›‘æ§
  trackNetworkStatus(): void {
    const connection = (navigator as any).connection;
    if (connection) {
      this.reportMetric('network_status', {
        effective_type: connection.effectiveType,
        downlink: connection.downlink,
        rtt: connection.rtt,
        timestamp: Date.now()
      });
    }
  }

  // å‘é€æ€§èƒ½æŒ‡æ ‡
  private reportMetric(metricName: string, data: any): void {
    fetch('/api/v1/analytics/performance', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        metric_name: metricName,
        data,
        device_info: this.getDeviceInfo(),
        app_version: this.getAppVersion()
      })
    }).catch(error => {
      console.error('æ€§èƒ½æŒ‡æ ‡å‘é€å¤±è´¥:', error);
    });
  }
}
```

---

## ğŸ”’ ç§»åŠ¨ç«¯å®‰å…¨ä¸éšç§

### 1. æ•°æ®å®‰å…¨

#### 1.1 æ•°æ®åŠ å¯†

```typescript
// æ•°æ®åŠ å¯†å·¥å…·
class DataEncryption {
  private encryptionKey: string;

  constructor(key: string) {
    this.encryptionKey = key;
  }

  // AESåŠ å¯†
  async encrypt(data: string): Promise<string> {
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(data);

    const key = await crypto.subtle.importKey(
      'raw',
      encoder.encode(this.encryptionKey),
      { name: 'AES-GCM' },
      false,
      ['encrypt']
    );

    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encryptedData = await crypto.subtle.encrypt(
      {
        name: 'AES-GCM',
        iv: iv
      },
      key,
      dataBuffer
    );

    const result = new Uint8Array(iv.length + encryptedData.byteLength);
    result.set(iv);
    result.set(new Uint8Array(encryptedData), iv.length);

    return btoa(String.fromCharCode(...result));
  }

  // AESè§£å¯†
  async decrypt(encryptedData: string): Promise<string> {
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();

    const data = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
    const iv = data.slice(0, 12);
    const encrypted = data.slice(12);

    const key = await crypto.subtle.importKey(
      'raw',
      encoder.encode(this.encryptionKey),
      { name: 'AES-GCM' },
      false,
      ['decrypt']
    );

    const decryptedData = await crypto.subtle.decrypt(
      {
        name: 'AES-GCM',
        iv: iv
      },
      key,
      encrypted
    );

    return decoder.decode(decryptedData);
  }

  // å®‰å…¨å­˜å‚¨æ•æ„Ÿæ•°æ®
  async storeSensitiveData(key: string, value: string): Promise<void> {
    const encrypted = await this.encrypt(value);
    await SecureStorage.setItem(key, encrypted);
  }

  // è·å–æ•æ„Ÿæ•°æ®
  async getSensitiveData(key: string): Promise<string | null> {
    try {
      const encrypted = await SecureStorage.getItem(key);
      if (!encrypted) return null;

      return await this.decrypt(encrypted);
    } catch (error) {
      console.error('è·å–æ•æ„Ÿæ•°æ®å¤±è´¥:', error);
      return null;
    }
  }
}
```

#### 1.2 ç”Ÿç‰©è¯†åˆ«å®‰å…¨

```typescript
// ç”Ÿç‰©è¯†åˆ«å®‰å…¨
class BiometricSecurity {
  private encryption: DataEncryption;

  constructor(encryptionKey: string) {
    this.encryption = new DataEncryption(encryptionKey);
  }

  // æ£€æŸ¥ç”Ÿç‰©è¯†åˆ«æ”¯æŒ
  async checkBiometricSupport(): Promise<BiometricSupport> {
    const supported = await LocalAuthentication.isSupportedAsync();

    if (!supported) {
      return { supported: false, reason: 'è®¾å¤‡ä¸æ”¯æŒç”Ÿç‰©è¯†åˆ«' };
    }

    const enrolled = await LocalAuthentication.isEnrolledAsync();
    if (!enrolled) {
      return { supported: false, reason: 'è®¾å¤‡æœªå½•å…¥ç”Ÿç‰©è¯†åˆ«ä¿¡æ¯' };
    }

    const hardwareLevel = await LocalAuthentication.getEnrolledLevelAsync();

    return {
      supported: true,
      hardwareLevel,
      availableMethods: await LocalAuthentication.supportedAuthenticationTypesAsync()
    };
  }

  // ç”Ÿç‰©è¯†åˆ«è®¤è¯
  async authenticate(reason: string): Promise<AuthenticationResult> {
    try {
      const result = await LocalAuthentication.authenticateAsync({
        promptMessage: reason,
        fallbackLabel: 'ä½¿ç”¨å¯†ç ',
        cancelLabel: 'å–æ¶ˆ',
        disableDeviceFallback: false,
        biometricSecurityLevel: 'strong'
      });

      if (result.success) {
        return {
          success: true,
          method: result.authenticationType,
          timestamp: Date.now()
        };
      } else {
        return {
          success: false,
          reason: result.error || 'è®¤è¯å¤±è´¥'
        };
      }
    } catch (error) {
      return {
        success: false,
        reason: error.message
      };
    }
  }

  // å®‰å…¨å­˜å‚¨ç”Ÿç‰©è¯†åˆ«æ¨¡æ¿
  async storeBiometricTemplate(userId: string, template: BiometricTemplate): Promise<void> {
    const encryptedTemplate = await this.encryption.encrypt(JSON.stringify(template));

    await SecureStorage.setItem(`biometric_${userId}`, encryptedTemplate);
  }

  // è·å–ç”Ÿç‰©è¯†åˆ«æ¨¡æ¿
  async getBiometricTemplate(userId: string): Promise<BiometricTemplate | null> {
    try {
      const encryptedTemplate = await SecureStorage.getItem(`biometric_${userId}`);
      if (!encryptedTemplate) return null;

      const decryptedTemplate = await this.encryption.decrypt(encryptedTemplate);
      return JSON.parse(decryptedTemplate);
    } catch (error) {
      console.error('è·å–ç”Ÿç‰©è¯†åˆ«æ¨¡æ¿å¤±è´¥:', error);
      return null;
    }
  }
}
```

### 2. éšç§ä¿æŠ¤

#### 2.1 ä½ç½®éšç§ä¿æŠ¤

```typescript
// ä½ç½®éšç§ä¿æŠ¤
class LocationPrivacy {
  private privacySettings: LocationPrivacySettings;

  constructor(settings: LocationPrivacySettings) {
    this.privacySettings = settings;
  }

  // æ¨¡ç³ŠåŒ–ä½ç½®ä¿¡æ¯
  async obfuscateLocation(location: LocationInfo): Promise<LocationInfo> {
    if (!this.privacySettings.enableLocationObfuscation) {
      return location;
    }

    const precision = this.privacySettings.locationPrecision;

    // å¯¹ç»çº¬åº¦è¿›è¡Œæ¨¡ç³ŠåŒ–å¤„ç†
    const fuzzyLatitude = this.fuzzyCoordinate(location.latitude, precision);
    const fuzzyLongitude = this.fuzzyCoordinate(location.longitude, precision);

    return {
      ...location,
      latitude: fuzzyLatitude,
      longitude: fuzzyLongitude,
      accuracy: precision,
      obfuscated: true
    };
  }

  // æ¨¡ç³ŠåŒ–åæ ‡
  private fuzzyCoordinate(coordinate: number, precision: number): number {
    const factor = Math.pow(10, precision);
    return Math.round(coordinate * factor) / factor;
  }

  // æ£€æŸ¥ä½ç½®è®¿é—®æƒé™
  async checkLocationPermission(): Promise<LocationPermissionResult> {
    try {
      const { status } = await Location.requestForegroundPermissionsAsync();

      if (status === 'granted') {
        return { granted: true, status };
      } else if (status === 'denied') {
        return { granted: false, status, reason: 'ç”¨æˆ·æ‹’ç»äº†ä½ç½®æƒé™' };
      } else {
        return { granted: false, status, reason: 'ä½ç½®æƒé™çŠ¶æ€æœªçŸ¥' };
      }
    } catch (error) {
      return {
        granted: false,
        reason: error.message
      };
    }
  }

  // ä½ç½®æ•°æ®æœ€å°åŒ–
  minimizeLocationData(location: LocationInfo, purpose: LocationPurpose): LocationInfo {
    const minimizedData: LocationInfo = {
      latitude: location.latitude,
      longitude: location.longitude,
      timestamp: location.timestamp
    };

    // æ ¹æ®ç”¨é€”å†³å®šè¿”å›å“ªäº›ä¿¡æ¯
    switch (purpose) {
      case 'attendance':
        minimizedData.accuracy = Math.max(location.accuracy || 0, 50); // è€ƒå‹¤åªéœ€è¦50ç±³ç²¾åº¦
        break;
      case 'access_control':
        minimizedData.accuracy = Math.max(location.accuracy || 0, 10); // é—¨ç¦éœ€è¦10ç±³ç²¾åº¦
        break;
      case 'emergency':
        // ç´§æ€¥æƒ…å†µè¿”å›å®Œæ•´ä¿¡æ¯
        return location;
      default:
        minimizedData.accuracy = precision; // é»˜è®¤ä½¿ç”¨è®¾å®šçš„ç²¾åº¦
    }

    return minimizedData;
  }
}
```

#### 2.2 æ•°æ®è„±æ•

```typescript
// æ•°æ®è„±æ•å·¥å…·
class DataMasking {

  // æ‰‹æœºå·è„±æ•
  maskPhoneNumber(phoneNumber: string): string {
    if (!phoneNumber || phoneNumber.length < 11) {
      return phoneNumber;
    }

    return phoneNumber.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
  }

  // èº«ä»½è¯å·è„±æ•
  maskIdCard(idCard: string): string {
    if (!idCard || idCard.length < 18) {
      return idCard;
    }

    return idCard.replace(/(\d{6})\d{8}(\d{4})/, '$1********$2');
  }

  // å§“åè„±æ•
  maskName(name: string): string {
    if (!name || name.length <= 2) {
      return name;
    }

    if (name.length === 3) {
      return name.replace(/(\w).(\w)/, '$1*$2');
    } else {
      return name.replace(/(\w)\w+(\w)/, '$1**$2');
    }
  }

  // åœ°å€è„±æ•
  maskAddress(address: string): string {
    if (!address || address.length < 10) {
      return address;
    }

    // ä¿ç•™å‰6ä½å’Œå4ä½
    return address.replace(/(.{6}).*(.{4})/, '$1****$2');
  }

  // é“¶è¡Œå¡å·è„±æ•
  maskBankCard(cardNumber: string): string {
    if (!cardNumber || cardNumber.length < 16) {
      return cardNumber;
    }

    return cardNumber.replace(/(\d{4})\d+(\d{4})/, '$1 **** **** $2');
  }

  // é‚®ç®±è„±æ•
  maskEmail(email: string): string {
    if (!email || !email.includes('@')) {
      return email;
    }

    const [username, domain] = email.split('@');

    if (username.length <= 3) {
      return `${username[0]}***@${domain}`;
    } else {
      return `${username.substring(0, 3)}***@${domain}`;
    }
  }
}
```

---

## ğŸ“± ç§»åŠ¨ç«¯æµ‹è¯•ç­–ç•¥

### 1. è‡ªåŠ¨åŒ–æµ‹è¯•

#### 1.1 å•å…ƒæµ‹è¯•

```typescript
// å•å…ƒæµ‹è¯•ç¤ºä¾‹
import { renderHook, act } from '@testing-library/react-hooks';
import { useAttendanceService } from '../services/attendance';
import { mockSdk } from '../__mocks__/sdk';

describe('useAttendanceService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('clockIn', () => {
    it('should successfully clock in with valid location', async () => {
      const mockLocation = {
        latitude: 39.9042,
        longitude: 116.4074,
        accuracy: 10,
        address: 'åŒ—äº¬å¸‚æœé˜³åŒº'
      };

      const expectedResponse = {
        success: true,
        clockInId: '12345',
        clockTime: '2024-01-01 09:00:00',
        location: 'åŒ—äº¬å¸‚æœé˜³åŒº'
      };

      mockSdk.api.post.mockResolvedValue({ data: expectedResponse });

      const { result } = renderHook(() => useAttendanceService(mockSdk));

      await act(async () => {
        const response = await result.current.clockIn(mockLocation);
        expect(response).toEqual(expectedResponse);
      });

      expect(mockSdk.api.post).toHaveBeenCalledWith('/api/v1/attendance/clock-in', {
        userId: mockSdk.auth.getCurrentUser().id,
        location: mockLocation,
        timestamp: expect.any(Number)
      });
    });

    it('should handle clock in failure', async () => {
      const mockLocation = {
        latitude: 39.9042,
        longitude: 116.4074,
        accuracy: 10,
        address: 'åŒ—äº¬å¸‚æœé˜³åŒº'
      };

      const errorMessage = 'ç½‘ç»œè¿æ¥å¤±è´¥';
      mockSdk.api.post.mockRejectedValue(new Error(errorMessage));

      const { result } = renderHook(() => useAttendanceService(mockSdk));

      await act(async () => {
        const response = await result.current.clockIn(mockLocation);
        expect(response.success).toBe(false);
        expect(response.reason).toBe(errorMessage);
      });
    });
  });
});
```

#### 1.2 é›†æˆæµ‹è¯•

```typescript
// é›†æˆæµ‹è¯•ç¤ºä¾‹
import { render, fireEvent, waitFor } from '@testing-library/react-native';
import { AttendanceScreen } from '../screens/AttendanceScreen';
import { NavigationContainer } from '@react-navigation/native';

describe('AttendanceScreen Integration Tests', () => {
  it('should complete full clock in flow', async () => {
    const mockNavigation = {
      navigate: jest.fn(),
      goBack: jest.fn()
    };

    const { getByTestId, getByText } = render(
      <NavigationContainer>
        <AttendanceScreen navigation={mockNavigation} />
      </NavigationContainer>
    );

    // ç­‰å¾…é¡µé¢åŠ è½½
    await waitFor(() => {
      expect(getByText('è€ƒå‹¤æ‰“å¡')).toBeTruthy();
    });

    // ç‚¹å‡»æ‰“å¡æŒ‰é’®
    const clockInButton = getByTestId('clock-in-button');
    fireEvent.press(clockInButton);

    // æ£€æŸ¥å®šä½æƒé™è¯·æ±‚
    await waitFor(() => {
      expect(getByText('è¯·æ±‚å®šä½æƒé™')).toBeTruthy();
    });

    // æ¨¡æ‹Ÿæƒé™æˆäºˆ
    const grantPermissionButton = getByTestId('grant-permission-button');
    fireEvent.press(grantPermissionButton);

    // æ£€æŸ¥æ‰“å¡æˆåŠŸæç¤º
    await waitFor(() => {
      expect(getByText('æ‰“å¡æˆåŠŸ')).toBeTruthy();
    });
  });

  it('should handle biometric clock in', async () => {
    // Mockç”Ÿç‰©è¯†åˆ«æˆåŠŸ
    LocalAuthentication.authenticateAsync.mockResolvedValue({
      success: true,
      authenticationType: 'facial'
    });

    const mockNavigation = {
      navigate: jest.fn(),
      goBack: jest.fn()
    };

    const { getByTestId } = render(
      <NavigationContainer>
        <AttendanceScreen navigation={mockNavigation} />
      </NavigationContainer>
    );

    // ç‚¹å‡»ç”Ÿç‰©è¯†åˆ«æ‰“å¡
    const biometricButton = getByTestId('biometric-clock-in-button');
    fireEvent.press(biometricButton);

    // æ£€æŸ¥ç”Ÿç‰©è¯†åˆ«è®¤è¯
    await waitFor(() => {
      expect(LocalAuthentication.authenticateAsync).toHaveBeenCalledWith({
        promptMessage: 'è¯·è¿›è¡Œäººè„¸è¯†åˆ«',
        fallbackLabel: 'ä½¿ç”¨å¯†ç ',
        cancelLabel: 'å–æ¶ˆ',
        disableDeviceFallback: false
      });
    });
  });
});
```

#### 1.3 E2Eæµ‹è¯•

```typescript
// E2Eæµ‹è¯•ç¤ºä¾‹ (Detox)
describe('Attendance E2E Tests', () => {
  beforeAll(async () => {
    await device.launchApp();
  });

  beforeEach(async () => {
    await device.reloadReactNative();
  });

  it('should complete full attendance flow', async () => {
    // ç™»å½•
    await element(by.id('username-input')).typeText('testuser');
    await element(by.id('password-input')).typeText('password123');
    await element(by.id('login-button')).tap();

    // ç­‰å¾…é¦–é¡µåŠ è½½
    await waitFor(element(by.id('home-screen')))
      .toBeVisible()
      .withTimeout(5000);

    // å¯¼èˆªåˆ°è€ƒå‹¤é¡µé¢
    await element(by.id('attendance-tab')).tap();

    // ç­‰å¾…è€ƒå‹¤é¡µé¢åŠ è½½
    await waitFor(element(by.id('attendance-screen')))
      .toBeVisible()
      .withTimeout(5000);

    // ç‚¹å‡»æ‰“å¡æŒ‰é’®
    await element(by.id('clock-in-button')).tap();

    // å¤„ç†æƒé™è¯·æ±‚ï¼ˆå¦‚æœå‡ºç°ï¼‰
    try {
      await waitFor(element(by.text('å…è®¸')))
        .toBeVisible()
        .withTimeout(3000);
      await element(by.text('å…è®¸')).tap();
    } catch (error) {
      // æƒé™å¯èƒ½å·²ç»æˆäºˆ
    }

    // éªŒè¯æ‰“å¡æˆåŠŸ
    await waitFor(element(by.text('æ‰“å¡æˆåŠŸ')))
      .toBeVisible()
      .withTimeout(10000);

    // æ£€æŸ¥æ‰“å¡è®°å½•
    await element(by.id('attendance-records')).tap();
    await waitFor(element(by.text('ä»Šæ—¥æ‰“å¡è®°å½•')))
      .toBeVisible()
      .withTimeout(5000);
  });

  it('should handle visitor registration flow', async () => {
    // å¯¼èˆªåˆ°è®¿å®¢é¡µé¢
    await element(by.id('visitor-tab')).tap();

    // ç‚¹å‡»è®¿å®¢é¢„çº¦
    await element(by.id('visitor-appointment-button')).tap();

    // å¡«å†™è®¿å®¢ä¿¡æ¯
    await element(by.id('visitor-name-input')).typeText('å¼ ä¸‰');
    await element(by.id('visitor-phone-input')).typeText('13800138000');
    await element(by.id('visit-purpose-input')).typeText('å•†åŠ¡æ‹œè®¿');

    // é€‰æ‹©è®¿é—®æ—¶é—´
    await element(by.id('visit-date-picker')).tap();
    await element(by.text('ç¡®å®š')).tap();

    // æäº¤é¢„çº¦
    await element(by.id('submit-appointment-button')).tap();

    // éªŒè¯é¢„çº¦æˆåŠŸ
    await waitFor(element(by.text('é¢„çº¦æˆåŠŸ')))
      .toBeVisible()
      .withTimeout(10000);
  });
});
```

### 2. æ€§èƒ½æµ‹è¯•

#### 2.1 å¯åŠ¨æ€§èƒ½æµ‹è¯•

```typescript
// å¯åŠ¨æ€§èƒ½æµ‹è¯•
describe('App Startup Performance', () => {
  it('should complete startup within acceptable time', async () => {
    const startTime = Date.now();

    await device.launchApp();

    // ç­‰å¾…é¦–é¡µåŠ è½½å®Œæˆ
    await waitFor(element(by.id('home-screen')))
      .toBeVisible()
      .withTimeout(15000); // æœ€å¤§ç­‰å¾…15ç§’

    const startupTime = Date.now() - startTime;

    // éªŒè¯å¯åŠ¨æ—¶é—´åœ¨å¯æ¥å—èŒƒå›´å†…ï¼ˆ5ç§’ï¼‰
    expect(startupTime).toBeLessThan(5000);

    // è®°å½•å¯åŠ¨æ—¶é—´
    console.log(`App startup time: ${startupTime}ms`);
  });

  it('should handle memory usage during startup', async () => {
    await device.launchApp();

    // è·å–å¯åŠ¨åçš„å†…å­˜ä½¿ç”¨æƒ…å†µ
    const memoryUsage = await device.getMemoryUsage();

    // éªŒè¯å†…å­˜ä½¿ç”¨åœ¨åˆç†èŒƒå›´å†…ï¼ˆ200MBï¼‰
    expect(memoryUsage.used).toBeLessThan(200 * 1024 * 1024);

    console.log(`Memory usage after startup: ${memoryUsage.used / 1024 / 1024}MB`);
  });
});
```

#### 2.2 UIæ€§èƒ½æµ‹è¯•

```typescript
// UIæ€§èƒ½æµ‹è¯•
describe('UI Performance Tests', () => {
  it('should maintain 60fps during scrolling', async () => {
    await device.launchApp();

    // å¯¼èˆªåˆ°é•¿åˆ—è¡¨é¡µé¢
    await element(by.id('attendance-records')).tap();

    // è®°å½•FPS
    const fpsMonitor = await device.startFPSMonitoring();

    // æ»šåŠ¨åˆ—è¡¨
    await element(by.id('records-list')).scroll(500, 'down');

    // åœæ­¢FPSç›‘æ§
    const fpsData = await device.stopFPSMonitoring(fpsMonitor);

    // éªŒè¯å¹³å‡FPSä¸ä½äº45
    const averageFPS = fpsData.reduce((sum, fps) => sum + fps, 0) / fpsData.length;
    expect(averageFPS).toBeGreaterThan(45);

    console.log(`Average FPS during scrolling: ${averageFPS}`);
  });

  it('should handle rapid UI interactions smoothly', async () => {
    await device.launchApp();

    const startTime = Date.now();

    // å¿«é€Ÿåˆ‡æ¢å¤šä¸ªæ ‡ç­¾é¡µ
    for (let i = 0; i < 10; i++) {
      await element(by.id('home-tab')).tap();
      await element(by.id('attendance-tab')).tap();
      await element(by.id('access-tab')).tap();
    }

    const interactionTime = Date.now() - startTime;

    // éªŒè¯äº¤äº’å“åº”æ—¶é—´ï¼ˆæ¯æ¬¡åˆ‡æ¢ä¸è¶…è¿‡100msï¼‰
    expect(interactionTime / 30).toBeLessThan(100);

    console.log(`Average tab switch time: ${interactionTime / 30}ms`);
  });
});
```

---

## ğŸ“š ç§»åŠ¨ç«¯æ–‡æ¡£å’ŒåŸ¹è®­

### 1. å¼€å‘æ–‡æ¡£ç»“æ„

```
mobile-documentation/
â”œâ”€â”€ README.md                           # ç§»åŠ¨ç«¯å¼€å‘æ€»è§ˆ
â”œâ”€â”€ getting-started/
â”‚   â”œâ”€â”€ installation.md              # å¼€å‘ç¯å¢ƒæ­å»º
â”‚   â”œâ”€â”€ project-structure.md         # é¡¹ç›®ç»“æ„è¯´æ˜
â”‚   â”œâ”€â”€ build-process.md             # æ„å»ºæµç¨‹
â”‚   â””â”€â”€ deployment.md                # éƒ¨ç½²æŒ‡å—
â”œâ”€â”€ development/
â”‚   â”œâ”€â”€ coding-standards.md          # ç¼–ç è§„èŒƒ
â”‚   â”œâ”€â”€ component-library.md         # ç»„ä»¶åº“ä½¿ç”¨
â”‚   â”œâ”€â”€ api-integration.md           # APIé›†æˆæŒ‡å—
â”‚   â””â”€â”€ debugging.md                 # è°ƒè¯•æŠ€å·§
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ authentication.md            # è®¤è¯åŠŸèƒ½
â”‚   â”œâ”€â”€ biometric.md                 # ç”Ÿç‰©è¯†åˆ«
â”‚   â”œâ”€â”€ location.md                  # å®šä½æœåŠ¡
â”‚   â”œâ”€â”€ push-notification.md         # æ¨é€é€šçŸ¥
â”‚   â””â”€â”€ offline-mode.md              # ç¦»çº¿æ¨¡å¼
â”œâ”€â”€ testing/
â”‚   â”œâ”€â”€ unit-testing.md              # å•å…ƒæµ‹è¯•
â”‚   â”œâ”€â”€ integration-testing.md       # é›†æˆæµ‹è¯•
â”‚   â”œâ”€â”€ e2e-testing.md               # ç«¯åˆ°ç«¯æµ‹è¯•
â”‚   â””â”€â”€ performance-testing.md       # æ€§èƒ½æµ‹è¯•
â”œâ”€â”€ deployment/
â”‚   â”œâ”€â”€ ios-deployment.md            # iOSéƒ¨ç½²
â”‚   â”œâ”€â”€ android-deployment.md        # Androidéƒ¨ç½²
â”‚   â”œâ”€â”€ app-store-release.md         # åº”ç”¨å•†åº—å‘å¸ƒ
â”‚   â””â”€â”€ enterprise-distribution.md   # ä¼ä¸šåˆ†å‘
â””â”€â”€ troubleshooting/
    â”œâ”€â”€ common-issues.md             # å¸¸è§é—®é¢˜
    â”œâ”€â”€ performance-issues.md        # æ€§èƒ½é—®é¢˜
    â”œâ”€â”€ security-issues.md           # å®‰å…¨é—®é¢˜
    â””â”€â”€ compatibility-issues.md      # å…¼å®¹æ€§é—®é¢˜
```

### 2. å¼€å‘è€…åŸ¹è®­è®¡åˆ’

#### 2.1 æ–°äººåŸ¹è®­å¤§çº²

```markdown
# IOE-DREAMç§»åŠ¨ç«¯å¼€å‘æ–°äººåŸ¹è®­è®¡åˆ’

## ç¬¬1å‘¨ï¼šåŸºç¡€åŸ¹è®­
- IOE-DREAMç³»ç»Ÿæ¶æ„ä»‹ç»
- ç§»åŠ¨ç«¯æŠ€æœ¯æ ˆé€‰æ‹©å’Œç¯å¢ƒæ­å»º
- Gitå·¥ä½œæµç¨‹å’Œä»£ç è§„èŒƒ
- åŸºç¡€ç»„ä»¶ä½¿ç”¨å’Œå¼€å‘æµç¨‹

## ç¬¬2å‘¨ï¼šæ ¸å¿ƒåŠŸèƒ½å¼€å‘
- ç”¨æˆ·è®¤è¯å’Œæƒé™ç®¡ç†
- APIé›†æˆå’Œæ•°æ®ç®¡ç†
- ç”Ÿç‰©è¯†åˆ«é›†æˆ
- å®šä½æœåŠ¡å’Œåœ°å›¾é›†æˆ

## ç¬¬3å‘¨ï¼šä¸šåŠ¡æ¨¡å—å¼€å‘
- è€ƒå‹¤æ‰“å¡åŠŸèƒ½å¼€å‘
- é—¨ç¦é€šè¡ŒåŠŸèƒ½å¼€å‘
- æ¶ˆè´¹æ”¯ä»˜åŠŸèƒ½å¼€å‘
- è®¿å®¢ç®¡ç†åŠŸèƒ½å¼€å‘

## ç¬¬4å‘¨ï¼šé«˜çº§åŠŸèƒ½å’Œä¼˜åŒ–
- è§†é¢‘ç›‘æ§åŠŸèƒ½å¼€å‘
- æ¨é€é€šçŸ¥å®ç°
- ç¦»çº¿æ¨¡å¼å¼€å‘
- æ€§èƒ½ä¼˜åŒ–å’Œè°ƒè¯•

## ç¬¬5å‘¨ï¼šæµ‹è¯•å’Œéƒ¨ç½²
- å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
- æ€§èƒ½æµ‹è¯•å’Œå‹åŠ›æµ‹è¯•
- iOSåº”ç”¨æ‰“åŒ…å’Œå‘å¸ƒ
- Androidåº”ç”¨æ‰“åŒ…å’Œå‘å¸ƒ

## ç¬¬6å‘¨ï¼šé¡¹ç›®å®æˆ˜
- ç‹¬ç«‹å®Œæˆä¸€ä¸ªå°åŠŸèƒ½æ¨¡å—
- Code Reviewå’Œæœ€ä½³å®è·µ
- é—®é¢˜æ’æŸ¥å’Œè§£å†³èƒ½åŠ›
- å›¢é˜Ÿåä½œå’Œæ²Ÿé€š
```

#### 2.2 æŠ€èƒ½æå‡åŸ¹è®­

```markdown
# ç§»åŠ¨ç«¯å¼€å‘æŠ€èƒ½æå‡åŸ¹è®­

## è¿›é˜¶æŠ€èƒ½
- React Native/Flutteré«˜çº§ç‰¹æ€§
- åŸç”Ÿæ¨¡å—å¼€å‘å’Œé›†æˆ
- æ€§èƒ½è°ƒä¼˜å’Œå†…å­˜ç®¡ç†
- å®‰å…¨å¼€å‘å’Œæ•°æ®ä¿æŠ¤

## ä¸“ä¸šæŠ€èƒ½
- éŸ³è§†é¢‘å¤„ç†å’Œä¼˜åŒ–
- å›¾åƒå¤„ç†å’ŒAIé›†æˆ
- è“ç‰™å’ŒNFCå¼€å‘
- ç¦»çº¿å­˜å‚¨å’Œæ•°æ®åŒæ­¥

## æ¶æ„æŠ€èƒ½
- ç§»åŠ¨ç«¯æ¶æ„è®¾è®¡
- çŠ¶æ€ç®¡ç†æœ€ä½³å®è·µ
- ç»„ä»¶åŒ–å¼€å‘æ¨¡å¼
- æ’ä»¶åŒ–å’Œçƒ­æ›´æ–°

## è¿ç»´æŠ€èƒ½
- è‡ªåŠ¨åŒ–æ„å»ºå’Œéƒ¨ç½²
- ç›‘æ§å‘Šè­¦å’Œæ—¥å¿—åˆ†æ
- å´©æºƒåˆ†æå’Œç‰ˆæœ¬ç®¡ç†
- ç”¨æˆ·åé¦ˆå’Œé—®é¢˜å®šä½
```

---

## ğŸ“‹ ç§»åŠ¨ç«¯é›†æˆæ£€æŸ¥æ¸…å•

### âœ… å¼€å‘ç¯å¢ƒæ£€æŸ¥
- [ ] Node.js 16+ ç‰ˆæœ¬å®‰è£…
- [ ] React Native CLI å·¥å…·å®‰è£…
- [ ] Android Studio å’Œ Android SDK é…ç½®
- [ ] Xcode å’Œ iOS Simulator é…ç½®
- [ ] Git å®¢æˆ·ç«¯é…ç½®
- [ ] VS Code / IDE æ’ä»¶å®‰è£…

### âœ… é¡¹ç›®é…ç½®æ£€æŸ¥
- [ ] package.json ä¾èµ–ç‰ˆæœ¬æ­£ç¡®
- [ ] iOS/Android å¹³å°é…ç½®æ­£ç¡®
- [ ] ç­¾åè¯ä¹¦å’Œå¯†é’¥é…ç½®
- [ ] ç¬¬ä¸‰æ–¹SDKé…ç½®ï¼ˆåœ°å›¾ã€æ¨é€ã€ç»Ÿè®¡ç­‰ï¼‰
- [ ] ç½‘ç»œè¯·æ±‚å’ŒAPIç«¯ç‚¹é…ç½®
- [ ] æ„å»ºè„šæœ¬å’ŒCI/CDé…ç½®

### âœ… åŠŸèƒ½é›†æˆæ£€æŸ¥
- [ ] ç”¨æˆ·è®¤è¯å’Œç™»å½•åŠŸèƒ½
- [ ] ç”Ÿç‰©è¯†åˆ«åŠŸèƒ½é›†æˆ
- [ ] å®šä½æœåŠ¡å’Œåœ°å›¾åŠŸèƒ½
- [ ] äºŒç»´ç æ‰«æå’Œç”Ÿæˆ
- [ ] NFC/è“ç‰™åŠŸèƒ½é›†æˆ
- [ ] æ¨é€é€šçŸ¥åŠŸèƒ½
- [ ] ç¦»çº¿æ•°æ®åŒæ­¥

### âœ… æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥
- [ ] åº”ç”¨å¯åŠ¨æ—¶é—´ä¼˜åŒ–
- [ ] å†…å­˜ä½¿ç”¨ä¼˜åŒ–
- [ ] ç½‘ç»œè¯·æ±‚ä¼˜åŒ–
- [ ] å›¾ç‰‡åŠ è½½å’Œç¼“å­˜ä¼˜åŒ–
- [ ] åˆ—è¡¨æ»šåŠ¨æ€§èƒ½ä¼˜åŒ–
- [ ] åŒ…ä½“ç§¯ä¼˜åŒ–

### âœ… å®‰å…¨æ£€æŸ¥
- [ ] æ•°æ®åŠ å¯†å’Œå­˜å‚¨å®‰å…¨
- [ ] APIé€šä¿¡å®‰å…¨ï¼ˆHTTPSã€è¯ä¹¦éªŒè¯ï¼‰
- [ ] ç”Ÿç‰©è¯†åˆ«å®‰å…¨å®ç°
- [ ] ç”¨æˆ·éšç§ä¿æŠ¤
- [ ] ä»£ç æ··æ·†å’Œä¿æŠ¤
- [ ] å®‰å…¨æ¼æ´æ‰«æ

### âœ… æµ‹è¯•æ£€æŸ¥
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 70%
- [ ] é›†æˆæµ‹è¯•åœºæ™¯å®Œæ•´
- [ ] E2Eæµ‹è¯•æ ¸å¿ƒæµç¨‹
- [ ] æ€§èƒ½æµ‹è¯•é€šè¿‡
- [ ] å…¼å®¹æ€§æµ‹è¯•é€šè¿‡
- [ ] å®‰å…¨æµ‹è¯•é€šè¿‡

### âœ… éƒ¨ç½²æ£€æŸ¥
- [ ] iOSåº”ç”¨æ„å»ºå’Œç­¾å
- [ ] Androidåº”ç”¨æ„å»ºå’Œç­¾å
- [ ] åº”ç”¨å•†åº—å‘å¸ƒèµ„æ–™å‡†å¤‡
- [ ] ç‰ˆæœ¬ç®¡ç†å’Œå‘å¸ƒæµç¨‹
- [ ] ç›‘æ§å’Œé”™è¯¯è¿½è¸ªé…ç½®
- [ ] ç”¨æˆ·åé¦ˆæ¸ é“å»ºç«‹

---

**ğŸ“ æ–‡æ¡£ç»´æŠ¤**: IOE-DREAMç§»åŠ¨ç«¯å¼€å‘å›¢é˜Ÿ
**ğŸ”„ æ›´æ–°å‘¨æœŸ**: æ¯æœˆæ›´æ–°
**âœ… å®¡æ ¸çŠ¶æ€**: å·²é€šè¿‡æ¶æ„å§”å‘˜ä¼šå®¡æ ¸