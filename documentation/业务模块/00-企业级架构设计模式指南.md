# IOE-DREAM ä¼ä¸šçº§æ¶æ„è®¾è®¡æ¨¡å¼æŒ‡å—

> **ç‰ˆæœ¬**: v1.0.0
> **åˆ›å»ºæ—¥æœŸ**: 2025-12-21
> **é€‚ç”¨èŒƒå›´**: IOE-DREAMæ™ºæ…§å›­åŒºå…¨ç³»ç»Ÿæ¶æ„è®¾è®¡
> **åˆ¶å®šæœºæ„**: IOE-DREAMæ¶æ„å§”å‘˜ä¼š

---

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£ä¸ºIOE-DREAMæ™ºæ…§å›­åŒºç®¡ç†ç³»ç»Ÿæä¾›ä¼ä¸šçº§æ¶æ„è®¾è®¡æ¨¡å¼æŒ‡å—ï¼Œç¡®ä¿ç³»ç»Ÿå…·å¤‡é«˜å¯æ‰©å±•æ€§ã€é«˜å¯ç»´æŠ¤æ€§ã€é«˜å¤ç”¨æ€§å’Œé«˜æ€§èƒ½ç‰¹æ€§ã€‚

### ğŸ¯ è®¾è®¡ç›®æ ‡

- **ç»„ä»¶åŒ–æ¨¡å—åŒ–**: ç¡®ä¿ç³»ç»Ÿæ¨¡å—é—´æ¾è€¦åˆã€é«˜å†…èš
- **é«˜å¤ç”¨æ€§**: è®¾è®¡å¯å¤ç”¨çš„ç»„ä»¶å’ŒæœåŠ¡
- **ç»“æ„æ¸…æ™°**: å»ºç«‹æ¸…æ™°çš„åˆ†å±‚æ¶æ„å’Œæ¨¡å—è¾¹ç•Œ
- **ä¼ä¸šçº§è´¨é‡**: æ»¡è¶³ä¼ä¸šçº§åº”ç”¨çš„æ€§èƒ½ã€å®‰å…¨ã€å¯é æ€§è¦æ±‚

---

## ğŸ—ï¸ ä¼ä¸šçº§æ¶æ„æ¨¡å¼

### 1. åˆ†å±‚æ¶æ„æ¨¡å¼ (Layered Architecture)

#### 1.1 å››å±‚æ¶æ„æ ‡å‡†

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Controller Layer (æ¥å£æ§åˆ¶å±‚)                â”‚
â”‚  - HTTPè¯·æ±‚å¤„ç†ã€å‚æ•°éªŒè¯ã€æƒé™æ§åˆ¶                           â”‚
â”‚  - ç»Ÿä¸€å“åº”æ ¼å¼(ResponseDTO)                                 â”‚
â”‚  - RESTful APIè®¾è®¡                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Service Layer (æ ¸å¿ƒä¸šåŠ¡å±‚)                    â”‚
â”‚  - æ ¸å¿ƒä¸šåŠ¡é€»è¾‘å®ç°                                          â”‚
â”‚  - äº‹åŠ¡ç®¡ç†(@Transactional)                                 â”‚
â”‚  - ä¸šåŠ¡è§„åˆ™éªŒè¯                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Manager Layer (æµç¨‹ç®¡ç†å±‚)                    â”‚
â”‚  - å¤æ‚æµç¨‹ç¼–æ’                                              â”‚
â”‚  - ç¼“å­˜ç®¡ç†                                                 â”‚
â”‚  - ç¬¬ä¸‰æ–¹æœåŠ¡é›†æˆ                                            â”‚
â”‚  - è·¨æ¨¡å—åè°ƒ                                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    DAO Layer (æ•°æ®è®¿é—®å±‚)                        â”‚
â”‚  - æ•°æ®åº“CRUDæ“ä½œ                                            â”‚
â”‚  - ç»§æ‰¿BaseMapper                                           â”‚
â”‚  - ä½¿ç”¨@Mapperæ³¨è§£                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å¼ºåˆ¶è§„èŒƒ**:
- âœ… Controlleråªå¤„ç†HTTPè¯·æ±‚ï¼Œä¸åŒ…å«ä¸šåŠ¡é€»è¾‘
- âœ… Serviceå±‚å®ç°æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼Œä½¿ç”¨@Transactional
- âœ… Managerå±‚å¤„ç†å¤æ‚æµç¨‹ï¼Œçº¯Javaç±»(ä¸ä½¿ç”¨Springæ³¨è§£)
- âœ… DAOå±‚åªè´Ÿè´£æ•°æ®è®¿é—®ï¼Œç»§æ‰¿BaseMapper
- âŒ **ç¦æ­¢è·¨å±‚è®¿é—®**: Controllerä¸èƒ½ç›´æ¥è°ƒç”¨Manager/DAO

#### 1.2 å±‚é—´è°ƒç”¨è§„èŒƒ

```java
// âœ… æ­£ç¡®çš„è°ƒç”¨æ¨¡å¼
@RestController
public class UserController {
    @Resource
    private UserService userService;  // Serviceå±‚æ³¨å…¥

    @PostMapping("/users")
    public ResponseDTO<UserVO> create(@Valid @RequestBody UserAddForm form) {
        return ResponseDTO.ok(userService.create(form));
    }
}

@Service
@Transactional(rollbackFor = Exception.class)
public class UserServiceImpl implements UserService {
    @Resource
    private UserManager userManager;  // Managerå±‚æ³¨å…¥

    public UserVO create(UserAddForm form) {
        return userManager.create(form);
    }
}

// Managerå±‚ - çº¯Javaç±»ï¼Œä¸ä½¿ç”¨Springæ³¨è§£
public class UserManager {
    private final UserDao userDao;
    private final DepartmentDao departmentDao;

    public UserManager(UserDao userDao, DepartmentDao departmentDao) {
        this.userDao = userDao;
        this.departmentDao = departmentDao;
    }

    public UserVO create(UserAddForm form) {
        // å¤æ‚ä¸šåŠ¡é€»è¾‘ç¼–æ’
        UserEntity user = convertToEntity(form);
        userDao.insert(user);
        return convertToVO(user);
    }
}
```

### 2. å¾®æœåŠ¡æ¶æ„æ¨¡å¼ (Microservice Architecture)

#### 2.1 æœåŠ¡åˆ’åˆ†åŸåˆ™

| æœåŠ¡ç±»å‹ | ç«¯å£ | èŒè´£ | æ ¸å¿ƒæ¨¡å— |
|----------|------|------|----------|
| **Gateway Service** | 8080 | APIç½‘å…³ã€è·¯ç”±ã€é™æµã€è®¤è¯ | Nacos Gateway |
| **Common Service** | 8088 | ç”¨æˆ·ç®¡ç†ã€æƒé™ã€å­—å…¸ã€é€šçŸ¥ | ç”¨æˆ·/æƒé™/é€šçŸ¥ |
| **Access Service** | 8090 | é—¨ç¦æ§åˆ¶ã€é€šè¡Œè®°å½•ã€æƒé™éªŒè¯ | é—¨ç¦è®¾å¤‡ç®¡ç† |
| **Attendance Service** | 8091 | è€ƒå‹¤æ‰“å¡ã€æ’ç­ç®¡ç†ã€ç»Ÿè®¡æŠ¥è¡¨ | è€ƒå‹¤è§„åˆ™å¼•æ“ |
| **Consume Service** | 8094 | æ¶ˆè´¹ç®¡ç†ã€è´¦æˆ·ç®¡ç†ã€å……å€¼é€€æ¬¾ | æ”¯ä»˜å¤„ç† |
| **Visitor Service** | 8095 | è®¿å®¢é¢„çº¦ã€èº«ä»½éªŒè¯ã€é€šè¡Œç®¡ç† | è®¿å®¢æµç¨‹ç®¡ç† |
| **Video Service** | 8092 | è§†é¢‘ç›‘æ§ã€AIåˆ†æã€å‘Šè­¦ç®¡ç† | è§†é¢‘æµå¤„ç† |
| **DeviceComm Service** | 8087 | è®¾å¤‡é€šè®¯ã€åè®®é€‚é…ã€æ•°æ®é‡‡é›† | åè®®å¤„ç†å™¨ |
| **OA Service** | 8093 | å·¥ä½œæµå¼•æ“ã€å®¡æ‰¹æµç¨‹ | æµç¨‹å¼•æ“ |

#### 2.2 æœåŠ¡é—´é€šä¿¡æ¨¡å¼

```yaml
# é€šä¿¡æ–¹å¼é€‰æ‹©å†³ç­–æ ‘
åŒæ­¥è°ƒç”¨:
  - æ¡ä»¶: å®æ—¶å“åº”è¦æ±‚ < 200ms
  - æ–¹å¼: HTTP/REST + GatewayServiceClient
  - ç¤ºä¾‹: ç”¨æˆ·ä¿¡æ¯æŸ¥è¯¢ã€æƒé™éªŒè¯

å¼‚æ­¥æ¶ˆæ¯:
  - æ¡ä»¶: éå®æ—¶ã€æ‰¹é‡å¤„ç†ã€äº‹ä»¶é€šçŸ¥
  - æ–¹å¼: RabbitMQ + äº‹ä»¶é©±åŠ¨
  - ç¤ºä¾‹: è€ƒå‹¤è®¡ç®—å®Œæˆé€šçŸ¥ã€æ¶ˆè´¹è®°å½•åŒæ­¥

äº‹ä»¶è®¢é˜…:
  - æ¡ä»¶: è·¨æ¨¡å—äº‹ä»¶å“åº”
  - æ–¹å¼: RabbitMQ Topic + è®¢é˜…æ¨¡å¼
  - ç¤ºä¾‹: é—¨ç¦äº‹ä»¶è§¦å‘è§†é¢‘å½•åˆ¶
```

### 3. é¢†åŸŸé©±åŠ¨è®¾è®¡æ¨¡å¼ (Domain-Driven Design)

#### 3.1 é¢†åŸŸæ¨¡å‹è®¾è®¡

```java
// èšåˆæ ¹ (Aggregate Root)
@Data
@EqualsAndHashCode(callSuper = true)
@TableName("t_access_user")
public class AccessUserEntity extends BaseEntity {

    @TableId(type = IdType.AUTO)
    private Long userId;

    @NotBlank
    @Size(max = 50)
    @TableField("user_name")
    private String userName;

    // é¢†åŸŸè¡Œä¸º - ä¸šåŠ¡è§„åˆ™å°è£…
    public boolean canAccessArea(Long areaId) {
        // æ£€æŸ¥ç”¨æˆ·æƒé™çš„é¢†åŸŸé€»è¾‘
        return checkAreaPermission(areaId);
    }

    public void recordAccessEvent(Long deviceId, AccessType type) {
        // è®°å½•é€šè¡Œäº‹ä»¶çš„é¢†åŸŸé€»è¾‘
        AccessRecordEntity record = AccessRecordEntity.builder()
            .userId(this.userId)
            .deviceId(deviceId)
            .accessType(type)
            .accessTime(LocalDateTime.now())
            .build();
        // é¢†åŸŸäº‹ä»¶å‘å¸ƒ
        DomainEventPublisher.publish(new AccessEvent(record));
    }
}

// å€¼å¯¹è±¡ (Value Object)
@Data
@AllArgsConstructor
public class AccessArea {
    private Long areaId;
    private String areaName;
    private AreaType areaType;

    // å€¼å¯¹è±¡ä¸å¯å˜
    public AccessArea withNewName(String newName) {
        return new AccessArea(this.areaId, newName, this.areaType);
    }
}

// é¢†åŸŸæœåŠ¡ (Domain Service)
@Service
public class AccessDomainService {

    @Resource
    private AccessUserRepository userRepository;

    public boolean validateAccessPermission(Long userId, Long areaId) {
        AccessUser user = userRepository.findById(userId);
        return user.canAccessArea(areaId);
    }
}
```

#### 3.2 é¢†åŸŸäº‹ä»¶æ¨¡å¼

```java
// é¢†åŸŸäº‹ä»¶
@Data
@AllArgsConstructor
public class AccessEvent implements DomainEvent {
    private String eventId;
    private Long userId;
    private Long deviceId;
    private AccessType accessType;
    private LocalDateTime eventTime;
    private String eventData;
}

// äº‹ä»¶å‘å¸ƒå™¨
@Component
public class DomainEventPublisher {

    @Resource
    private RabbitTemplate rabbitTemplate;

    public void publish(DomainEvent event) {
        rabbitTemplate.convertAndSend(
            "domain.events.exchange",
            "access.routing.key",
            event
        );
    }
}

// äº‹ä»¶å¤„ç†å™¨
@Component
@RabbitListener(queues = "access.event.queue")
public class AccessEventHandler {

    @RabbitHandler
    public void handleAccessEvent(AccessEvent event) {
        // å¤„ç†é—¨ç¦äº‹ä»¶
        if (event.getAccessType() == AccessType.IN) {
            triggerVideoRecording(event.getDeviceId());
            sendNotificationToSecurity(event);
        }
    }
}
```

---

## ğŸ¨ è®¾è®¡æ¨¡å¼åº”ç”¨æŒ‡å—

### 1. ç­–ç•¥æ¨¡å¼ (Strategy Pattern)

#### 1.1 é€‚ç”¨åœºæ™¯

- **å¤šç§ç®—æ³•å®ç°**: æ”¯ä»˜æ–¹å¼ã€è®¤è¯æ–¹å¼ã€éªŒè¯ç­–ç•¥
- **è¿è¡Œæ—¶ç®—æ³•åˆ‡æ¢**: æ ¹æ®é…ç½®é€‰æ‹©ä¸åŒå®ç°
- **å¼€é—­åŸåˆ™**: æ–°å¢ç®—æ³•æ— éœ€ä¿®æ”¹ç°æœ‰ä»£ç 

#### 1.2 æ ‡å‡†å®ç°æ¨¡æ¿

```java
// ç­–ç•¥æ¥å£
public interface PaymentStrategy {
    PaymentResult processPayment(PaymentRequest request);
    boolean supports(PaymentType type);
}

// ç­–ç•¥å·¥å‚
@Component
public class PaymentStrategyFactory {

    private final Map<PaymentType, PaymentStrategy> strategies;

    public PaymentStrategyFactory(List<PaymentStrategy> strategyList) {
        this.strategies = strategyList.stream()
            .collect(Collectors.toMap(
                strategy -> strategy.getSupportedType(),
                Function.identity()
            ));
    }

    public PaymentStrategy getStrategy(PaymentType type) {
        PaymentStrategy strategy = strategies.get(type);
        if (strategy == null) {
            throw new UnsupportedOperationException("Unsupported payment type: " + type);
        }
        return strategy;
    }
}

// å…·ä½“ç­–ç•¥å®ç°
@Component
public class WechatPaymentStrategy implements PaymentStrategy {

    @Override
    public PaymentResult processPayment(PaymentRequest request) {
        // å¾®ä¿¡æ”¯ä»˜å®ç°
        WechatPayResponse response = wechatPayClient.pay(request);
        return convertToResult(response);
    }

    @Override
    public boolean supports(PaymentType type) {
        return PaymentType.WECHAT.equals(type);
    }
}

// ç­–ç•¥ä½¿ç”¨
@Service
public class PaymentService {

    @Resource
    private PaymentStrategyFactory strategyFactory;

    public PaymentResult processPayment(PaymentRequest request) {
        PaymentStrategy strategy = strategyFactory.getStrategy(request.getType());
        return strategy.processPayment(request);
    }
}
```

### 2. å·¥å‚æ¨¡å¼ (Factory Pattern)

#### 2.1 é€‚ç”¨åœºæ™¯

- **å¯¹è±¡åˆ›å»ºå¤æ‚**: è®¾å¤‡åè®®å¤„ç†å™¨ã€æ¶ˆæ¯å¤„ç†å™¨
- **é…ç½®é©±åŠ¨åˆ›å»º**: æ ¹æ®é…ç½®åˆ›å»ºä¸åŒå®ç°
- **ä¾èµ–æ³¨å…¥ç®€åŒ–**: ç®€åŒ–å¤æ‚å¯¹è±¡çš„åˆ›å»ºè¿‡ç¨‹

#### 2.2 æŠ½è±¡å·¥å‚å®ç°

```java
// æŠ½è±¡å·¥å‚æ¥å£
public interface DeviceProtocolFactory {
    DeviceProtocolHandler createHandler(DeviceType type, DeviceConfig config);
    boolean supports(DeviceType type);
}

// å…·ä½“å·¥å‚å®ç°
@Component
public class ZktecoDeviceProtocolFactory implements DeviceProtocolFactory {

    @Override
    public DeviceProtocolHandler createHandler(DeviceType type, DeviceConfig config) {
        switch (type) {
            case ACCESS:
                return new ZktecoAccessProtocolHandler(config);
            case ATTENDANCE:
                return new ZktecoAttendanceProtocolHandler(config);
            default:
                throw new IllegalArgumentException("Unsupported device type: " + type);
        }
    }

    @Override
    public boolean supports(DeviceType type) {
        return DeviceType.ACCESS.equals(type) || DeviceType.ATTENDANCE.equals(type);
    }
}

// å·¥å‚æ³¨å†Œå™¨
@Component
public class DeviceProtocolFactoryRegistry {

    private final List<DeviceProtocolFactory> factories;

    public DeviceProtocolFactoryRegistry(List<DeviceProtocolFactory> factories) {
        this.factories = factories;
    }

    public DeviceProtocolHandler createHandler(DeviceType type, DeviceConfig config) {
        return factories.stream()
            .filter(factory -> factory.supports(type))
            .findFirst()
            .map(factory -> factory.createHandler(type, config))
            .orElseThrow(() -> new IllegalArgumentException("No factory found for type: " + type));
    }
}
```

### 3. è£…é¥°å™¨æ¨¡å¼ (Decorator Pattern)

#### 3.1 é€‚ç”¨åœºæ™¯

- **åŠŸèƒ½å¢å¼º**: åŸºç¡€æœåŠ¡ä¸Šæ·»åŠ ç¼“å­˜ã€æ—¥å¿—ã€ç›‘æ§
- **åŠ¨æ€ç»„åˆ**: è¿è¡Œæ—¶ç»„åˆä¸åŒåŠŸèƒ½
- **AOPæ›¿ä»£**: æ‰‹åŠ¨å®ç°æ¨ªåˆ‡å…³æ³¨ç‚¹

#### 3.2 æœåŠ¡è£…é¥°å™¨å®ç°

```java
// åŸºç¡€æœåŠ¡æ¥å£
public interface UserService {
    UserVO getUserById(Long userId);
    List<UserVO> getUsersByDepartment(Long deptId);
}

// åŸºç¡€æœåŠ¡å®ç°
@Service
public class UserServiceImpl implements UserService {

    @Resource
    private UserDao userDao;

    @Override
    public UserVO getUserById(Long userId) {
        UserEntity entity = userDao.selectById(userId);
        return convertToVO(entity);
    }

    @Override
    public List<UserVO> getUsersByDepartment(Long deptId) {
        List<UserEntity> entities = userDao.selectByDepartment(deptId);
        return entities.stream()
            .map(this::convertToVO)
            .collect(Collectors.toList());
    }
}

// ç¼“å­˜è£…é¥°å™¨
@Component
@Primary
public class CachedUserService implements UserService {

    @Resource
    @Qualifier("userServiceImpl")
    private UserService userService;

    @Resource
    private RedisTemplate<String, Object> redisTemplate;

    @Override
    public UserVO getUserById(Long userId) {
        String cacheKey = "user:" + userId;
        UserVO cached = (UserVO) redisTemplate.opsForValue().get(cacheKey);

        if (cached != null) {
            return cached;
        }

        UserVO result = userService.getUserById(userId);
        redisTemplate.opsForValue().set(cacheKey, result, Duration.ofMinutes(30));
        return result;
    }

    @Override
    public List<UserVO> getUsersByDepartment(Long deptId) {
        // å®ç°ç¼“å­˜é€»è¾‘
        return userService.getUsersByDepartment(deptId);
    }
}

// æ—¥å¿—è£…é¥°å™¨
@Component
@ConditionalOnProperty(name = "logging.user.enabled", havingValue = "true", matchIfMissing = true)
public class LoggingUserService implements UserService {

    @Resource
    private UserService userService;

    @Override
    public UserVO getUserById(Long userId) {
        log.info("Getting user by id: {}", userId);
        long startTime = System.currentTimeMillis();

        try {
            UserVO result = userService.getUserById(userId);
            long duration = System.currentTimeMillis() - startTime;
            log.info("Successfully got user: {} in {}ms", userId, duration);
            return result;
        } catch (Exception e) {
            log.error("Failed to get user: {}", userId, e);
            throw e;
        }
    }

    @Override
    public List<UserVO> getUsersByDepartment(Long deptId) {
        log.info("Getting users by department: {}", deptId);
        return userService.getUsersByDepartment(deptId);
    }
}
```

### 4. æ¨¡æ¿æ–¹æ³•æ¨¡å¼ (Template Method Pattern)

#### 4.1 é€‚ç”¨åœºæ™¯

- **æµç¨‹æ ‡å‡†åŒ–**: ä¸šåŠ¡æµç¨‹æœ‰å›ºå®šæ­¥éª¤ï¼Œå…·ä½“å®ç°å¯å˜
- **ä»£ç å¤ç”¨**: æå–å…¬å…±å¤„ç†é€»è¾‘åˆ°æŠ½è±¡ç±»
- **æ‰©å±•æ€§**: å…è®¸å­ç±»é‡å†™ç‰¹å®šæ­¥éª¤

#### 4.2 ä¸šåŠ¡æµç¨‹æ¨¡æ¿

```java
// æŠ½è±¡æ¨¡æ¿ç±»
public abstract class AbstractBusinessProcessTemplate<T, R> {

    // æ¨¡æ¿æ–¹æ³• - å®šä¹‰ç®—æ³•éª¨æ¶
    public final R execute(T request) {
        // 1. å‰ç½®æ ¡éªŒ
        validateRequest(request);

        // 2. å‡†å¤‡æ•°æ®
        prepareData(request);

        // 3. æ‰§è¡Œä¸šåŠ¡é€»è¾‘
        R result = doProcess(request);

        // 4. åç½®å¤„ç†
        postProcess(request, result);

        // 5. å‘é€é€šçŸ¥
        sendNotification(request, result);

        return result;
    }

    // æŠ½è±¡æ–¹æ³• - å­ç±»å¿…é¡»å®ç°
    protected abstract R doProcess(T request);

    // é’©å­æ–¹æ³• - å­ç±»å¯é€‰æ‹©æ€§é‡å†™
    protected void validateRequest(T request) {
        // é»˜è®¤æ ¡éªŒé€»è¾‘
        if (request == null) {
            throw new IllegalArgumentException("Request cannot be null");
        }
    }

    protected void prepareData(T request) {
        // é»˜è®¤æ•°æ®å‡†å¤‡é€»è¾‘
    }

    protected void postProcess(T request, R result) {
        // é»˜è®¤åç½®å¤„ç†é€»è¾‘
    }

    protected void sendNotification(T request, R result) {
        // é»˜è®¤é€šçŸ¥é€»è¾‘
    }
}

// å…·ä½“å®ç°
@Component
public class AccessProcessTemplate extends AbstractBusinessProcessTemplate<AccessRequest, AccessResult> {

    @Resource
    private AccessDeviceService deviceService;

    @Override
    protected AccessResult doProcess(AccessRequest request) {
        // å…·ä½“çš„é—¨ç¦å¤„ç†é€»è¾‘
        boolean canAccess = deviceService.verifyAccess(request);

        if (canAccess) {
            deviceService.grantAccess(request);
            return AccessResult.success();
        } else {
            return AccessResult.failure("Access denied");
        }
    }

    @Override
    protected void validateRequest(AccessRequest request) {
        super.validateRequest(request);

        if (request.getUserId() == null) {
            throw new IllegalArgumentException("User ID is required");
        }

        if (request.getDeviceId() == null) {
            throw new IllegalArgumentException("Device ID is required");
        }
    }

    @Override
    protected void sendNotification(AccessRequest request, AccessResult result) {
        if (!result.isSuccess()) {
            // å‘é€å¤±è´¥é€šçŸ¥
            notificationService.sendAccessDeniedNotification(request);
        }
    }
}
```

---

## ğŸ”§ ç»„ä»¶åŒ–æ¨¡å—åŒ–æ¶æ„

### 1. ç»„ä»¶è®¾è®¡åŸåˆ™

#### 1.1 å•ä¸€èŒè´£åŸåˆ™ (SRP)
- æ¯ä¸ªç»„ä»¶åªè´Ÿè´£ä¸€ä¸ªåŠŸèƒ½é¢†åŸŸ
- é¿å…å¤§è€Œå…¨çš„ç»„ä»¶è®¾è®¡
- ä¿æŒç»„ä»¶çš„é«˜å†…èšæ€§

#### 1.2 å¼€é—­åŸåˆ™ (OCP)
- å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­
- ä½¿ç”¨æ¥å£å’ŒæŠ½è±¡ç±»å®šä¹‰ç»„ä»¶è¾¹ç•Œ
- é€šè¿‡ç»„åˆè€Œéç»§æ‰¿å®ç°åŠŸèƒ½æ‰©å±•

#### 1.3 ä¾èµ–å€’ç½®åŸåˆ™ (DIP)
- é«˜å±‚æ¨¡å—ä¸ä¾èµ–ä½å±‚æ¨¡å—
- æŠ½è±¡ä¸ä¾èµ–å…·ä½“å®ç°
- ä½¿ç”¨ä¾èµ–æ³¨å…¥ç®¡ç†ç»„ä»¶å…³ç³»

### 2. ç»„ä»¶åŒ–å®ç°è§„èŒƒ

#### 2.1 ç»„ä»¶æ¥å£è®¾è®¡

```java
// ç»„ä»¶æ¥å£ - å®šä¹‰ç»„ä»¶å¥‘çº¦
public interface DataProcessor<T, R> {
    R process(T data);
    boolean supports(Class<?> dataType);
    String getComponentName();
}

// ç»„ä»¶åŸºç±»
public abstract class AbstractDataProcessor<T, R> implements DataProcessor<T, R> {

    @Resource
    protected ComponentLogger logger;

    @Override
    public final R process(T data) {
        long startTime = System.currentTimeMillis();
        logger.info("Starting data processing with component: {}", getComponentName());

        try {
            // å‰ç½®å¤„ç†
            T processedData = preProcess(data);

            // æ ¸å¿ƒå¤„ç†
            R result = doProcess(processedData);

            // åç½®å¤„ç†
            R finalResult = postProcess(result);

            long duration = System.currentTimeMillis() - startTime;
            logger.info("Data processing completed in {}ms", duration);

            return finalResult;

        } catch (Exception e) {
            logger.error("Data processing failed", e);
            throw new ComponentProcessingException("Failed to process data", e);
        }
    }

    protected abstract R doProcess(T data);

    protected T preProcess(T data) {
        return data; // é»˜è®¤ä¸åšé¢„å¤„ç†
    }

    protected R postProcess(R result) {
        return result; // é»˜è®¤ä¸åšåå¤„ç†
    }
}
```

#### 2.2 ç»„ä»¶æ³¨å†Œå’Œç®¡ç†

```java
// ç»„ä»¶æ³¨å†Œå™¨
@Component
public class ComponentRegistry {

    private final Map<String, DataProcessor<?, ?>> components = new ConcurrentHashMap<>();

    @PostConstruct
    public void registerComponents() {
        // è‡ªåŠ¨æ³¨å†Œæ‰€æœ‰DataProcessorç»„ä»¶
        ApplicationContext context = ApplicationContextHolder.getApplicationContext();
        Map<String, DataProcessor> processorBeans = context.getBeansOfType(DataProcessor.class);

        processorBeans.values().forEach(processor -> {
            components.put(processor.getComponentName(), processor);
        });

        logger.info("Registered {} components", components.size());
    }

    @SuppressWarnings("unchecked")
    public <T, R> DataProcessor<T, R> getComponent(String componentName) {
        DataProcessor<?, ?> component = components.get(componentName);
        if (component == null) {
            throw new ComponentNotFoundException("Component not found: " + componentName);
        }
        return (DataProcessor<T, R>) component;
    }

    public <T, R> DataProcessor<T, R> findComponent(Class<?> dataType) {
        return components.values().stream()
            .filter(processor -> processor.supports(dataType))
            .map(processor -> (DataProcessor<T, R>) processor)
            .findFirst()
            .orElseThrow(() -> new ComponentNotFoundException("No component found for data type: " + dataType));
    }
}

// ç»„ä»¶ç®¡ç†å™¨
@Service
public class ComponentManager {

    @Resource
    private ComponentRegistry componentRegistry;

    public <T, R> R processData(String componentName, T data) {
        DataProcessor<T, R> component = componentRegistry.getComponent(componentName);
        return component.process(data);
    }

    public <T, R> R processDataByType(T data) {
        DataProcessor<T, R> component = componentRegistry.findComponent(data.getClass());
        return component.process(data);
    }
}
```

### 3. é…ç½®é©±åŠ¨çš„ç»„ä»¶åŒ–

#### 3.1 ç»„ä»¶é…ç½®æ¨¡å‹

```yaml
# application.yml
components:
  data-processors:
    - name: "userProcessor"
      class: "com.ioedream.component.UserDataProcessor"
      enabled: true
      config:
        batchSize: 100
        timeout: 30000
    - name: "orderProcessor"
      class: "com.ioedream.component.OrderDataProcessor"
      enabled: true
      config:
        validationEnabled: true
        retryCount: 3
```

#### 3.2 åŠ¨æ€ç»„ä»¶åŠ è½½

```java
// ç»„ä»¶é…ç½®å±æ€§
@Data
@ConfigurationProperties(prefix = "components")
@Component
public class ComponentProperties {

    private List<DataProcessorConfig> dataProcessors = new ArrayList<>();

    @Data
    public static class DataProcessorConfig {
        private String name;
        private String className;
        private boolean enabled = true;
        private Map<String, Object> config = new HashMap<>();
    }
}

// åŠ¨æ€ç»„ä»¶åŠ è½½å™¨
@Component
public class DynamicComponentLoader {

    @Resource
    private ComponentRegistry componentRegistry;

    @Resource
    private ComponentProperties componentProperties;

    @PostConstruct
    public void loadComponents() {
        componentProperties.getDataProcessors().stream()
            .filter(DataProcessorConfig::isEnabled)
            .forEach(this::loadComponent);
    }

    @SuppressWarnings("unchecked")
    private void loadComponent(ComponentProperties.DataProcessorConfig config) {
        try {
            // åŠ¨æ€åŠ è½½ç»„ä»¶ç±»
            Class<?> componentClass = Class.forName(config.getClassName());

            // éªŒè¯ç»„ä»¶æ¥å£
            if (!DataProcessor.class.isAssignableFrom(componentClass)) {
                throw new IllegalArgumentException("Class must implement DataProcessor interface: " + config.getClassName());
            }

            // åˆ›å»ºç»„ä»¶å®ä¾‹
            DataProcessor<?, ?> component = (DataProcessor<?, ?>) componentClass.getDeclaredConstructor().newInstance();

            // åº”ç”¨é…ç½®
            applyConfiguration(component, config.getConfig());

            // æ³¨å†Œç»„ä»¶
            componentRegistry.register(config.getName(), component);

            logger.info("Successfully loaded component: {}", config.getName());

        } catch (Exception e) {
            logger.error("Failed to load component: {}", config.getName(), e);
        }
    }

    private void applyConfiguration(DataProcessor<?, ?> component, Map<String, Object> config) {
        // ä½¿ç”¨åå°„æˆ–å…¶ä»–æ–¹å¼åº”ç”¨é…ç½®
        if (component instanceof Configurable) {
            ((Configurable) component).configure(config);
        }
    }
}
```

---

## ğŸ“ æ¶æ„è´¨é‡æ ‡å‡†

### 1. ä»£ç è´¨é‡æŒ‡æ ‡

| æŒ‡æ ‡ | è¦æ±‚ | æ£€æŸ¥æ–¹å¼ |
|------|------|----------|
| åœˆå¤æ‚åº¦ | â‰¤ 10 | SonarQubeæ£€æŸ¥ |
| ç±»è¡Œæ•° | â‰¤ 500è¡Œ | Code Review |
| æ–¹æ³•è¡Œæ•° | â‰¤ 50è¡Œ | Code Review |
| æµ‹è¯•è¦†ç›–ç‡ | â‰¥ 80% | JaCoCoæŠ¥å‘Š |
| æŠ€æœ¯å€ºåŠ¡ | Açº§ | SonarQubeè´¨é‡é—¨ç¦ |

### 2. æ€§èƒ½æ ‡å‡†

| æŒ‡æ ‡ | è¦æ±‚ | ç›‘æ§æ–¹å¼ |
|------|------|----------|
| APIå“åº”æ—¶é—´ | P95 < 200ms | APMç›‘æ§ |
| æ•°æ®åº“æŸ¥è¯¢ | å•æ¬¡ < 100ms | æ…¢æŸ¥è¯¢ç›‘æ§ |
| ç¼“å­˜å‘½ä¸­ç‡ | â‰¥ 90% | Redisç›‘æ§ |
| ç³»ç»Ÿå¯ç”¨æ€§ | â‰¥ 99.9% | å¥åº·æ£€æŸ¥ |

### 3. å®‰å…¨æ ‡å‡†

| è¦æ±‚ | å®ç°æ–¹å¼ | éªŒè¯æ–¹å¼ |
|------|----------|----------|
| è¾“å…¥éªŒè¯ | @Valid + JSR303 | å•å…ƒæµ‹è¯• |
| æƒé™æ§åˆ¶ | RBAC + @PreAuthorize | é›†æˆæµ‹è¯• |
| æ•æ„Ÿæ•°æ®åŠ å¯† | AES + RSA | å®‰å…¨å®¡è®¡ |
| å®¡è®¡æ—¥å¿— | AOP + Logback | æ—¥å¿—å®¡è®¡ |

---

## ğŸš€ å®æ–½è·¯çº¿å›¾

### Phase 1: åŸºç¡€æ¶æ„æ ‡å‡†åŒ– (P0)
- [ ] å®Œå–„å››å±‚æ¶æ„è§„èŒƒ
- [ ] ç»Ÿä¸€ä¾èµ–æ³¨å…¥æ ‡å‡†
- [ ] å»ºç«‹ä»£ç è´¨é‡é—¨ç¦
- [ ] å®Œå–„å•å…ƒæµ‹è¯•è¦†ç›–ç‡

### Phase 2: è®¾è®¡æ¨¡å¼åº”ç”¨ (P1)
- [ ] ç­–ç•¥æ¨¡å¼æ ‡å‡†åŒ–
- [ ] å·¥å‚æ¨¡å¼ç»„ä»¶åŒ–
- [ ] è£…é¥°å™¨æ¨¡å¼å¢å¼º
- [ ] æ¨¡æ¿æ–¹æ³•æ¨¡å¼æµç¨‹åŒ–

### Phase 3: é«˜çº§æ¶æ„ä¼˜åŒ– (P2)
- [ ] é¢†åŸŸé©±åŠ¨è®¾è®¡å®æ–½
- [ ] äº‹ä»¶é©±åŠ¨æ¶æ„
- [ ] CQRSæ¨¡å¼åº”ç”¨
- [ ] å¾®æœåŠ¡æ²»ç†å®Œå–„

---

## ğŸ“š é™„å½•

### A. è®¾è®¡æ¨¡å¼å†³ç­–æ ‘

```
é€‰æ‹©è®¾è®¡æ¨¡å¼ï¼š
â”œâ”€â”€ éœ€è¦å¤šç§ç®—æ³•å®ç°ï¼Ÿ
â”‚   â”œâ”€â”€ æ˜¯ â†’ ç­–ç•¥æ¨¡å¼
â”‚   â””â”€â”€ å¦ â†’ ç»§ç»­
â”œâ”€â”€ éœ€è¦åˆ›å»ºå¤æ‚å¯¹è±¡ï¼Ÿ
â”‚   â”œâ”€â”€ æ˜¯ â†’ å·¥å‚æ¨¡å¼/å»ºé€ è€…æ¨¡å¼
â”‚   â””â”€â”€ å¦ â†’ ç»§ç»­
â”œâ”€â”€ éœ€è¦å¢å¼ºç°æœ‰åŠŸèƒ½ï¼Ÿ
â”‚   â”œâ”€â”€ æ˜¯ â†’ è£…é¥°å™¨æ¨¡å¼
â”‚   â””â”€â”€ å¦ â†’ ç»§ç»­
â”œâ”€â”€ éœ€è¦å®šä¹‰ç®—æ³•éª¨æ¶ï¼Ÿ
â”‚   â”œâ”€â”€ æ˜¯ â†’ æ¨¡æ¿æ–¹æ³•æ¨¡å¼
â”‚   â””â”€â”€ å¦ â†’ è€ƒè™‘å…¶ä»–æ¨¡å¼
```

### B. ç»„ä»¶åŒ–æ£€æŸ¥æ¸…å•

- [ ] ç»„ä»¶èŒè´£å•ä¸€æ˜ç¡®
- [ ] ç»„ä»¶æ¥å£è®¾è®¡åˆç†
- [ ] ç»„ä»¶é—´ä¾èµ–æœ€å°åŒ–
- [ ] ç»„ä»¶å¯ç‹¬ç«‹æµ‹è¯•
- [ ] ç»„ä»¶é…ç½®å¤–éƒ¨åŒ–
- [ ] ç»„ä»¶ç‰ˆæœ¬å¯ç®¡ç†

---

**ğŸ“ æ–‡æ¡£ç»´æŠ¤**: IOE-DREAMæ¶æ„å§”å‘˜ä¼š
**ğŸ”„ æ›´æ–°å‘¨æœŸ**: æ¯å­£åº¦æ›´æ–°
**âœ… å®¡æ ¸çŠ¶æ€**: å·²é€šè¿‡æ¶æ„å§”å‘˜ä¼šå®¡æ ¸