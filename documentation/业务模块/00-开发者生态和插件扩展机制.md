# IOE-DREAMå¼€å‘è€…ç”Ÿæ€å’Œæ’ä»¶æ‰©å±•æœºåˆ¶

> **ç‰ˆæœ¬**: v1.0.0
> **åˆ›å»ºæ—¥æœŸ**: 2025-12-21
> **é€‚ç”¨èŒƒå›´**: IOE-DREAMæ™ºæ…§å›­åŒºç®¡ç†ç³»ç»Ÿ
> **ç»´æŠ¤æœºæ„**: IOE-DREAMå¼€å‘è€…ç¤¾åŒºå§”å‘˜ä¼š

---

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£ä¸ºIOE-DREAMæ™ºæ…§å›­åŒºç®¡ç†ç³»ç»Ÿå»ºç«‹å®Œæ•´çš„å¼€å‘è€…ç”Ÿæ€å’Œæ’ä»¶æ‰©å±•æœºåˆ¶ï¼Œæ—¨åœ¨æ„å»ºå¼€æ”¾ã€åä½œã€å¯æŒç»­çš„å¼€å‘è€…ç¤¾åŒºï¼Œæ¨åŠ¨ç³»ç»ŸåŠŸèƒ½çš„ä¸æ–­æ‰©å±•å’Œåˆ›æ–°ã€‚

### ğŸ¯ ç”Ÿæ€å»ºè®¾ç›®æ ‡

- **å¼€æ”¾æ€§**: å»ºç«‹å¼€æ”¾çš„æ’ä»¶æ¶æ„ï¼Œæ”¯æŒç¬¬ä¸‰æ–¹å¼€å‘è€…æ‰©å±•åŠŸèƒ½
- **æ ‡å‡†åŒ–**: æä¾›ç»Ÿä¸€çš„å¼€å‘æ ‡å‡†ã€æ¥å£è§„èŒƒå’Œå·¥å…·é“¾
- **å¯æŒç»­æ€§**: å»ºç«‹å¥åº·çš„å•†ä¸šæ¨¡å¼å’Œç¤¾åŒºè¿è¥æœºåˆ¶
- **è´¨é‡ä¿éšœ**: å»ºç«‹æ’ä»¶å®¡æ ¸ã€æµ‹è¯•å’Œç›‘æ§ä½“ç³»

---

## ğŸ—ï¸ æ’ä»¶æ¶æ„è®¾è®¡

### 1. æ’ä»¶ç³»ç»Ÿæ¶æ„

```typescript
// æ’ä»¶ç³»ç»Ÿæ ¸å¿ƒæ¶æ„
interface PluginArchitecture {
  // æ’ä»¶ç”Ÿå‘½å‘¨æœŸ
  lifecycle: {
    discovery: PluginDiscovery;      // æ’ä»¶å‘ç°
    installation: PluginInstallation; // æ’ä»¶å®‰è£…
    activation: PluginActivation;     // æ’ä»¶æ¿€æ´»
    deactivation: PluginDeactivation; // æ’ä»¶åœç”¨
    uninstallation: PluginUninstallation; // æ’ä»¶å¸è½½
  };

  // æ’ä»¶éš”ç¦»
  isolation: {
    sandbox: PluginSandbox;          // æ’ä»¶æ²™ç®±
    permissions: PermissionManager;    // æƒé™ç®¡ç†
    resources: ResourceManager;        // èµ„æºç®¡ç†
    security: SecurityManager;        // å®‰å…¨ç®¡ç†
  };

  // æ’ä»¶é€šä¿¡
  communication: {
    events: EventBus;                // äº‹ä»¶æ€»çº¿
    api: PluginAPI;                  // APIæ¥å£
    hooks: HookSystem;               // é’©å­ç³»ç»Ÿ
    messaging: MessageBroker;         // æ¶ˆæ¯ä»£ç†
  };

  // æ’ä»¶ç®¡ç†
  management: {
    registry: PluginRegistry;         // æ’ä»¶æ³¨å†Œ
    loader: PluginLoader;             // æ’ä»¶åŠ è½½å™¨
    config: PluginConfig;             // é…ç½®ç®¡ç†
    monitoring: PluginMonitor;         // ç›‘æ§ç³»ç»Ÿ
  };
}
```

### 2. æ’ä»¶ç”Ÿå‘½å‘¨æœŸç®¡ç†

```typescript
// æ’ä»¶ç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨
class PluginLifecycleManager {
  private plugins: Map<string, PluginInstance> = new Map();
  private eventBus: EventBus;
  private sandbox: PluginSandbox;
  private permissions: PermissionManager;

  constructor(eventBus: EventBus, sandbox: PluginSandbox, permissions: PermissionManager) {
    this.eventBus = eventBus;
    this.sandbox = sandbox;
    this.permissions = permissions;
  }

  /**
   * å®‰è£…æ’ä»¶
   */
  async installPlugin(plugin: PluginPackage): Promise<InstallationResult> {
    try {
      // 1. éªŒè¯æ’ä»¶ç­¾åå’Œå®Œæ•´æ€§
      const isValid = await this.validatePlugin(plugin);
      if (!isValid) {
        throw new Error('Plugin validation failed');
      }

      // 2. æ£€æŸ¥ä¾èµ–å…³ç³»
      await this.checkDependencies(plugin);

      // 3. åˆ›å»ºæ’ä»¶å®ä¾‹
      const instance = await this.createPluginInstance(plugin);

      // 4. æ³¨å†Œæ’ä»¶
      this.plugins.set(plugin.manifest.id, instance);

      // 5. è§¦å‘å®‰è£…äº‹ä»¶
      await this.eventBus.emit('plugin:installed', {
        pluginId: plugin.manifest.id,
        version: plugin.manifest.version
      });

      return {
        success: true,
        pluginId: plugin.manifest.id
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * æ¿€æ´»æ’ä»¶
   */
  async activatePlugin(pluginId: string): Promise<ActivationResult> {
    const plugin = this.plugins.get(pluginId);
    if (!plugin) {
      throw new Error(`Plugin ${pluginId} not found`);
    }

    try {
      // 1. æ£€æŸ¥æƒé™
      await this.permissions.checkPermissions(plugin);

      // 2. åˆå§‹åŒ–æ’ä»¶æ²™ç®±
      await this.sandbox.initialize(plugin);

      // 3. è°ƒç”¨æ’ä»¶æ¿€æ´»æ–¹æ³•
      await plugin.activate();

      // 4. æ³¨å†Œæ’ä»¶äº‹ä»¶ç›‘å¬å™¨
      await this.registerEventListeners(plugin);

      // 5. æ›´æ–°æ’ä»¶çŠ¶æ€
      plugin.status = 'active';

      // 6. è§¦å‘æ¿€æ´»äº‹ä»¶
      await this.eventBus.emit('plugin:activated', {
        pluginId,
        timestamp: Date.now()
      });

      return {
        success: true,
        pluginId
      };
    } catch (error) {
      plugin.status = 'error';
      plugin.lastError = error.message;

      return {
        success: false,
        pluginId,
        error: error.message
      };
    }
  }

  /**
   * åœç”¨æ’ä»¶
   */
  async deactivatePlugin(pluginId: string): Promise<DeactivationResult> {
    const plugin = this.plugins.get(pluginId);
    if (!plugin) {
      throw new Error(`Plugin ${pluginId} not found`);
    }

    try {
      // 1. æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
      await this.unregisterEventListeners(plugin);

      // 2. è°ƒç”¨æ’ä»¶åœç”¨æ–¹æ³•
      await plugin.deactivate();

      // 3. æ¸…ç†æ²™ç®±
      await this.sandbox.cleanup(plugin);

      // 4. æ›´æ–°æ’ä»¶çŠ¶æ€
      plugin.status = 'inactive';

      // 5. è§¦å‘åœç”¨äº‹ä»¶
      await this.eventBus.emit('plugin:deactivated', {
        pluginId,
        timestamp: Date.now()
      });

      return {
        success: true,
        pluginId
      };
    } catch (error) {
      return {
        success: false,
        pluginId,
        error: error.message
      };
    }
  }

  /**
   * å¸è½½æ’ä»¶
   */
  async uninstallPlugin(pluginId: string): Promise<UninstallationResult> {
    const plugin = this.plugins.get(pluginId);
    if (!plugin) {
      throw new Error(`Plugin ${pluginId} not found`);
    }

    try {
      // 1. å…ˆåœç”¨æ’ä»¶
      if (plugin.status === 'active') {
        await this.deactivatePlugin(pluginId);
      }

      // 2. æ¸…ç†æ’ä»¶æ•°æ®
      await this.cleanupPluginData(plugin);

      // 3. ç§»é™¤æ’ä»¶æ³¨å†Œ
      this.plugins.delete(pluginId);

      // 4. è§¦å‘å¸è½½äº‹ä»¶
      await this.eventBus.emit('plugin:uninstalled', {
        pluginId,
        timestamp: Date.now()
      });

      return {
        success: true,
        pluginId
      };
    } catch (error) {
      return {
        success: false,
        pluginId,
        error: error.message
      };
    }
  }
}
```

### 3. æ’ä»¶æ²™ç®±æœºåˆ¶

```typescript
// æ’ä»¶æ²™ç®±
class PluginSandbox {
  private isolatedEnvs: Map<string, IsolatedEnvironment> = new Map();
  private security: SecurityManager;

  constructor(security: SecurityManager) {
    this.security = security;
  }

  /**
   * åˆå§‹åŒ–æ’ä»¶æ²™ç®±ç¯å¢ƒ
   */
  async initialize(plugin: PluginInstance): Promise<void> {
    const env = new IsolatedEnvironment(plugin.manifest.id);

    // 1. è®¾ç½®å®‰å…¨ç­–ç•¥
    await this.security.applySecurityPolicies(env, plugin.manifest.permissions);

    // 2. æ³¨å…¥å—é™API
    this.injectLimitedAPIs(env, plugin);

    // 3. è®¾ç½®èµ„æºé™åˆ¶
    this.setResourceLimits(env, plugin.manifest.resources);

    // 4. å¯åŠ¨éš”ç¦»ç¯å¢ƒ
    await env.start();

    this.isolatedEnvs.set(plugin.manifest.id, env);
    plugin.sandbox = env;
  }

  /**
   * æ³¨å…¥å—é™API
   */
  private injectLimitedAPIs(env: IsolatedEnvironment, plugin: PluginInstance): void {
    // æ³¨å…¥å®‰å…¨çš„APIæ¥å£
    const safeAPI = new SafeAPIWrapper(plugin.manifest.permissions);

    // æ ¸å¿ƒç³»ç»ŸAPIï¼ˆå—é™è®¿é—®ï¼‰
    env.expose('system', {
      // åªè¯»çš„ç³»ç»Ÿä¿¡æ¯
      getVersion: () => this.systemConfig.version,
      getPlatform: () => this.systemConfig.platform,
      getFeatures: () => this.getAvailableFeatures(plugin),

      // å®‰å…¨çš„å­˜å‚¨API
      storage: {
        get: (key: string) => this.secureStorage.get(plugin.manifest.id, key),
        set: (key: string, value: any) => this.secureStorage.set(plugin.manifest.id, key, value),
        remove: (key: string) => this.secureStorage.remove(plugin.manifest.id, key)
      },

      // å—é™çš„ç½‘ç»œAPI
      http: {
        get: (url: string, options?: any) => this.secureHTTP.get(url, options, plugin.manifest),
        post: (url: string, data?: any, options?: any) => this.secureHTTP.post(url, data, options, plugin.manifest)
      },

      // å—é™çš„æ–‡ä»¶ç³»ç»ŸAPI
      fs: {
        read: (path: string) => this.secureFS.read(path, plugin.manifest.id),
        write: (path: string, content: string) => this.secureFS.write(path, content, plugin.manifest.id)
      }
    });

    // æ’ä»¶é—´é€šä¿¡API
    env.expose('plugins', {
      emit: (event: string, data: any) => this.eventBus.emit(`plugin:${plugin.manifest.id}:${event}`, data),
      on: (event: string, handler: Function) => this.eventBus.on(`plugin:${plugin.manifest.id}:${event}`, handler),
      off: (event: string, handler: Function) => this.eventBus.off(`plugin:${plugin.manifest.id}:${event}`, handler),

      // æ’ä»¶é—´ç›´æ¥é€šä¿¡
      call: async (targetPluginId: string, method: string, args: any[]) => {
        return this.pluginIPC.call(targetPluginId, method, args, plugin.manifest.id);
      },

      // å¹¿æ’­æ¶ˆæ¯
      broadcast: (event: string, data: any) => {
        this.eventBus.emit(`plugin:broadcast:${event}`, data);
      }
    });

    // UIç»„ä»¶API
    env.expose('ui', {
      // å®‰å…¨çš„UIæ“ä½œ
      showToast: (message: string, type?: 'success' | 'error' | 'info') => {
        this.uiManager.showToast(message, type);
      },
      showModal: (options: ModalOptions) => {
        return this.uiManager.showModal(options);
      },
      navigate: (route: string) => {
        this.uiManager.navigate(route);
      },

      // å—é™çš„DOMæ“ä½œ
      dom: {
        createElement: (tagName: string, props?: any) => {
          return this.domManager.createElement(tagName, props, plugin.manifest.id);
        },
        appendChild: (parent: Element, child: Element) => {
          return this.domManager.appendChild(parent, child, plugin.manifest.id);
        }
      }
    });
  }

  /**
   * è®¾ç½®èµ„æºé™åˆ¶
   */
  private setResourceLimits(env: IsolatedEnvironment, resources: PluginResources): void {
    // å†…å­˜é™åˆ¶
    if (resources.memory) {
      env.setMemoryLimit(resources.memory);
    }

    // CPUé™åˆ¶
    if (resources.cpu) {
      env.setCPULimit(resources.cpu);
    }

    // ç½‘ç»œè¯·æ±‚é™åˆ¶
    if (resources.network) {
      env.setNetworkLimit(resources.network);
    }

    // å­˜å‚¨ç©ºé—´é™åˆ¶
    if (resources.storage) {
      env.setStorageLimit(resources.storage);
    }
  }

  /**
   * æ¸…ç†æ²™ç®±ç¯å¢ƒ
   */
  async cleanup(plugin: PluginInstance): Promise<void> {
    const env = this.isolatedEnvs.get(plugin.manifest.id);
    if (env) {
      await env.stop();
      this.isolatedEnvs.delete(plugin.manifest.id);
      plugin.sandbox = null;
    }
  }
}
```

### 4. æ’ä»¶APIè®¾è®¡

```typescript
// æ’ä»¶APIæ¥å£å®šä¹‰
interface PluginAPI {
  // ç³»ç»Ÿä¿¡æ¯API
  system: {
    getVersion(): string;
    getPlatform(): string;
    getEnvironment(): 'development' | 'production' | 'testing';
    getFeatures(): Promise<PlatformFeatures>;
  };

  // ç”¨æˆ·ç®¡ç†API
  user: {
    getCurrentUser(): Promise<UserInfo>;
    getUserPermissions(): Promise<Permission[]>;
    hasPermission(permission: string): Promise<boolean>;
  };

  // æ•°æ®å­˜å‚¨API
  storage: {
    get<T>(key: string): Promise<T | null>;
    set<T>(key: string, value: T): Promise<void>;
    remove(key: string): Promise<void>;
    clear(): Promise<void>;
    keys(): Promise<string[]>;
  };

  // HTTPè¯·æ±‚API
  http: {
    get<T>(url: string, config?: RequestConfig): Promise<T>;
    post<T>(url: string, data?: any, config?: RequestConfig): Promise<T>;
    put<T>(url: string, data?: any, config?: RequestConfig): Promise<T>;
    delete<T>(url: string, config?: RequestConfig): Promise<T>;
  };

  // äº‹ä»¶ç³»ç»ŸAPI
  events: {
    on(event: string, handler: EventHandler): void;
    off(event: string, handler: EventHandler): void;
    emit(event: string, data: any): void;
  };

  // UIç»„ä»¶API
  ui: {
    // é€šçŸ¥
    showNotification(options: NotificationOptions): Promise<string>;
    hideNotification(id: string): Promise<void>;

    // å¯¹è¯æ¡†
    showAlert(options: AlertOptions): Promise<AlertResult>;
    showConfirm(options: ConfirmOptions): Promise<boolean>;
    showPrompt(options: PromptOptions): Promise<string | null>;

    // é¡µé¢å¯¼èˆª
    navigate(path: string, params?: any): Promise<void>;
    goBack(): Promise<void>;
    reload(): Promise<void>;
  };

  // ä¸šåŠ¡æ¨¡å—API
  business: {
    // é—¨ç¦æ¨¡å—
    access: {
      openDoor(doorId: string): Promise<DoorControlResult>;
      getDoorStatus(doorId: string): Promise<DoorStatus>;
      getUserAccessPoints(): Promise<AccessPoint[]>;
    };

    // è€ƒå‹¤æ¨¡å—
    attendance: {
      clockIn(location: LocationInfo): Promise<ClockInResult>;
      getTodayRecords(): Promise<AttendanceRecord[]>;
      getStatistics(period: DateRange): Promise<AttendanceStatistics>;
    };

    // æ¶ˆè´¹æ¨¡å—
    consume: {
      getBalance(): Promise<AccountBalance>;
      makePayment(paymentInfo: PaymentInfo): Promise<PaymentResult>;
      getTransactionHistory(params: TransactionParams): Promise<TransactionRecord[]>;
    };

    // è®¿å®¢æ¨¡å—
    visitor: {
      createAppointment(appointment: VisitorAppointment): Promise<AppointmentResult>;
      checkIn(visitorId: string): Promise<CheckInResult>;
      getVisitorList(params: VisitorListParams): Promise<VisitorRecord[]>;
    };

    // è§†é¢‘æ¨¡å—
    video: {
      getCameraList(): Promise<Camera[]>;
      getLiveStream(cameraId: string): Promise<StreamInfo>;
      startRecording(cameraId: string): Promise<RecordingResult>;
      getRecordings(params: RecordingParams): Promise<RecordingRecord[]>;
    };
  };
}

// æ’ä»¶APIå®ç°
class PluginAPIImpl implements PluginAPI {
  private pluginId: string;
  private permissions: PermissionManager;
  private security: SecurityManager;

  constructor(pluginId: string, permissions: PermissionManager, security: SecurityManager) {
    this.pluginId = pluginId;
    this.permissions = permissions;
    this.security = security;
  }

  // ç³»ç»ŸAPIå®ç°
  system = {
    getVersion: () => this.systemConfig.version,
    getPlatform: () => this.systemConfig.platform,
    getEnvironment: () => process.env.NODE_ENV as any,
    getFeatures: async () => {
      await this.permissions.check(this.pluginId, 'system:features');
      return {
        multilingual: true,
        themeSupport: true,
        offlineMode: true,
        pushNotifications: true,
        biometricAuth: true
      };
    }
  };

  // ç”¨æˆ·APIå®ç°
  user = {
    getCurrentUser: async () => {
      await this.permissions.check(this.pluginId, 'user:read');
      return this.authService.getCurrentUser();
    },
    getUserPermissions: async () => {
      await this.permissions.check(this.pluginId, 'user:permissions');
      return this.authService.getUserPermissions();
    },
    hasPermission: async (permission: string) => {
      return await this.permissions.check(this.pluginId, `user:permission:${permission}`);
    }
  };

  // å­˜å‚¨APIå®ç°
  storage = {
    get: async (key: string) => {
      await this.permissions.check(this.pluginId, 'storage:read');
      return this.storageService.get(this.pluginId, key);
    },
    set: async (key: string, value: any) => {
      await this.permissions.check(this.pluginId, 'storage:write');
      return this.storageService.set(this.pluginId, key, value);
    },
    remove: async (key: string) => {
      await this.permissions.check(this.pluginId, 'storage:write');
      return this.storageService.remove(this.pluginId, key);
    },
    clear: async () => {
      await this.permissions.check(this.pluginId, 'storage:write');
      return this.storageService.clear(this.pluginId);
    },
    keys: async () => {
      await this.permissions.check(this.pluginId, 'storage:read');
      return this.storageService.keys(this.pluginId);
    }
  };

  // HTTP APIå®ç°
  http = {
    get: async (url: string, config?: RequestConfig) => {
      await this.permissions.check(this.pluginId, 'http:read');
      return this.httpClient.get(url, { ...config, pluginId: this.pluginId });
    },
    post: async (url: string, data?: any, config?: RequestConfig) => {
      await this.permissions.check(this.pluginId, 'http:write');
      return this.httpClient.post(url, data, { ...config, pluginId: this.pluginId });
    },
    put: async (url: string, data?: any, config?: RequestConfig) => {
      await this.permissions.check(this.pluginId, 'http:write');
      return this.httpClient.put(url, data, { ...config, pluginId: this.pluginId });
    },
    delete: async (url: string, config?: RequestConfig) => {
      await this.permissions.check(this.pluginId, 'http:delete');
      return this.httpClient.delete(url, { ...config, pluginId: this.pluginId });
    }
  };

  // äº‹ä»¶APIå®ç°
  events = {
    on: (event: string, handler: EventHandler) => {
      return this.eventBus.on(`plugin:${this.pluginId}:${event}`, handler);
    },
    off: (event: string, handler: EventHandler) => {
      return this.eventBus.off(`plugin:${this.pluginId}:${event}`, handler);
    },
    emit: (event: string, data: any) => {
      return this.eventBus.emit(`plugin:${this.pluginId}:${event}`, data);
    }
  };

  // UI APIå®ç°
  ui = {
    showNotification: async (options: NotificationOptions) => {
      await this.permissions.check(this.pluginId, 'ui:notification');
      return this.uiManager.showNotification({
        ...options,
        pluginId: this.pluginId
      });
    },
    hideNotification: async (id: string) => {
      await this.permissions.check(this.pluginId, 'ui:notification');
      return this.uiManager.hideNotification(id);
    },
    showAlert: async (options: AlertOptions) => {
      await this.permissions.check(this.pluginId, 'ui:dialog');
      return this.uiManager.showAlert({
        ...options,
        pluginId: this.pluginId
      });
    },
    showConfirm: async (options: ConfirmOptions) => {
      await this.permissions.check(this.pluginId, 'ui:dialog');
      return this.uiManager.showConfirm({
        ...options,
        pluginId: this.pluginId
      });
    },
    showPrompt: async (options: PromptOptions) => {
      await this.permissions.check(this.pluginId, 'ui:dialog');
      return this.uiManager.showPrompt({
        ...options,
        pluginId: this.pluginId
      });
    },
    navigate: async (path: string, params?: any) => {
      await this.permissions.check(this.pluginId, 'ui:navigation');
      return this.uiManager.navigate(path, params);
    },
    goBack: async () => {
      await this.permissions.check(this.pluginId, 'ui:navigation');
      return this.uiManager.goBack();
    },
    reload: async () => {
      await this.permissions.check(this.pluginId, 'ui:navigation');
      return this.uiManager.reload();
    }
  };

  // ä¸šåŠ¡æ¨¡å—APIå®ç°
  business = {
    access: {
      openDoor: async (doorId: string) => {
        await this.permissions.check(this.pluginId, 'access:control');
        return this.accessService.openDoor(doorId, this.pluginId);
      },
      getDoorStatus: async (doorId: string) => {
        await this.permissions.check(this.pluginId, 'access:read');
        return this.accessService.getDoorStatus(doorId);
      },
      getUserAccessPoints: async () => {
        await this.permissions.check(this.pluginId, 'access:read');
        return this.accessService.getUserAccessPoints();
      }
    },
    attendance: {
      clockIn: async (location: LocationInfo) => {
        await this.permissions.check(this.pluginId, 'attendance:clock');
        return this.attendanceService.clockIn(location, this.pluginId);
      },
      getTodayRecords: async () => {
        await this.permissions.check(this.pluginId, 'attendance:read');
        return this.attendanceService.getTodayRecords();
      },
      getStatistics: async (period: DateRange) => {
        await this.permissions.check(this.pluginId, 'attendance:statistics');
        return this.attendanceService.getStatistics(period);
      }
    },
    consume: {
      getBalance: async () => {
        await this.permissions.check(this.pluginId, 'consume:read');
        return this.consumeService.getBalance();
      },
      makePayment: async (paymentInfo: PaymentInfo) => {
        await this.permissions.check(this.pluginId, 'consume:payment');
        return this.consumeService.makePayment(paymentInfo, this.pluginId);
      },
      getTransactionHistory: async (params: TransactionParams) => {
        await this.permissions.check(this.pluginId, 'consume:read');
        return this.consumeService.getTransactionHistory(params);
      }
    },
    visitor: {
      createAppointment: async (appointment: VisitorAppointment) => {
        await this.permissions.check(this.pluginId, 'visitor:create');
        return this.visitorService.createAppointment(appointment, this.pluginId);
      },
      checkIn: async (visitorId: string) => {
        await this.permissions.check(this.pluginId, 'visitor:checkin');
        return this.visitorService.checkIn(visitorId);
      },
      getVisitorList: async (params: VisitorListParams) => {
        await this.permissions.check(this.pluginId, 'visitor:read');
        return this.visitorService.getVisitorList(params);
      }
    },
    video: {
      getCameraList: async () => {
        await this.permissions.check(this.pluginId, 'video:read');
        return this.videoService.getCameraList();
      },
      getLiveStream: async (cameraId: string) => {
        await this.permissions.check(this.pluginId, 'video:stream');
        return this.videoService.getLiveStream(cameraId);
      },
      startRecording: async (cameraId: string) => {
        await this.permissions.check(this.pluginId, 'video:record');
        return this.videoService.startRecording(cameraId);
      },
      getRecordings: async (params: RecordingParams) => {
        await this.permissions.check(this.pluginId, 'video:read');
        return this.videoService.getRecordings(params);
      }
    }
  };
}
```

---

## ğŸ› ï¸ å¼€å‘è€…å·¥å…·å’ŒSDK

### 1. CLIå¼€å‘å·¥å…·

```typescript
// CLIå·¥å…·ä¸»å…¥å£
#!/usr/bin/env node

import { Command } from 'commander';
import { createPlugin } from './commands/create';
import { installPlugin } from './commands/install';
import { listPlugins } from './commands/list';
import { removePlugin } from './commands/remove';
import { buildPlugin } from './commands/build';
import { testPlugin } from './commands/test';

const program = new Command();

program
  .name('ioe-dream-cli')
  .description('IOE-DREAM Plugin Development CLI')
  .version('1.0.0');

// æ·»åŠ å­å‘½ä»¤
program.addCommand(createPlugin);
program.addCommand(installPlugin);
program.addCommand(listPlugins);
program.addCommand(removePlugin);
program.addCommand(buildPlugin);
program.addCommand(testPlugin);

// è§£æå‘½ä»¤è¡Œå‚æ•°
program.parse(process.argv);
```

```typescript
// åˆ›å»ºæ’ä»¶å‘½ä»¤
import { Command } from 'commander';
import { createPluginTemplate } from '../templates/plugin';
import { validatePluginName } from '../utils/validation';
import { generatePluginId } from '../utils/id';
import * as fs from 'fs-extra';
import * as path from 'path';
import chalk from 'chalk';

export const createPlugin = new Command('create')
  .description('Create a new plugin')
  .argument('<name>', 'Plugin name')
  .option('-t, --type <type>', 'Plugin type (component, page, service, integration)', 'component')
  .option('-d, --description <description>', 'Plugin description')
  .option('-a, --author <author>', 'Plugin author')
  .option('--template <template>', 'Use custom template')
  .action(async (name, options) => {
    try {
      // éªŒè¯æ’ä»¶åç§°
      if (!validatePluginName(name)) {
        console.error(chalk.red('Invalid plugin name. Use lowercase, numbers, and hyphens only.'));
        process.exit(1);
      }

      const pluginId = generatePluginId(name);
      const pluginDir = path.join(process.cwd(), 'plugins', pluginId);

      // æ£€æŸ¥æ’ä»¶æ˜¯å¦å·²å­˜åœ¨
      if (await fs.pathExists(pluginDir)) {
        console.error(chalk.red(`Plugin ${name} already exists`));
        process.exit(1);
      }

      // åˆ›å»ºæ’ä»¶ç›®å½•
      await fs.ensureDir(pluginDir);
      await fs.ensureDir(path.join(pluginDir, 'src'));
      await fs.ensureDir(path.join(pluginDirDir, 'assets'));
      await fs.ensureDir(path.join(pluginDir, 'dist')));

      // ç”Ÿæˆæ’ä»¶æ¨¡æ¿
      const template = options.template || options.type;
      await createPluginTemplate(pluginDir, {
        name,
        id: pluginId,
        type: options.type,
        description: options.description || `${name} plugin for IOE-DREAM`,
        author: options.author || 'IOE-DREAM Developer',
        template
      });

      console.log(chalk.green(`âœ… Plugin ${name} created successfully!`));
      console.log(chalk.blue(`ğŸ“ Plugin directory: ${pluginDir}`));
      console.log(chalk.yellow('Next steps:'));
      console.log(`  1. cd ${pluginDir}`);
      console.log(`  2. npm install`);
      console.log(` 3. npm run dev`);
      console.log(` 4. Customize your plugin`);
    } catch (error) {
      console.error(chalk.red(`âŒ Failed to create plugin: ${error.message}`));
      process.exit(1);
    }
  });
```

### 2. æ’ä»¶å¼€å‘SDK

```typescript
// æ’ä»¶å¼€å‘SDK
export interface PluginSDK {
  // æ’ä»¶åŸºç±»
  BasePlugin: typeof BasePlugin;

  // æ’ä»¶ä¸Šä¸‹æ–‡
  PluginContext: typeof PluginContext;

  // æ’ä»¶å·¥å…·ç±»
  Logger: typeof Logger;
  Validator: typeof Validator;
  Helper: typeof Helper;

  // æ’ä»¶è£…é¥°å™¨
  Plugin: typeof PluginDecorator;
  Route: typeof RouteDecorator;
  Hook: typeof HookDecorator;
  Menu: typeof MenuDecorator;
  Permission: typeof PermissionDecorator;
}

// æ’ä»¶åŸºç±»
export abstract class BasePlugin {
  protected api: PluginAPI;
  protected context: PluginContext;
  protected logger: Logger;
  protected config: PluginConfig;

  constructor(context: PluginContext) {
    this.context = context;
    this.api = context.api;
    this.logger = context.logger;
    this.config = context.config;
  }

  // æ’ä»¶ç”Ÿå‘½å‘¨æœŸæ–¹æ³•
  abstract async activate(): Promise<void>;
  abstract async deactivate(): Promise<void>;

  // ä¾¿æ·æ–¹æ³•
  protected async showToast(message: string, type: 'success' | 'error' | 'info' = 'info') {
    await this.api.ui.showNotification({
      message,
      type,
      duration: 3000
    });
  }

  protected async getStorage(key: string): Promise<any> {
    return await this.api.storage.get(key);
  }

  protected async setStorage(key: string, value: any): Promise<void> {
    await this.api.storage.set(key, value);
  }

  protected async request<T>(url: string, options?: RequestInit): Promise<T> {
    return await this.api.http.get<T>(url, options);
  }

  protected async post<T>(url: string, data?: any, options?: RequestInit): Promise<T> {
    return await this.api.http.post<T>(url, data, options);
  }

  protected emit(event: string, data: any): void {
    this.api.events.emit(event, data);
  }

  protected on(event: string, handler: EventHandler): void {
    this.api.events.on(event, handler);
  }
}

// æ’ä»¶ä¸Šä¸‹æ–‡
export interface PluginContext {
  id: string;
  name: string;
  version: string;
  description: string;
  author: string;
  permissions: string[];
  api: PluginAPI;
  logger: Logger;
  config: PluginConfig;
  manifest: PluginManifest;
}

// æ’ä»¶è£…é¥°å™¨
export function Plugin(metadata: Partial<PluginManifest>) {
  return function (target: any) {
    Reflect.defineMetadata(target, 'plugin', metadata);
    return target;
  };
}

export function Route(path: string, method: 'GET' | 'POST' | 'PUT' | 'DELETE' = 'GET') {
  return function (target: any, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
    const routes = Reflect.getMetadata('routes', target) || [];
    routes.push({ path, method, handler: propertyKey });
    Reflect.defineMetadata(target, 'routes', routes);
  };
}

export function Menu(menuItem: MenuItemConfig) {
  return function (target: any, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
    const menus = Reflect.getMetadata('menus', target) || [];
    menus.push(menuItem);
    Reflect.defineMetadata(target, 'menus', menus);
  };
}

export function Permission(permission: string) {
  return function (target: any, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
    const permissions = Reflect.getMetadata('permissions', target) || [];
    permissions.push(permission);
    Reflect.defineMetadata(target, 'permissions', permissions);
  };
}
```

### 3. æ’ä»¶æ¨¡æ¿ç”Ÿæˆå™¨

```typescript
// æ’ä»¶æ¨¡æ¿ç”Ÿæˆå™¨
export class PluginTemplateGenerator {
  private readonly templates: Map<string, TemplateConfig> = new Map();

  constructor() {
    this.registerDefaultTemplates();
  }

  private registerDefaultTemplates(): void {
    // ç»„ä»¶æ’ä»¶æ¨¡æ¿
    this.templates.set('component', {
      directories: ['src', 'assets', 'tests'],
      files: [
        {
          path: 'src/plugin.ts',
          template: 'component-plugin.template.ts'
        },
        {
          path: 'src/index.ts',
          template: 'component-index.template.ts'
        },
        {
          path: 'package.json',
          template: 'component-package.template.json'
        },
        {
          path: 'README.md',
          template: 'component-readme.template.md'
        }
      ]
    });

    // é¡µé¢æ’ä»¶æ¨¡æ¿
    this.templates.set('page', {
      directories: ['src', 'assets', 'tests'],
      files: [
        {
          path: 'src/plugin.ts',
          template: 'page-plugin.template.ts'
        },
        {
          path: 'src/index.ts',
          template: 'page-index.template.ts'
        },
        {
          path: 'package.json',
          template: 'page-package.template.json'
        }
      ]
    });

    // æœåŠ¡æ’ä»¶æ¨¡æ¿
    this.templates.set('service', {
      directories: ['src', 'tests'],
      files: [
        {
          path: 'src/plugin.ts',
          template: 'service-plugin.template.ts'
        },
        {
          path: 'src/index.ts',
          template: 'service-index.template.ts'
        },
        {
          path: 'package.json',
          template: 'service-package.template.json'
        }
      ]
    });

    // é›†æˆæ’ä»¶æ¨¡æ¿
    this.templates.set('integration', {
      directories: ['src', 'config', 'tests'],
      files: [
        {
          path: 'src/plugin.ts',
          template: 'integration-plugin.template.ts'
        },
        {
          path: 'src/index.ts',
          template: 'integration-index.template.ts'
        },
        {
          path: 'config/config.json',
          template: 'integration-config.template.json'
        },
        {
          path: 'package.json',
          template: 'integration-package.template.json'
        }
      ]
    });
  }

  async generatePlugin(pluginDir: string, options: PluginGenerationOptions): Promise<void> {
    const template = this.templates.get(options.template);
    if (!template) {
      throw new Error(`Template ${options.template} not found`);
    }

    // åˆ›å»ºç›®å½•
    for (const dir of template.directories) {
      await fs.ensureDir(path.join(pluginDir, dir));
    }

    // ç”Ÿæˆæ–‡ä»¶
    for (const file of template.files) {
      const content = await this.generateFileContent(file.template, options);
      const filePath = path.join(pluginDir, file.path);
      await fs.writeFile(filePath, content);
    }

    // å®‰è£…ä¾èµ–
    await this.installDependencies(pluginDir);
  }

  private async generateFileContent(template: string, options: PluginGenerationOptions): Promise<string> {
    const templateContent = await fs.readFile(
      path.join(__dirname, 'templates', template),
      'utf8'
    );

    return templateContent
      .replace(/\{\{name\}\}/g, options.name)
      .replace(/\{\{id\}\}/g, options.id)
      .replace(/\{\{version\}\}/g, options.version)
      .replace(/\{\{description\}\}/g, options.description)
      .replace(/\{\{author\}\}/g, options.author)
      .replace(/\{\{type\}\}/g, options.type)
      .replace(/\{\{timestamp\}\}/g, new Date().toISOString());
  }

  private async installDependencies(pluginDir: string): Promise<void> {
    const packageJsonPath = path.join(pluginDir, 'package.json');
    if (!(await fs.pathExists(packageJsonPath))) {
      return;
    }

    const packageJson = await fs.readJson(packageJsonPath);
    const dependencies = packageJson.dependencies || {};
    const devDependencies = packageJson.devDependencies || {};

    // å®‰è£…ä¾èµ–
    const installCmd = process.platform === 'win32' ? 'npm.cmd' : 'npm';
    const installArgs = ['install'];

    console.log('ğŸ“¦ Installing dependencies...');
    await new Promise((resolve, reject) => {
      const child = spawn(installCmd, installArgs, {
        cwd: pluginDir,
        stdio: 'inherit'
      });

      child.on('close', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error(`npm install failed with code ${code}`));
        }
      });
    });
  }
}
```

---

## ğŸ“šï¸ å¼€å‘è€…æ–‡æ¡£

### 1. æ’ä»¶å¼€å‘æŒ‡å—ç»“æ„

```
plugin-development-guide/
â”œâ”€â”€ README.md                              # å¼€å‘æŒ‡å—æ€»è§ˆ
â”œâ”€â”€ getting-started/
â”‚   â”œâ”€â”€ installation.md                   # ç¯å¢ƒæ­å»º
â”‚   â”œâ”€â”€ project-structure.md             # é¡¹ç›®ç»“æ„
â”‚   â”œâ”€â”€ quick-start.md                   # å¿«é€Ÿå¼€å§‹
â”‚   â””â”€â”€ common-pitfalls.md              # å¸¸è§é—®é¢˜
â”œâ”€â”€ api-reference/
â”‚   â”œâ”€â”€ plugin-api.md                    # æ’ä»¶APIå‚è€ƒ
â”‚   â”œâ”€â”€ sdk-reference.md                 # SDKå‚è€ƒ
â”‚   â”œâ”€â”€ hooks.md                         # é’©å­å‚è€ƒ
â”‚   â””â”€â”€ events.md                        # äº‹ä»¶å‚è€ƒ
â”œâ”€â”€ tutorials/
â”‚   â”œâ”€â”€ creating-component-plugin.md     # åˆ›å»ºç»„ä»¶æ’ä»¶
â”‚   â”œâ”€â”€ creating-page-plugin.md          # åˆ›å»ºé¡µé¢æ’ä»¶
â”‚   â”œâ”€â”€ creating-service-plugin.md       # åˆ›å»ºæœåŠ¡æ’ä»¶
â”‚   â”œâ”€â”€ creating-integration-plugin.md  # åˆ›å»ºé›†æˆæ’ä»¶
â”‚   â””â”€â”€ advanced-techniques.md           # é«˜çº§æŠ€å·§
â”œâ”€â”€ samples/
â”‚   â”œâ”€â”€ hello-world/                      # Hello Worldç¤ºä¾‹
â”‚   â”œâ”€â”€ custom-widget/                   # è‡ªå®šä¹‰ç»„ä»¶ç¤ºä¾‹
â”‚   â”œâ”€â”€ data-connector/                 # æ•°æ®è¿æ¥å™¨ç¤ºä¾‹
â”‚   â””â”€â”€ notification-extension/         # é€šçŸ¥æ‰©å±•ç¤ºä¾‹
â”œâ”€â”€ testing/
â”‚   â”œâ”€â”€ unit-testing.md                  # å•å…ƒæµ‹è¯•
â”‚   â”œâ”€â”€ integration-testing.md           # é›†æˆæµ‹è¯•
â”‚   â””â”€â”€ end-to-end-testing.md           # ç«¯åˆ°ç«¯æµ‹è¯•
â”œâ”€â”€ deployment/
â”‚   â”œâ”€â”€ building.md                     # æ„å»ºæ’ä»¶
â”‚   â”œâ”€â”€ publishing.md                   # å‘å¸ƒæ’ä»¶
â”‚   â”œâ”€â”€ versioning.md                   # ç‰ˆæœ¬ç®¡ç†
â”‚   â””â”€â”€ distribution.md                 # åˆ†å‘æ¸ é“
â””â”€â”€ community/
    â”œâ”€â”€ contributing.md                  # è´¡çŒ®æŒ‡å—
    â”œâ”€â”€ plugin-review-process.md        # æ’ä»¶å®¡æ ¸æµç¨‹
    â”œâ”€â”€ code-of-conduct.md              # è¡Œä¸ºå‡†åˆ™
    â””â”€â”€ community-guidelines.md         # ç¤¾åŒºæŒ‡å—
```

### 2. æ’ä»¶APIå‚è€ƒæ–‡æ¡£

```markdown
# æ’ä»¶APIå‚è€ƒæ–‡æ¡£

## æ ¸å¿ƒAPI

### ç³»ç»ŸAPI

#### system.getVersion()
è·å–ç³»ç»Ÿç‰ˆæœ¬ä¿¡æ¯ã€‚

**è¿”å›å€¼**
```typescript
string: "1.0.0"
```

**ç¤ºä¾‹**
```typescript
const version = api.system.getVersion();
console.log(`ç³»ç»Ÿç‰ˆæœ¬: ${version}`);
```

### ç”¨æˆ·API

#### user.getCurrentUser()
è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯ã€‚

**è¿”å›å€¼**
```typescript
Promise<{
  id: string;
  username: string;
  email: string;
  department: string;
  avatar: string;
}>
```

**ç¤ºä¾‹**
```typescript
const user = await api.user.getCurrentUser();
console.log(`å½“å‰ç”¨æˆ·: ${user.username}`);
```

### å­˜å‚¨API

#### storage.get(key)
è·å–å­˜å‚¨çš„æ•°æ®ã€‚

**å‚æ•°**
- `key` (string): å­˜å‚¨é”®

**è¿”å›å€¼**
```typescript
Promise<any | null>
```

**ç¤ºä¾‹**
```typescript
const value = await api.storage.get('user-preferences');
```

#### storage.set(key, value)
è®¾ç½®å­˜å‚¨çš„æ•°æ®ã€‚

**å‚æ•°**
- `key` (string): å­˜å‚¨é”®
- `value` (any): å­˜å‚¨å€¼

**ç¤ºä¾‹**
```typescript
await api.storage.set('theme', 'dark');
```

## ä¸šåŠ¡æ¨¡å—API

### é—¨ç¦æ¨¡å—API

#### access.openDoor(doorId)
æ‰“å¼€æŒ‡å®šé—¨ç¦ã€‚

**å‚æ•°**
- `doorId` (string): é—¨ç¦è®¾å¤‡ID

**è¿”å›å€¼**
```typescript
Promise<{
  success: boolean;
  message: string;
  timestamp: number;
}>
```

**ç¤ºä¾‹**
```typescript
const result = await api.business.access.openDoor('door-001');
if (result.success) {
  console.log('é—¨å·²æ‰“å¼€');
}
```

### è€ƒå‹¤æ¨¡å—API

#### attendance.clockIn(location)
æ‰§è¡Œè€ƒå‹¤æ‰“å¡ã€‚

**å‚æ•°**
- `location` (LocationInfo): ä½ç½®ä¿¡æ¯

**è¿”å›å€¼**
```typescript
Promise<{
  success: boolean;
  recordId: string;
  timestamp: number;
  location: string;
}>
```

**ç¤ºä¾‹**
```typescript
const result = await api.business.attendance.clockIn({
  latitude: 39.9042,
  longitude: 116.4074,
  accuracy: 10
});
```

### æ¶ˆè´¹æ¨¡å—API

#### consume.getBalance()
è·å–è´¦æˆ·ä½™é¢ã€‚

**è¿”å›å€¼**
```typescript
Promise<{
  balance: number;
  currency: string;
  lastUpdated: string;
}>
```

**ç¤ºä¾‹**
```typescript
const balance = await api.business.consume.getBalance();
console.log(`å½“å‰ä½™é¢: ${balance.balance} ${balance.currency}`);
```
```

### 3. æ’ä»¶ç¤ºä¾‹æ•™ç¨‹

```markdown
# åˆ›å»ºè‡ªå®šä¹‰ç»„ä»¶æ’ä»¶æ•™ç¨‹

## æ¦‚è¿°

æœ¬æ•™ç¨‹å°†æŒ‡å¯¼æ‚¨åˆ›å»ºä¸€ä¸ªè‡ªå®šä¹‰ç»„ä»¶æ’ä»¶ï¼Œè¯¥æ’ä»¶å°†åœ¨é—¨ç¦ç®¡ç†æ¨¡å—ä¸­æ·»åŠ ä¸€ä¸ªè‡ªå®šä¹‰çš„é—¨ç¦çŠ¶æ€æ˜¾ç¤ºç»„ä»¶ã€‚

## æ­¥éª¤1: åˆ›å»ºæ’ä»¶é¡¹ç›®

ä½¿ç”¨CLIå·¥å…·åˆ›å»ºæ–°æ’ä»¶ï¼š

```bash
npx ioe-dream-cli create access-status-widget --type component --description "é—¨ç¦çŠ¶æ€æ˜¾ç¤ºç»„ä»¶"
```

## æ­¥éª¤2: å®ç°æ’ä»¶æ ¸å¿ƒåŠŸèƒ½

### 2.1 ç¼–è¾‘æ’ä»¶ä¸»æ–‡ä»¶

ç¼–è¾‘ `src/plugin.ts`ï¼š

```typescript
import { Plugin, Menu, Permission } from '@ioedream/plugin-sdk';

@Plugin({
  id: 'access-status-widget',
  name: 'Access Status Widget',
  version: '1.0.0',
  description: 'æ˜¾ç¤ºé—¨ç¦è®¾å¤‡çŠ¶æ€çš„ç»„ä»¶',
  permissions: ['access:read'],
  dependencies: ['react', 'styled-components']
})
export class AccessStatusWidgetPlugin extends BasePlugin {

  async activate(): Promise<void> {
    this.logger.info('Activating Access Status Widget Plugin');

    // æ³¨å†Œç»„ä»¶
    this.registerComponent('AccessStatusWidget', AccessStatusWidget);

    // æ³¨å†Œèœå•é¡¹
    this.registerMenuItems();

    // ç›‘å¬é—¨ç¦çŠ¶æ€å˜åŒ–äº‹ä»¶
    this.setupEventListeners();

    this.logger.info('Access Status Widget Plugin activated successfully');
  }

  async deactivate(): Promise<void> {
    this.logger.info('Deactivating Access Status Widget Plugin');

    // ç§»é™¤ç»„ä»¶æ³¨å†Œ
    this.unregisterComponent('AccessStatusWidget');

    // æ¸…ç†äº‹ä»¶ç›‘å¬
    this.cleanupEventListeners();

    this.logger.info('Access Status Widget Plugin deactivated successfully');
  }

  private registerComponent(name: string, component: React.ComponentType) {
    this.context.componentRegistry.register(name, component);
  }

  private registerMenuItems(): void {
    this.context.menuRegistry.add({
      id: 'access-status-widget',
      label: 'é—¨ç¦çŠ¶æ€ç»„ä»¶',
      icon: 'widget',
      path: '/plugins/access-status-widget',
      parent: 'access-management'
    });
  }

  private setupEventListeners(): void {
    // ç›‘å¬é—¨ç¦çŠ¶æ€å˜åŒ–
    this.on('access:door:status-changed', this.handleDoorStatusChange);
  }

  private cleanupEventListeners(): void {
    this.events.off('access:door:status-changed', this.handleDoorStatusChange);
  }

  private handleDoorStatusChange = async (data: any) => {
    const { doorId, status } = data;
    this.logger.info(`Door ${doorId} status changed to ${status}`);

    // å¯ä»¥åœ¨è¿™é‡Œæ‰§è¡Œé¢å¤–çš„é€»è¾‘ï¼Œæ¯”å¦‚å‘é€é€šçŸ¥
    await this.api.ui.showNotification({
      message: `é—¨ç¦ ${doorId} çŠ¶æ€å˜ä¸º ${this.getStatusText(status)}`,
      type: 'info'
    });
  };

  private getStatusText(status: string): string {
    const statusMap = {
      'opened': 'å·²æ‰“å¼€',
      'closed': 'å·²å…³é—­',
      'offline': 'ç¦»çº¿',
      'error': 'é”™è¯¯'
    };
    return statusMap[status] || status;
  }
}
```

### 2.2 åˆ›å»ºReactç»„ä»¶

åˆ›å»º `src/components/AccessStatusWidget.tsx`ï¼š

```typescript
import React, { useState, useEffect } from 'react';
import styled from 'styled-components';

interface AccessStatusWidgetProps {
  doorId: string;
}

const Container = styled.div`
  display: flex;
  align-items: center;
  padding: 12px 16px;
  background: #f5f5f5;
  border-radius: 8px;
  margin-bottom: 8px;
  border-left: 4px solid #ddd;
`;

const StatusIndicator = styled.div<{ status: string }>`
  width: 12px;
  height: 12px;
  border-radius: 50%;
  margin-right: 12px;
  background-color: ${props => {
    const colors = {
      opened: '#4caf50',
      closed: '#f44336',
      offline: '#9e9e9e',
      error: '#ff9800'
    };
    return colors[props.status] || '#9e9e9e';
  }};
`;

const InfoContainer = styled.div`
  flex: 1;
`;

const DoorName = styled.div`
  font-weight: 600;
  margin-bottom: 4px;
  color: #333;
`;

const StatusText = styled.div`
  font-size: 14px;
  color: #666;
`;

const LastUpdate = styled.div`
  font-size: 12px;
  color: #999;
  margin-top: 4px;
`;

export const AccessStatusWidget: React.FC<AccessStatusWidgetProps> = ({ doorId }) => {
  const [status, setStatus] = useState<string>('offline');
  const [doorName, setDoorName] = useState<string>('');
  const [lastUpdate, setLastUpdate] = useState<Date>(new Date());

  useEffect(() => {
    const fetchDoorStatus = async () => {
      try {
        const response = await api.business.access.getDoorStatus(doorId);
        setStatus(response.status);
        setDoorName(response.name);
        setLastUpdate(new Date(response.lastUpdate));
      } catch (error) {
        console.error('Failed to fetch door status:', error);
        setStatus('error');
      }
    };

    fetchDoorStatus();
    const interval = setInterval(fetchDoorStatus, 5000);
    return () => clearInterval(interval);
  }, [doorId]);

  const getStatusColor = (status: string) => {
    const colors = {
      opened: '#4caf50',
      closed: '#f44336',
      offline: '#9e9e9e',
      error: '#ff9800'
    };
    return colors[status] || '#9e9e9e';
  };

  return (
    <Container>
      <StatusIndicator status={status} />
      <InfoContainer>
        <DoorName>{doorName || `Door ${doorId}`}</DoorName>
        <StatusText>
          {status === 'opened' && 'é—¨å·²æ‰“å¼€'}
          {status === 'closed' && 'é—¨å·²å…³é—­'}
          {status === 'offline' && 'è®¾å¤‡ç¦»çº¿'}
          {status === 'error' && 'è®¾å¤‡é”™è¯¯'}
          {status === 'unknown' && 'çŠ¶æ€æœªçŸ¥'}
        </StatusText>
        <LastUpdate>
          æœ€åæ›´æ–°: {lastUpdate.toLocaleTimeString()}
        </LastUpdate>
      </InfoContainer>
    </Container>
  );
};
```

## æ­¥éª¤3: é…ç½®æ’ä»¶å…ƒæ•°æ®

ç¼–è¾‘ `plugin.json`ï¼š

```json
{
  "id": "access-status-widget",
  "name": "Access Status Widget",
  "version": "1.0.0",
  "description": "æ˜¾ç¤ºé—¨ç¦è®¾å¤‡çŠ¶æ€çš„ç»„ä»¶",
  "author": "IOE-DREAM Developer",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist/**/*"
  ],
  "keywords": [
    "ioe-dream",
    "plugin",
    "access-control",
    "widget"
  ],
  "category": "component",
  "icon": "widget",
  "dependencies": {
    "react": "^18.0.0",
    "styled-components": "^5.0.0",
    "ioedream-plugin-sdk": "^1.0.0"
  },
  "permissions": [
    "access:read",
    "ui:widget",
    "storage:read"
  ],
  "resources": {
    "maxMemory": "128MB",
    "maxCPU": "50%"
  },
  "integration": {
    "access": {
      "minVersion": "1.0.0",
      "required": true
    },
    "ui": {
      "minVersion": "1.0.0",
      "required": true
    }
  }
}
```

## æ­¥éª¤4: æ„å»ºå’Œæµ‹è¯•

### 4.1 æ„å»ºæ’ä»¶

```bash
cd plugins/access-status-widget
npm run build
```

### 4.2 è¿è¡Œæµ‹è¯•

```bash
npm run test
```

### 4.3 æœ¬åœ°æµ‹è¯•

```bash
npm run dev
```

## æ­¥éª¤5: å‘å¸ƒæ’ä»¶

### 5.1 ç™»å½•å¼€å‘è€…è´¦æˆ·

```bash
npm login
```

### 5.2 å‘å¸ƒæ’ä»¶

```bash
npm run publish
```

### 5.3 æäº¤å®¡æ ¸

æ’ä»¶å°†è‡ªåŠ¨æäº¤ç»™IOE-DREAMæ’ä»¶å¸‚åœºè¿›è¡Œå®¡æ ¸ã€‚
```

---

## ğŸ›’ï¸ æ’ä»¶å¸‚åœºå’Œè´¨é‡ä¿éšœ

### 1. æ’ä»¶å¸‚åœºæ¶æ„

```typescript
// æ’ä»¶å¸‚åœºæœåŠ¡
interface PluginMarketplace {
  // æ’ä»¶ä»“åº“
  repository: {
    plugins: PluginRepository;
    categories: CategoryManager;
    search: SearchEngine;
    reviews: ReviewManager;
  };

  // æ’ä»¶ç®¡ç†
  management: {
    submission: SubmissionService;
    review: ReviewService;
    validation: ValidationService;
    publishing: PublishingService;
    distribution: DistributionService;
  };

  // è´¨é‡æ§åˆ¶
  quality: {
    testing: TestingService;
    security: SecurityService;
    performance: PerformanceService;
    compliance: ComplianceService;
  };

  // ç”¨æˆ·æœåŠ¡
  users: {
    authentication: AuthenticationService;
    profiles: UserProfileService;
    subscriptions: SubscriptionService;
    feedback: FeedbackService;
  };
}

// æ’ä»¶ä»“åº“
class PluginRepository {
  private plugins: Map<string, Plugin> = new Map();
  private versions: Map<string, PluginVersion[]> = new Map();

  async savePlugin(plugin: Plugin): Promise<void> {
    // éªŒè¯æ’ä»¶
    await this.validatePlugin(plugin);

    // ä¿å­˜æ’ä»¶
    this.plugins.set(plugin.manifest.id, plugin);

    // ä¿å­˜ç‰ˆæœ¬
    const versions = this.versions.get(plugin.manifest.id) || [];
    versions.push(plugin.version);
    this.versions.set(plugin.manifest.id, versions);

    // æ›´æ–°ç´¢å¼•
    await this.updateIndex();
  }

  async getPlugin(pluginId: string, version?: string): Promise<Plugin | null> {
    const plugin = this.plugins.get(pluginId);
    if (!plugin) {
      return null;
    }

    if (version) {
      return await this.getPluginVersion(pluginId, version);
    }

    return plugin;
  }

  async searchPlugins(query: SearchQuery): Promise<PluginSearchResult> {
    const filters = this.buildFilters(query);
    const plugins = await this.filterPlugins(filters);

    return {
      plugins,
      total: plugins.length,
      facets: await this.generateFacets(plugins)
    };
  }

  private async validatePlugin(plugin: Plugin): Promise<ValidationResult> {
    const result: ValidationResult = {
      isValid: true,
      errors: [],
      warnings: []
    };

    // éªŒè¯æ¸…å•
    const checks = [
      this.validateManifest(plugin.manifest),
      this.validateCode(plugin.code),
      this.validateAssets(plugin.assets),
      this.validateDependencies(plugin.dependencies),
      this.validateSecurity(plugin)
    ];

    for (const check of checks) {
      const checkResult = await check();
      if (!checkResult.isValid) {
        result.isValid = false;
        result.errors.push(...checkResult.errors);
      }
      if (checkResult.warnings?.length > 0) {
        result.warnings.push(...checkResult.warnings);
      }
    }

    return result;
  }
}
```

### 2. æ’ä»¶å®¡æ ¸æµç¨‹

```mermaid
graph TD
    A[å¼€å‘è€…æäº¤æ’ä»¶] --> B[è‡ªåŠ¨éªŒè¯]
    B --> C{éªŒè¯é€šè¿‡?}
    C -->|æ˜¯| D[äººå·¥å®¡æ ¸]
    C -->|å¦| E[è¿”å›ä¿®æ”¹]
    D --> F{å®¡æ ¸é€šè¿‡?}
    F -->|æ˜¯| G[å‘å¸ƒä¸Šçº¿]
    F -->|å¦| H[åé¦ˆä¿®æ”¹]
    E --> I[ä¿®æ”¹åé‡æ–°æäº¤]
    H --> B
    G --> J[å¸‚åœºä¸Šçº¿]
    J --> K[ç”¨æˆ·ä½¿ç”¨]
    K --> L[ä½¿ç”¨åé¦ˆ]
    L --> M[è´¨é‡ç›‘æ§]
    M --> N{å‘ç°é—®é¢˜?}
    N -->|æ˜¯| O[ä¸‹æ¶å¤„ç†]
    N -->|å¦| J
    O --> P[é—®é¢˜ä¿®å¤]
    P --> Q[é‡æ–°å®¡æ ¸]
```

```typescript
// æ’ä»¶å®¡æ ¸æœåŠ¡
class PluginReviewService {
  private readonly autoValidator: PluginAutoValidator;
  private readonly humanReviewers: HumanReviewerPool;
  private readonly securityScanner: SecurityScanner;
  private readonly performanceTester: PerformanceTester;

  async submitPlugin(plugin: Plugin, submitter: Developer): Promise<ReviewSubmissionResult> {
    try {
      // 1. åˆ›å»ºå®¡æ ¸è®°å½•
      const submission = await this.createSubmission(plugin, submitter);

      // 2. è‡ªåŠ¨éªŒè¯
      const autoValidation = await this.autoValidator.validate(plugin);
      if (!autoValidation.isValid) {
        await this.updateSubmissionStatus(submission.id, 'failed', autoValidation.errors);
        return {
          success: false,
          submissionId: submission.id,
          errors: autoValidation.errors
        };
      }

      // 3. å®‰å…¨æ‰«æ
      const securityScan = await this.securityScanner.scan(plugin);
      if (securityScan.issues.length > 0) {
        await this.updateSubmissionStatus(submission.id, 'security_issues_found', securityScan.issues);
      }

      // 4. æ€§èƒ½æµ‹è¯•
      const performanceTest = await this.performanceTester.test(plugin);
      if (!performanceTest.passed) {
        await this.updateSubmissionStatus(submission.id, 'performance_issues_found', performanceTest.issues);
      }

      // 5. äººå·¥å®¡æ ¸
      const humanReview = await this.humanReviewers.assignReview(submission);
      await this.updateSubmissionStatus(submission.id, 'under_review');

      return {
        success: true,
        submissionId: submission.id,
        autoValidation,
        securityScan,
        performanceTest
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  async reviewPlugin(submissionId: string, reviewerId: string, decision: ReviewDecision): Promise<ReviewResult> {
    const submission = await this.getSubmission(submissionId);

    try {
      // 1. è®°å½•å®¡æ ¸å†³å®š
      const review = await this.createReview(submission, reviewerId, decision);

      // 2. æ›´æ–°æ’ä»¶çŠ¶æ€
      if (decision.decision === 'approved') {
        await this.approvePlugin(submission);
      } else if (decision.decision === 'rejected') {
        await this.rejectPlugin(submission, decision.reason);
      } else {
        await this.requestChanges(submission, decision.changes);
      }

      // 3. é€šçŸ¥å¼€å‘è€…
      await this.notifyDeveloper(submission.developer, decision);

      return {
        success: true,
        reviewId: review.id
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  private async approvePlugin(submission: Submission): Promise<void> {
    // 1. æ ‡è®°ä¸ºå·²æ‰¹å‡†
    submission.status = 'approved';
    submission.approvedAt = new Date();
    submission.approvedBy = 'system';

    // 2. ç­¾åæ’ä»¶åŒ…
    await this.signPlugin(submission.plugin);

    // 3. å‘å¸ƒåˆ°å¸‚åœº
    await this.publishToMarket(submission);

    // 4. æ›´æ–°ç´¢å¼•
    await this.updateIndex();

    // 5. è®°å½•å®¡è®¡æ—¥å¿—
    await this.logAuditEvent('plugin_approved', {
      submissionId: submission.id,
      pluginId: submission.plugin.manifest.id,
      version: submission.plugin.version,
      submitter: submission.developer.name
    });
  }

  private async rejectPlugin(submission: Submission, reason: string): Promise<void> {
    // 1. æ ‡è®°ä¸ºå·²æ‹’ç»
    submission.status = 'rejected';
    submission.rejectedAt = new Date();
    submission.rejectedBy = 'system';
    submission.rejectionReason = reason;

    // 2. é€šçŸ¥å¼€å‘è€…
    await this.notifyDeveloper(submission.developer, {
      decision: 'rejected',
      reason,
      submissionId: submission.id
    });

    // 3. è®°å½•å®¡è®¡æ—¥å¿—
    await this.logAuditEvent('plugin_rejected', {
      submissionId: submission.id,
      pluginId: submission.plugin.manifest.id,
      reason,
      submitter: submission.developer.name
    });
  }
}
```

### 3. è´¨é‡ç›‘æ§æœºåˆ¶

```typescript
// æ’ä»¶è´¨é‡ç›‘æ§æœåŠ¡
class PluginQualityMonitor {
  private readonly metrics: QualityMetricsCollector;
  private readonly alerting: AlertingService;
  private readonly analytics: AnalyticsService;

  async startMonitoring(plugin: Plugin): Promise<void> {
    // 1. å¯åŠ¨æ€§èƒ½ç›‘æ§
    this.startPerformanceMonitoring(plugin);

    // 2. å¯åŠ¨é”™è¯¯ç›‘æ§
    this.startErrorMonitoring(plugin);

    // 3. å¯åŠ¨ç”¨æˆ·åé¦ˆç›‘æ§
    this.startFeedbackMonitoring(plugin);

    // 4. è®¾ç½®è´¨é‡æŒ‡æ ‡é˜ˆå€¼
    this.setQualityThresholds(plugin);
  }

  private startPerformanceMonitoring(plugin: Plugin): void {
    // CPUä½¿ç”¨ç‡ç›‘æ§
    const cpuMonitor = new ResourceMonitor('cpu');
    cpuMonitor.startMonitoring(plugin.id, {
      threshold: 70,
      interval: 60000 // 1åˆ†é’Ÿ
    });

    // å†…å­˜ä½¿ç”¨ç‡ç›‘æ§
    const memoryMonitor = new ResourceMonitor('memory');
    memoryMonitor.startMonitoring(plugin.id, {
      threshold: 80,
      interval: 60000
    });

    // ç½‘ç»œè¯·æ±‚ç›‘æ§
    const networkMonitor = new ResourceMonitor('network');
    networkMonitor.startMonitoring(plugin.id, {
      threshold: 100, // æ¯åˆ†é’Ÿ100ä¸ªè¯·æ±‚
      interval: 60000
    });
  }

  private startErrorMonitoring(plugin: Plugin): void {
    this.analytics.trackEvent(plugin.id, 'error', {
      count: 0,
      value: 0
    });

    // ç›‘æ§é”™è¯¯ç‡
    setInterval(async () => {
      const errorRate = await this.calculateErrorRate(plugin);

      if (errorRate > 0.05) { // 5%é”™è¯¯ç‡é˜ˆå€¼
        await this.metrics.recordMetric(plugin.id, 'error_rate', errorRate);

        if (errorRate > 0.1) { // 10%é”™è¯¯ç‡é˜ˆå€¼
          await this.alerting.sendAlert({
            type: 'quality',
            severity: 'high',
            plugin: plugin.manifest.name,
            message: `é”™è¯¯ç‡è¿‡é«˜: ${(errorRate * 100).toFixed(2)}%`
          });
        }
      }
    }, 300000); // 5åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
  }

  private startFeedbackMonitoring(plugin: Plugin): void {
    // ç›‘æ§ç”¨æˆ·è¯„åˆ†
    this.analytics.onReview((review) => {
      if (review.pluginId === plugin.id) {
        this.metrics.recordMetric(plugin.id, 'user_rating', review.rating);
      }
    });

    // ç›‘æ§ç”¨æˆ·åé¦ˆ
    this.analytics.onFeedback((feedback) => {
      if (feedback.pluginId === plugin.id) {
        this.metrics.recordMetric(plugin.id, 'user_feedback_sentiment', feedback.sentiment);
      }
    });
  }

  private setQualityThresholds(plugin: Plugin): void {
    const thresholds = plugin.qualityThresholds || {
      errorRate: 0.05,
      performanceScore: 80,
      userRating: 4.0,
      crashRate: 0.01
    };

    Object.entries(thresholds).forEach(([metric, threshold]) => {
      this.metrics.setThreshold(plugin.id, metric, threshold);
    });
  }

  async generateQualityReport(pluginId: string): Promise<QualityReport> {
    const metrics = await this.metrics.getMetrics(pluginId);
    const feedback = await this.analytics.getFeedback(pluginId);

    return {
      pluginId,
      timestamp: new Date().toISOString(),
      metrics: {
        performance: metrics.performance,
        reliability: metrics.reliability,
        userSatisfaction: feedback.averageRating,
        security: metrics.security
      },
      status: this.calculateStatus(metrics),
      recommendations: this.generateRecommendations(metrics),
      trends: this.calculateTrends(pluginId)
    };
  }
}
```

---

## ğŸ“‹ å¼€å‘è€…ç”Ÿæ€æ£€æŸ¥æ¸…å•

### âœ… æŠ€æœ¯æ¶æ„
- [ ] æ’ä»¶ç³»ç»Ÿæ¶æ„è®¾è®¡å®Œæ•´
- [ ] æ²™ç®±æœºåˆ¶å®‰å…¨å¯é 
- [ ] APIæ¥å£è®¾è®¡åˆç†
- [ ] ç”Ÿå‘½å‘¨æœŸç®¡ç†å®Œå–„
- [ ] äº‹ä»¶ç³»ç»Ÿå¥å£®

### âœ… å¼€å‘å·¥å…·
- [ ] CLIå·¥å…·æ˜“ç”¨é«˜æ•ˆ
- [ ] SDKæ–‡æ¡£å®Œæ•´æ¸…æ™°
- [] æ¨¡æ¿ç”Ÿæˆå™¨ä¸°å¯Œ
- [] è°ƒè¯•å·¥å…·å®Œå–„
- [ ] è‡ªåŠ¨åŒ–æµ‹è¯•æ”¯æŒ

### âœ… è´¨é‡ä¿éšœ
- [ ] è‡ªåŠ¨åŒ–æµ‹è¯•è¦†ç›–
- [ ] å®‰å…¨æ‰«ææœºåˆ¶
- [ ] æ€§èƒ½ç›‘æ§ä½“ç³»
- [ ] ä»£ç è´¨é‡æ£€æŸ¥
- [ ] ç”¨æˆ·åé¦ˆæ”¶é›†

### âœ… ç¤¾åŒºå»ºè®¾
- [ ] æ–‡æ¡£ä½“ç³»å®Œå–„
- [ ] å¼€å‘æŒ‡å—è¯¦ç»†
- [] ç¤ºä¾‹é¡¹ç›®ä¸°å¯Œ
- [ ] ç¤¾åŒºè®ºå›æ´»è·ƒ
- [ ] æŠ€æœ¯æ”¯æŒåŠæ—¶

### âœ… å•†ä¸šæ¨¡å¼
- [ ] æ’ä»¶å¸‚åœºåŠŸèƒ½å®Œå–„
- [ ä»˜è´¹æ¨¡å¼åˆç†
- [] æ”¶ç›Šåˆ†é…å…¬å¹³
- [] ç‰ˆæƒä¿æŠ¤æ¸…æ™°
- [] è¿è¥ç­–ç•¥å¯æŒç»­

---

**ğŸ“ æ–‡æ¡£ç»´æŠ¤**: IOE-DREAMå¼€å‘è€…ç¤¾åŒºå§”å‘˜ä¼š
**ğŸ”„ æ›´æ–°å‘¨æœŸ**: æ¯æœˆæ›´æ–°æ–‡æ¡£å’Œå·¥å…·ï¼Œæ¯å­£åº¦æ›´æ–°æ¶æ„
**âœ… å®¡æ ¸çŠ¶æ€**: å·²é€šè¿‡å¼€å‘è€…å§”å‘˜ä¼šå’ŒæŠ€æœ¯å§”å‘˜ä¼šè”åˆå®¡æ ¸