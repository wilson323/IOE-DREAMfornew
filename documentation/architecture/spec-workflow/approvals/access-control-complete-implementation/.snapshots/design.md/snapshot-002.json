{
  "id": "snapshot_1764070481794_xryicc5ij",
  "approvalId": "approval_1763282517692_ph2enfqkr",
  "approvalTitle": "门禁系统完整实现设计文档审批",
  "version": 2,
  "timestamp": "2025-11-25T11:34:41.794Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# 门禁系统完整实现设计文档\n\n## 概述\n\n本文档详细描述了IOE-DREAM智慧园区门禁系统的完整技术设计方案，严格遵循repowiki开发规范体系，确保代码质量、系统性能和可维护性。\n\n**设计目标**:\n- 实现35% → 90%+的门禁模块功能覆盖率\n- 建立符合repowiki规范的标准开发流程\n- 确保企业级系统稳定性和安全性\n- 实现80%+的单元测试覆盖率\n\n## Steering文档对齐\n\n### 技术标准对齐 (tech.md)\n\n**严格遵循repowiki技术规范**:\n- **包名规范**: 强制使用jakarta.*，禁止javax.*\n- **依赖注入**: 强制使用@Resource，禁止@Autowired\n- **架构规范**: 严格四层架构Controller → Service → Manager → DAO\n- **权限控制**: 所有接口必须添加@SaCheckPermission注解\n- **代码质量**: 每个方法不超过50行，单一职责原则\n\n**SmartAdmin v3技术栈集成**:\n- Spring Boot 3.5.4 + Jakarta EE\n- Vue 3 + Composition API + TypeScript\n- MyBatis-Plus 3.5 + MySQL 8.0\n- Redis 6.0集群 + Caffeine本地缓存\n- Sa-Token权限认证 + RBAC权限模型\n\n### 项目结构对齐 (structure.md)\n\n**标准包结构**:\n```\nnet.lab1024.sa.admin.module.smart.access/\n├── controller/     # 控制器层 - HTTP接口\n├── service/        # 业务逻辑层 - 业务流程\n├── manager/        # 管理层 - 跨模块调用、缓存\n├── dao/           # 数据访问层 - 数据库操作\n├── domain/        # 领域模型层 - Entity、VO、DTO\n│   ├── entity/    # 实体类\n│   ├── vo/        # 视图对象\n│   ├── dto/       # 数据传输对象\n│   └── form/      # 表单对象\n└── constant/      # 常量定义 - 枚举、常量类\n```\n\n**前端结构对齐**:\n```\nsrc/views/smart/access/\n├── components/    # 通用组件\n├── pages/         # 页面组件\n├── api/          # API接口封装\n├── stores/       # Pinia状态管理\n└── types/        # TypeScript类型定义\n```\n\n## 代码复用分析\n\n### 现有组件利用\n\n**核心基础组件**:\n- **BaseCacheManager**: 多级缓存管理器，继承实现门禁专用缓存\n- **BaseEntity**: 通用实体基类，包含审计字段\n- **ResponseDTO**: 统一响应格式，确保API一致性\n- **SmartException**: 统一异常处理体系\n- **SaTokenUtil**: Sa-Token工具类，权限验证辅助\n\n**工具类复用**:\n- **SmartBeanUtil**: 对象拷贝和转换工具\n- **SmartVerificationUtil**: 参数验证工具\n- **SmartResponseUtil**: 响应构建工具\n- **RedisUtil**: Redis操作工具类\n\n### 集成点设计\n\n**系统集成点**:\n- **用户权限系统**: 集成现有UserPermissionEntity和RBAC模型\n- **组织架构系统**: 集成SmartAreaEntity区域管理\n- **设备管理系统**: 扩展SmartDeviceEntity设备管理\n- **日志审计系统**: 集成OperationLog操作日志记录\n\n**数据库集成**:\n- **用户表**: t_smart_user (现有，扩展门禁权限字段)\n- **角色表**: t_smart_role (现有，添加门禁权限标识)\n- **设备表**: t_smart_device (现有，扩展门禁设备类型)\n- **区域表**: t_smart_area (现有，添加门禁区域类型)\n\n## 架构设计\n\n### 整体架构图\n\n```mermaid\ngraph TD\n    subgraph \"前端层\"\n        A[Vue3管理界面] --> B[AccessControl Dashboard]\n        A --> C[RealTimeMonitor]\n        A --> D[DeviceManagement]\n    end\n\n    subgraph \"API网关层\"\n        E[Nginx Gateway] --> F[LoadBalancer]\n    end\n\n    subgraph \"应用层\"\n        G[AccessController] --> H[AccessService]\n        I[DeviceController] --> J[DeviceService]\n        K[MonitorController] --> L[MonitorService]\n    end\n\n    subgraph \"业务层\"\n        H --> M[AccessManager]\n        J --> N[DeviceManager]\n        L --> O[MonitorManager]\n    end\n\n    subgraph \"缓存层\"\n        P[Caffeine L1缓存] --> Q[Redis L2缓存]\n        R[WebSocket Session] --> S[消息队列]\n    end\n\n    subgraph \"数据层\"\n        T[MySQL主库] --> U[MyBatis-Plus]\n        V[Redis集群] --> W[数据同步]\n    end\n\n    subgraph \"硬件层\"\n        X[门禁控制器] --> Y[生物识别设备]\n        Z[监控摄像头] --> AA[告警设备]\n    end\n\n    B --> E\n    C --> E\n    D --> E\n    E --> G\n    E --> I\n    E --> K\n    M --> P\n    N --> P\n    O --> R\n    P --> T\n    P --> V\n    U --> X\n    W --> X\n```\n\n### 模块化设计原则\n\n**单一文件职责**:\n- **Controller类**: 仅处理HTTP请求/响应，不超过200行代码\n- **Service类**: 仅处理业务逻辑，不超过300行代码\n- **Manager类**: 仅处理跨模块调用和缓存，不超过200行代码\n- **DAO接口**: 仅处理数据访问，使用MyBatis-Plus简化\n\n**组件隔离原则**:\n- **权限验证组件**: 独立的权限验证逻辑，可复用\n- **设备通信组件**: 抽象设备通信接口，支持多种协议\n- **生物识别组件**: 封装生物识别算法，支持多种识别方式\n- **告警处理组件**: 统一的告警处理流程，支持多种告警渠道\n\n**服务层分离**:\n- **数据访问层**: 使用MyBatis-Plus，自动生成CRUD方法\n- **业务逻辑层**: 复杂业务流程编排，事务管理\n- **表现层**: Controller仅做参数验证和响应格式化\n- **缓存管理层**: 统一的缓存策略，支持多级缓存\n\n## 组件和接口设计\n\n### 核心Controller组件\n\n#### AccessAreaController - 区域管理控制器\n\n**Purpose**: 负责门禁区域空间的CRUD操作和层级管理\n\n**Interfaces**:\n```java\n@RestController\n@RequestMapping(\"/api/smart/access/area\")\n@SaCheckPermission(\"smart:access:area\")\npublic class AccessAreaController {\n\n    /**\n     * 获取区域树形结构\n     * @return 区域树形列表\n     */\n    @GetMapping(\"/tree\")\n    public ResponseDTO<List<AccessAreaTreeVO>> getAreaTree();\n\n    /**\n     * 创建新区域\n     * @param form 区域创建表单\n     * @return 创建结果\n     */\n    @PostMapping(\"/create\")\n    @OperationLog(operationType = OperationLogTypeEnum.ADD, operationContent = \"创建门禁区域\")\n    public ResponseDTO<Long> createArea(@Valid @RequestBody AccessAreaCreateForm form);\n\n    /**\n     * 更新区域信息\n     * @param form 区域更新表单\n     * @return 更新结果\n     */\n    @PutMapping(\"/update\")\n    @OperationLog(operationType = OperationLogTypeEnum.UPDATE, operationContent = \"更新门禁区域\")\n    public ResponseDTO<Void> updateArea(@Valid @RequestBody AccessAreaUpdateForm form);\n\n    /**\n     * 删除区域\n     * @param areaId 区域ID\n     * @return 删除结果\n     */\n    @DeleteMapping(\"/delete/{areaId}\")\n    @OperationLog(operationType = OperationLogTypeEnum.DELETE, operationContent = \"删除门禁区域\")\n    public ResponseDTO<Void> deleteArea(@PathVariable Long areaId);\n\n    /**\n     * 为区域分配设备\n     * @param form 设备分配表单\n     * @return 分配结果\n     */\n    @PostMapping(\"/assign-device\")\n    @OperationLog(operationType = OperationLogTypeEnum.UPDATE, operationContent = \"区域设备分配\")\n    public ResponseDTO<Void> assignDevice(@Valid @RequestBody AreaDeviceAssignForm form);\n}\n```\n\n**Dependencies**:\n- AccessAreaService: 区域管理业务逻辑\n- SmartAreaService: 基础区域服务(复用)\n- SmartDeviceService: 设备管理服务(复用)\n- OperationLogAspect: 操作日志切面(复用)\n\n**Reuses**:\n- 继承现有SmartAreaEntity数据模型\n- 复用OperationLog操作日志注解\n- 复用ResponseDTO统一响应格式\n- 复用@Valid参数验证\n\n#### AccessDeviceController - 设备管理控制器\n\n**Purpose**: 负责门禁设备的完整生命周期管理和实时控制\n\n**Interfaces**:\n```java\n@RestController\n@RequestMapping(\"/api/smart/access/device\")\n@SaCheckPermission(\"smart:access:device\")\npublic class AccessDeviceController {\n\n    /**\n     * 获取设备列表\n     * @param query 查询条件\n     * @return 设备分页列表\n     */\n    @GetMapping(\"/page\")\n    public ResponseDTO<PageResult<AccessDeviceVO>> getDevicePage(AccessDeviceQuery query);\n\n    /**\n     * 获取设备详情\n     * @param deviceId 设备ID\n     * @return 设备详情\n     */\n    @GetMapping(\"/detail/{deviceId}\")\n    public ResponseDTO<AccessDeviceDetailVO> getDeviceDetail(@PathVariable Long deviceId);\n\n    /**\n     * 添加设备\n     * @param form 设备添加表单\n     * @return 添加结果\n     */\n    @PostMapping(\"/add\")\n    @OperationLog(operationType = OperationLogTypeEnum.ADD, operationContent = \"添加门禁设备\")\n    public ResponseDTO<Long> addDevice(@Valid @RequestBody AccessDeviceAddForm form);\n\n    /**\n     * 更新设备\n     * @param form 设备更新表单\n     * @return 更新结果\n     */\n    @PutMapping(\"/update\")\n    @OperationLog(operationType = OperationLogTypeEnum.UPDATE, operationContent = \"更新门禁设备\")\n    public ResponseDTO<Void> updateDevice(@Valid @RequestBody AccessDeviceUpdateForm form);\n\n    /**\n     * 删除设备\n     * @param deviceId 设备ID\n     * @return 删除结果\n     */\n    @DeleteMapping(\"/delete/{deviceId}\")\n    @OperationLog(operationType = OperationLogTypeEnum.DELETE, operationContent = \"删除门禁设备\")\n    public ResponseDTO<Void> deleteDevice(@PathVariable Long deviceId);\n\n    /**\n     * 设备控制 - 远程开门\n     * @param form 控制表单\n     * @return 控制结果\n     */\n    @PostMapping(\"/control/open\")\n    @OperationLog(operationType = OperationLogTypeEnum.OTHER, operationContent = \"远程开门控制\")\n    public ResponseDTO<Void> remoteOpen(@Valid @RequestBody DeviceControlForm form);\n\n    /**\n     * 设备控制 - 重启设备\n     * @param form 控制表单\n     * @return 控制结果\n     */\n    @PostMapping(\"/control/restart\")\n    @OperationLog(operationType = OperationLogTypeEnum.OTHER, operationContent = \"重启设备\")\n    public ResponseDTO<Void> restartDevice(@Valid @RequestBody DeviceControlForm form);\n\n    /**\n     * 获取设备状态\n     * @param deviceId 设备ID\n     * @return 设备状态\n     */\n    @GetMapping(\"/status/{deviceId}\")\n    public ResponseDTO<DeviceStatusVO> getDeviceStatus(@PathVariable Long deviceId);\n}\n```\n\n**Dependencies**:\n- AccessDeviceService: 设备管理业务逻辑\n- SmartDeviceService: 基础设备服务(复用)\n- DeviceCommunicationService: 设备通信服务\n- AccessMonitorWebSocket: 实时监控WebSocket\n\n**Reuses**:\n- 继承现有SmartDeviceEntity数据模型\n- 复用设备通信协议框架\n- 复用WebSocket连接管理\n\n#### AccessMonitorController - 实时监控控制器\n\n**Purpose**: 负责门禁实时监控、事件查询和告警管理\n\n**Interfaces**:\n```java\n@RestController\n@RequestMapping(\"/api/smart/access/monitor\")\n@SaCheckPermission(\"smart:access:monitor\")\npublic class AccessMonitorController {\n\n    /**\n     * 获取实时监控数据\n     * @return 监控数据概览\n     */\n    @GetMapping(\"/overview\")\n    public ResponseDTO<MonitorOverviewVO> getMonitorOverview();\n\n    /**\n     * 获取通行事件列表\n     * @param query 查询条件\n     * @return 通行事件分页列表\n     */\n    @GetMapping(\"/events/page\")\n    public ResponseDTO<PageResult<AccessEventVO>> getAccessEventPage(AccessEventQuery query);\n\n    /**\n     * 获取告警事件列表\n     * @param query 查询条件\n     * @return 告警事件分页列表\n     */\n    @GetMapping(\"/alerts/page\")\n    public ResponseDTO<PageResult<AccessAlertVO>> getAccessAlertPage(AccessAlertQuery query);\n\n    /**\n     * 处理告警事件\n     * @param form 告警处理表单\n     * @return 处理结果\n     */\n    @PostMapping(\"/alert/handle\")\n    @OperationLog(operationType = OperationLogTypeEnum.UPDATE, operationContent = \"处理门禁告警\")\n    public ResponseDTO<Void> handleAlert(@Valid @RequestBody AlertHandleForm form);\n\n    /**\n     * 获取设备实时状态\n     * @param areaId 区域ID(可选)\n     * @return 设备状态列表\n     */\n    @GetMapping(\"/device-status\")\n    public ResponseDTO<List<DeviceStatusVO>> getDeviceStatus(@RequestParam(required = false) Long areaId);\n\n    /**\n     * 获取通行统计数据\n     * @param query 统计查询条件\n     * @return 统计数据\n     */\n    @GetMapping(\"/statistics\")\n    public ResponseDTO<AccessStatisticsVO> getAccessStatistics(AccessStatisticsQuery query);\n}\n```\n\n**Dependencies**:\n- AccessMonitorService: 监控业务逻辑\n- AccessEventService: 事件管理服务\n- AccessAlertService: 告警管理服务\n- AccessMonitorWebSocket: WebSocket服务\n\n### 核心Service组件\n\n#### AccessAreaService - 区域管理服务\n\n**Purpose**: 处理门禁区域的业务逻辑，包括层级管理、权限分配、设备关联\n\n**关键业务逻辑**:\n```java\n@Service\n@Transactional(rollbackFor = Exception.class)\n@RequiredArgsConstructor\npublic class AccessAreaService {\n\n    private final AccessAreaDao accessAreaDao;\n    private final AccessAreaManager accessAreaManager;\n    private final SmartDeviceService smartDeviceService;\n\n    /**\n     * 创建区域 - 业务逻辑\n     * 1. 验证区域名称唯一性\n     * 2. 验证父区域存在性\n     * 3. 生成区域编码\n     * 4. 设置默认权限配置\n     * 5. 清除相关缓存\n     */\n    @Override\n    public ResponseDTO<Long> createArea(AccessAreaCreateForm form) {\n        // 业务验证逻辑\n        validateAreaNameUniqueness(form.getAreaName(), form.getParentId());\n        validateParentAreaExist(form.getParentId());\n\n        // 构建实体\n        AccessAreaEntity entity = new AccessAreaEntity();\n        entity.setAreaName(form.getAreaName());\n        entity.setParentId(form.getParentId());\n        entity.setAreaCode(generateAreaCode(form.getParentId()));\n        entity.setAreaType(AreaTypeEnum.ACCESS_CONTROL);\n        entity.setAccessLevel(form.getAccessLevel());\n        entity.setDescription(form.getDescription());\n\n        // 保存实体\n        Long areaId = accessAreaDao.save(entity);\n\n        // 清除缓存\n        accessAreaManager.clearAreaCache();\n\n        return ResponseDTO.ok(areaId);\n    }\n\n    /**\n     * 删除区域 - 业务逻辑\n     * 1. 检查区域下是否有子区域\n     * 2. 检查区域是否关联设备\n     * 3. 检查区域是否关联用户权限\n     * 4. 软删除区域\n     * 5. 处理相关数据关联\n     */\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public ResponseDTO<Void> deleteArea(Long areaId) {\n        AccessAreaEntity area = accessAreaDao.getById(areaId);\n        if (area == null) {\n            throw new SmartException(\"区域不存在\");\n        }\n\n        // 业务检查\n        validateDeleteConstraints(areaId);\n\n        // 软删除区域\n        area.setDeletedFlag(DeletedFlagEnum.DELETED);\n        accessAreaDao.updateById(area);\n\n        // 处理关联数据\n        handleRelatedDataOnDelete(areaId);\n\n        // 清除缓存\n        accessAreaManager.clearAreaCache();\n\n        return ResponseDTO.ok();\n    }\n\n    /**\n     * 区域设备分配 - 业务逻辑\n     * 1. 验证设备存在性\n     * 2. 验证区域存在性\n     * 3. 检查设备是否已分配\n     * 4. 建立关联关系\n     * 5. 更新设备区域属性\n     */\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public ResponseDTO<Void> assignDevice(AreaDeviceAssignForm form) {\n        // 验证存在性\n        validateAreaExist(form.getAreaId());\n        validateDevicesExist(form.getDeviceIds());\n\n        // 批量分配设备\n        for (Long deviceId : form.getDeviceIds()) {\n            SmartDeviceEntity device = smartDeviceService.getById(deviceId);\n            device.setAreaId(form.getAreaId());\n            device.setDeviceType(DeviceTypeEnum.ACCESS_CONTROL);\n            smartDeviceService.updateById(device);\n\n            // 建立区域设备关联\n            AccessAreaDeviceEntity relation = new AccessAreaDeviceEntity();\n            relation.setAreaId(form.getAreaId());\n            relation.setDeviceId(deviceId);\n            accessAreaDeviceDao.save(relation);\n        }\n\n        // 清除缓存\n        accessAreaManager.clearDeviceCache();\n\n        return ResponseDTO.ok();\n    }\n}\n```\n\n**业务注意事项**:\n- **层级限制**: 区域层级不超过5层，防止性能问题\n- **权限继承**: 子区域继承父区域权限，支持权限覆盖\n- **设备分配**: 一个设备只能分配到一个区域，支持多对多关系\n- **删除约束**: 删除区域前必须处理所有关联关系\n- **缓存策略**: 区域信息使用多级缓存，更新时清除相关缓存\n\n#### AccessDeviceService - 设备管理服务\n\n**Purpose**: 处理门禁设备的业务逻辑，包括设备注册、状态管理、远程控制\n\n**关键业务逻辑**:\n```java\n@Service\n@Transactional(rollbackFor = Exception.class)\n@RequiredArgsConstructor\npublic class AccessDeviceService {\n\n    private final AccessDeviceDao accessDeviceDao;\n    private final AccessDeviceManager accessDeviceManager;\n    private final DeviceCommunicationService deviceCommunicationService;\n    private final BiometricService biometricService;\n\n    /**\n     * 添加设备 - 业务逻辑\n     * 1. 验证设备唯一标识\n     * 2. 验证设备类型和协议\n     * 3. 设备在线注册验证\n     * 4. 设置默认配置参数\n     * 5. 初始化设备状态\n     */\n    @Override\n    public ResponseDTO<Long> addDevice(AccessDeviceAddForm form) {\n        // 验证设备唯一性\n        validateDeviceUniqueness(form.getDeviceCode());\n\n        // 验证设备在线状态\n        DeviceOnlineStatus onlineStatus = deviceCommunicationService.checkDeviceOnline(form.getDeviceIp(), form.getDevicePort());\n        if (onlineStatus.isOffline()) {\n            throw new SmartException(\"设备离线，请检查网络连接\");\n        }\n\n        // 构建设备实体\n        AccessDeviceEntity entity = new AccessDeviceEntity();\n        entity.setDeviceCode(form.getDeviceCode());\n        entity.setDeviceName(form.getDeviceName());\n        entity.setDeviceType(form.getDeviceType());\n        entity.setDeviceIp(form.getDeviceIp());\n        entity.setDevicePort(form.getDevicePort());\n        entity.setProtocolType(form.getProtocolType());\n        entity.setLocation(form.getLocation());\n        entity.setAreaId(form.getAreaId());\n        entity.setDeviceStatus(DeviceStatusEnum.ONLINE);\n        entity.setSupportBiometric(form.getSupportBiometric());\n        entity.setSupportCard(form.getSupportCard());\n        entity.setSupportPassword(form.getSupportPassword());\n\n        // 保存设备\n        Long deviceId = accessDeviceDao.save(entity);\n\n        // 初始化设备配置\n        initializeDeviceConfig(deviceId, form);\n\n        // 启动设备监控\n        accessDeviceManager.startDeviceMonitor(deviceId);\n\n        return ResponseDTO.ok(deviceId);\n    }\n\n    /**\n     * 远程开门 - 业务逻辑\n     * 1. 验证设备存在性和在线状态\n     * 2. 验证用户权限\n     * 3. 发送开门命令\n     * 4. 记录操作日志\n     * 5. 推送实时通知\n     */\n    @Override\n    public ResponseDTO<Void> remoteOpen(DeviceControlForm form) {\n        // 验证设备\n        AccessDeviceEntity device = accessDeviceDao.getById(form.getDeviceId());\n        if (device == null) {\n            throw new SmartException(\"设备不存在\");\n        }\n\n        if (device.getDeviceStatus() != DeviceStatusEnum.ONLINE) {\n            throw new SmartException(\"设备离线，无法控制\");\n        }\n\n        // 验证权限\n        validateRemoteControlPermission();\n\n        // 发送开门命令\n        DeviceCommandResult result = deviceCommunicationService.sendOpenCommand(\n            device.getDeviceIp(),\n            device.getDevicePort(),\n            form.getOpenDuration()\n        );\n\n        if (!result.isSuccess()) {\n            throw new SmartException(\"开门命令执行失败: \" + result.getErrorMessage());\n        }\n\n        // 记录操作日志\n        recordDeviceControlLog(device.getDeviceId(), DeviceControlOperationEnum.REMOTE_OPEN);\n\n        // 推送WebSocket通知\n        accessDeviceManager.pushDeviceControlNotification(device.getDeviceId(), \"远程开门\");\n\n        return ResponseDTO.ok();\n    }\n\n    /**\n     * 设备状态同步 - 业务逻辑\n     * 1. 批量查询设备状态\n     * 2. 更新数据库状态\n     * 3. 触发状态变更事件\n     * 4. 推送实时通知\n     */\n    @Override\n    @Async\n    public void syncDeviceStatus() {\n        List<AccessDeviceEntity> devices = accessDeviceDao.list();\n\n        for (AccessDeviceEntity device : devices) {\n            try {\n                DeviceOnlineStatus status = deviceCommunicationService.checkDeviceOnline(\n                    device.getDeviceIp(), device.getDevicePort()\n                );\n\n                DeviceStatusEnum newStatus = status.isOnline() ? DeviceStatusEnum.ONLINE : DeviceStatusEnum.OFFLINE;\n                DeviceStatusEnum oldStatus = device.getDeviceStatus();\n\n                if (newStatus != oldStatus) {\n                    // 更新设备状态\n                    device.setDeviceStatus(newStatus);\n                    accessDeviceDao.updateById(device);\n\n                    // 触发状态变更事件\n                    deviceStatusChanged(device.getDeviceId(), oldStatus, newStatus);\n\n                    // 如果设备上线，重新初始化\n                    if (newStatus == DeviceStatusEnum.ONLINE) {\n                        initializeDeviceConfig(device.getDeviceId(), null);\n                    }\n                }\n            } catch (Exception e) {\n                log.error(\"设备状态同步失败: device={}\", device.getDeviceCode(), e);\n            }\n        }\n    }\n}\n```\n\n**业务注意事项**:\n- **设备通信**: 统一设备通信协议，支持TCP/UDP/HTTP多种方式\n- **状态监控**: 定时同步设备状态，异常时自动告警\n- **权限控制**: 远程控制操作需要特殊权限，记录详细操作日志\n- **配置管理**: 设备配置支持热更新，无需重启设备\n- **故障处理**: 设备离线时自动切换到备用处理流程\n\n## 数据模型设计\n\n### 核心实体模型\n\n#### AccessAreaEntity - 门禁区域实体\n\n```java\n@Data\n@EqualsAndHashCode(callSuper = true)\n@TableName(\"t_access_area\")\npublic class AccessAreaEntity extends BaseEntity {\n\n    /**\n     * 区域ID\n     */\n    @TableId(value = \"area_id\", type = IdType.AUTO)\n    private Long areaId;\n\n    /**\n     * 区域名称\n     */\n    @TableField(\"area_name\")\n    @NotBlank(message = \"区域名称不能为空\")\n    @Length(max = 100, message = \"区域名称长度不能超过100个字符\")\n    private String areaName;\n\n    /**\n     * 区域编码 - 自动生成\n     */\n    @TableField(\"area_code\")\n    @Pattern(regexp = \"^[A-Z0-9_-]+$\", message = \"区域编码格式不正确\")\n    private String areaCode;\n\n    /**\n     * 父区域ID\n     */\n    @TableField(\"parent_id\")\n    private Long parentId;\n\n    /**\n     * 区域层级\n     */\n    @TableField(\"area_level\")\n    @Min(value = 1, message = \"区域层级不能小于1\")\n    @Max(value = 5, message = \"区域层级不能超过5\")\n    private Integer areaLevel;\n\n    /**\n     * 访问级别 - 1-5级，数字越小权限越高\n     */\n    @TableField(\"access_level\")\n    @Min(value = 1, message = \"访问级别不能小于1\")\n    @Max(value = 5, message = \"访问级别不能超过5\")\n    private Integer accessLevel;\n\n    /**\n     * 区域类型\n     */\n    @TableField(\"area_type\")\n    private String areaType;\n\n    /**\n     * 区域描述\n     */\n    @TableField(\"description\")\n    @Length(max = 500, message = \"区域描述长度不能超过500个字符\")\n    private String description;\n\n    /**\n     * 排序字段\n     */\n    @TableField(\"sort_order\")\n    @Min(value = 0, message = \"排序值不能小于0\")\n    private Integer sortOrder;\n\n    /**\n     * 是否启用\n     */\n    @TableField(\"enabled_flag\")\n    private Boolean enabledFlag;\n}\n```\n\n#### AccessDeviceEntity - 门禁设备实体\n\n```java\n@Data\n@EqualsAndHashCode(callSuper = true)\n@TableName(\"t_access_device\")\npublic class AccessDeviceEntity extends BaseEntity {\n\n    /**\n     * 设备ID\n     */\n    @TableId(value = \"device_id\", type = IdType.AUTO)\n    private Long deviceId;\n\n    /**\n     * 设备编码 - 唯一标识\n     */\n    @TableField(\"device_code\")\n    @NotBlank(message = \"设备编码不能为空\")\n    @Unique(value = \"设备编码已存在\", groups = {UpdateGroup.class})\n    private String deviceCode;\n\n    /**\n     * 设备名称\n     */\n    @TableField(\"device_name\")\n    @NotBlank(message = \"设备名称不能为空\")\n    @Length(max = 100, message = \"设备名称长度不能超过100个字符\")\n    private String deviceName;\n\n    /**\n     * 设备类型\n     */\n    @TableField(\"device_type\")\n    @NotNull(message = \"设备类型不能为空\")\n    private String deviceType;\n\n    /**\n     * 设备IP地址\n     */\n    @TableField(\"device_ip\")\n    @Pattern(regexp = \"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$\",\n             message = \"IP地址格式不正确\")\n    private String deviceIp;\n\n    /**\n     * 设备端口\n     */\n    @TableField(\"device_port\")\n    @Min(value = 1, message = \"端口号不能小于1\")\n    @Max(value = 65535, message = \"端口号不能超过65535\")\n    private Integer devicePort;\n\n    /**\n     * 协议类型\n     */\n    @TableField(\"protocol_type\")\n    private String protocolType;\n\n    /**\n     * 设备状态\n     */\n    @TableField(\"device_status\")\n    private String deviceStatus;\n\n    /**\n     * 所属区域ID\n     */\n    @TableField(\"area_id\")\n    private Long areaId;\n\n    /**\n     * 设备位置\n     */\n    @TableField(\"location\")\n    @Length(max = 200, message = \"设备位置长度不能超过200个字符\")\n    private String location;\n\n    /**\n     * 是否支持生物识别\n     */\n    @TableField(\"support_biometric\")\n    private Boolean supportBiometric;\n\n    /**\n     * 是否支持刷卡\n     */\n    @TableField(\"support_card\")\n    private Boolean supportCard;\n\n    /**\n     * 是否支持密码\n     */\n    @TableField(\"support_password\")\n    private Boolean supportPassword;\n\n    /**\n     * 最后在线时间\n     */\n    @TableField(\"last_online_time\")\n    private LocalDateTime lastOnlineTime;\n\n    /**\n     * 设备配置信息\n     */\n    @TableField(\"device_config\")\n    private String deviceConfig;\n\n    /**\n     * 设备版本信息\n     */\n    @TableField(\"device_version\")\n    private String deviceVersion;\n}\n```\n\n#### AccessEventEntity - 通行事件实体\n\n```java\n@Data\n@EqualsAndHashCode(callSuper = true)\n@TableName(\"t_access_event\")\npublic class AccessEventEntity extends BaseEntity {\n\n    /**\n     * 事件ID\n     */\n    @TableId(value = \"event_id\", type = IdType.AUTO)\n    private Long eventId;\n\n    /**\n     * 事件编号\n     */\n    @TableField(\"event_no\")\n    @NotBlank(message = \"事件编号不能为空\")\n    private String eventNo;\n\n    /**\n     * 用户ID\n     */\n    @TableField(\"user_id\")\n    private Long userId;\n\n    /**\n     * 用户姓名\n     */\n    @TableField(\"user_name\")\n    private String userName;\n\n    /**\n     * 设备ID\n     */\n    @TableField(\"device_id\")\n    private Long deviceId;\n\n    /**\n     * 设备名称\n     */\n    @TableField(\"device_name\")\n    private String deviceName;\n\n    /**\n     * 区域ID\n     */\n    @TableField(\"area_id\")\n    private Long areaId;\n\n    /**\n     * 区域名称\n     */\n    @TableField(\"area_name\")\n    private String areaName;\n\n    /**\n     * 通行类型\n     */\n    @TableField(\"access_type\")\n    private String accessType;\n\n    /**\n     * 验证方式\n     */\n    @TableField(\"verify_method\")\n    private String verifyMethod;\n\n    /**\n     * 通行结果\n     */\n    @TableField(\"access_result\")\n    private String accessResult;\n\n    /**\n     * 通行时间\n     */\n    @TableField(\"access_time\")\n    private LocalDateTime accessTime;\n\n    /**\n     * 通行照片URL\n     */\n    @TableField(\"photo_url\")\n    private String photoUrl;\n\n    /**\n     * 体温检测结果\n     */\n    @TableField(\"temperature_result\")\n    private BigDecimal temperatureResult;\n\n    /**\n     * 备注信息\n     */\n    @TableField(\"remark\")\n    private String remark;\n}\n```\n\n### 数据库设计约束\n\n**表设计规范**:\n- **主键**: 所有表使用BIGINT AUTO_INCREMENT主键\n- **审计字段**: 继承BaseEntity，包含create_time, update_time, create_user_id, update_user_id\n- **软删除**: 所有业务表支持软删除，使用deleted_flag字段\n- **字符集**: 统一使用utf8mb4，支持emoji和特殊字符\n- **存储引擎**: 使用InnoDB，支持事务和外键\n\n**索引设计**:\n```sql\n-- 区域表索引\nCREATE INDEX idx_access_area_parent_id ON t_access_area(parent_id);\nCREATE INDEX idx_access_area_area_code ON t_access_area(area_code);\nCREATE INDEX idx_access_area_enabled_flag ON t_access_area(enabled_flag);\n\n-- 设备表索引\nCREATE INDEX idx_access_device_device_code ON t_access_device(device_code);\nCREATE INDEX idx_access_device_area_id ON t_access_device(area_id);\nCREATE INDEX idx_access_device_status ON t_access_device(device_status);\nCREATE INDEX idx_access_device_ip_port ON t_access_device(device_ip, device_port);\n\n-- 事件表索引\nCREATE INDEX idx_access_event_user_id ON t_access_event(user_id);\nCREATE INDEX idx_access_event_device_id ON t_access_event(device_id);\nCREATE INDEX idx_access_event_area_id ON t_access_event(area_id);\nCREATE INDEX idx_access_event_access_time ON t_access_event(access_time);\nCREATE INDEX idx_access_event_result ON t_access_event(access_result);\n```\n\n## 错误处理设计\n\n### 错误场景处理\n\n#### 1. 设备通信异常场景\n\n**场景描述**: 设备离线或网络连接失败时，系统无法正常控制设备\n\n**处理策略**:\n```java\n@Component\n@Slf4j\npublic class DeviceCommunicationErrorHandler {\n\n    /**\n     * 设备通信异常处理\n     */\n    public DeviceCommandResult handleCommunicationException(Long deviceId, Exception e) {\n        AccessDeviceEntity device = accessDeviceService.getById(deviceId);\n\n        // 1. 记录异常日志\n        log.error(\"设备通信异常: deviceId={}, deviceCode={}, error={}\",\n            deviceId, device.getDeviceCode(), e.getMessage(), e);\n\n        // 2. 更新设备状态为离线\n        device.setDeviceStatus(DeviceStatusEnum.OFFLINE);\n        device.setLastOnlineTime(LocalDateTime.now());\n        accessDeviceService.updateById(device);\n\n        // 3. 创建告警事件\n        createDeviceOfflineAlert(deviceId);\n\n        // 4. 推送WebSocket通知\n        pushDeviceOfflineNotification(deviceId);\n\n        // 5. 返回失败结果\n        return DeviceCommandResult.failure(\"设备通信失败: \" + e.getMessage());\n    }\n\n    /**\n     * 设备重连机制\n     */\n    @Scheduled(fixedDelay = 30000) // 30秒重试一次\n    public void retryOfflineDevices() {\n        List<AccessDeviceEntity> offlineDevices = accessDeviceService.listOfflineDevices();\n\n        for (AccessDeviceEntity device : offlineDevices) {\n            try {\n                // 尝试连接设备\n                DeviceOnlineStatus status = deviceCommunicationService.checkDeviceOnline(\n                    device.getDeviceIp(), device.getDevicePort()\n                );\n\n                if (status.isOnline()) {\n                    // 设备上线，更新状态\n                    device.setDeviceStatus(DeviceStatusEnum.ONLINE);\n                    accessDeviceService.updateById(device);\n\n                    // 发送上线通知\n                    pushDeviceOnlineNotification(device.getDeviceId());\n\n                    log.info(\"设备重新上线: deviceId={}, deviceCode={}\",\n                        device.getDeviceId(), device.getDeviceCode());\n                }\n            } catch (Exception e) {\n                log.warn(\"设备重连失败: deviceId={}, deviceCode={}\",\n                    device.getDeviceId(), device.getDeviceCode(), e);\n            }\n        }\n    }\n}\n```\n\n**用户影响**:\n- 设备离线时，用户无法进行远程控制，界面显示设备离线状态\n- 系统自动记录离线事件，生成告警通知管理人员\n- 设备恢复在线后，系统自动恢复正常功能\n\n#### 2. 权限验证异常场景\n\n**场景描述**: 用户访问未授权的功能或资源时，系统需要正确处理权限异常\n\n**处理策略**:\n```java\n@RestControllerAdvice\n@Slf4j\npublic class AccessControlExceptionHandler {\n\n    /**\n     * 权限不足异常处理\n     */\n    @ExceptionHandler(AccessDeniedException.class)\n    public ResponseDTO<Void> handleAccessDeniedException(AccessDeniedException e) {\n        // 1. 记录权限异常日志\n        log.warn(\"用户权限不足: userId={}, endpoint={}, ip={}\",\n            LoginUtil.getLoginUserId(),\n            getCurrentRequestURI(),\n            getClientIpAddress());\n\n        // 2. 记录访问审计日志\n        recordAccessAuditLog(AuditResultEnum.ACCESS_DENIED);\n\n        // 3. 返回标准权限错误响应\n        return ResponseDTO.error(SystemErrorCode.ACCESS_DENIED, \"权限不足，无法访问该功能\");\n    }\n\n    /**\n     * 会话过期异常处理\n     */\n    @ExceptionHandler(NotLoginException.class)\n    public ResponseDTO<Void> handleNotLoginException(NotLoginException e) {\n        // 1. 记录会话过期日志\n        log.info(\"用户会话过期: token={}, ip={}\",\n            e.getTokenValue(), getClientIpAddress());\n\n        // 2. 清除本地会话信息\n        StpUtil.logout();\n\n        // 3. 返回会话过期响应\n        return ResponseDTO.error(SystemErrorCode.SESSION_EXPIRED, \"登录已过期，请重新登录\");\n    }\n}\n```\n\n**用户影响**:\n- 权限不足时，系统显示友好的错误提示，不会暴露系统内部信息\n- 会话过期时，自动跳转到登录页面\n- 所有权限异常都会记录审计日志\n\n#### 3. 数据并发冲突场景\n\n**场景描述**: 多个用户同时修改同一区域或设备信息时，可能产生数据冲突\n\n**处理策略**:\n```java\n@Service\npublic class AccessAreaService {\n\n    /**\n     * 乐观锁更新区域信息\n     */\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public ResponseDTO<Void> updateArea(AccessAreaUpdateForm form) {\n        // 1. 使用版本号进行乐观锁控制\n        AccessAreaEntity existingArea = accessAreaDao.selectByIdForUpdate(form.getAreaId());\n        if (existingArea == null) {\n            throw new SmartException(\"区域不存在\");\n        }\n\n        // 2. 检查版本号\n        if (!existingArea.getVersion().equals(form.getVersion())) {\n            throw new SmartException(\"区域信息已被其他用户修改，请刷新后重试\");\n        }\n\n        // 3. 更新区域信息\n        existingArea.setAreaName(form.getAreaName());\n        existingArea.setDescription(form.getDescription());\n        existingArea.setAccessLevel(form.getAccessLevel());\n        existingArea.setUpdateUserId(LoginUtil.getLoginUserId());\n        existingArea.setUpdateTime(LocalDateTime.now());\n\n        // 4. 更新时会自动检查版本号\n        int updateCount = accessAreaDao.updateById(existingArea);\n        if (updateCount == 0) {\n            throw new SmartException(\"区域信息更新失败，请重试\");\n        }\n\n        // 5. 清除相关缓存\n        accessAreaManager.clearAreaCache();\n\n        return ResponseDTO.ok();\n    }\n}\n```\n\n**用户影响**:\n- 并发修改时，后提交的用户会收到友好的冲突提示\n- 系统不会产生数据不一致的问题\n- 用户可以刷新页面重新获取最新数据进行修改\n\n#### 4. 生物识别异常场景\n\n**场景描述**: 生物识别设备故障或识别失败时的异常处理\n\n**处理策略**:\n```java\n@Service\npublic class BiometricVerificationService {\n\n    /**\n     * 生物识别验证异常处理\n     */\n    public VerificationResult handleBiometricException(VerificationRequest request, Exception e) {\n        // 1. 记录识别异常日志\n        log.error(\"生物识别失败: userId={}, deviceId={}, method={}, error={}\",\n            request.getUserId(), request.getDeviceId(), request.getVerifyMethod(), e.getMessage(), e);\n\n        // 2. 检查设备状态\n        checkDeviceStatus(request.getDeviceId());\n\n        // 3. 尝试降级验证\n        if (canFallbackToCardVerification(request)) {\n            return fallbackToCardVerification(request);\n        }\n\n        if (canFallbackToPasswordVerification(request)) {\n            return fallbackToPasswordVerification(request);\n        }\n\n        // 4. 记录验证失败事件\n        recordVerificationFailure(request, e);\n\n        // 5. 触发设备故障告警\n        if (isDeviceFault(e)) {\n            createDeviceFaultAlert(request.getDeviceId());\n        }\n\n        // 6. 返回验证失败结果\n        return VerificationResult.failure(\"验证失败: \" + e.getMessage());\n    }\n\n    /**\n     * 设备故障检测\n     */\n    private boolean isDeviceFault(Exception e) {\n        return e instanceof DeviceTimeoutException ||\n               e instanceof DeviceConnectionException ||\n               e instanceof DeviceResponseException;\n    }\n\n    /**\n     * 降级到刷卡验证\n     */\n    private VerificationResult fallbackToCardVerification(VerificationRequest request) {\n        if (!request.getDeviceSupportsCard()) {\n            return null;\n        }\n\n        try {\n            return cardVerificationService.verify(request);\n        } catch (Exception e) {\n            log.warn(\"降级刷卡验证失败: {}\", e.getMessage());\n            return null;\n        }\n    }\n}\n```\n\n**用户影响**:\n- 生物识别失败时，系统自动尝试其他验证方式\n- 设备故障时，系统生成告警通知维护人员\n- 用户仍然可以通过备用验证方式通行\n\n## 测试策略\n\n### 单元测试策略\n\n**测试覆盖率目标**: 80%+\n\n**测试框架**: JUnit 5 + Mockito + AssertJ\n\n**核心测试组件**:\n```java\n@ExtendWith(MockitoExtension.class)\nclass AccessAreaServiceTest {\n\n    @Mock\n    private AccessAreaDao accessAreaDao;\n\n    @Mock\n    private AccessAreaManager accessAreaManager;\n\n    @InjectMocks\n    private AccessAreaService accessAreaService;\n\n    @Test\n    @DisplayName(\"创建区域 - 成功场景\")\n    void testCreateArea_Success() {\n        // Given\n        AccessAreaCreateForm form = new AccessAreaCreateForm();\n        form.setAreaName(\"测试区域\");\n        form.setParentId(1L);\n        form.setAccessLevel(3);\n\n        AccessAreaEntity savedArea = new AccessAreaEntity();\n        savedArea.setAreaId(100L);\n        savedArea.setAreaName(\"测试区域\");\n        savedArea.setAreaCode(\"AREA_001\");\n\n        when(accessAreaDao.save(any(AccessAreaEntity.class))).thenReturn(100L);\n        when(accessAreaDao.selectByAreaNameAndParentId(anyString(), anyLong())).thenReturn(null);\n        when(accessAreaDao.selectById(anyLong())).thenReturn(new AccessAreaEntity());\n\n        // When\n        ResponseDTO<Long> result = accessAreaService.createArea(form);\n\n        // Then\n        assertThat(result.isSuccess()).isTrue();\n        assertThat(result.getData()).isEqualTo(100L);\n\n        verify(accessAreaDao).save(any(AccessAreaEntity.class));\n        verify(accessAreaManager).clearAreaCache();\n    }\n\n    @Test\n    @DisplayName(\"创建区域 - 区域名称重复\")\n    void testCreateArea_DuplicateName() {\n        // Given\n        AccessAreaCreateForm form = new AccessAreaCreateForm();\n        form.setAreaName(\"重复区域\");\n        form.setParentId(1L);\n\n        when(accessAreaDao.selectByAreaNameAndParentId(\"重复区域\", 1L))\n            .thenReturn(new AccessAreaEntity());\n\n        // When & Then\n        assertThatThrownBy(() -> accessAreaService.createArea(form))\n            .isInstanceOf(SmartException.class)\n            .hasMessage(\"区域名称已存在\");\n    }\n\n    @Test\n    @DisplayName(\"删除区域 - 存在子区域\")\n    void testDeleteArea_HasChildren() {\n        // Given\n        Long areaId = 1L;\n        when(accessAreaDao.hasChildAreas(areaId)).thenReturn(true);\n\n        // When & Then\n        assertThatThrownBy(() -> accessAreaService.deleteArea(areaId))\n            .isInstanceOf(SmartException.class)\n            .hasMessage(\"该区域下存在子区域，无法删除\");\n    }\n\n    @Test\n    @DisplayName(\"区域设备分配 - 成功场景\")\n    void testAssignDevice_Success() {\n        // Given\n        AreaDeviceAssignForm form = new AreaDeviceAssignForm();\n        form.setAreaId(1L);\n        form.setDeviceIds(Arrays.asList(10L, 11L, 12L));\n\n        when(accessAreaDao.selectById(1L)).thenReturn(new AccessAreaEntity());\n        when(smartDeviceService.getById(10L)).thenReturn(new SmartDeviceEntity());\n        when(smartDeviceService.getById(11L)).thenReturn(new SmartDeviceEntity());\n        when(smartDeviceService.getById(12L)).thenReturn(new SmartDeviceEntity());\n\n        // When\n        ResponseDTO<Void> result = accessAreaService.assignDevice(form);\n\n        // Then\n        assertThat(result.isSuccess()).isTrue();\n        verify(smartDeviceService, times(3)).updateById(any(SmartDeviceEntity.class));\n        verify(accessAreaManager).clearDeviceCache();\n    }\n}\n```\n\n### 集成测试策略\n\n**测试重点**: 数据库事务、缓存一致性、外部服务集成\n\n**测试场景**:\n```java\n@SpringBootTest\n@TestPropertySource(locations = \"classpath:application-test.yml\")\n@Transactional\nclass AccessAreaServiceIntegrationTest {\n\n    @Autowired\n    private AccessAreaService accessAreaService;\n\n    @Autowired\n    private AccessAreaDao accessAreaDao;\n\n    @Test\n    @DisplayName(\"区域CRUD完整流程测试\")\n    void testAreaCRUD_CompleteFlow() {\n        // 1. 创建区域\n        AccessAreaCreateForm createForm = new AccessAreaCreateForm();\n        createForm.setAreaName(\"集成测试区域\");\n        createForm.setParentId(null);\n        createForm.setAccessLevel(3);\n\n        ResponseDTO<Long> createResult = accessAreaService.createArea(createForm);\n        assertThat(createResult.isSuccess()).isTrue();\n        Long areaId = createResult.getData();\n\n        // 2. 查询区域\n        AccessAreaEntity area = accessAreaDao.selectById(areaId);\n        assertThat(area).isNotNull();\n        assertThat(area.getAreaName()).isEqualTo(\"集成测试区域\");\n        assertThat(area.getAreaCode()).isNotNull();\n\n        // 3. 更新区域\n        AccessAreaUpdateForm updateForm = new AccessAreaUpdateForm();\n        updateForm.setAreaId(areaId);\n        updateForm.setAreaName(\"更新后区域\");\n        updateForm.setVersion(area.getVersion());\n\n        ResponseDTO<Void> updateResult = accessAreaService.updateArea(updateForm);\n        assertThat(updateResult.isSuccess()).isTrue();\n\n        // 4. 验证更新结果\n        AccessAreaEntity updatedArea = accessAreaDao.selectById(areaId);\n        assertThat(updatedArea.getAreaName()).isEqualTo(\"更新后区域\");\n\n        // 5. 删除区域\n        ResponseDTO<Void> deleteResult = accessAreaService.deleteArea(areaId);\n        assertThat(deleteResult.isSuccess()).isTrue();\n\n        // 6. 验证软删除结果\n        AccessAreaEntity deletedArea = accessAreaDao.selectById(areaId);\n        assertThat(deletedArea).isNotNull();\n        assertThat(deletedArea.getDeletedFlag()).isEqualTo(DeletedFlagEnum.DELETED);\n    }\n\n    @Test\n    @DisplayName(\"并发创建区域测试\")\n    void testCreateArea_ConcurrentCreation() throws InterruptedException {\n        int threadCount = 10;\n        CountDownLatch latch = new CountDownLatch(threadCount);\n        List<Future<Long>> futures = new ArrayList<>();\n        ExecutorService executor = Executors.newFixedThreadPool(threadCount);\n\n        // 并发创建相同名称的区域\n        for (int i = 0; i < threadCount; i++) {\n            futures.add(executor.submit(() -> {\n                try {\n                    AccessAreaCreateForm form = new AccessAreaCreateForm();\n                    form.setAreaName(\"并发测试区域\");\n                    form.setParentId(null);\n\n                    ResponseDTO<Long> result = accessAreaService.createArea(form);\n                    return result.isSuccess() ? result.getData() : null;\n                } finally {\n                    latch.countDown();\n                }\n            }));\n        }\n\n        latch.await(30, TimeUnit.SECONDS);\n\n        // 只有一个应该成功\n        long successCount = futures.stream()\n            .mapToLong(future -> {\n                try {\n                    return future.get() != null ? 1 : 0;\n                } catch (Exception e) {\n                    return 0;\n                }\n            })\n            .sum();\n\n        assertThat(successCount).isEqualTo(1);\n\n        executor.shutdown();\n    }\n}\n```\n\n### 端到端测试策略\n\n**测试重点**: 完整业务流程、用户场景、系统集成\n\n**测试场景**:\n```java\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)\nclass AccessControlE2ETest {\n\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    @LocalServerPort\n    private int port;\n\n    @Test\n    @DisplayName(\"完整门禁验证流程\")\n    void testCompleteAccessControlFlow() {\n        String baseUrl = \"http://localhost:\" + port;\n\n        // 1. 用户登录\n        LoginRequest loginRequest = new LoginRequest();\n        loginRequest.setLoginName(\"admin\");\n        loginRequest.setPassword(\"123456\");\n\n        ResponseEntity<LoginResponse> loginResponse = restTemplate.postForEntity(\n            baseUrl + \"/api/auth/login\", loginRequest, LoginResponse.class);\n\n        assertThat(loginResponse.getStatusCode()).isEqualTo(HttpStatus.OK);\n        assertThat(loginResponse.getBody().getToken()).isNotNull();\n\n        String token = loginResponse.getBody().getToken();\n\n        // 2. 创建区域\n        AccessAreaCreateForm areaForm = new AccessAreaCreateForm();\n        areaForm.setAreaName(\"主楼大厅\");\n        areaForm.setAccessLevel(2);\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.setBearerAuth(token);\n        HttpEntity<AccessAreaCreateForm> areaRequest = new HttpEntity<>(areaForm, headers);\n\n        ResponseEntity<ResponseDTO> areaResponse = restTemplate.postForEntity(\n            baseUrl + \"/api/smart/access/area/create\", areaRequest, ResponseDTO.class);\n\n        assertThat(areaResponse.getStatusCode()).isEqualTo(HttpStatus.OK);\n        assertThat(areaResponse.getBody().isSuccess()).isTrue();\n\n        Long areaId = (Long) areaResponse.getBody().getData();\n\n        // 3. 添加设备\n        AccessDeviceAddForm deviceForm = new AccessDeviceAddForm();\n        deviceForm.setDeviceName(\"主门禁设备\");\n        deviceForm.setDeviceCode(\"DEV001\");\n        deviceForm.setDeviceIp(\"192.168.1.100\");\n        deviceForm.setDevicePort(8080);\n        deviceForm.setAreaId(areaId);\n\n        HttpEntity<AccessDeviceAddForm> deviceRequest = new HttpEntity<>(deviceForm, headers);\n\n        ResponseEntity<ResponseDTO> deviceResponse = restTemplate.postForEntity(\n            baseUrl + \"/api/smart/access/device/add\", deviceRequest, ResponseDTO.class);\n\n        assertThat(deviceResponse.getStatusCode()).isEqualTo(HttpStatus.OK);\n        assertThat(deviceResponse.getBody().isSuccess()).isTrue();\n\n        Long deviceId = (Long) deviceResponse.getBody().getData();\n\n        // 4. 远程开门测试\n        DeviceControlForm controlForm = new DeviceControlForm();\n        controlForm.setDeviceId(deviceId);\n        controlForm.setOpenDuration(5);\n\n        HttpEntity<DeviceControlForm> controlRequest = new HttpEntity<>(controlForm, headers);\n\n        ResponseEntity<ResponseDTO> controlResponse = restTemplate.postForEntity(\n            baseUrl + \"/api/smart/access/device/control/open\", controlRequest, ResponseDTO.class);\n\n        assertThat(controlResponse.getStatusCode()).isEqualTo(HttpStatus.OK);\n\n        // 5. 验证通行记录\n        AccessEventQuery eventQuery = new AccessEventQuery();\n        eventQuery.setDeviceId(deviceId);\n\n        String queryUrl = baseUrl + \"/api/smart/access/monitor/events/page?\" +\n            \"deviceId=\" + deviceId + \"&pageNum=1&pageSize=10\";\n\n        ResponseEntity<ResponseDTO> eventResponse = restTemplate.getForEntity(\n            queryUrl, ResponseDTO.class, headers);\n\n        assertThat(eventResponse.getStatusCode()).isEqualTo(HttpStatus.OK);\n        assertThat(eventResponse.getBody().isSuccess()).isTrue();\n    }\n}\n```\n\n### 性能测试策略\n\n**测试目标**:\n- API响应时间 < 200ms (95%的请求)\n- 并发用户数 1000+\n- 系统资源使用率 < 70%\n\n**测试工具**: JMeter + Gatling\n\n**测试场景**:\n```java\n// JMeter测试计划示例\npublic class AccessControlPerformanceTest {\n\n    @Test\n    @DisplayName(\"区域管理接口性能测试\")\n    void testAreaManagementPerformance() {\n        // 测试创建区域接口性能\n        TestPlan createAreaPlan = new TestPlan();\n        createAreaPlan.addThreadGroup(50, 100, 10) // 50线程，100并发，10秒 Ramp-up\n            .addSampler(HttpSampler.class)\n                .setDomain(\"localhost\")\n                .setPort(8080)\n                .setPath(\"/api/smart/access/area/create\")\n                .setMethod(\"POST\")\n                .addArgument(\"areaName\", \"性能测试区域\")\n                .addArgument(\"accessLevel\", \"3\")\n            .addAssertion(DurationAssertion.class, 200); // 响应时间小于200ms\n\n        // 测试区域树查询接口性能\n        TestPlan treeQueryPlan = new TestPlan();\n        treeQueryPlan.addThreadGroup(100, 200, 5)\n            .addSampler(HttpSampler.class)\n                .setDomain(\"localhost\")\n                .setPort(8080)\n                .setPath(\"/api/smart/access/area/tree\")\n                .setMethod(\"GET\")\n            .addAssertion(DurationAssertion.class, 100); // 响应时间小于100ms\n\n        // 执行测试\n        JMeterEngine engine = new JMeterEngine();\n        TestResults results = engine.run(createAreaPlan, treeQueryPlan);\n\n        // 验证性能指标\n        assertThat(results.getAverageResponseTime()).isLessThan(200);\n        assertThat(results.getErrorRate()).isLessThan(0.01); // 错误率小于1%\n        assertThat(results.getThroughput()).isGreaterThan(100); // 吞吐量大于100 TPS\n    }\n}\n```\n\n## 安全设计\n\n### 数据安全\n\n**敏感数据加密**:\n```java\n@Component\npublic class SensitiveDataEncryption {\n\n    private final AESUtil aesUtil;\n\n    /**\n     * 加密生物特征数据\n     */\n    public String encryptBiometricData(String rawData) {\n        return aesUtil.encrypt(rawData, getBiometricEncryptionKey());\n    }\n\n    /**\n     * 解密生物特征数据\n     */\n    public String decryptBiometricData(String encryptedData) {\n        return aesUtil.decrypt(encryptedData, getBiometricEncryptionKey());\n    }\n\n    /**\n     * 获取生物特征加密密钥\n     */\n    private String getBiometricEncryptionKey() {\n        // 使用硬件安全模块或密钥管理服务\n        return keyManagementService.getEncryptionKey(\"BIOMETRIC\");\n    }\n}\n```\n\n**数据脱敏**:\n```java\n@Component\npublic class AccessEventDataMasking {\n\n    /**\n     * 脱敏处理用户姓名\n     */\n    public String maskUserName(String userName) {\n        if (StringUtils.isBlank(userName) || userName.length() <= 2) {\n            return \"*\";\n        }\n        return userName.charAt(0) + \"***\" + userName.charAt(userName.length() - 1);\n    }\n\n    /**\n     * 脱敏处理身份证号\n     */\n    public String maskIdCard(String idCard) {\n        if (StringUtils.isBlank(idCard) || idCard.length() != 18) {\n            return \"***\";\n        }\n        return idCard.substring(0, 6) + \"********\" + idCard.substring(14);\n    }\n}\n```\n\n### 访问控制\n\n**细粒度权限控制**:\n```java\n@Component\npublic class AccessControlService {\n\n    /**\n     * 检查用户区域访问权限\n     */\n    public boolean checkAreaAccessPermission(Long userId, Long areaId) {\n        // 1. 获取用户角色\n        List<Long> userRoleIds = userRoleService.getUserRoleIds(userId);\n\n        // 2. 检查直接区域权限\n        for (Long roleId : userRoleIds) {\n            if (roleAreaService.hasAreaPermission(roleId, areaId)) {\n                return true;\n            }\n        }\n\n        // 3. 检查父区域权限继承\n        AccessAreaEntity area = accessAreaService.getById(areaId);\n        while (area != null && area.getParentId() != null) {\n            for (Long roleId : userRoleIds) {\n                if (roleAreaService.hasAreaPermission(roleId, area.getParentId())) {\n                    return true;\n                }\n            }\n            area = accessAreaService.getById(area.getParentId());\n        }\n\n        return false;\n    }\n\n    /**\n     * 检查时间段访问权限\n     */\n    public boolean checkTimeAccessPermission(Long userId, LocalDateTime accessTime) {\n        // 1. 获取用户时间段权限\n        List<UserTimePermission> timePermissions = userTimePermissionService\n            .getUserTimePermissions(userId);\n\n        // 2. 检查当前时间是否在允许的时间段内\n        DayOfWeek dayOfWeek = accessTime.getDayOfWeek();\n        int hour = accessTime.getHour();\n\n        for (UserTimePermission permission : timePermissions) {\n            if (permission.getDayOfWeek().equals(dayOfWeek.name()) &&\n                hour >= permission.getStartHour() &&\n                hour <= permission.getEndHour()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n```\n\n### 审计日志\n\n**操作日志记录**:\n```java\n@Aspect\n@Component\n@Slf4j\npublic class AccessControlAuditAspect {\n\n    @Around(\"@annotation(operationLog)\")\n    public Object logOperation(ProceedingJoinPoint joinPoint, OperationLog operationLog) throws Throwable {\n        // 1. 获取操作信息\n        String operationType = operationLog.operationType();\n        String operationContent = operationLog.operationContent();\n        String methodName = joinPoint.getSignature().getName();\n        Object[] args = joinPoint.getArgs();\n\n        // 2. 记录操作开始\n        log.info(\"开始执行操作: type={}, content={}, method={}, args={}\",\n            operationType, operationContent, methodName, Arrays.toString(args));\n\n        try {\n            // 3. 执行目标方法\n            long startTime = System.currentTimeMillis();\n            Object result = joinPoint.proceed();\n            long endTime = System.currentTimeMillis();\n\n            // 4. 记录操作成功日志\n            log.info(\"操作执行成功: type={}, content={}, duration={}ms\",\n                operationType, operationContent, endTime - startTime);\n\n            // 5. 保存审计日志\n            saveAuditLog(operationType, operationContent, methodName, args,\n                AuditResultEnum.SUCCESS, endTime - startTime);\n\n            return result;\n\n        } catch (Exception e) {\n            // 6. 记录操作失败日志\n            log.error(\"操作执行失败: type={}, content={}, error={}\",\n                operationType, operationContent, e.getMessage(), e);\n\n            // 7. 保存审计日志\n            saveAuditLog(operationType, operationContent, methodName, args,\n                AuditResultEnum.FAILED, 0, e.getMessage());\n\n            throw e;\n        }\n    }\n}\n```\n\n本设计文档详细定义了门禁系统的技术实现方案，严格遵循repowiki开发规范，确保代码质量、系统性能和安全性。通过模块化设计、完善的错误处理策略和全面的测试策略，为后续的精准开发提供详细指导。",
  "fileStats": {
    "size": 55318,
    "lines": 1792,
    "lastModified": "2025-11-19T09:44:23.830Z"
  },
  "comments": []
}