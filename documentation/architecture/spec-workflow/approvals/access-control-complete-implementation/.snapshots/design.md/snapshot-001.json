{
  "id": "snapshot_1763282517719_z4uqrcd9w",
  "approvalId": "approval_1763282517692_ph2enfqkr",
  "approvalTitle": "门禁系统完整实现设计文档审批",
  "version": 1,
  "timestamp": "2025-11-16T08:41:57.719Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# 门禁系统完整实现设计文档\r\n\r\n## 概述\r\n\r\n本文档详细描述了IOE-DREAM智慧园区门禁系统的完整技术设计方案，严格遵循repowiki开发规范体系，确保代码质量、系统性能和可维护性。\r\n\r\n**设计目标**:\r\n- 实现35% → 90%+的门禁模块功能覆盖率\r\n- 建立符合repowiki规范的标准开发流程\r\n- 确保企业级系统稳定性和安全性\r\n- 实现80%+的单元测试覆盖率\r\n\r\n## Steering文档对齐\r\n\r\n### 技术标准对齐 (tech.md)\r\n\r\n**严格遵循repowiki技术规范**:\r\n- **包名规范**: 强制使用jakarta.*，禁止javax.*\r\n- **依赖注入**: 强制使用@Resource，禁止@Autowired\r\n- **架构规范**: 严格四层架构Controller → Service → Manager → DAO\r\n- **权限控制**: 所有接口必须添加@SaCheckPermission注解\r\n- **代码质量**: 每个方法不超过50行，单一职责原则\r\n\r\n**SmartAdmin v3技术栈集成**:\r\n- Spring Boot 3.5.4 + Jakarta EE\r\n- Vue 3 + Composition API + TypeScript\r\n- MyBatis-Plus 3.5 + MySQL 8.0\r\n- Redis 6.0集群 + Caffeine本地缓存\r\n- Sa-Token权限认证 + RBAC权限模型\r\n\r\n### 项目结构对齐 (structure.md)\r\n\r\n**标准包结构**:\r\n```\r\nnet.lab1024.sa.admin.module.smart.access/\r\n├── controller/     # 控制器层 - HTTP接口\r\n├── service/        # 业务逻辑层 - 业务流程\r\n├── manager/        # 管理层 - 跨模块调用、缓存\r\n├── dao/           # 数据访问层 - 数据库操作\r\n├── domain/        # 领域模型层 - Entity、VO、DTO\r\n│   ├── entity/    # 实体类\r\n│   ├── vo/        # 视图对象\r\n│   ├── dto/       # 数据传输对象\r\n│   └── form/      # 表单对象\r\n└── constant/      # 常量定义 - 枚举、常量类\r\n```\r\n\r\n**前端结构对齐**:\r\n```\r\nsrc/views/smart/access/\r\n├── components/    # 通用组件\r\n├── pages/         # 页面组件\r\n├── api/          # API接口封装\r\n├── stores/       # Pinia状态管理\r\n└── types/        # TypeScript类型定义\r\n```\r\n\r\n## 代码复用分析\r\n\r\n### 现有组件利用\r\n\r\n**核心基础组件**:\r\n- **BaseCacheManager**: 多级缓存管理器，继承实现门禁专用缓存\r\n- **BaseEntity**: 通用实体基类，包含审计字段\r\n- **ResponseDTO**: 统一响应格式，确保API一致性\r\n- **SmartException**: 统一异常处理体系\r\n- **SaTokenUtil**: Sa-Token工具类，权限验证辅助\r\n\r\n**工具类复用**:\r\n- **SmartBeanUtil**: 对象拷贝和转换工具\r\n- **SmartVerificationUtil**: 参数验证工具\r\n- **SmartResponseUtil**: 响应构建工具\r\n- **RedisUtil**: Redis操作工具类\r\n\r\n### 集成点设计\r\n\r\n**系统集成点**:\r\n- **用户权限系统**: 集成现有UserPermissionEntity和RBAC模型\r\n- **组织架构系统**: 集成SmartAreaEntity区域管理\r\n- **设备管理系统**: 扩展SmartDeviceEntity设备管理\r\n- **日志审计系统**: 集成OperationLog操作日志记录\r\n\r\n**数据库集成**:\r\n- **用户表**: t_smart_user (现有，扩展门禁权限字段)\r\n- **角色表**: t_smart_role (现有，添加门禁权限标识)\r\n- **设备表**: t_smart_device (现有，扩展门禁设备类型)\r\n- **区域表**: t_smart_area (现有，添加门禁区域类型)\r\n\r\n## 架构设计\r\n\r\n### 整体架构图\r\n\r\n```mermaid\r\ngraph TD\r\n    subgraph \"前端层\"\r\n        A[Vue3管理界面] --> B[AccessControl Dashboard]\r\n        A --> C[RealTimeMonitor]\r\n        A --> D[DeviceManagement]\r\n    end\r\n\r\n    subgraph \"API网关层\"\r\n        E[Nginx Gateway] --> F[LoadBalancer]\r\n    end\r\n\r\n    subgraph \"应用层\"\r\n        G[AccessController] --> H[AccessService]\r\n        I[DeviceController] --> J[DeviceService]\r\n        K[MonitorController] --> L[MonitorService]\r\n    end\r\n\r\n    subgraph \"业务层\"\r\n        H --> M[AccessManager]\r\n        J --> N[DeviceManager]\r\n        L --> O[MonitorManager]\r\n    end\r\n\r\n    subgraph \"缓存层\"\r\n        P[Caffeine L1缓存] --> Q[Redis L2缓存]\r\n        R[WebSocket Session] --> S[消息队列]\r\n    end\r\n\r\n    subgraph \"数据层\"\r\n        T[MySQL主库] --> U[MyBatis-Plus]\r\n        V[Redis集群] --> W[数据同步]\r\n    end\r\n\r\n    subgraph \"硬件层\"\r\n        X[门禁控制器] --> Y[生物识别设备]\r\n        Z[监控摄像头] --> AA[告警设备]\r\n    end\r\n\r\n    B --> E\r\n    C --> E\r\n    D --> E\r\n    E --> G\r\n    E --> I\r\n    E --> K\r\n    M --> P\r\n    N --> P\r\n    O --> R\r\n    P --> T\r\n    P --> V\r\n    U --> X\r\n    W --> X\r\n```\r\n\r\n### 模块化设计原则\r\n\r\n**单一文件职责**:\r\n- **Controller类**: 仅处理HTTP请求/响应，不超过200行代码\r\n- **Service类**: 仅处理业务逻辑，不超过300行代码\r\n- **Manager类**: 仅处理跨模块调用和缓存，不超过200行代码\r\n- **DAO接口**: 仅处理数据访问，使用MyBatis-Plus简化\r\n\r\n**组件隔离原则**:\r\n- **权限验证组件**: 独立的权限验证逻辑，可复用\r\n- **设备通信组件**: 抽象设备通信接口，支持多种协议\r\n- **生物识别组件**: 封装生物识别算法，支持多种识别方式\r\n- **告警处理组件**: 统一的告警处理流程，支持多种告警渠道\r\n\r\n**服务层分离**:\r\n- **数据访问层**: 使用MyBatis-Plus，自动生成CRUD方法\r\n- **业务逻辑层**: 复杂业务流程编排，事务管理\r\n- **表现层**: Controller仅做参数验证和响应格式化\r\n- **缓存管理层**: 统一的缓存策略，支持多级缓存\r\n\r\n## 组件和接口设计\r\n\r\n### 核心Controller组件\r\n\r\n#### AccessAreaController - 区域管理控制器\r\n\r\n**Purpose**: 负责门禁区域空间的CRUD操作和层级管理\r\n\r\n**Interfaces**:\r\n```java\r\n@RestController\r\n@RequestMapping(\"/api/smart/access/area\")\r\n@SaCheckPermission(\"smart:access:area\")\r\npublic class AccessAreaController {\r\n\r\n    /**\r\n     * 获取区域树形结构\r\n     * @return 区域树形列表\r\n     */\r\n    @GetMapping(\"/tree\")\r\n    public ResponseDTO<List<AccessAreaTreeVO>> getAreaTree();\r\n\r\n    /**\r\n     * 创建新区域\r\n     * @param form 区域创建表单\r\n     * @return 创建结果\r\n     */\r\n    @PostMapping(\"/create\")\r\n    @OperationLog(operationType = OperationLogTypeEnum.ADD, operationContent = \"创建门禁区域\")\r\n    public ResponseDTO<Long> createArea(@Valid @RequestBody AccessAreaCreateForm form);\r\n\r\n    /**\r\n     * 更新区域信息\r\n     * @param form 区域更新表单\r\n     * @return 更新结果\r\n     */\r\n    @PutMapping(\"/update\")\r\n    @OperationLog(operationType = OperationLogTypeEnum.UPDATE, operationContent = \"更新门禁区域\")\r\n    public ResponseDTO<Void> updateArea(@Valid @RequestBody AccessAreaUpdateForm form);\r\n\r\n    /**\r\n     * 删除区域\r\n     * @param areaId 区域ID\r\n     * @return 删除结果\r\n     */\r\n    @DeleteMapping(\"/delete/{areaId}\")\r\n    @OperationLog(operationType = OperationLogTypeEnum.DELETE, operationContent = \"删除门禁区域\")\r\n    public ResponseDTO<Void> deleteArea(@PathVariable Long areaId);\r\n\r\n    /**\r\n     * 为区域分配设备\r\n     * @param form 设备分配表单\r\n     * @return 分配结果\r\n     */\r\n    @PostMapping(\"/assign-device\")\r\n    @OperationLog(operationType = OperationLogTypeEnum.UPDATE, operationContent = \"区域设备分配\")\r\n    public ResponseDTO<Void> assignDevice(@Valid @RequestBody AreaDeviceAssignForm form);\r\n}\r\n```\r\n\r\n**Dependencies**:\r\n- AccessAreaService: 区域管理业务逻辑\r\n- SmartAreaService: 基础区域服务(复用)\r\n- SmartDeviceService: 设备管理服务(复用)\r\n- OperationLogAspect: 操作日志切面(复用)\r\n\r\n**Reuses**:\r\n- 继承现有SmartAreaEntity数据模型\r\n- 复用OperationLog操作日志注解\r\n- 复用ResponseDTO统一响应格式\r\n- 复用@Valid参数验证\r\n\r\n#### AccessDeviceController - 设备管理控制器\r\n\r\n**Purpose**: 负责门禁设备的完整生命周期管理和实时控制\r\n\r\n**Interfaces**:\r\n```java\r\n@RestController\r\n@RequestMapping(\"/api/smart/access/device\")\r\n@SaCheckPermission(\"smart:access:device\")\r\npublic class AccessDeviceController {\r\n\r\n    /**\r\n     * 获取设备列表\r\n     * @param query 查询条件\r\n     * @return 设备分页列表\r\n     */\r\n    @GetMapping(\"/page\")\r\n    public ResponseDTO<PageResult<AccessDeviceVO>> getDevicePage(AccessDeviceQuery query);\r\n\r\n    /**\r\n     * 获取设备详情\r\n     * @param deviceId 设备ID\r\n     * @return 设备详情\r\n     */\r\n    @GetMapping(\"/detail/{deviceId}\")\r\n    public ResponseDTO<AccessDeviceDetailVO> getDeviceDetail(@PathVariable Long deviceId);\r\n\r\n    /**\r\n     * 添加设备\r\n     * @param form 设备添加表单\r\n     * @return 添加结果\r\n     */\r\n    @PostMapping(\"/add\")\r\n    @OperationLog(operationType = OperationLogTypeEnum.ADD, operationContent = \"添加门禁设备\")\r\n    public ResponseDTO<Long> addDevice(@Valid @RequestBody AccessDeviceAddForm form);\r\n\r\n    /**\r\n     * 更新设备\r\n     * @param form 设备更新表单\r\n     * @return 更新结果\r\n     */\r\n    @PutMapping(\"/update\")\r\n    @OperationLog(operationType = OperationLogTypeEnum.UPDATE, operationContent = \"更新门禁设备\")\r\n    public ResponseDTO<Void> updateDevice(@Valid @RequestBody AccessDeviceUpdateForm form);\r\n\r\n    /**\r\n     * 删除设备\r\n     * @param deviceId 设备ID\r\n     * @return 删除结果\r\n     */\r\n    @DeleteMapping(\"/delete/{deviceId}\")\r\n    @OperationLog(operationType = OperationLogTypeEnum.DELETE, operationContent = \"删除门禁设备\")\r\n    public ResponseDTO<Void> deleteDevice(@PathVariable Long deviceId);\r\n\r\n    /**\r\n     * 设备控制 - 远程开门\r\n     * @param form 控制表单\r\n     * @return 控制结果\r\n     */\r\n    @PostMapping(\"/control/open\")\r\n    @OperationLog(operationType = OperationLogTypeEnum.OTHER, operationContent = \"远程开门控制\")\r\n    public ResponseDTO<Void> remoteOpen(@Valid @RequestBody DeviceControlForm form);\r\n\r\n    /**\r\n     * 设备控制 - 重启设备\r\n     * @param form 控制表单\r\n     * @return 控制结果\r\n     */\r\n    @PostMapping(\"/control/restart\")\r\n    @OperationLog(operationType = OperationLogTypeEnum.OTHER, operationContent = \"重启设备\")\r\n    public ResponseDTO<Void> restartDevice(@Valid @RequestBody DeviceControlForm form);\r\n\r\n    /**\r\n     * 获取设备状态\r\n     * @param deviceId 设备ID\r\n     * @return 设备状态\r\n     */\r\n    @GetMapping(\"/status/{deviceId}\")\r\n    public ResponseDTO<DeviceStatusVO> getDeviceStatus(@PathVariable Long deviceId);\r\n}\r\n```\r\n\r\n**Dependencies**:\r\n- AccessDeviceService: 设备管理业务逻辑\r\n- SmartDeviceService: 基础设备服务(复用)\r\n- DeviceCommunicationService: 设备通信服务\r\n- AccessMonitorWebSocket: 实时监控WebSocket\r\n\r\n**Reuses**:\r\n- 继承现有SmartDeviceEntity数据模型\r\n- 复用设备通信协议框架\r\n- 复用WebSocket连接管理\r\n\r\n#### AccessMonitorController - 实时监控控制器\r\n\r\n**Purpose**: 负责门禁实时监控、事件查询和告警管理\r\n\r\n**Interfaces**:\r\n```java\r\n@RestController\r\n@RequestMapping(\"/api/smart/access/monitor\")\r\n@SaCheckPermission(\"smart:access:monitor\")\r\npublic class AccessMonitorController {\r\n\r\n    /**\r\n     * 获取实时监控数据\r\n     * @return 监控数据概览\r\n     */\r\n    @GetMapping(\"/overview\")\r\n    public ResponseDTO<MonitorOverviewVO> getMonitorOverview();\r\n\r\n    /**\r\n     * 获取通行事件列表\r\n     * @param query 查询条件\r\n     * @return 通行事件分页列表\r\n     */\r\n    @GetMapping(\"/events/page\")\r\n    public ResponseDTO<PageResult<AccessEventVO>> getAccessEventPage(AccessEventQuery query);\r\n\r\n    /**\r\n     * 获取告警事件列表\r\n     * @param query 查询条件\r\n     * @return 告警事件分页列表\r\n     */\r\n    @GetMapping(\"/alerts/page\")\r\n    public ResponseDTO<PageResult<AccessAlertVO>> getAccessAlertPage(AccessAlertQuery query);\r\n\r\n    /**\r\n     * 处理告警事件\r\n     * @param form 告警处理表单\r\n     * @return 处理结果\r\n     */\r\n    @PostMapping(\"/alert/handle\")\r\n    @OperationLog(operationType = OperationLogTypeEnum.UPDATE, operationContent = \"处理门禁告警\")\r\n    public ResponseDTO<Void> handleAlert(@Valid @RequestBody AlertHandleForm form);\r\n\r\n    /**\r\n     * 获取设备实时状态\r\n     * @param areaId 区域ID(可选)\r\n     * @return 设备状态列表\r\n     */\r\n    @GetMapping(\"/device-status\")\r\n    public ResponseDTO<List<DeviceStatusVO>> getDeviceStatus(@RequestParam(required = false) Long areaId);\r\n\r\n    /**\r\n     * 获取通行统计数据\r\n     * @param query 统计查询条件\r\n     * @return 统计数据\r\n     */\r\n    @GetMapping(\"/statistics\")\r\n    public ResponseDTO<AccessStatisticsVO> getAccessStatistics(AccessStatisticsQuery query);\r\n}\r\n```\r\n\r\n**Dependencies**:\r\n- AccessMonitorService: 监控业务逻辑\r\n- AccessEventService: 事件管理服务\r\n- AccessAlertService: 告警管理服务\r\n- AccessMonitorWebSocket: WebSocket服务\r\n\r\n### 核心Service组件\r\n\r\n#### AccessAreaService - 区域管理服务\r\n\r\n**Purpose**: 处理门禁区域的业务逻辑，包括层级管理、权限分配、设备关联\r\n\r\n**关键业务逻辑**:\r\n```java\r\n@Service\r\n@Transactional(rollbackFor = Exception.class)\r\n@RequiredArgsConstructor\r\npublic class AccessAreaService {\r\n\r\n    private final AccessAreaDao accessAreaDao;\r\n    private final AccessAreaManager accessAreaManager;\r\n    private final SmartDeviceService smartDeviceService;\r\n\r\n    /**\r\n     * 创建区域 - 业务逻辑\r\n     * 1. 验证区域名称唯一性\r\n     * 2. 验证父区域存在性\r\n     * 3. 生成区域编码\r\n     * 4. 设置默认权限配置\r\n     * 5. 清除相关缓存\r\n     */\r\n    @Override\r\n    public ResponseDTO<Long> createArea(AccessAreaCreateForm form) {\r\n        // 业务验证逻辑\r\n        validateAreaNameUniqueness(form.getAreaName(), form.getParentId());\r\n        validateParentAreaExist(form.getParentId());\r\n\r\n        // 构建实体\r\n        AccessAreaEntity entity = new AccessAreaEntity();\r\n        entity.setAreaName(form.getAreaName());\r\n        entity.setParentId(form.getParentId());\r\n        entity.setAreaCode(generateAreaCode(form.getParentId()));\r\n        entity.setAreaType(AreaTypeEnum.ACCESS_CONTROL);\r\n        entity.setAccessLevel(form.getAccessLevel());\r\n        entity.setDescription(form.getDescription());\r\n\r\n        // 保存实体\r\n        Long areaId = accessAreaDao.save(entity);\r\n\r\n        // 清除缓存\r\n        accessAreaManager.clearAreaCache();\r\n\r\n        return ResponseDTO.ok(areaId);\r\n    }\r\n\r\n    /**\r\n     * 删除区域 - 业务逻辑\r\n     * 1. 检查区域下是否有子区域\r\n     * 2. 检查区域是否关联设备\r\n     * 3. 检查区域是否关联用户权限\r\n     * 4. 软删除区域\r\n     * 5. 处理相关数据关联\r\n     */\r\n    @Override\r\n    @Transactional(rollbackFor = Exception.class)\r\n    public ResponseDTO<Void> deleteArea(Long areaId) {\r\n        AccessAreaEntity area = accessAreaDao.getById(areaId);\r\n        if (area == null) {\r\n            throw new SmartException(\"区域不存在\");\r\n        }\r\n\r\n        // 业务检查\r\n        validateDeleteConstraints(areaId);\r\n\r\n        // 软删除区域\r\n        area.setDeletedFlag(DeletedFlagEnum.DELETED);\r\n        accessAreaDao.updateById(area);\r\n\r\n        // 处理关联数据\r\n        handleRelatedDataOnDelete(areaId);\r\n\r\n        // 清除缓存\r\n        accessAreaManager.clearAreaCache();\r\n\r\n        return ResponseDTO.ok();\r\n    }\r\n\r\n    /**\r\n     * 区域设备分配 - 业务逻辑\r\n     * 1. 验证设备存在性\r\n     * 2. 验证区域存在性\r\n     * 3. 检查设备是否已分配\r\n     * 4. 建立关联关系\r\n     * 5. 更新设备区域属性\r\n     */\r\n    @Override\r\n    @Transactional(rollbackFor = Exception.class)\r\n    public ResponseDTO<Void> assignDevice(AreaDeviceAssignForm form) {\r\n        // 验证存在性\r\n        validateAreaExist(form.getAreaId());\r\n        validateDevicesExist(form.getDeviceIds());\r\n\r\n        // 批量分配设备\r\n        for (Long deviceId : form.getDeviceIds()) {\r\n            SmartDeviceEntity device = smartDeviceService.getById(deviceId);\r\n            device.setAreaId(form.getAreaId());\r\n            device.setDeviceType(DeviceTypeEnum.ACCESS_CONTROL);\r\n            smartDeviceService.updateById(device);\r\n\r\n            // 建立区域设备关联\r\n            AccessAreaDeviceEntity relation = new AccessAreaDeviceEntity();\r\n            relation.setAreaId(form.getAreaId());\r\n            relation.setDeviceId(deviceId);\r\n            accessAreaDeviceDao.save(relation);\r\n        }\r\n\r\n        // 清除缓存\r\n        accessAreaManager.clearDeviceCache();\r\n\r\n        return ResponseDTO.ok();\r\n    }\r\n}\r\n```\r\n\r\n**业务注意事项**:\r\n- **层级限制**: 区域层级不超过5层，防止性能问题\r\n- **权限继承**: 子区域继承父区域权限，支持权限覆盖\r\n- **设备分配**: 一个设备只能分配到一个区域，支持多对多关系\r\n- **删除约束**: 删除区域前必须处理所有关联关系\r\n- **缓存策略**: 区域信息使用多级缓存，更新时清除相关缓存\r\n\r\n#### AccessDeviceService - 设备管理服务\r\n\r\n**Purpose**: 处理门禁设备的业务逻辑，包括设备注册、状态管理、远程控制\r\n\r\n**关键业务逻辑**:\r\n```java\r\n@Service\r\n@Transactional(rollbackFor = Exception.class)\r\n@RequiredArgsConstructor\r\npublic class AccessDeviceService {\r\n\r\n    private final AccessDeviceDao accessDeviceDao;\r\n    private final AccessDeviceManager accessDeviceManager;\r\n    private final DeviceCommunicationService deviceCommunicationService;\r\n    private final BiometricService biometricService;\r\n\r\n    /**\r\n     * 添加设备 - 业务逻辑\r\n     * 1. 验证设备唯一标识\r\n     * 2. 验证设备类型和协议\r\n     * 3. 设备在线注册验证\r\n     * 4. 设置默认配置参数\r\n     * 5. 初始化设备状态\r\n     */\r\n    @Override\r\n    public ResponseDTO<Long> addDevice(AccessDeviceAddForm form) {\r\n        // 验证设备唯一性\r\n        validateDeviceUniqueness(form.getDeviceCode());\r\n\r\n        // 验证设备在线状态\r\n        DeviceOnlineStatus onlineStatus = deviceCommunicationService.checkDeviceOnline(form.getDeviceIp(), form.getDevicePort());\r\n        if (onlineStatus.isOffline()) {\r\n            throw new SmartException(\"设备离线，请检查网络连接\");\r\n        }\r\n\r\n        // 构建设备实体\r\n        AccessDeviceEntity entity = new AccessDeviceEntity();\r\n        entity.setDeviceCode(form.getDeviceCode());\r\n        entity.setDeviceName(form.getDeviceName());\r\n        entity.setDeviceType(form.getDeviceType());\r\n        entity.setDeviceIp(form.getDeviceIp());\r\n        entity.setDevicePort(form.getDevicePort());\r\n        entity.setProtocolType(form.getProtocolType());\r\n        entity.setLocation(form.getLocation());\r\n        entity.setAreaId(form.getAreaId());\r\n        entity.setDeviceStatus(DeviceStatusEnum.ONLINE);\r\n        entity.setSupportBiometric(form.getSupportBiometric());\r\n        entity.setSupportCard(form.getSupportCard());\r\n        entity.setSupportPassword(form.getSupportPassword());\r\n\r\n        // 保存设备\r\n        Long deviceId = accessDeviceDao.save(entity);\r\n\r\n        // 初始化设备配置\r\n        initializeDeviceConfig(deviceId, form);\r\n\r\n        // 启动设备监控\r\n        accessDeviceManager.startDeviceMonitor(deviceId);\r\n\r\n        return ResponseDTO.ok(deviceId);\r\n    }\r\n\r\n    /**\r\n     * 远程开门 - 业务逻辑\r\n     * 1. 验证设备存在性和在线状态\r\n     * 2. 验证用户权限\r\n     * 3. 发送开门命令\r\n     * 4. 记录操作日志\r\n     * 5. 推送实时通知\r\n     */\r\n    @Override\r\n    public ResponseDTO<Void> remoteOpen(DeviceControlForm form) {\r\n        // 验证设备\r\n        AccessDeviceEntity device = accessDeviceDao.getById(form.getDeviceId());\r\n        if (device == null) {\r\n            throw new SmartException(\"设备不存在\");\r\n        }\r\n\r\n        if (device.getDeviceStatus() != DeviceStatusEnum.ONLINE) {\r\n            throw new SmartException(\"设备离线，无法控制\");\r\n        }\r\n\r\n        // 验证权限\r\n        validateRemoteControlPermission();\r\n\r\n        // 发送开门命令\r\n        DeviceCommandResult result = deviceCommunicationService.sendOpenCommand(\r\n            device.getDeviceIp(),\r\n            device.getDevicePort(),\r\n            form.getOpenDuration()\r\n        );\r\n\r\n        if (!result.isSuccess()) {\r\n            throw new SmartException(\"开门命令执行失败: \" + result.getErrorMessage());\r\n        }\r\n\r\n        // 记录操作日志\r\n        recordDeviceControlLog(device.getDeviceId(), DeviceControlOperationEnum.REMOTE_OPEN);\r\n\r\n        // 推送WebSocket通知\r\n        accessDeviceManager.pushDeviceControlNotification(device.getDeviceId(), \"远程开门\");\r\n\r\n        return ResponseDTO.ok();\r\n    }\r\n\r\n    /**\r\n     * 设备状态同步 - 业务逻辑\r\n     * 1. 批量查询设备状态\r\n     * 2. 更新数据库状态\r\n     * 3. 触发状态变更事件\r\n     * 4. 推送实时通知\r\n     */\r\n    @Override\r\n    @Async\r\n    public void syncDeviceStatus() {\r\n        List<AccessDeviceEntity> devices = accessDeviceDao.list();\r\n\r\n        for (AccessDeviceEntity device : devices) {\r\n            try {\r\n                DeviceOnlineStatus status = deviceCommunicationService.checkDeviceOnline(\r\n                    device.getDeviceIp(), device.getDevicePort()\r\n                );\r\n\r\n                DeviceStatusEnum newStatus = status.isOnline() ? DeviceStatusEnum.ONLINE : DeviceStatusEnum.OFFLINE;\r\n                DeviceStatusEnum oldStatus = device.getDeviceStatus();\r\n\r\n                if (newStatus != oldStatus) {\r\n                    // 更新设备状态\r\n                    device.setDeviceStatus(newStatus);\r\n                    accessDeviceDao.updateById(device);\r\n\r\n                    // 触发状态变更事件\r\n                    deviceStatusChanged(device.getDeviceId(), oldStatus, newStatus);\r\n\r\n                    // 如果设备上线，重新初始化\r\n                    if (newStatus == DeviceStatusEnum.ONLINE) {\r\n                        initializeDeviceConfig(device.getDeviceId(), null);\r\n                    }\r\n                }\r\n            } catch (Exception e) {\r\n                log.error(\"设备状态同步失败: device={}\", device.getDeviceCode(), e);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**业务注意事项**:\r\n- **设备通信**: 统一设备通信协议，支持TCP/UDP/HTTP多种方式\r\n- **状态监控**: 定时同步设备状态，异常时自动告警\r\n- **权限控制**: 远程控制操作需要特殊权限，记录详细操作日志\r\n- **配置管理**: 设备配置支持热更新，无需重启设备\r\n- **故障处理**: 设备离线时自动切换到备用处理流程\r\n\r\n## 数据模型设计\r\n\r\n### 核心实体模型\r\n\r\n#### AccessAreaEntity - 门禁区域实体\r\n\r\n```java\r\n@Data\r\n@EqualsAndHashCode(callSuper = true)\r\n@TableName(\"t_access_area\")\r\npublic class AccessAreaEntity extends BaseEntity {\r\n\r\n    /**\r\n     * 区域ID\r\n     */\r\n    @TableId(value = \"area_id\", type = IdType.AUTO)\r\n    private Long areaId;\r\n\r\n    /**\r\n     * 区域名称\r\n     */\r\n    @TableField(\"area_name\")\r\n    @NotBlank(message = \"区域名称不能为空\")\r\n    @Length(max = 100, message = \"区域名称长度不能超过100个字符\")\r\n    private String areaName;\r\n\r\n    /**\r\n     * 区域编码 - 自动生成\r\n     */\r\n    @TableField(\"area_code\")\r\n    @Pattern(regexp = \"^[A-Z0-9_-]+$\", message = \"区域编码格式不正确\")\r\n    private String areaCode;\r\n\r\n    /**\r\n     * 父区域ID\r\n     */\r\n    @TableField(\"parent_id\")\r\n    private Long parentId;\r\n\r\n    /**\r\n     * 区域层级\r\n     */\r\n    @TableField(\"area_level\")\r\n    @Min(value = 1, message = \"区域层级不能小于1\")\r\n    @Max(value = 5, message = \"区域层级不能超过5\")\r\n    private Integer areaLevel;\r\n\r\n    /**\r\n     * 访问级别 - 1-5级，数字越小权限越高\r\n     */\r\n    @TableField(\"access_level\")\r\n    @Min(value = 1, message = \"访问级别不能小于1\")\r\n    @Max(value = 5, message = \"访问级别不能超过5\")\r\n    private Integer accessLevel;\r\n\r\n    /**\r\n     * 区域类型\r\n     */\r\n    @TableField(\"area_type\")\r\n    private String areaType;\r\n\r\n    /**\r\n     * 区域描述\r\n     */\r\n    @TableField(\"description\")\r\n    @Length(max = 500, message = \"区域描述长度不能超过500个字符\")\r\n    private String description;\r\n\r\n    /**\r\n     * 排序字段\r\n     */\r\n    @TableField(\"sort_order\")\r\n    @Min(value = 0, message = \"排序值不能小于0\")\r\n    private Integer sortOrder;\r\n\r\n    /**\r\n     * 是否启用\r\n     */\r\n    @TableField(\"enabled_flag\")\r\n    private Boolean enabledFlag;\r\n}\r\n```\r\n\r\n#### AccessDeviceEntity - 门禁设备实体\r\n\r\n```java\r\n@Data\r\n@EqualsAndHashCode(callSuper = true)\r\n@TableName(\"t_access_device\")\r\npublic class AccessDeviceEntity extends BaseEntity {\r\n\r\n    /**\r\n     * 设备ID\r\n     */\r\n    @TableId(value = \"device_id\", type = IdType.AUTO)\r\n    private Long deviceId;\r\n\r\n    /**\r\n     * 设备编码 - 唯一标识\r\n     */\r\n    @TableField(\"device_code\")\r\n    @NotBlank(message = \"设备编码不能为空\")\r\n    @Unique(value = \"设备编码已存在\", groups = {UpdateGroup.class})\r\n    private String deviceCode;\r\n\r\n    /**\r\n     * 设备名称\r\n     */\r\n    @TableField(\"device_name\")\r\n    @NotBlank(message = \"设备名称不能为空\")\r\n    @Length(max = 100, message = \"设备名称长度不能超过100个字符\")\r\n    private String deviceName;\r\n\r\n    /**\r\n     * 设备类型\r\n     */\r\n    @TableField(\"device_type\")\r\n    @NotNull(message = \"设备类型不能为空\")\r\n    private String deviceType;\r\n\r\n    /**\r\n     * 设备IP地址\r\n     */\r\n    @TableField(\"device_ip\")\r\n    @Pattern(regexp = \"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$\",\r\n             message = \"IP地址格式不正确\")\r\n    private String deviceIp;\r\n\r\n    /**\r\n     * 设备端口\r\n     */\r\n    @TableField(\"device_port\")\r\n    @Min(value = 1, message = \"端口号不能小于1\")\r\n    @Max(value = 65535, message = \"端口号不能超过65535\")\r\n    private Integer devicePort;\r\n\r\n    /**\r\n     * 协议类型\r\n     */\r\n    @TableField(\"protocol_type\")\r\n    private String protocolType;\r\n\r\n    /**\r\n     * 设备状态\r\n     */\r\n    @TableField(\"device_status\")\r\n    private String deviceStatus;\r\n\r\n    /**\r\n     * 所属区域ID\r\n     */\r\n    @TableField(\"area_id\")\r\n    private Long areaId;\r\n\r\n    /**\r\n     * 设备位置\r\n     */\r\n    @TableField(\"location\")\r\n    @Length(max = 200, message = \"设备位置长度不能超过200个字符\")\r\n    private String location;\r\n\r\n    /**\r\n     * 是否支持生物识别\r\n     */\r\n    @TableField(\"support_biometric\")\r\n    private Boolean supportBiometric;\r\n\r\n    /**\r\n     * 是否支持刷卡\r\n     */\r\n    @TableField(\"support_card\")\r\n    private Boolean supportCard;\r\n\r\n    /**\r\n     * 是否支持密码\r\n     */\r\n    @TableField(\"support_password\")\r\n    private Boolean supportPassword;\r\n\r\n    /**\r\n     * 最后在线时间\r\n     */\r\n    @TableField(\"last_online_time\")\r\n    private LocalDateTime lastOnlineTime;\r\n\r\n    /**\r\n     * 设备配置信息\r\n     */\r\n    @TableField(\"device_config\")\r\n    private String deviceConfig;\r\n\r\n    /**\r\n     * 设备版本信息\r\n     */\r\n    @TableField(\"device_version\")\r\n    private String deviceVersion;\r\n}\r\n```\r\n\r\n#### AccessEventEntity - 通行事件实体\r\n\r\n```java\r\n@Data\r\n@EqualsAndHashCode(callSuper = true)\r\n@TableName(\"t_access_event\")\r\npublic class AccessEventEntity extends BaseEntity {\r\n\r\n    /**\r\n     * 事件ID\r\n     */\r\n    @TableId(value = \"event_id\", type = IdType.AUTO)\r\n    private Long eventId;\r\n\r\n    /**\r\n     * 事件编号\r\n     */\r\n    @TableField(\"event_no\")\r\n    @NotBlank(message = \"事件编号不能为空\")\r\n    private String eventNo;\r\n\r\n    /**\r\n     * 用户ID\r\n     */\r\n    @TableField(\"user_id\")\r\n    private Long userId;\r\n\r\n    /**\r\n     * 用户姓名\r\n     */\r\n    @TableField(\"user_name\")\r\n    private String userName;\r\n\r\n    /**\r\n     * 设备ID\r\n     */\r\n    @TableField(\"device_id\")\r\n    private Long deviceId;\r\n\r\n    /**\r\n     * 设备名称\r\n     */\r\n    @TableField(\"device_name\")\r\n    private String deviceName;\r\n\r\n    /**\r\n     * 区域ID\r\n     */\r\n    @TableField(\"area_id\")\r\n    private Long areaId;\r\n\r\n    /**\r\n     * 区域名称\r\n     */\r\n    @TableField(\"area_name\")\r\n    private String areaName;\r\n\r\n    /**\r\n     * 通行类型\r\n     */\r\n    @TableField(\"access_type\")\r\n    private String accessType;\r\n\r\n    /**\r\n     * 验证方式\r\n     */\r\n    @TableField(\"verify_method\")\r\n    private String verifyMethod;\r\n\r\n    /**\r\n     * 通行结果\r\n     */\r\n    @TableField(\"access_result\")\r\n    private String accessResult;\r\n\r\n    /**\r\n     * 通行时间\r\n     */\r\n    @TableField(\"access_time\")\r\n    private LocalDateTime accessTime;\r\n\r\n    /**\r\n     * 通行照片URL\r\n     */\r\n    @TableField(\"photo_url\")\r\n    private String photoUrl;\r\n\r\n    /**\r\n     * 体温检测结果\r\n     */\r\n    @TableField(\"temperature_result\")\r\n    private BigDecimal temperatureResult;\r\n\r\n    /**\r\n     * 备注信息\r\n     */\r\n    @TableField(\"remark\")\r\n    private String remark;\r\n}\r\n```\r\n\r\n### 数据库设计约束\r\n\r\n**表设计规范**:\r\n- **主键**: 所有表使用BIGINT AUTO_INCREMENT主键\r\n- **审计字段**: 继承BaseEntity，包含create_time, update_time, create_user_id, update_user_id\r\n- **软删除**: 所有业务表支持软删除，使用deleted_flag字段\r\n- **字符集**: 统一使用utf8mb4，支持emoji和特殊字符\r\n- **存储引擎**: 使用InnoDB，支持事务和外键\r\n\r\n**索引设计**:\r\n```sql\r\n-- 区域表索引\r\nCREATE INDEX idx_access_area_parent_id ON t_access_area(parent_id);\r\nCREATE INDEX idx_access_area_area_code ON t_access_area(area_code);\r\nCREATE INDEX idx_access_area_enabled_flag ON t_access_area(enabled_flag);\r\n\r\n-- 设备表索引\r\nCREATE INDEX idx_access_device_device_code ON t_access_device(device_code);\r\nCREATE INDEX idx_access_device_area_id ON t_access_device(area_id);\r\nCREATE INDEX idx_access_device_status ON t_access_device(device_status);\r\nCREATE INDEX idx_access_device_ip_port ON t_access_device(device_ip, device_port);\r\n\r\n-- 事件表索引\r\nCREATE INDEX idx_access_event_user_id ON t_access_event(user_id);\r\nCREATE INDEX idx_access_event_device_id ON t_access_event(device_id);\r\nCREATE INDEX idx_access_event_area_id ON t_access_event(area_id);\r\nCREATE INDEX idx_access_event_access_time ON t_access_event(access_time);\r\nCREATE INDEX idx_access_event_result ON t_access_event(access_result);\r\n```\r\n\r\n## 错误处理设计\r\n\r\n### 错误场景处理\r\n\r\n#### 1. 设备通信异常场景\r\n\r\n**场景描述**: 设备离线或网络连接失败时，系统无法正常控制设备\r\n\r\n**处理策略**:\r\n```java\r\n@Component\r\n@Slf4j\r\npublic class DeviceCommunicationErrorHandler {\r\n\r\n    /**\r\n     * 设备通信异常处理\r\n     */\r\n    public DeviceCommandResult handleCommunicationException(Long deviceId, Exception e) {\r\n        AccessDeviceEntity device = accessDeviceService.getById(deviceId);\r\n\r\n        // 1. 记录异常日志\r\n        log.error(\"设备通信异常: deviceId={}, deviceCode={}, error={}\",\r\n            deviceId, device.getDeviceCode(), e.getMessage(), e);\r\n\r\n        // 2. 更新设备状态为离线\r\n        device.setDeviceStatus(DeviceStatusEnum.OFFLINE);\r\n        device.setLastOnlineTime(LocalDateTime.now());\r\n        accessDeviceService.updateById(device);\r\n\r\n        // 3. 创建告警事件\r\n        createDeviceOfflineAlert(deviceId);\r\n\r\n        // 4. 推送WebSocket通知\r\n        pushDeviceOfflineNotification(deviceId);\r\n\r\n        // 5. 返回失败结果\r\n        return DeviceCommandResult.failure(\"设备通信失败: \" + e.getMessage());\r\n    }\r\n\r\n    /**\r\n     * 设备重连机制\r\n     */\r\n    @Scheduled(fixedDelay = 30000) // 30秒重试一次\r\n    public void retryOfflineDevices() {\r\n        List<AccessDeviceEntity> offlineDevices = accessDeviceService.listOfflineDevices();\r\n\r\n        for (AccessDeviceEntity device : offlineDevices) {\r\n            try {\r\n                // 尝试连接设备\r\n                DeviceOnlineStatus status = deviceCommunicationService.checkDeviceOnline(\r\n                    device.getDeviceIp(), device.getDevicePort()\r\n                );\r\n\r\n                if (status.isOnline()) {\r\n                    // 设备上线，更新状态\r\n                    device.setDeviceStatus(DeviceStatusEnum.ONLINE);\r\n                    accessDeviceService.updateById(device);\r\n\r\n                    // 发送上线通知\r\n                    pushDeviceOnlineNotification(device.getDeviceId());\r\n\r\n                    log.info(\"设备重新上线: deviceId={}, deviceCode={}\",\r\n                        device.getDeviceId(), device.getDeviceCode());\r\n                }\r\n            } catch (Exception e) {\r\n                log.warn(\"设备重连失败: deviceId={}, deviceCode={}\",\r\n                    device.getDeviceId(), device.getDeviceCode(), e);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**用户影响**:\r\n- 设备离线时，用户无法进行远程控制，界面显示设备离线状态\r\n- 系统自动记录离线事件，生成告警通知管理人员\r\n- 设备恢复在线后，系统自动恢复正常功能\r\n\r\n#### 2. 权限验证异常场景\r\n\r\n**场景描述**: 用户访问未授权的功能或资源时，系统需要正确处理权限异常\r\n\r\n**处理策略**:\r\n```java\r\n@RestControllerAdvice\r\n@Slf4j\r\npublic class AccessControlExceptionHandler {\r\n\r\n    /**\r\n     * 权限不足异常处理\r\n     */\r\n    @ExceptionHandler(AccessDeniedException.class)\r\n    public ResponseDTO<Void> handleAccessDeniedException(AccessDeniedException e) {\r\n        // 1. 记录权限异常日志\r\n        log.warn(\"用户权限不足: userId={}, endpoint={}, ip={}\",\r\n            LoginUtil.getLoginUserId(),\r\n            getCurrentRequestURI(),\r\n            getClientIpAddress());\r\n\r\n        // 2. 记录访问审计日志\r\n        recordAccessAuditLog(AuditResultEnum.ACCESS_DENIED);\r\n\r\n        // 3. 返回标准权限错误响应\r\n        return ResponseDTO.error(SystemErrorCode.ACCESS_DENIED, \"权限不足，无法访问该功能\");\r\n    }\r\n\r\n    /**\r\n     * 会话过期异常处理\r\n     */\r\n    @ExceptionHandler(NotLoginException.class)\r\n    public ResponseDTO<Void> handleNotLoginException(NotLoginException e) {\r\n        // 1. 记录会话过期日志\r\n        log.info(\"用户会话过期: token={}, ip={}\",\r\n            e.getTokenValue(), getClientIpAddress());\r\n\r\n        // 2. 清除本地会话信息\r\n        StpUtil.logout();\r\n\r\n        // 3. 返回会话过期响应\r\n        return ResponseDTO.error(SystemErrorCode.SESSION_EXPIRED, \"登录已过期，请重新登录\");\r\n    }\r\n}\r\n```\r\n\r\n**用户影响**:\r\n- 权限不足时，系统显示友好的错误提示，不会暴露系统内部信息\r\n- 会话过期时，自动跳转到登录页面\r\n- 所有权限异常都会记录审计日志\r\n\r\n#### 3. 数据并发冲突场景\r\n\r\n**场景描述**: 多个用户同时修改同一区域或设备信息时，可能产生数据冲突\r\n\r\n**处理策略**:\r\n```java\r\n@Service\r\npublic class AccessAreaService {\r\n\r\n    /**\r\n     * 乐观锁更新区域信息\r\n     */\r\n    @Override\r\n    @Transactional(rollbackFor = Exception.class)\r\n    public ResponseDTO<Void> updateArea(AccessAreaUpdateForm form) {\r\n        // 1. 使用版本号进行乐观锁控制\r\n        AccessAreaEntity existingArea = accessAreaDao.selectByIdForUpdate(form.getAreaId());\r\n        if (existingArea == null) {\r\n            throw new SmartException(\"区域不存在\");\r\n        }\r\n\r\n        // 2. 检查版本号\r\n        if (!existingArea.getVersion().equals(form.getVersion())) {\r\n            throw new SmartException(\"区域信息已被其他用户修改，请刷新后重试\");\r\n        }\r\n\r\n        // 3. 更新区域信息\r\n        existingArea.setAreaName(form.getAreaName());\r\n        existingArea.setDescription(form.getDescription());\r\n        existingArea.setAccessLevel(form.getAccessLevel());\r\n        existingArea.setUpdateUserId(LoginUtil.getLoginUserId());\r\n        existingArea.setUpdateTime(LocalDateTime.now());\r\n\r\n        // 4. 更新时会自动检查版本号\r\n        int updateCount = accessAreaDao.updateById(existingArea);\r\n        if (updateCount == 0) {\r\n            throw new SmartException(\"区域信息更新失败，请重试\");\r\n        }\r\n\r\n        // 5. 清除相关缓存\r\n        accessAreaManager.clearAreaCache();\r\n\r\n        return ResponseDTO.ok();\r\n    }\r\n}\r\n```\r\n\r\n**用户影响**:\r\n- 并发修改时，后提交的用户会收到友好的冲突提示\r\n- 系统不会产生数据不一致的问题\r\n- 用户可以刷新页面重新获取最新数据进行修改\r\n\r\n#### 4. 生物识别异常场景\r\n\r\n**场景描述**: 生物识别设备故障或识别失败时的异常处理\r\n\r\n**处理策略**:\r\n```java\r\n@Service\r\npublic class BiometricVerificationService {\r\n\r\n    /**\r\n     * 生物识别验证异常处理\r\n     */\r\n    public VerificationResult handleBiometricException(VerificationRequest request, Exception e) {\r\n        // 1. 记录识别异常日志\r\n        log.error(\"生物识别失败: userId={}, deviceId={}, method={}, error={}\",\r\n            request.getUserId(), request.getDeviceId(), request.getVerifyMethod(), e.getMessage(), e);\r\n\r\n        // 2. 检查设备状态\r\n        checkDeviceStatus(request.getDeviceId());\r\n\r\n        // 3. 尝试降级验证\r\n        if (canFallbackToCardVerification(request)) {\r\n            return fallbackToCardVerification(request);\r\n        }\r\n\r\n        if (canFallbackToPasswordVerification(request)) {\r\n            return fallbackToPasswordVerification(request);\r\n        }\r\n\r\n        // 4. 记录验证失败事件\r\n        recordVerificationFailure(request, e);\r\n\r\n        // 5. 触发设备故障告警\r\n        if (isDeviceFault(e)) {\r\n            createDeviceFaultAlert(request.getDeviceId());\r\n        }\r\n\r\n        // 6. 返回验证失败结果\r\n        return VerificationResult.failure(\"验证失败: \" + e.getMessage());\r\n    }\r\n\r\n    /**\r\n     * 设备故障检测\r\n     */\r\n    private boolean isDeviceFault(Exception e) {\r\n        return e instanceof DeviceTimeoutException ||\r\n               e instanceof DeviceConnectionException ||\r\n               e instanceof DeviceResponseException;\r\n    }\r\n\r\n    /**\r\n     * 降级到刷卡验证\r\n     */\r\n    private VerificationResult fallbackToCardVerification(VerificationRequest request) {\r\n        if (!request.getDeviceSupportsCard()) {\r\n            return null;\r\n        }\r\n\r\n        try {\r\n            return cardVerificationService.verify(request);\r\n        } catch (Exception e) {\r\n            log.warn(\"降级刷卡验证失败: {}\", e.getMessage());\r\n            return null;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**用户影响**:\r\n- 生物识别失败时，系统自动尝试其他验证方式\r\n- 设备故障时，系统生成告警通知维护人员\r\n- 用户仍然可以通过备用验证方式通行\r\n\r\n## 测试策略\r\n\r\n### 单元测试策略\r\n\r\n**测试覆盖率目标**: 80%+\r\n\r\n**测试框架**: JUnit 5 + Mockito + AssertJ\r\n\r\n**核心测试组件**:\r\n```java\r\n@ExtendWith(MockitoExtension.class)\r\nclass AccessAreaServiceTest {\r\n\r\n    @Mock\r\n    private AccessAreaDao accessAreaDao;\r\n\r\n    @Mock\r\n    private AccessAreaManager accessAreaManager;\r\n\r\n    @InjectMocks\r\n    private AccessAreaService accessAreaService;\r\n\r\n    @Test\r\n    @DisplayName(\"创建区域 - 成功场景\")\r\n    void testCreateArea_Success() {\r\n        // Given\r\n        AccessAreaCreateForm form = new AccessAreaCreateForm();\r\n        form.setAreaName(\"测试区域\");\r\n        form.setParentId(1L);\r\n        form.setAccessLevel(3);\r\n\r\n        AccessAreaEntity savedArea = new AccessAreaEntity();\r\n        savedArea.setAreaId(100L);\r\n        savedArea.setAreaName(\"测试区域\");\r\n        savedArea.setAreaCode(\"AREA_001\");\r\n\r\n        when(accessAreaDao.save(any(AccessAreaEntity.class))).thenReturn(100L);\r\n        when(accessAreaDao.selectByAreaNameAndParentId(anyString(), anyLong())).thenReturn(null);\r\n        when(accessAreaDao.selectById(anyLong())).thenReturn(new AccessAreaEntity());\r\n\r\n        // When\r\n        ResponseDTO<Long> result = accessAreaService.createArea(form);\r\n\r\n        // Then\r\n        assertThat(result.isSuccess()).isTrue();\r\n        assertThat(result.getData()).isEqualTo(100L);\r\n\r\n        verify(accessAreaDao).save(any(AccessAreaEntity.class));\r\n        verify(accessAreaManager).clearAreaCache();\r\n    }\r\n\r\n    @Test\r\n    @DisplayName(\"创建区域 - 区域名称重复\")\r\n    void testCreateArea_DuplicateName() {\r\n        // Given\r\n        AccessAreaCreateForm form = new AccessAreaCreateForm();\r\n        form.setAreaName(\"重复区域\");\r\n        form.setParentId(1L);\r\n\r\n        when(accessAreaDao.selectByAreaNameAndParentId(\"重复区域\", 1L))\r\n            .thenReturn(new AccessAreaEntity());\r\n\r\n        // When & Then\r\n        assertThatThrownBy(() -> accessAreaService.createArea(form))\r\n            .isInstanceOf(SmartException.class)\r\n            .hasMessage(\"区域名称已存在\");\r\n    }\r\n\r\n    @Test\r\n    @DisplayName(\"删除区域 - 存在子区域\")\r\n    void testDeleteArea_HasChildren() {\r\n        // Given\r\n        Long areaId = 1L;\r\n        when(accessAreaDao.hasChildAreas(areaId)).thenReturn(true);\r\n\r\n        // When & Then\r\n        assertThatThrownBy(() -> accessAreaService.deleteArea(areaId))\r\n            .isInstanceOf(SmartException.class)\r\n            .hasMessage(\"该区域下存在子区域，无法删除\");\r\n    }\r\n\r\n    @Test\r\n    @DisplayName(\"区域设备分配 - 成功场景\")\r\n    void testAssignDevice_Success() {\r\n        // Given\r\n        AreaDeviceAssignForm form = new AreaDeviceAssignForm();\r\n        form.setAreaId(1L);\r\n        form.setDeviceIds(Arrays.asList(10L, 11L, 12L));\r\n\r\n        when(accessAreaDao.selectById(1L)).thenReturn(new AccessAreaEntity());\r\n        when(smartDeviceService.getById(10L)).thenReturn(new SmartDeviceEntity());\r\n        when(smartDeviceService.getById(11L)).thenReturn(new SmartDeviceEntity());\r\n        when(smartDeviceService.getById(12L)).thenReturn(new SmartDeviceEntity());\r\n\r\n        // When\r\n        ResponseDTO<Void> result = accessAreaService.assignDevice(form);\r\n\r\n        // Then\r\n        assertThat(result.isSuccess()).isTrue();\r\n        verify(smartDeviceService, times(3)).updateById(any(SmartDeviceEntity.class));\r\n        verify(accessAreaManager).clearDeviceCache();\r\n    }\r\n}\r\n```\r\n\r\n### 集成测试策略\r\n\r\n**测试重点**: 数据库事务、缓存一致性、外部服务集成\r\n\r\n**测试场景**:\r\n```java\r\n@SpringBootTest\r\n@TestPropertySource(locations = \"classpath:application-test.yml\")\r\n@Transactional\r\nclass AccessAreaServiceIntegrationTest {\r\n\r\n    @Autowired\r\n    private AccessAreaService accessAreaService;\r\n\r\n    @Autowired\r\n    private AccessAreaDao accessAreaDao;\r\n\r\n    @Test\r\n    @DisplayName(\"区域CRUD完整流程测试\")\r\n    void testAreaCRUD_CompleteFlow() {\r\n        // 1. 创建区域\r\n        AccessAreaCreateForm createForm = new AccessAreaCreateForm();\r\n        createForm.setAreaName(\"集成测试区域\");\r\n        createForm.setParentId(null);\r\n        createForm.setAccessLevel(3);\r\n\r\n        ResponseDTO<Long> createResult = accessAreaService.createArea(createForm);\r\n        assertThat(createResult.isSuccess()).isTrue();\r\n        Long areaId = createResult.getData();\r\n\r\n        // 2. 查询区域\r\n        AccessAreaEntity area = accessAreaDao.selectById(areaId);\r\n        assertThat(area).isNotNull();\r\n        assertThat(area.getAreaName()).isEqualTo(\"集成测试区域\");\r\n        assertThat(area.getAreaCode()).isNotNull();\r\n\r\n        // 3. 更新区域\r\n        AccessAreaUpdateForm updateForm = new AccessAreaUpdateForm();\r\n        updateForm.setAreaId(areaId);\r\n        updateForm.setAreaName(\"更新后区域\");\r\n        updateForm.setVersion(area.getVersion());\r\n\r\n        ResponseDTO<Void> updateResult = accessAreaService.updateArea(updateForm);\r\n        assertThat(updateResult.isSuccess()).isTrue();\r\n\r\n        // 4. 验证更新结果\r\n        AccessAreaEntity updatedArea = accessAreaDao.selectById(areaId);\r\n        assertThat(updatedArea.getAreaName()).isEqualTo(\"更新后区域\");\r\n\r\n        // 5. 删除区域\r\n        ResponseDTO<Void> deleteResult = accessAreaService.deleteArea(areaId);\r\n        assertThat(deleteResult.isSuccess()).isTrue();\r\n\r\n        // 6. 验证软删除结果\r\n        AccessAreaEntity deletedArea = accessAreaDao.selectById(areaId);\r\n        assertThat(deletedArea).isNotNull();\r\n        assertThat(deletedArea.getDeletedFlag()).isEqualTo(DeletedFlagEnum.DELETED);\r\n    }\r\n\r\n    @Test\r\n    @DisplayName(\"并发创建区域测试\")\r\n    void testCreateArea_ConcurrentCreation() throws InterruptedException {\r\n        int threadCount = 10;\r\n        CountDownLatch latch = new CountDownLatch(threadCount);\r\n        List<Future<Long>> futures = new ArrayList<>();\r\n        ExecutorService executor = Executors.newFixedThreadPool(threadCount);\r\n\r\n        // 并发创建相同名称的区域\r\n        for (int i = 0; i < threadCount; i++) {\r\n            futures.add(executor.submit(() -> {\r\n                try {\r\n                    AccessAreaCreateForm form = new AccessAreaCreateForm();\r\n                    form.setAreaName(\"并发测试区域\");\r\n                    form.setParentId(null);\r\n\r\n                    ResponseDTO<Long> result = accessAreaService.createArea(form);\r\n                    return result.isSuccess() ? result.getData() : null;\r\n                } finally {\r\n                    latch.countDown();\r\n                }\r\n            }));\r\n        }\r\n\r\n        latch.await(30, TimeUnit.SECONDS);\r\n\r\n        // 只有一个应该成功\r\n        long successCount = futures.stream()\r\n            .mapToLong(future -> {\r\n                try {\r\n                    return future.get() != null ? 1 : 0;\r\n                } catch (Exception e) {\r\n                    return 0;\r\n                }\r\n            })\r\n            .sum();\r\n\r\n        assertThat(successCount).isEqualTo(1);\r\n\r\n        executor.shutdown();\r\n    }\r\n}\r\n```\r\n\r\n### 端到端测试策略\r\n\r\n**测试重点**: 完整业务流程、用户场景、系统集成\r\n\r\n**测试场景**:\r\n```java\r\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\r\n@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)\r\nclass AccessControlE2ETest {\r\n\r\n    @Autowired\r\n    private TestRestTemplate restTemplate;\r\n\r\n    @LocalServerPort\r\n    private int port;\r\n\r\n    @Test\r\n    @DisplayName(\"完整门禁验证流程\")\r\n    void testCompleteAccessControlFlow() {\r\n        String baseUrl = \"http://localhost:\" + port;\r\n\r\n        // 1. 用户登录\r\n        LoginRequest loginRequest = new LoginRequest();\r\n        loginRequest.setLoginName(\"admin\");\r\n        loginRequest.setPassword(\"123456\");\r\n\r\n        ResponseEntity<LoginResponse> loginResponse = restTemplate.postForEntity(\r\n            baseUrl + \"/api/auth/login\", loginRequest, LoginResponse.class);\r\n\r\n        assertThat(loginResponse.getStatusCode()).isEqualTo(HttpStatus.OK);\r\n        assertThat(loginResponse.getBody().getToken()).isNotNull();\r\n\r\n        String token = loginResponse.getBody().getToken();\r\n\r\n        // 2. 创建区域\r\n        AccessAreaCreateForm areaForm = new AccessAreaCreateForm();\r\n        areaForm.setAreaName(\"主楼大厅\");\r\n        areaForm.setAccessLevel(2);\r\n\r\n        HttpHeaders headers = new HttpHeaders();\r\n        headers.setBearerAuth(token);\r\n        HttpEntity<AccessAreaCreateForm> areaRequest = new HttpEntity<>(areaForm, headers);\r\n\r\n        ResponseEntity<ResponseDTO> areaResponse = restTemplate.postForEntity(\r\n            baseUrl + \"/api/smart/access/area/create\", areaRequest, ResponseDTO.class);\r\n\r\n        assertThat(areaResponse.getStatusCode()).isEqualTo(HttpStatus.OK);\r\n        assertThat(areaResponse.getBody().isSuccess()).isTrue();\r\n\r\n        Long areaId = (Long) areaResponse.getBody().getData();\r\n\r\n        // 3. 添加设备\r\n        AccessDeviceAddForm deviceForm = new AccessDeviceAddForm();\r\n        deviceForm.setDeviceName(\"主门禁设备\");\r\n        deviceForm.setDeviceCode(\"DEV001\");\r\n        deviceForm.setDeviceIp(\"192.168.1.100\");\r\n        deviceForm.setDevicePort(8080);\r\n        deviceForm.setAreaId(areaId);\r\n\r\n        HttpEntity<AccessDeviceAddForm> deviceRequest = new HttpEntity<>(deviceForm, headers);\r\n\r\n        ResponseEntity<ResponseDTO> deviceResponse = restTemplate.postForEntity(\r\n            baseUrl + \"/api/smart/access/device/add\", deviceRequest, ResponseDTO.class);\r\n\r\n        assertThat(deviceResponse.getStatusCode()).isEqualTo(HttpStatus.OK);\r\n        assertThat(deviceResponse.getBody().isSuccess()).isTrue();\r\n\r\n        Long deviceId = (Long) deviceResponse.getBody().getData();\r\n\r\n        // 4. 远程开门测试\r\n        DeviceControlForm controlForm = new DeviceControlForm();\r\n        controlForm.setDeviceId(deviceId);\r\n        controlForm.setOpenDuration(5);\r\n\r\n        HttpEntity<DeviceControlForm> controlRequest = new HttpEntity<>(controlForm, headers);\r\n\r\n        ResponseEntity<ResponseDTO> controlResponse = restTemplate.postForEntity(\r\n            baseUrl + \"/api/smart/access/device/control/open\", controlRequest, ResponseDTO.class);\r\n\r\n        assertThat(controlResponse.getStatusCode()).isEqualTo(HttpStatus.OK);\r\n\r\n        // 5. 验证通行记录\r\n        AccessEventQuery eventQuery = new AccessEventQuery();\r\n        eventQuery.setDeviceId(deviceId);\r\n\r\n        String queryUrl = baseUrl + \"/api/smart/access/monitor/events/page?\" +\r\n            \"deviceId=\" + deviceId + \"&pageNum=1&pageSize=10\";\r\n\r\n        ResponseEntity<ResponseDTO> eventResponse = restTemplate.getForEntity(\r\n            queryUrl, ResponseDTO.class, headers);\r\n\r\n        assertThat(eventResponse.getStatusCode()).isEqualTo(HttpStatus.OK);\r\n        assertThat(eventResponse.getBody().isSuccess()).isTrue();\r\n    }\r\n}\r\n```\r\n\r\n### 性能测试策略\r\n\r\n**测试目标**:\r\n- API响应时间 < 200ms (95%的请求)\r\n- 并发用户数 1000+\r\n- 系统资源使用率 < 70%\r\n\r\n**测试工具**: JMeter + Gatling\r\n\r\n**测试场景**:\r\n```java\r\n// JMeter测试计划示例\r\npublic class AccessControlPerformanceTest {\r\n\r\n    @Test\r\n    @DisplayName(\"区域管理接口性能测试\")\r\n    void testAreaManagementPerformance() {\r\n        // 测试创建区域接口性能\r\n        TestPlan createAreaPlan = new TestPlan();\r\n        createAreaPlan.addThreadGroup(50, 100, 10) // 50线程，100并发，10秒 Ramp-up\r\n            .addSampler(HttpSampler.class)\r\n                .setDomain(\"localhost\")\r\n                .setPort(8080)\r\n                .setPath(\"/api/smart/access/area/create\")\r\n                .setMethod(\"POST\")\r\n                .addArgument(\"areaName\", \"性能测试区域\")\r\n                .addArgument(\"accessLevel\", \"3\")\r\n            .addAssertion(DurationAssertion.class, 200); // 响应时间小于200ms\r\n\r\n        // 测试区域树查询接口性能\r\n        TestPlan treeQueryPlan = new TestPlan();\r\n        treeQueryPlan.addThreadGroup(100, 200, 5)\r\n            .addSampler(HttpSampler.class)\r\n                .setDomain(\"localhost\")\r\n                .setPort(8080)\r\n                .setPath(\"/api/smart/access/area/tree\")\r\n                .setMethod(\"GET\")\r\n            .addAssertion(DurationAssertion.class, 100); // 响应时间小于100ms\r\n\r\n        // 执行测试\r\n        JMeterEngine engine = new JMeterEngine();\r\n        TestResults results = engine.run(createAreaPlan, treeQueryPlan);\r\n\r\n        // 验证性能指标\r\n        assertThat(results.getAverageResponseTime()).isLessThan(200);\r\n        assertThat(results.getErrorRate()).isLessThan(0.01); // 错误率小于1%\r\n        assertThat(results.getThroughput()).isGreaterThan(100); // 吞吐量大于100 TPS\r\n    }\r\n}\r\n```\r\n\r\n## 安全设计\r\n\r\n### 数据安全\r\n\r\n**敏感数据加密**:\r\n```java\r\n@Component\r\npublic class SensitiveDataEncryption {\r\n\r\n    private final AESUtil aesUtil;\r\n\r\n    /**\r\n     * 加密生物特征数据\r\n     */\r\n    public String encryptBiometricData(String rawData) {\r\n        return aesUtil.encrypt(rawData, getBiometricEncryptionKey());\r\n    }\r\n\r\n    /**\r\n     * 解密生物特征数据\r\n     */\r\n    public String decryptBiometricData(String encryptedData) {\r\n        return aesUtil.decrypt(encryptedData, getBiometricEncryptionKey());\r\n    }\r\n\r\n    /**\r\n     * 获取生物特征加密密钥\r\n     */\r\n    private String getBiometricEncryptionKey() {\r\n        // 使用硬件安全模块或密钥管理服务\r\n        return keyManagementService.getEncryptionKey(\"BIOMETRIC\");\r\n    }\r\n}\r\n```\r\n\r\n**数据脱敏**:\r\n```java\r\n@Component\r\npublic class AccessEventDataMasking {\r\n\r\n    /**\r\n     * 脱敏处理用户姓名\r\n     */\r\n    public String maskUserName(String userName) {\r\n        if (StringUtils.isBlank(userName) || userName.length() <= 2) {\r\n            return \"*\";\r\n        }\r\n        return userName.charAt(0) + \"***\" + userName.charAt(userName.length() - 1);\r\n    }\r\n\r\n    /**\r\n     * 脱敏处理身份证号\r\n     */\r\n    public String maskIdCard(String idCard) {\r\n        if (StringUtils.isBlank(idCard) || idCard.length() != 18) {\r\n            return \"***\";\r\n        }\r\n        return idCard.substring(0, 6) + \"********\" + idCard.substring(14);\r\n    }\r\n}\r\n```\r\n\r\n### 访问控制\r\n\r\n**细粒度权限控制**:\r\n```java\r\n@Component\r\npublic class AccessControlService {\r\n\r\n    /**\r\n     * 检查用户区域访问权限\r\n     */\r\n    public boolean checkAreaAccessPermission(Long userId, Long areaId) {\r\n        // 1. 获取用户角色\r\n        List<Long> userRoleIds = userRoleService.getUserRoleIds(userId);\r\n\r\n        // 2. 检查直接区域权限\r\n        for (Long roleId : userRoleIds) {\r\n            if (roleAreaService.hasAreaPermission(roleId, areaId)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        // 3. 检查父区域权限继承\r\n        AccessAreaEntity area = accessAreaService.getById(areaId);\r\n        while (area != null && area.getParentId() != null) {\r\n            for (Long roleId : userRoleIds) {\r\n                if (roleAreaService.hasAreaPermission(roleId, area.getParentId())) {\r\n                    return true;\r\n                }\r\n            }\r\n            area = accessAreaService.getById(area.getParentId());\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * 检查时间段访问权限\r\n     */\r\n    public boolean checkTimeAccessPermission(Long userId, LocalDateTime accessTime) {\r\n        // 1. 获取用户时间段权限\r\n        List<UserTimePermission> timePermissions = userTimePermissionService\r\n            .getUserTimePermissions(userId);\r\n\r\n        // 2. 检查当前时间是否在允许的时间段内\r\n        DayOfWeek dayOfWeek = accessTime.getDayOfWeek();\r\n        int hour = accessTime.getHour();\r\n\r\n        for (UserTimePermission permission : timePermissions) {\r\n            if (permission.getDayOfWeek().equals(dayOfWeek.name()) &&\r\n                hour >= permission.getStartHour() &&\r\n                hour <= permission.getEndHour()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\n### 审计日志\r\n\r\n**操作日志记录**:\r\n```java\r\n@Aspect\r\n@Component\r\n@Slf4j\r\npublic class AccessControlAuditAspect {\r\n\r\n    @Around(\"@annotation(operationLog)\")\r\n    public Object logOperation(ProceedingJoinPoint joinPoint, OperationLog operationLog) throws Throwable {\r\n        // 1. 获取操作信息\r\n        String operationType = operationLog.operationType();\r\n        String operationContent = operationLog.operationContent();\r\n        String methodName = joinPoint.getSignature().getName();\r\n        Object[] args = joinPoint.getArgs();\r\n\r\n        // 2. 记录操作开始\r\n        log.info(\"开始执行操作: type={}, content={}, method={}, args={}\",\r\n            operationType, operationContent, methodName, Arrays.toString(args));\r\n\r\n        try {\r\n            // 3. 执行目标方法\r\n            long startTime = System.currentTimeMillis();\r\n            Object result = joinPoint.proceed();\r\n            long endTime = System.currentTimeMillis();\r\n\r\n            // 4. 记录操作成功日志\r\n            log.info(\"操作执行成功: type={}, content={}, duration={}ms\",\r\n                operationType, operationContent, endTime - startTime);\r\n\r\n            // 5. 保存审计日志\r\n            saveAuditLog(operationType, operationContent, methodName, args,\r\n                AuditResultEnum.SUCCESS, endTime - startTime);\r\n\r\n            return result;\r\n\r\n        } catch (Exception e) {\r\n            // 6. 记录操作失败日志\r\n            log.error(\"操作执行失败: type={}, content={}, error={}\",\r\n                operationType, operationContent, e.getMessage(), e);\r\n\r\n            // 7. 保存审计日志\r\n            saveAuditLog(operationType, operationContent, methodName, args,\r\n                AuditResultEnum.FAILED, 0, e.getMessage());\r\n\r\n            throw e;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n本设计文档详细定义了门禁系统的技术实现方案，严格遵循repowiki开发规范，确保代码质量、系统性能和安全性。通过模块化设计、完善的错误处理策略和全面的测试策略，为后续的精准开发提供详细指导。",
  "fileStats": {
    "size": 57109,
    "lines": 1792,
    "lastModified": "2025-11-16T08:41:48.583Z"
  },
  "comments": []
}