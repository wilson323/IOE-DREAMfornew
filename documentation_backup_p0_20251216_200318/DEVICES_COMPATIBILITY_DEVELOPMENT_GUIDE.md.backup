# IOE-DREAM æ™ºæ…§å›­åŒºä¸€å¡é€šç®¡ç†å¹³å° - è®¾å¤‡å…¼å®¹å¼€å‘æŒ‡å—

> **ç‰ˆæœ¬**: v1.0.0
> **åˆ›å»ºæ—¶é—´**: 2025-12-16
> **é€‚ç”¨èŒƒå›´**: é—¨ç¦ã€è€ƒå‹¤ã€æ¶ˆè´¹ã€è®¿å®¢ã€è§†é¢‘ç›‘æ§ç­‰ä¸šåŠ¡æ¨¡å—
> **æ ¸å¿ƒç›®æ ‡**: ç»Ÿä¸€è®¾å¤‡æ¥å…¥è§„èŒƒï¼Œå®ç°å¤šå‚å•†è®¾å¤‡æ— ç¼å…¼å®¹

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

### æ ¸å¿ƒç›®æ ‡

ä¸ºå¼€å‘å›¢é˜Ÿæä¾›å®Œæ•´çš„è®¾å¤‡å…¼å®¹å¼€å‘æŒ‡å¯¼ï¼Œç¡®ä¿å„ä¸ªä¸šåŠ¡æ¨¡å—èƒ½å¤Ÿï¼š
1. **ç»Ÿä¸€è®¾å¤‡æ¥å…¥**ï¼šé‡‡ç”¨ç»Ÿä¸€çš„åè®®é€‚é…å™¨æ¶æ„
2. **å‚å•†æ— å…³**ï¼šä¸šåŠ¡é€»è¾‘ä¸å…·ä½“å‚å•†è®¾å¤‡è§£è€¦
3. **å¿«é€Ÿæ¥å…¥**ï¼šæ–°å‚å•†è®¾å¤‡æ¥å…¥æ ‡å‡†åŒ–ã€æµç¨‹åŒ–
4. **ç¨³å®šè¿è¡Œ**ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†å’Œç›‘æ§æœºåˆ¶

### é€‚ç”¨èŒƒå›´

æœ¬æ–‡æ¡£é€‚ç”¨äºä»¥ä¸‹ä¸šåŠ¡æ¨¡å—çš„å¼€å‘ï¼š
- **é—¨ç¦ç®¡ç†**ï¼šæ”¯æŒç†µåŸºç§‘æŠ€ã€ä¸­æ§æ™ºæ…§ç­‰é—¨ç¦è®¾å¤‡
- **è€ƒå‹¤ç®¡ç†**ï¼šæ”¯æŒå¤šç§è€ƒå‹¤è®¾å¤‡å’Œè¯†åˆ«æ–¹å¼
- **æ¶ˆè´¹ç®¡ç†**ï¼šæ”¯æŒPOSæœºã€è‡ªåŠ©æ¶ˆè´¹æœºç­‰è®¾å¤‡
- **è®¿å®¢ç®¡ç†**ï¼šæ”¯æŒè®¿å®¢æœºã€äººè„¸è¯†åˆ«ç»ˆç«¯ç­‰è®¾å¤‡
- **è§†é¢‘ç›‘æ§**ï¼šæ”¯æŒå„å‚å•†æ‘„åƒå¤´å’ŒNVRè®¾å¤‡
- **è®¾å¤‡é€šè®¯**ï¼šç»Ÿä¸€çš„è®¾å¤‡é€šè®¯åè®®ç®¡ç†

## ğŸ—ï¸ æ¶æ„è®¾è®¡æ¦‚è§ˆ

### æ ¸å¿ƒæ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    IOE-DREAM ä¸šåŠ¡æœåŠ¡å±‚                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ é—¨ç¦æœåŠ¡     â”‚ â”‚ è€ƒå‹¤æœåŠ¡     â”‚ â”‚ æ¶ˆè´¹æœåŠ¡     â”‚ â”‚ è®¿å®¢æœåŠ¡     â”‚   â”‚
â”‚  â”‚ Access     â”‚ â”‚ Attendance â”‚ â”‚ Consume     â”‚ â”‚ Visitor     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    è®¾å¤‡é€šè®¯å¾®æœåŠ¡                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚           ProtocolAdapterFactory                          â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚   â”‚
â”‚  â”‚  â”‚ é—¨ç¦åè®®é€‚é… â”‚ â”‚ æ¶ˆè´¹åè®®é€‚é… â”‚ â”‚ è€ƒå‹¤åè®®é€‚é… â”‚  ...      â”‚   â”‚
â”‚  â”‚  â”‚ å™¨é›†åˆ      â”‚ â”‚ å™¨é›†åˆ      â”‚ â”‚ å™¨é›†åˆ      â”‚          â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                        ç‰©ç†è®¾å¤‡å±‚                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ç†µåŸºè®¾å¤‡     â”‚ â”‚ ä¸­æ§è®¾å¤‡     â”‚ â”‚ æµ·åº·è®¾å¤‡     â”‚ â”‚ å¤§åè®¾å¤‡     â”‚   â”‚
â”‚  â”‚ Access     â”‚ â”‚ Consume     â”‚ â”‚ Video      â”‚ â”‚ Security   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æŠ€æœ¯æ ˆ

| ç»„ä»¶ | æŠ€æœ¯é€‰å‹ | è¯´æ˜ |
|------|----------|------|
| å¾®æœåŠ¡æ¡†æ¶ | Spring Boot 3.5.8 | ä¸»ä¸šåŠ¡æœåŠ¡æ¡†æ¶ |
| åè®®é€‚é…å™¨ | Java Interface + Factory Pattern | ç»Ÿä¸€åè®®å¤„ç†æ¶æ„ |
| æ•°æ®å­˜å‚¨ | MySQL 8.0 + MyBatis-Plus | åè®®æ¶ˆæ¯å’Œè®¾å¤‡ä¿¡æ¯å­˜å‚¨ |
| ç¼“å­˜ | Redis | è®¾å¤‡æ˜ å°„å’Œæ€§èƒ½ä¼˜åŒ– |
| APIç½‘å…³ | Spring Cloud Gateway | ç»Ÿä¸€æœåŠ¡å…¥å£å’Œè·¯ç”± |
| é…ç½®ç®¡ç† | Nacos | åŠ¨æ€é…ç½®å’Œåè®®æ³¨å†Œ |

## ğŸ”Œ è®¾å¤‡é€šè®¯åè®®æ¶æ„

### æ ¸å¿ƒæ¥å£è®¾è®¡

```java
/**
 * è®¾å¤‡åè®®é€‚é…å™¨ç»Ÿä¸€æ¥å£
 * æ‰€æœ‰å‚å•†åè®®é€‚é…å™¨å¿…é¡»å®ç°æ­¤æ¥å£
 */
public interface ProtocolAdapter {

    // ==================== åè®®æ ‡è¯†æ¥å£ ====================

    /**
     * è·å–åè®®ç±»å‹æ ‡è¯†
     * æ ¼å¼ï¼š{å‚å•†}_{è®¾å¤‡ç±»å‹}_{ç‰ˆæœ¬å·}
     * ç¤ºä¾‹ï¼šACCESS_ENTROPY_V4_8, CONSUME_ZKTECO_V1_0
     */
    String getProtocolType();

    /**
     * è·å–è®¾å¤‡å‚å•†
     */
    String getManufacturer();

    /**
     * è·å–åè®®ç‰ˆæœ¬
     */
    String getVersion();

    /**
     * è·å–æ”¯æŒçš„è®¾å¤‡å‹å·åˆ—è¡¨
     */
    String[] getSupportedDeviceModels();

    /**
     * æ£€æŸ¥æ˜¯å¦æ”¯æŒæŒ‡å®šè®¾å¤‡å‹å·
     */
    boolean isDeviceModelSupported(String deviceModel);

    // ==================== æ¶ˆæ¯å¤„ç†æ ¸å¿ƒæ¥å£ ====================

    /**
     * è§£æè®¾å¤‡æ¶ˆæ¯
     * @param rawData è®¾å¤‡åŸå§‹æ•°æ®ï¼ˆå­—èŠ‚æ•°ç»„ï¼‰
     * @param deviceId è®¾å¤‡ID
     * @return è§£æåçš„åè®®æ¶ˆæ¯å¯¹è±¡
     * @throws ProtocolParseException åè®®è§£æå¼‚å¸¸
     */
    ProtocolMessage parseDeviceMessage(byte[] rawData, Long deviceId) throws ProtocolParseException;

    /**
     * æ„å»ºè®¾å¤‡å“åº”æ¶ˆæ¯
     * @param messageType æ¶ˆæ¯ç±»å‹
     * @param businessData ä¸šåŠ¡æ•°æ®Map
     * @param deviceId è®¾å¤‡ID
     * @return è®¾å¤‡å“åº”æ¶ˆæ¯ï¼ˆå­—èŠ‚æ•°ç»„ï¼‰
     * @throws ProtocolBuildException åè®®æ„å»ºå¼‚å¸¸
     */
    byte[] buildDeviceResponse(String messageType, Map<String, Object> businessData, Long deviceId) throws ProtocolBuildException;

    // ==================== ä¸šåŠ¡æ•°æ®å¤„ç†æ¥å£ ====================

    /**
     * å¤„ç†é—¨ç¦ä¸šåŠ¡æ•°æ®
     */
    Future<ProtocolProcessResult> processAccessBusiness(String businessType, Map<String, Object> businessData, Long deviceId);

    /**
     * å¤„ç†æ¶ˆè´¹ä¸šåŠ¡æ•°æ®
     */
    Future<ProtocolProcessResult> processConsumeBusiness(String businessType, Map<String, Object> businessData, Long deviceId);

    /**
     * å¤„ç†è€ƒå‹¤ä¸šåŠ¡æ•°æ®
     */
    Future<ProtocolProcessResult> processAttendanceBusiness(String businessType, Map<String, Object> businessData, Long deviceId);

    // ==================== è®¾å¤‡ç®¡ç†æ¥å£ ====================

    /**
     * åˆå§‹åŒ–è®¾å¤‡è¿æ¥
     */
    Future<ProtocolInitResult> initializeDevice(Map<String, Object> deviceInfo, Map<String, Object> config);

    /**
     * è·å–è®¾å¤‡çŠ¶æ€
     */
    ProtocolDeviceStatus getDeviceStatus(Long deviceId);

    // ==================== ç»„ä»¶ç”Ÿå‘½å‘¨æœŸæ¥å£ ====================

    /**
     * åˆå§‹åŒ–åè®®é€‚é…å™¨
     */
    void initialize();

    /**
     * é”€æ¯åè®®é€‚é…å™¨
     */
    void destroy();

    /**
     * è·å–é€‚é…å™¨çŠ¶æ€
     */
    String getAdapterStatus();
}
```

### åè®®é€‚é…å™¨å·¥å‚

```java
/**
 * åè®®é€‚é…å™¨å·¥å‚
 * è´Ÿè´£æ‰€æœ‰åè®®é€‚é…å™¨çš„æ³¨å†Œã€æŸ¥æ‰¾å’Œç®¡ç†
 */
@Component
public class ProtocolAdapterFactory {

    // åè®®é€‚é…å™¨æ³¨å†Œè¡¨
    private final Map<String, ProtocolAdapter> adapterRegistry = new ConcurrentHashMap<>();

    // è®¾å¤‡å‹å·åˆ°åè®®ç±»å‹çš„æ˜ å°„
    private final Map<String, String> deviceModelToProtocolMap = new ConcurrentHashMap<>();

    /**
     * æ³¨å†Œåè®®é€‚é…å™¨
     */
    public void registerAdapter(ProtocolAdapter adapter) {
        String protocolType = adapter.getProtocolType();
        adapterRegistry.put(protocolType, adapter);

        // æ³¨å†Œè®¾å¤‡å‹å·æ˜ å°„
        for (String model : adapter.getSupportedDeviceModels()) {
            deviceModelToProtocolMap.put(model.toUpperCase(), protocolType);
        }
    }

    /**
     * æ ¹æ®è®¾å¤‡å‹å·è·å–é€‚é…å™¨
     */
    public ProtocolAdapter getAdapterByDeviceModel(String deviceModel) {
        String protocolType = deviceModelToProtocolMap.get(deviceModel.toUpperCase());
        return protocolType != null ? adapterRegistry.get(protocolType) : null;
    }

    /**
     * è·å–æ‰€æœ‰æ”¯æŒçš„è®¾å¤‡å‹å·
     */
    public List<String> getSupportedDeviceModels() {
        return new ArrayList<>(deviceModelToProtocolMap.keySet());
    }
}
```

## ğŸšª é—¨ç¦ç®¡ç†æ¨¡å—è®¾å¤‡å…¼å®¹æŒ‡å—

### æ”¯æŒçš„å‚å•†å’Œè®¾å¤‡

| å‚å•† | åè®®ç±»å‹ | æ”¯æŒè®¾å¤‡å‹å· | åŠŸèƒ½ç‰¹æ€§ |
|------|----------|--------------|----------|
| ç†µåŸºç§‘æŠ€ | ACCESS_ENTROPY_V4_8 | MA300, MA300T, SC405, SC700, SC705, F18, TA800C, TA800T, WK2600 | äººè„¸è¯†åˆ«ã€æŒ‡çº¹è¯†åˆ«ã€åˆ·å¡ã€äºŒç»´ç ã€æ´»ä½“æ£€æµ‹ |
| ä¸­æ§æ™ºæ…§ | ACCESS_ZKTECO_V2_0 | SC405, SC700, SC810, INPOS | å¤šæ¨¡æ€è¯†åˆ«ã€åæ½œå›ã€èƒè¿«æŠ¥è­¦ã€å°¾éšæ£€æµ‹ |
| æµ·åº·å¨è§† | ACCESS_HIKVISION_V1_5 | DS-K2801, DS-K2802, DS-K2803 | äººè„¸è¯†åˆ«ã€é—¨ç£è”åŠ¨ã€è§†é¢‘ç›‘æ§ã€æŠ¥è­¦æ¨é€ |
| å¤§åæŠ€æœ¯ | ACCESS_DAHUA_V2_0 | ASC1204C, ASC2204C, ASC3204C | ç”Ÿç‰©è¯†åˆ«ã€é—¨ç¦æ§åˆ¶ã€è®¿å®¢ç®¡ç†ã€ç§»åŠ¨å¼€é—¨ |

### é—¨ç¦è®¾å¤‡æ¥å…¥å¼€å‘æµç¨‹

#### 1. åˆ›å»ºåè®®é€‚é…å™¨

```java
@Component
public class HikvisionAccessAdapter implements ProtocolAdapter {

    @Override
    public String getProtocolType() {
        return "ACCESS_HIKVISION_V1_5";
    }

    @Override
    public String getManufacturer() {
        return "æµ·åº·å¨è§†";
    }

    @Override
    public String[] getSupportedDeviceModels() {
        return new String[]{"DS-K2801", "DS-K2802", "DS-K2803"};
    }

    @Override
    public ProtocolMessage parseDeviceMessage(byte[] rawData, Long deviceId) throws ProtocolParseException {
        // è§£ææµ·åº·å¨è§†é—¨ç¦åè®®
        HikvisionAccessMessage message = new HikvisionAccessMessage();

        // 1. è§£æåè®®å¤´ï¼ˆæµ·åº·å¨è§†åè®®æ ¼å¼ï¼‰
        ByteBuffer buffer = ByteBuffer.wrap(rawData).order(ByteOrder.BIG_ENDIAN);
        buffer.getShort(); // åè®®æ ‡è¯†
        short dataLength = buffer.getShort();
        byte[] dataBytes = new byte[dataLength];
        buffer.get(dataBytes);

        // 2. è§£æJSONæ ¼å¼çš„ä¸šåŠ¡æ•°æ®
        JSONObject jsonData = JSON.parseObject(new String(dataBytes, StandardCharsets.UTF_8));
        message.setDeviceId(jsonData.getString("DeviceID"));
        message.setEventType(jsonData.getString("EventType"));
        message.setCardNo(jsonData.getString("CardNo"));
        message.setVerifyResult(jsonData.getString("VerifyResult"));

        return message;
    }

    @Override
    public Future<ProtocolProcessResult> processAccessBusiness(String businessType, Map<String, Object> businessData, Long deviceId) {
        switch (businessType) {
            case "REAL_TIME_EVENT":
                return processAccessEvent(businessData, deviceId);
            case "ALARM_EVENT":
                return processAlarmEvent(businessData, deviceId);
            case "VIDEO_VERIFY":
                return processVideoVerification(businessData, deviceId);
            default:
                return CompletableFuture.completedFuture(
                    new ProtocolProcessResult(false, "ä¸æ”¯æŒçš„ä¸šåŠ¡ç±»å‹: " + businessType)
                );
        }
    }

    private Future<ProtocolProcessResult> processVideoVerification(Map<String, Object> businessData, Long deviceId) {
        // æµ·åº·å¨è§†ç‰¹è‰²åŠŸèƒ½ï¼šè§†é¢‘è”åŠ¨éªŒè¯
        CompletableFuture<ProtocolProcessResult> future = new CompletableFuture<>();

        // 1. è·å–äººè„¸å›¾åƒæ•°æ®
        String faceImage = (String) businessData.get("faceImage");

        // 2. è°ƒç”¨äººè„¸è¯†åˆ«æœåŠ¡
        faceRecognitionService.verifyFace(faceImage)
            .thenAccept(recognizeResult -> {
                // 3. å¤„ç†è¯†åˆ«ç»“æœ
                if (recognizeResult.isSuccess()) {
                    // å¼€é—¨æŒ‡ä»¤
                    sendOpenDoorCommand(deviceId, "è§†é¢‘éªŒè¯é€šè¿‡");
                    future.complete(new ProtocolProcessResult(true, "è§†é¢‘éªŒè¯æˆåŠŸ"));
                } else {
                    // æ‹’ç»å¼€é—¨ï¼Œè®°å½•æ—¥å¿—
                    future.complete(new ProtocolProcessResult(false, "è§†é¢‘éªŒè¯å¤±è´¥"));
                }
            })
            .exceptionally(throwable -> {
                future.complete(new ProtocolProcessResult(false, "è§†é¢‘éªŒè¯å¼‚å¸¸: " + throwable.getMessage()));
            });

        return future;
    }
}
```

#### 2. åˆ›å»ºé—¨ç¦æ¶ˆæ¯å®ä½“

```java
package net.lab1024.sa.device.comm.protocol.hikvision;

@Data
public class HikvisionAccessMessage implements ProtocolMessage {

    // åè®®åŸºæœ¬ä¿¡æ¯
    private String protocolVersion = "V1.5";
    private String deviceModel;
    private String deviceIp;
    private String macAddress;

    // äº‹ä»¶ä¿¡æ¯
    private String eventType; // CardEvent, FaceEvent, AlarmEvent
    private String cardNo;
    private String userId;
    private String userName;
    private String verifyResult; // Success, Fail, Timeout

    // ç”Ÿç‰©è¯†åˆ«ä¿¡æ¯
    private String faceImage; // Base64ç¼–ç çš„äººè„¸å›¾åƒ
    private Float faceScore; // äººè„¸è¯†åˆ«åˆ†æ•°
    private String livenessResult; // Real, Photo, Video

    // é—¨æ§ä¿¡æ¯
    private String doorStatus; // Open, Close, ForceOpen
    private String lockStatus; // Lock, Unlock, Fault
    private String doorDirection; // In, Out, Unknown

    // æŠ¥è­¦ä¿¡æ¯
    private String alarmType; // DoorForced, DoorOpenTooLong, Tamper
    private String alarmLevel; // Low, Medium, High, Critical
    private LocalDateTime alarmTime;

    // å¤„ç†ä¿¡æ¯
    private LocalDateTime receiveTime;
    private LocalDateTime processTime;
    private String processResult;
    private String errorMessage;
}
```

#### 3. é—¨ç¦æœåŠ¡é›†æˆ

```java
@Service
public class AccessServiceImpl implements AccessService {

    @Resource
    private GatewayServiceClient gatewayServiceClient;

    @Resource
    private FaceRecognitionService faceRecognitionService;

    @Resource
    private VideoSurveillanceService videoSurveillanceService;

    /**
     * å¤„ç†é—¨ç¦äº‹ä»¶ï¼ˆå‚å•†æ— å…³ï¼‰
     */
    @Override
    public ResponseDTO<AccessResultVO> processAccessEvent(AccessEventForm eventForm) {
        try {
            // 1. æ ¹æ®è®¾å¤‡ä¿¡æ¯è·å–åè®®é€‚é…å™¨
            ProtocolAdapter adapter = getProtocolAdapterByDevice(eventForm.getDeviceId());

            // 2. æ„å»ºä¸šåŠ¡æ•°æ®
            Map<String, Object> businessData = new HashMap<>();
            businessData.put("eventType", eventForm.getEventType());
            businessData.put("cardNo", eventForm.getCardNo());
            businessData.put("verifyMethod", eventForm.getVerifyMethod());
            businessData.put("accessTime", eventForm.getAccessTime());

            // 3. è°ƒç”¨è®¾å¤‡é€šè®¯æœåŠ¡å¤„ç†ä¸šåŠ¡
            ResponseDTO<ProtocolProcessResult> result = gatewayServiceClient.callDeviceCommService(
                "/api/v1/device-comm/process-access",
                HttpMethod.POST,
                Map.of(
                    "protocolType", adapter.getProtocolType(),
                    "businessType", "REAL_TIME_EVENT",
                    "businessData", businessData,
                    "deviceId", eventForm.getDeviceId()
                ),
                ProtocolProcessResult.class
            );

            // 4. å¤„ç†ä¸šåŠ¡ç»“æœ
            if (result.getData().getSuccess()) {
                // ä¿å­˜é€šè¡Œè®°å½•
                saveAccessRecord(eventForm, result.getData());

                // è§†é¢‘è”åŠ¨ï¼ˆå¦‚æœè®¾å¤‡æ”¯æŒï¼‰
                if (adapter.getManufacturer().contains("æµ·åº·å¨è§†") ||
                    adapter.getManufacturer().contains("å¤§å")) {
                    triggerVideoLinkage(eventForm);
                }

                return ResponseDTO.ok(buildAccessResult(eventForm));
            } else {
                return ResponseDTO.error("ACCESS_FAILED", "é—¨ç¦å¤„ç†å¤±è´¥: " + result.getData().getProcessDetails());
            }

        } catch (Exception e) {
            log.error("é—¨ç¦äº‹ä»¶å¤„ç†å¼‚å¸¸", e);
            return ResponseDTO.error("SYSTEM_ERROR", "ç³»ç»Ÿå¼‚å¸¸: " + e.getMessage());
        }
    }

    /**
     * æ ¹æ®è®¾å¤‡è·å–åè®®é€‚é…å™¨
     */
    private ProtocolAdapter getProtocolAdapterByDevice(Long deviceId) {
        // 1. æŸ¥è¯¢è®¾å¤‡ä¿¡æ¯
        DeviceEntity device = deviceService.getById(deviceId);

        // 2. é€šè¿‡è®¾å¤‡å‹å·è·å–é€‚é…å™¨
        return protocolAdapterFactory.getAdapterByDeviceModel(device.getDeviceModel());
    }

    /**
     * è§†é¢‘è”åŠ¨å¤„ç†
     */
    private void triggerVideoLinkage(AccessEventForm eventForm) {
        // 1. è·å–å…³è”çš„æ‘„åƒå¤´
        List<CameraEntity> cameras = getLinkedCameras(eventForm.getAccessPointId());

        // 2. æŠ“æ‹é—¨ç¦äº‹ä»¶å›¾ç‰‡
        for (CameraEntity camera : cameras) {
            videoSurveillanceService.captureImage(camera.getCameraId(), eventForm.getEventId())
                .thenAccept(imageUrl -> {
                    // 3. ä¿å­˜å…³è”å›¾ç‰‡
                    saveAccessEventImage(eventForm.getEventId(), imageUrl);
                });
        }

        // 4. è§¦å‘å½•åƒ
        videoSurveillanceService.startRecording(cameras, "é—¨ç¦äº‹ä»¶å½•åƒ");
    }
}
```

## â° è€ƒå‹¤ç®¡ç†æ¨¡å—è®¾å¤‡å…¼å®¹æŒ‡å—

### æ”¯æŒçš„å‚å•†å’Œè®¾å¤‡

| å‚å•† | åè®®ç±»å‹ | æ”¯æŒè®¾å¤‡å‹å· | åŠŸèƒ½ç‰¹æ€§ |
|------|----------|--------------|----------|
| ç†µåŸºç§‘æŠ€ | ATTENDANCE_ENTROPY_V4_0 | MA300, MA300T, F18, TA800C | äººè„¸è€ƒå‹¤ã€æŒ‡çº¹è€ƒå‹¤ã€åˆ·å¡è€ƒå‹¤ã€æ´»ä½“æ£€æµ‹ |
| ä¸­æ§æ™ºæ…§ | ATTENDANCE_ZKTECO_V1_5 | SC405, SC700, SC810, U160 | å¤šæ¨¡æ€è€ƒå‹¤ã€ä½ç½®éªŒè¯ã€ç…§ç‰‡é‡‡é›† |
| ç§‘å¯† | ATTENDANCE_COMEY_V2_1 | CA-1000, CA-2000, CA-3000 | äººè„¸è¯†åˆ«ã€æŒ‡çº¹è¯†åˆ«ã€è™¹è†œè¯†åˆ« |
| æ±‰ç‹ | ATTENDANCE_HANVONG_V1_8 | ASI3202X, ASI4221X, ASI7202X | äººè„¸è€ƒå‹¤ã€æ´»ä½“æ£€æµ‹ã€é—¨ç¦è€ƒå‹¤è”åŠ¨ |

### è€ƒå‹¤è®¾å¤‡æ¥å…¥å¼€å‘æµç¨‹

#### 1. åˆ›å»ºè€ƒå‹¤åè®®é€‚é…å™¨

```java
@Component
public class ComeyAttendanceAdapter implements ProtocolAdapter {

    @Override
    public String getProtocolType() {
        return "ATTENDANCE_COMEY_V2_1";
    }

    @Override
    public String getManufacturer() {
        return "ç§‘å¯†";
    }

    @Override
    public String[] getSupportedDeviceModels() {
        return new String[]{"CA-1000", "CA-2000", "CA-3000"};
    }

    @Override
    public ProtocolMessage parseDeviceMessage(byte[] rawData, Long deviceId) throws ProtocolParseException {
        // è§£æç§‘å¯†è€ƒå‹¤åè®®
        ComeyAttendanceMessage message = new ComeyAttendanceMessage();

        // ç§‘å¯†åè®®ç‰¹ç‚¹ï¼šæ”¯æŒå¤šæ¨¡æ€ç”Ÿç‰©è¯†åˆ«
        ByteBuffer buffer = ByteBuffer.wrap(rawData).order(ByteOrder.LITTLE_ENDIAN);

        // 1. è§£æåè®®å¤´
        buffer.getShort(); // COMEYæ ‡è¯†
        short messageType = buffer.getShort();
        int dataLength = buffer.getInt();

        // 2. æ ¹æ®æ¶ˆæ¯ç±»å‹è§£æ
        switch (messageType) {
            case 0x01: // è€ƒå‹¤è®°å½•
                parseAttendanceRecord(buffer, message);
                break;
            case 0x02: // ç”Ÿç‰©ç‰¹å¾æ³¨å†Œ
                parseBiometricRegistration(buffer, message);
                break;
            case 0x03: // è®¾å¤‡çŠ¶æ€
                parseDeviceStatus(buffer, message);
                break;
        }

        return message;
    }

    @Override
    public Future<ProtocolProcessResult> processAttendanceBusiness(String businessType, Map<String, Object> businessData, Long deviceId) {
        switch (businessType) {
            case "ATTENDANCE_RECORD":
                return processAttendanceRecord(businessData, deviceId);
            case "BIOMETRIC_REGISTRATION":
                return processBiometricRegistration(businessData, deviceId);
            case "SCHEDULE_SYNC":
                return processScheduleSync(businessData, deviceId);
            case "LOCATION_VERIFY":
                return processLocationVerification(businessData, deviceId);
            default:
                return CompletableFuture.completedFuture(
                    new ProtocolProcessResult(false, "ä¸æ”¯æŒçš„è€ƒå‹¤ä¸šåŠ¡ç±»å‹: " + businessType)
                );
        }
    }

    private Future<ProtocolProcessResult> processBiometricRegistration(Map<String, Object> businessData, Long deviceId) {
        // ç§‘å¯†ç‰¹è‰²åŠŸèƒ½ï¼šè™¹è†œè¯†åˆ«æ³¨å†Œ
        CompletableFuture<ProtocolProcessResult> future = new CompletableFuture<>();

        try {
            // 1. è·å–ç”Ÿç‰©ç‰¹å¾æ•°æ®
            String irisImageData = (String) businessData.get("irisImage");
            String fingerprintData = (String) businessData.get("fingerprintData");
            String faceData = (String) businessData.get("faceData");

            // 2. å¤šæ¨¡æ€ç‰¹å¾æ³¨å†Œ
            List<BiometricFeature> features = new ArrayList<>();

            // è™¹è†œç‰¹å¾æ³¨å†Œ
            if (irisImageData != null) {
                irisRecognitionService.registerIris(deviceId, irisImageData)
                    .thenAccept(irisFeature -> features.add(irisFeature));
            }

            // æŒ‡çº¹ç‰¹å¾æ³¨å†Œ
            if (fingerprintData != null) {
                fingerprintService.registerFingerprint(deviceId, fingerprintData)
                    .thenAccept(fingerprintFeature -> features.add(fingerprintFeature));
            }

            // äººè„¸ç‰¹å¾æ³¨å†Œ
            if (faceData != null) {
                faceRecognitionService.registerFace(deviceId, faceData)
                    .thenAccept(faceFeature -> features.add(faceFeature));
            }

            // 3. å¤„ç†æ³¨å†Œç»“æœ
            CompletableFuture.allOf(features.toArray(new CompletableFuture[0]))
                .thenAccept(results -> {
                    // ä¿å­˜ç”Ÿç‰©ç‰¹å¾åˆ°æ•°æ®åº“
                    saveBiometricFeatures(deviceId, features);

                    // é€šçŸ¥æ³¨å†ŒæˆåŠŸ
                    future.complete(new ProtocolProcessResult(true, "å¤šæ¨¡æ€ç”Ÿç‰©ç‰¹å¾æ³¨å†ŒæˆåŠŸ"));
                })
                .exceptionally(throwable -> {
                    future.complete(new ProtocolProcessResult(false, "ç”Ÿç‰©ç‰¹å¾æ³¨å†Œå¤±è´¥: " + throwable.getMessage()));
                });

        } catch (Exception e) {
            future.complete(new ProtocolProcessResult(false, "ç”Ÿç‰©ç‰¹å¾æ³¨å†Œå¼‚å¸¸: " + e.getMessage()));
        }

        return future;
    }

    private Future<ProtocolProcessResult> processLocationVerification(Map<String, Object> businessData, Long deviceId) {
        // ç§‘å¯†ç‰¹è‰²åŠŸèƒ½ï¼šWi-Fiå®šä½éªŒè¯
        return CompletableFuture.supplyAsync(() -> {
            try {
                // 1. è·å–è®¾å¤‡å®šä½ä¿¡æ¯
                String wifiBssid = (String) businessData.get("wifiBssid");
                String rssi = (String) businessData.get("rssi");
                String deviceMac = (String) businessData.get("deviceMac");

                // 2. éªŒè¯æ˜¯å¦åœ¨å…è®¸çš„è€ƒå‹¤èŒƒå›´å†…
                AttendanceArea area = getAttendanceAreaByDevice(deviceId);
                boolean inRange = locationService.isInRange(area, wifiBssid, deviceMac, Integer.parseInt(rssi));

                if (inRange) {
                    return new ProtocolProcessResult(true, "ä½ç½®éªŒè¯é€šè¿‡ï¼Œåœ¨å…è®¸çš„è€ƒå‹¤èŒƒå›´å†…");
                } else {
                    return new ProtocolProcessResult(false, "ä½ç½®éªŒè¯å¤±è´¥ï¼Œä¸åœ¨å…è®¸çš„è€ƒå‹¤èŒƒå›´å†…");
                }

            } catch (Exception e) {
                return new ProtocolProcessResult(false, "ä½ç½®éªŒè¯å¼‚å¸¸: " + e.getMessage());
            }
        });
    }
}
```

## ğŸ’³ æ¶ˆè´¹ç®¡ç†æ¨¡å—è®¾å¤‡å…¼å®¹æŒ‡å—

### æ”¯æŒçš„å‚å•†å’Œè®¾å¤‡

| å‚å•† | åè®®ç±»å‹ | æ”¯æŒè®¾å¤‡å‹å· | åŠŸèƒ½ç‰¹æ€§ |
|------|----------|--------------|----------|
| ä¸­æ§æ™ºæ…§ | CONSUME_ZKTECO_V1_0 | IC-600T, F2, SC700, SC810, IC-700A, IC-800A | åˆ·å¡æ¶ˆè´¹ã€ç¦»çº¿æ¶ˆè´¹ã€å……å€¼ç®¡ç†ã€è¡¥è´´å‘æ”¾ |
| ç†µåŸºç§‘æŠ€ | CONSUME_ENTROPY_V2_0 | MA300, SC700 | ç”Ÿç‰©è¯†åˆ«æ¶ˆè´¹ã€ç§»åŠ¨æ”¯ä»˜ã€ä¼šå‘˜ç®¡ç† |
| æ–°ä¸­æ–° | CONSUME_XINZHONG_V1_5 | XZ-POS100, XZ-POS200 | è§¦æ‘¸å±æ¶ˆè´¹ã€äº‘åŒæ­¥ã€å¹¿å‘Šæ˜¾ç¤º |
| æ‹“è¾¾ | CONSUME_TUODA_V2_2 | TDA-100, TDA-200 | åŒå±æ˜¾ç¤ºã€æ‰“å°å°ç¥¨ã€ä¼šå‘˜å¡è¯†åˆ« |

### æ¶ˆè´¹è®¾å¤‡æ¥å…¥å¼€å‘æµç¨‹

#### 1. åˆ›å»ºæ¶ˆè´¹åè®®é€‚é…å™¨

```java
@Component
public class XinzhongConsumeAdapter implements ProtocolAdapter {

    @Override
    public String getProtocolType() {
        return "CONSUME_XINZHONG_V1_5";
    }

    @Override
    public String getManufacturer() {
        return "ä¸­æ–°æ–°";
    }

    @Override
    public String[] getSupportedDeviceModels() {
        return new String[]{"XZ-POS100", "XZ-POS200"};
    }

    @Override
    public ProtocolMessage parseDeviceMessage(byte[] rawData, Long deviceId) throws ProtocolParseException {
        // è§£æä¸­æ–°æ–°æ¶ˆè´¹åè®®
        XinzhongConsumeMessage message = new XinzhongConsumeMessage();

        // ä¸­æ–°æ–°åè®®ç‰¹ç‚¹ï¼šæ”¯æŒåŒå±æ˜¾ç¤ºå’Œå¹¿å‘Šæ¨é€
        ByteBuffer buffer = ByteBuffer.wrap(rawData).order(ByteOrder.LITTLE_ENDIAN);

        // 1. è§£ææ¶ˆè´¹è®°å½•
        parseConsumeRecord(buffer, message);

        // 2. è§£æè®¾å¤‡çŠ¶æ€ï¼ˆç¬¬äºŒå±çŠ¶æ€ï¼‰
        parseSecondScreenStatus(buffer, message);

        // 3. è§£æå¹¿å‘Šæ’­æ”¾ç»Ÿè®¡
        parseAdvertPlayStats(buffer, message);

        return message;
    }

    @Override
    public Future<ProtocolProcessResult> processConsumeBusiness(String businessType, Map<String, Object> businessData, Long deviceId) {
        switch (businessType) {
            case "CONSUME_RECORD":
                return processConsumeRecord(businessData, deviceId);
            case "OFFLINE_SYNC":
                return processOfflineSync(businessData, deviceId);
            case "ADVERTISE_PLAY":
                return processAdvertisePlay(businessData, deviceId);
            case "SCREEN_UPDATE":
                return processSecondScreenUpdate(businessData, deviceId);
            case "PAYMENT_RESULT":
                return processPaymentResult(businessData, deviceId);
            default:
                return CompletableFuture.completedFuture(
                    new ProtocolProcessResult(false, "ä¸æ”¯æŒçš„æ¶ˆè´¹ä¸šåŠ¡ç±»å‹: " + businessType)
                );
        }
    }

    private Future<ProtocolProcessResult> processAdvertisePlay(Map<String, Object> businessData, Long deviceId) {
        // ä¸­æ–°æ–°ç‰¹è‰²åŠŸèƒ½ï¼šå¹¿å‘ŠæŠ•æ”¾ç»Ÿè®¡
        CompletableFuture<ProtocolProcessResult> future = new CompletableFuture<>();

        try {
            // 1. è·å–å¹¿å‘Šä¿¡æ¯
            String advertId = (String) businessData.get("advertId");
            String advertType = (String) businessData.get("advertType");
            Integer playDuration = (Integer) businessData.get("playDuration");
            Integer displayCount = (Integer) businessData.get("displayCount");

            // 2. è®°å½•å¹¿å‘Šæ’­æ”¾æ—¥å¿—
            AdvertPlayLog log = new AdvertPlayLog();
            log.setAdvertId(advertId);
            log.setDeviceId(deviceId);
            log.setAdvertType(advertType);
            log.setPlayDuration(playDuration);
            log.setDisplayCount(displayCount);
            log.setPlayTime(LocalDateTime.now());

            advertPlayLogService.save(log);

            // 3. æ›´æ–°å¹¿å‘Šæ’­æ”¾ç»Ÿè®¡
            advertService.updatePlayStats(advertId, deviceId, playDuration);

            // 4. è§¦å‘å¹¿å‘Šè´¹ç”¨ç»“ç®—
            advertService.settleAdvertCost(advertId, displayCount);

            future.complete(new ProtocolProcessResult(true, "å¹¿å‘Šæ’­æ”¾ç»Ÿè®¡è®°å½•æˆåŠŸ"));

        } catch (Exception e) {
            future.complete(new ProtocolProcessResult(false, "å¹¿å‘Šæ’­æ”¾ç»Ÿè®¡å¤±è´¥: " + e.getMessage()));
        }

        return future;
    }

    private Future<ProtocolProcessResult> processSecondScreenUpdate(Map<String, Object> businessData, Long deviceId) {
        // ä¸­æ–°æ–°ç‰¹è‰²åŠŸèƒ½ï¼šç¬¬äºŒå±å†…å®¹æ›´æ–°
        return CompletableFuture.supplyAsync(() -> {
            try {
                // 1. è·å–å±å¹•å†…å®¹
                String screenContent = (String) businessData.get("screenContent");
                String contentType = (String) businessData.get("contentType");
                Integer displayDuration = (Integer) businessData.get("displayDuration");

                // 2. æ„å»ºå±å¹•æ›´æ–°æŒ‡ä»¤
                Map<String, Object> updateCommand = Map.of(
                    "command", "UPDATE_SECOND_SCREEN",
                    "contentType", contentType,
                    "content", screenContent,
                    "duration", displayDuration
                );

                // 3. å‘é€æ›´æ–°æŒ‡ä»¤åˆ°è®¾å¤‡
                sendCommandToDevice(deviceId, updateCommand);

                // 4. è®°å½•å±å¹•å†…å®¹æ—¥å¿—
                ScreenContentLog log = new ScreenContentLog();
                log.setDeviceId(deviceId);
                log.setContentType(contentType);
                log.setContent(screenContent);
                log.setDisplayDuration(displayDuration);
                log.setUpdateTime(LocalDateTime.now());
                screenContentLogService.save(log);

                return new ProtocolProcessResult(true, "ç¬¬äºŒå±å†…å®¹æ›´æ–°æˆåŠŸ");

            } catch (Exception e) {
                return new ProtocolProcessResult(false, "ç¬¬äºŒå±å†…å®¹æ›´æ–°å¤±è´¥: " + e.getMessage());
            }
        });
    }

    private void sendCommandToDevice(Long deviceId, Map<String, Object> command) {
        // é€šè¿‡è®¾å¤‡é€šè®¯æœåŠ¡å‘é€æŒ‡ä»¤
        ProtocolAdapter adapter = protocolAdapterFactory.getAdapterByDeviceId(deviceId);
        if (adapter != null) {
            try {
                byte[] commandData = adapter.buildDeviceResponse("COMMAND", command, deviceId);
                deviceCommunicationService.sendCommand(deviceId, commandData);
            } catch (Exception e) {
                log.error("å‘é€è®¾å¤‡æŒ‡ä»¤å¤±è´¥, deviceId={}", deviceId, e);
            }
        }
    }
}
```

## ğŸ‘¥ è®¿å®¢ç®¡ç†æ¨¡å—è®¾å¤‡å…¼å®¹æŒ‡å—

### æ”¯æŒçš„å‚å•†å’Œè®¾å¤‡

| å‚å•† | åè®®ç±»å‹ | æ”¯æŒè®¾å¤‡å‹å· | åŠŸèƒ½ç‰¹æ€§ |
|------|----------|--------------|----------|
| ç†µåŸºç§‘æŠ€ | VISITOR_ENTROPY_V3_0 | MA300, SC700, TA800C | äººè„¸è¯†åˆ«è®¿å®¢ã€äºŒç»´ç é¢„çº¦ã€èº«ä»½è¯è¯»å– |
| ä¸­æ§æ™ºæ…§ | VISITOR_ZKTECO_V2_1 | SC405, SC810, SC602 | å¤šæ¨¡æ€è®¿å®¢ã€é»‘åå•æ£€æŸ¥ã€è®¿å®¢å¡å‘æ”¾ |
| æµ·åº·å¨è§† | VISITOR_HIKVISION_V1_8 | DS-K2801, DS-K5607 | äººè„¸è®¿å®¢ã€è§†é¢‘è”åŠ¨ã€é—¨ç¦æ§åˆ¶ |
| å¤§åæŠ€æœ¯ | VISITOR_DAHUA_V2_0 | ASC1204C, ASI3213X-L | äººè„¸è¯†åˆ«è®¿å®¢ã€è®¿å®¢æœºé›†æˆã€ç”µæ¢¯æ§åˆ¶ |

### è®¿å®¢è®¾å¤‡æ¥å…¥å¼€å‘æµç¨‹

#### 1. åˆ›å»ºè®¿å®¢åè®®é€‚é…å™¨

```java
@Component
public class HikvisionVisitorAdapter implements ProtocolAdapter {

    @Override
    public String getProtocolType() {
        return "VISITOR_HIKVISION_V1_8";
    }

    @Override
    public String getManufacturer() {
        return "æµ·åº·å¨è§†";
    }

    @Override
    public String[] getSupportedDeviceModels() {
        return new String[]{"DS-K2801", "DS-K5607"};
    }

    @Override
    public ProtocolMessage parseDeviceMessage(byte[] rawData, Long deviceId) throws ProtocolParseException {
        // è§£ææµ·åº·å¨è§†è®¿å®¢åè®®
        HikvisionVisitorMessage message = new HikvisionVisitorMessage();

        // æµ·åº·å¨è§†åè®®ç‰¹ç‚¹ï¼šæ·±åº¦é›†æˆè§†é¢‘ç›‘æ§
        ByteBuffer buffer = ByteBuffer.wrap(rawData).order(ByteOrder.BIG_ENDIAN);

        // 1. è§£æè®¿å®¢é¢„çº¦ä¿¡æ¯
        parseVisitorAppointment(buffer, message);

        // 2. è§£æè®¿å®¢åˆ°è®¿ä¿¡æ¯
        parseVisitorArrival(buffer, message);

        // 3. è§£æè§†é¢‘è”åŠ¨ä¿¡æ¯
        parseVideoLinkage(buffer, message);

        return message;
    }

    @Override
    public Future<ProtocolProcessResult> processAccessBusiness(String businessType, Map<String, Object> businessData, Long deviceId) {
        switch (businessType) {
            case "VISITOR_REGISTRATION":
                return processVisitorRegistration(businessData, deviceId);
            case "VISITOR_ARRIVAL":
                return processVisitorArrival(businessData, deviceId);
            case "VISITOR_DEPARTURE":
                return processVisitorDeparture(businessData, deviceId);
            case "BLACKLIST_CHECK":
                return processBlacklistCheck(businessData, deviceId);
            case "VIDEO_VERIFY":
                return processVideoVerification(businessData, deviceId);
            default:
                return CompletableFuture.completedFuture(
                    new ProtocolProcessResult(false, "ä¸æ”¯æŒçš„è®¿å®¢ä¸šåŠ¡ç±»å‹: " + businessType)
                );
        }
    }

    private Future<ProtocolProcessResult> processVisitorRegistration(Map<String, Object> businessData, Long deviceId) {
        // æµ·åº·å¨è§†ç‰¹è‰²åŠŸèƒ½ï¼šè§†é¢‘æŠ“æ‹è®¿å®¢ç…§ç‰‡
        CompletableFuture<ProtocolProcessResult> future = new CompletableFuture<>();

        try {
            // 1. è·å–è®¿å®¢ä¿¡æ¯
            String visitorName = (String) businessData.get("visitorName");
            String idCardNumber = (String) businessData.get("idCardNumber");
            String phoneNumber = (String) businessData.get("phoneNumber");
            String visitReason = (String) businessData.get("visitReason");

            // 2. è°ƒç”¨èº«ä»½è¯è¯»å–å™¨è¯»å–è®¿å®¢ä¿¡æ¯
            idCardReaderService.readIdCard(deviceId)
                .thenAccept(idCardInfo -> {
                    // 3. éªŒè¯èº«ä»½è¯ä¿¡æ¯
                    if (validateIdCardInfo(idCardInfo)) {
                        // 4. æŠ“æ‹è®¿å®¢ç…§ç‰‡ï¼ˆæµ·åº·å¨è§†æ‘„åƒå¤´ï¼‰
                        captureVisitorPhoto(deviceId, idCardInfo.getName())
                            .thenAccept(photoUrl -> {
                                // 5. åˆ›å»ºè®¿å®¢è®°å½•
                                VisitorEntity visitor = createVisitorRecord(idCardInfo, photoUrl, businessData);

                                // 6. ç”Ÿæˆè®¿å®¢ç 
                                generateVisitorQrCode(visitor.getVisitorId())
                                    .thenAccept(qrCodeUrl -> {
                                        visitor.setQrCodeUrl(qrCodeUrl);
                                        visitorService.save(visitor);

                                        // 7. å‘é€è®¿å®¢é€šçŸ¥
                                        sendVisitorNotification(visitor);

                                        future.complete(new ProtocolProcessResult(true, "è®¿å®¢æ³¨å†ŒæˆåŠŸï¼Œç…§ç‰‡å·²æŠ“æ‹"));
                                    });
                            });
                    } else {
                        future.complete(new ProtocolProcessResult(false, "èº«ä»½è¯ä¿¡æ¯éªŒè¯å¤±è´¥"));
                    }
                })
                .exceptionally(throwable -> {
                    future.complete(new ProtocolProcessResult(false, "èº«ä»½è¯è¯»å–å¤±è´¥: " + throwable.getMessage()));
                });

        } catch (Exception e) {
            future.complete(new ProtocolProcessResult(false, "è®¿å®¢æ³¨å†Œå¼‚å¸¸: " + e.getMessage()));
        }

        return future;
    }

    private CompletableFuture<String> captureVisitorPhoto(Long deviceId, String visitorName) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // è·å–å…³è”çš„æ‘„åƒå¤´
                List<CameraEntity> cameras = getVisitorCameras(deviceId);

                if (cameras.isEmpty()) {
                    throw new RuntimeException("æœªæ‰¾åˆ°å…³è”çš„æ‘„åƒå¤´");
                }

                CameraEntity camera = cameras.get(0);

                // è°ƒç”¨æµ·åº·å¨è§†æ‘„åƒå¤´æŠ“æ‹æ¥å£
                return videoSurveillanceService.capturePhoto(
                    camera.getCameraId(),
                    visitorName,
                    "è®¿å®¢ç…§ç‰‡"
                );

            } catch (Exception e) {
                throw new RuntimeException("è®¿å®¢ç…§ç‰‡æŠ“æ‹å¤±è´¥", e);
            }
        });
    }

    private Future<ProtocolProcessResult> processVideoVerification(Map<String, Object> businessData, Long deviceId) {
        // æµ·åº·å¨è§†ç‰¹è‰²åŠŸèƒ½ï¼šå®æ—¶äººè„¸è¯†åˆ«éªŒè¯
        CompletableFuture<ProtocolProcessResult> future = new CompletableFuture<>();

        try {
            // 1. è·å–è®¿å®¢ä¿¡æ¯å’Œäººè„¸å›¾åƒ
            Long visitorId = (Long) businessData.get("visitorId");
            String faceImage = (String) businessData.get("faceImage");

            // 2. è·å–è®¿å®¢æ³¨å†Œçš„äººè„¸ç‰¹å¾
            VisitorEntity visitor = visitorService.getById(visitorId);
            String registeredFaceFeature = visitor.getFaceFeature();

            // 3. è¿›è¡Œäººè„¸æ¯”å¯¹
            faceRecognitionService.compareFace(faceImage, registeredFaceFeature)
                .thenAccept(compareResult -> {
                    if (compareResult.getScore() > 0.8) {
                        // 4. éªŒè¯é€šè¿‡ï¼Œå¼€é—¨å¹¶è®°å½•æ—¥å¿—
                        openVisitorDoor(visitorId, deviceId);

                        // 5. æŠ“æ‹åˆ°è®¿ç…§ç‰‡
                        captureVisitPhoto(visitorId, deviceId)
                            .thenAccept(photoUrl -> {
                                saveVisitRecord(visitorId, photoUrl, "SUCCESS");
                                future.complete(new ProtocolProcessResult(true, "äººè„¸è¯†åˆ«éªŒè¯é€šè¿‡"));
                            });

                    } else {
                        // 6. éªŒè¯å¤±è´¥ï¼Œè®°å½•æ—¥å¿—å¹¶å‘Šè­¦
                        saveVisitRecord(visitorId, null, "FAILED");
                        sendSecurityAlert("è®¿å®¢äººè„¸è¯†åˆ«éªŒè¯å¤±è´¥", visitorId);

                        future.complete(new ProtocolProcessResult(false, "äººè„¸è¯†åˆ«éªŒè¯å¤±è´¥"));
                    }
                })
                .exceptionally(throwable -> {
                    future.complete(new ProtocolProcessResult(false, "äººè„¸è¯†åˆ«éªŒè¯å¼‚å¸¸: " + throwable.getMessage()));
                });

        } catch (Exception e) {
            future.complete(new ProtocolProcessResult(false, "è§†é¢‘éªŒè¯å¤„ç†å¼‚å¸¸: " + e.getMessage()));
        }

        return future;
    }

    private List<CameraEntity> getVisitorCameras(Long deviceId) {
        // æŸ¥è¯¢ä¸è®¿å®¢æœºå…³è”çš„æ‘„åƒå¤´
        return cameraService.listByAccessPointId(getAccessPointIdByDevice(deviceId));
    }

    private Long getAccessPointIdByDevice(Long deviceId) {
        // é€šè¿‡è®¾å¤‡IDæŸ¥è¯¢å¯¹åº”çš„è®¿é—®ç‚¹
        DeviceEntity device = deviceService.getById(deviceId);
        return device.getAccessPointId();
    }
}
```

## ğŸ“¹ è§†é¢‘ç›‘æ§æ¨¡å—è®¾å¤‡å…¼å®¹æŒ‡å—

### æ”¯æŒçš„å‚å•†å’Œè®¾å¤‡

| å‚å•† | åè®®ç±»å‹ | æ”¯æŒè®¾å¤‡å‹å· | åŠŸèƒ½ç‰¹æ€§ |
|------|----------|--------------|----------|
| æµ·åº·å¨è§† | VIDEO_HIKVISION_V2_0 | DS-2CDxxxx, DS-2DFxxxx, DS-2DExxxx | å®æ—¶æµåª’ä½“ã€äº‘å°æ§åˆ¶ã€æ™ºèƒ½åˆ†æã€äººè„¸è¯†åˆ« |
| å¤§åæŠ€æœ¯ | VIDEO_DAHUA_V2_1 | DH-IPC-HFWxxxx, DH-SD-xxxx, DH-NVRxxxx | å®æ—¶ç›‘æ§ã€æ™ºèƒ½è·Ÿè¸ªã€è¡Œä¸ºåˆ†æã€è½¦ç‰Œè¯†åˆ« |
| å®‡çŸ³ç§‘æŠ€ | VIDEO_EBPS_V1_5 | IPC-Bxxxx, NVR-xxxx, PTZ-xxxx | AIè§†é¢‘åˆ†æã€äººå‘˜ç»Ÿè®¡ã€å¼‚å¸¸æ£€æµ‹ã€3Dè¡Œä¸ºåˆ†æ |
| åä¸º | VIDEO_HUAWEI_V1_8 | Mxxxxç³»åˆ—Cç³»åˆ—, SDxxxxç³»åˆ— | AIæ™ºèƒ½åˆ†æã€äº‘å­˜å‚¨ã€è¾¹ç¼˜è®¡ç®—ã€5Gä¼ è¾“ |

### è§†é¢‘è®¾å¤‡æ¥å…¥å¼€å‘æµç¨‹

#### 1. åˆ›å»ºè§†é¢‘åè®®é€‚é…å™¨

```java
@Component
public class DahuaVideoAdapter implements ProtocolAdapter {

    @Override
    public String getProtocolType() {
        return "VIDEO_DAHUA_V2_1";
    }

    @Override
    public String getManufacturer() {
        return "å¤§åæŠ€æœ¯";
    }

    @Override
    public String[] getSupportedDeviceModels() {
        return new String[]{"DH-IPC-HFW5442", "DH-SD-6AL245", "DH-NVR5216"};
    }

    @Override
    public ProtocolMessage parseDeviceMessage(byte[] rawData, Long deviceId) throws ProtocolParseException {
        // è§£æå¤§åè§†é¢‘åè®®
        DahuaVideoMessage message = new DahuaVideoMessage();

        // å¤§ååè®®ç‰¹ç‚¹ï¼šæ”¯æŒæ™ºèƒ½åˆ†æå’Œè¾¹ç¼˜è®¡ç®—
        ByteBuffer buffer = ByteBuffer.wrap(rawData).order(ByteOrder.LITTLE_ENDIAN);

        // 1. è§£æåè®®å¤´
        parseProtocolHeader(buffer, message);

        // 2. è§£æè§†é¢‘æµä¿¡æ¯
        parseVideoStreamInfo(buffer, message);

        // 3. è§£æAIåˆ†æç»“æœ
        parseAIAnalysisResult(buffer, message);

        return message;
    }

    @Override
    public Future<ProtocolProcessResult> processAccessBusiness(String businessType, Map<String, Object> businessData, Long deviceId) {
        // è§†é¢‘è®¾å¤‡ä¸»è¦å¤„ç†é—¨ç¦è”åŠ¨äº‹ä»¶
        switch (businessType) {
            case "ACCESS_CONTROL_LINKAGE":
                return processAccessControlLinkage(businessData, deviceId);
            case "VIDEO_ANALYSIS_EVENT":
                return processVideoAnalysisEvent(businessData, deviceId);
            case "ALARM_DETECTION":
                return processAlarmDetection(businessData, deviceId);
            default:
                return CompletableFuture.completedFuture(
                    new ProtocolProcessResult(false, "ä¸æ”¯æŒçš„ä¸šåŠ¡ç±»å‹: " + businessType)
                );
        }
    }

    private Future<ProtocolProcessResult> processVideoAnalysisEvent(Map<String, Object> businessData, Long deviceId) {
        // å¤§åç‰¹è‰²åŠŸèƒ½ï¼šè¾¹ç¼˜AIåˆ†æ
        CompletableFuture<ProtocolProcessResult> future = new CompletableFuture<>();

        try {
            // 1. è·å–AIåˆ†æç»“æœ
            String eventType = (String) businessData.get("eventType");
            String eventDescription = (String) businessData.get("eventDescription");
            Double confidence = (Double) businessData.get("confidence");
            String imageUrl = (String) businessData.get("imageUrl");
            String videoUrl = (String) businessData.get("videoUrl");

            // 2. æ ¹æ®äº‹ä»¶ç±»å‹å¤„ç†
            switch (eventType) {
                case "PERSON_COUNT":
                    future.complete(processPersonCount(businessData, deviceId));
                    break;
                case "FACE_DETECTION":
                    future.complete(processFaceDetection(businessData, deviceId));
                    break;
                case "PERIMETER_INTRUSION":
                    future.complete(processPerimeterIntrusion(businessData, deviceId));
                    break;
                case "ABANDONED_OBJECT":
                    future.complete(processAbandonedObject(businessData, deviceId));
                    break;
                case "CROWD_DENSITY":
                    future.complete(processCrowdDensity(businessData, deviceId));
                    break;
                case "LOITERING":
                    future.complete(processLoitering(businessData, deviceId));
                    break;
                case "FIGHTING":
                    future.complete(processFighting(businessData, deviceId));
                    break;
                default:
                    // æœªçŸ¥äº‹ä»¶ç±»å‹ï¼Œè®°å½•æ—¥å¿—
                    log.warn("æœªçŸ¥çš„è§†é¢‘åˆ†æäº‹ä»¶ç±»å‹: {}", eventType);
                    future.complete(new ProtocolProcessResult(true, "äº‹ä»¶å·²è®°å½•"));
            }

        } catch (Exception e) {
            future.complete(new ProtocolProcessResult(false, "è§†é¢‘åˆ†æäº‹ä»¶å¤„ç†å¼‚å¸¸: " + e.getMessage()));
        }

        return future;
    }

    private ProtocolProcessResult processPersonCount(Map<String, Object> businessData, Long deviceId) {
        // å¤§åç‰¹è‰²åŠŸèƒ½ï¼šäººå‘˜æ•°é‡ç»Ÿè®¡
        try {
            // 1. è·å–äººå‘˜æ•°é‡å’ŒåŒºåŸŸä¿¡æ¯
            Integer personCount = (Integer) businessData.get("personCount");
            String regionId = (String) businessData.get("regionId");
            Integer maxCapacity = (Integer) businessData.get("maxCapacity");
            Double density = (Double) businessData.get("density");

            // 2. ä¿å­˜äººå‘˜ç»Ÿè®¡æ•°æ®
            VideoAnalysisEvent event = new VideoAnalysisEvent();
            event.setDeviceId(deviceId);
            event.setEventType("PERSON_COUNT");
            event.setEventTime(LocalDateTime.now());
            event.setPersonCount(personCount);
            event.setRegionId(regionId);
            event.setMaxCapacity(maxCapacity);
            event.setDensity(density);
            event.setConfidence((Double) businessData.get("confidence"));

            videoAnalysisEventService.save(event);

            // 3. æ£€æŸ¥æ˜¯å¦è¶…è¿‡å®¹é‡é™åˆ¶
            if (personCount > maxCapacity) {
                // è§¦å‘å®¹é‡å‘Šè­¦
                triggerCapacityAlert(regionId, personCount, maxCapacity);
            }

            return new ProtocolProcessResult(true, String.format("äººå‘˜ç»Ÿè®¡å®Œæˆï¼Œå½“å‰äººæ•°ï¼š%dï¼Œå¯†åº¦ï¼š%.2f", personCount, density));

        } catch (Exception e) {
            log.error("äººå‘˜æ•°é‡ç»Ÿè®¡å¤„ç†å¤±è´¥", e);
            return new ProtocolProcessResult(false, "äººå‘˜æ•°é‡ç»Ÿè®¡å¤„ç†å¤±è´¥: " + e.getMessage());
        }
    }

    private ProtocolProcessResult processFaceDetection(Map<String, Object> businessData, Long deviceId) {
        // å¤§åç‰¹è‰²åŠŸèƒ½ï¼šäººè„¸æ£€æµ‹å’Œè¯†åˆ«
        try {
            // 1. è·å–äººè„¸æ£€æµ‹ç»“æœ
            List<FaceDetectionResult> faceResults = (List<FaceDetectionResult>) businessData.get("faceResults");
            String imageUrl = (String) businessData.get("imageUrl");

            // 2. äººè„¸æ¯”å¯¹è¯†åˆ«
            for (FaceDetectionResult faceResult : faceResults) {
                String faceImage = faceResult.getFaceImage();
                String boundingBox = faceResult.getBoundingBox();

                // è°ƒç”¨äººè„¸è¯†åˆ«æœåŠ¡
                faceRecognitionService.recognizeFace(faceImage)
                    .thenAccept(recognizeResult -> {
                        if (recognizeResult.isMatched()) {
                            // åŒ¹é…æˆåŠŸï¼Œè®°å½•äººå‘˜ä¿¡æ¯
                            recordFaceMatch(deviceId, recognizeResult, imageUrl, boundingBox);
                        } else {
                            // åŒ¹é…å¤±è´¥ï¼Œè®°å½•ä¸ºé™Œç”Ÿäºº
                            recordUnknownPerson(deviceId, faceImage, imageUrl, boundingBox);
                        }
                    });
            }

            return new ProtocolProcessResult(true, String.format("äººè„¸æ£€æµ‹å®Œæˆï¼Œæ£€æµ‹åˆ°%då¼ äººè„¸", faceResults.size()));

        } catch (Exception e) {
            log.error("äººè„¸æ£€æµ‹å¤„ç†å¤±è´¥", e);
            return new ProtocolProcessResult(false, "äººè„¸æ£€æµ‹å¤„ç†å¤±è´¥: " + e.getMessage());
        }
    }

    private ProtocolProcessResult processPerimeterIntrusion(Map<String, Object> businessData, Long deviceId) {
        // å¤§åç‰¹è‰²åŠŸèƒ½ï¼šå‘¨ç•Œå…¥ä¾µæ£€æµ‹
        try {
            // 1. è·å–å…¥ä¾µä¿¡æ¯
            String intrusionType = (String) businessData.get("intrusionType");
            String intrusionDirection = (String) businessData.get("intrusionDirection");
            String intrusionPoint = (String) businessData.get("intrusionPoint");
            String alarmLevel = (String) businessData.get("alarmLevel");
            String videoUrl = (String) businessData.get("videoUrl");

            // 2. ä¿å­˜å…¥ä¾µäº‹ä»¶
            SecurityAlarmEvent alarmEvent = new SecurityAlarmEvent();
            alarmEvent.setDeviceId(deviceId);
            alarmEvent.setEventType("PERIMETER_INTRUSION");
            alarmEvent.setAlarmTime(LocalDateTime.now());
            alarmEvent.setIntrusionType(intrusionType);
            alarmEvent.setIntrusionDirection(intrusionDirection);
            alarmEvent.setIntrusionPoint(intrusionPoint);
            alarmEvent.setAlarmLevel(alarmLevel);
            alarmEvent.setVideoUrl(videoUrl);

            securityAlarmEventService.save(alarmEvent);

            // 3. è§¦å‘å®‰å…¨å‘Šè­¦
            triggerSecurityAlarm(alarmEvent);

            // 4. è”åŠ¨é—¨ç¦æ§åˆ¶
            linkageAccessControl(alarmEvent);

            return new ProtocolProcessResult(true, "å‘¨ç•Œå…¥ä¾µæ£€æµ‹å®Œæˆï¼Œå·²è§¦å‘å‘Šè­¦");

        } catch (Exception e) {
            log.error("å‘¨ç•Œå…¥ä¾µæ£€æµ‹å¤„ç†å¤±è´¥", e);
            return new ProtocolProcessResult(false, "å‘¨ç•Œå…¥ä¾µæ£€æµ‹å¤„ç†å¤±è´¥: " + e.getMessage());
        }
    }

    private void triggerSecurityAlarm(SecurityAlarmEvent alarmEvent) {
        // å‘é€å®æ—¶å‘Šè­¦é€šçŸ¥
        alarmNotificationService.sendAlarm(alarmEvent);

        // æ¨é€å‘Šè­¦åˆ°ç®¡ç†ç«¯
        websocketService.sendAlarmToAdmins(alarmEvent);

        // è®°å½•å‘Šè­¦æ—¥å¿—
        alarmLogService.saveAlarmLog(alarmEvent);
    }

    private void linkageAccessControl(SecurityAlarmEvent alarmEvent) {
        // è·å–å…³è”çš„é—¨ç¦è®¾å¤‡
        List<AccessDeviceEntity> accessDevices = getLinkedAccessDevices(alarmEvent.getDeviceId());

        // æ ¹æ®å‘Šè­¦çº§åˆ«æ‰§è¡Œä¸åŒçš„æ§åˆ¶ç­–ç•¥
        switch (alarmEvent.getAlarmLevel()) {
            case "HIGH":
                // é«˜çº§åˆ«å‘Šè­¦ï¼šç«‹å³é”å®šæ‰€æœ‰å…³è”é—¨ç¦
                for (AccessDeviceEntity device : accessDevices) {
                    lockAccessDevice(device.getDeviceId());
                }
                break;
            case "MEDIUM":
                // ä¸­çº§åˆ«å‘Šè­¦ï¼šè¦æ±‚äºŒæ¬¡éªŒè¯
                for (AccessDeviceEntity device : accessDevices) {
                    requireSecondaryVerification(device.getDeviceId());
                }
                break;
            case "LOW":
                // ä½çº§åˆ«å‘Šè­¦ï¼šè®°å½•æ—¥å¿—ï¼Œæ­£å¸¸é€šè¡Œ
                for (AccessDeviceEntity device : accessDevices) {
                    recordAccessLog(device.getDeviceId(), "å®‰å…¨å‘Šè­¦ï¼š" + alarmEvent.getIntrusionType());
                }
                break;
        }
    }
}
```

## ğŸ”§ ç»Ÿä¸€è®¾å¤‡æ¥å…¥å¼€å‘æµç¨‹

### æ ‡å‡†æ¥å…¥æ­¥éª¤

1. **å‚å•†åè®®åˆ†æ**
   - è·å–å‚å•†å®˜æ–¹åè®®æ–‡æ¡£
   - åˆ†ææ¶ˆæ¯æ ¼å¼å’Œæ•°æ®ç»“æ„
   - ç¡®å®šæ”¯æŒçš„è®¾å¤‡å‹å·å’ŒåŠŸèƒ½
   - è¯†åˆ«åè®®æ‰©å±•ç‚¹

2. **åè®®é€‚é…å™¨å¼€å‘**
   - å®ç° `ProtocolAdapter` æ¥å£
   - åˆ›å»ºæ¶ˆæ¯å®ä½“ç±»
   - å®ç°æ¶ˆæ¯è§£æå’Œæ„å»º
   - å®ç°ä¸šåŠ¡æ•°æ®å¤„ç†

3. **å·¥å‚æ³¨å†Œé›†æˆ**
   - æ·»åŠ åˆ°è‡ªåŠ¨æ³¨å†Œåˆ—è¡¨
   - é…ç½®è®¾å¤‡å‹å·æ˜ å°„
   - æµ‹è¯•é€‚é…å™¨åŠŸèƒ½

4. **ä¸šåŠ¡æœåŠ¡é›†æˆ**
   - é›†æˆåˆ°å¯¹åº”ä¸šåŠ¡æ¨¡å—
   - å®ç°å‚å•†ç‰¹è‰²åŠŸèƒ½
   - å¤„ç†å¼‚å¸¸å’Œé”™è¯¯

5. **æµ‹è¯•éªŒè¯**
   - å•å…ƒæµ‹è¯•é€‚é…å™¨åŠŸèƒ½
   - é›†æˆæµ‹è¯•ä¸šåŠ¡æµç¨‹
   - æ€§èƒ½æµ‹è¯•å’Œä¼˜åŒ–

### å¼€å‘è§„èŒƒè¦æ±‚

1. **å‘½åè§„èŒƒ**
   ```java
   // åè®®ç±»å‹å‘½åè§„èŒƒï¼š{ä¸šåŠ¡é¢†åŸŸ}_{å‚å•†}_{ç‰ˆæœ¬å·}
   public static final String PROTOCOL_TYPE = "ACCESS_ENTROPY_V4_8";

   // é€‚é…å™¨ç±»å‘½åè§„èŒƒï¼š{å‚å•†}+{ä¸šåŠ¡}+Adapter
   public class EntropyAccessAdapter implements ProtocolAdapter
   ```

2. **å¼‚å¸¸å¤„ç†è§„èŒƒ**
   ```java
   // æŠ›å‡ºæ ‡å‡†å¼‚å¸¸ç±»å‹
   throw new ProtocolParseException("åè®®è§£æå¤±è´¥: " + e.getMessage(), e);
   throw new ProtocolBuildException("åè®®æ„å»ºå¤±è´¥: " + e.getMessage(), e);
   ```

3. **æ—¥å¿—è®°å½•è§„èŒƒ**
   ```java
   // ç»“æ„åŒ–æ—¥å¿—è®°å½•
   log.info("[{}] {} å¤„ç†æ¶ˆæ¯: deviceSn={}, messageType={}, processTime={}ms",
       protocolType, operation, deviceSn, messageType, processTime);
   ```

4. **é…ç½®ç®¡ç†è§„èŒƒ**
   ```yaml
   # åè®®é…ç½®ç¤ºä¾‹
   device-communication:
     protocols:
       new-vendor:
         enabled: true
         adapter-class: com.example.NewVendorAdapter
         device-models: [NV-100, NV-200]
         features: [face_recognition, offline_sync]
   ```

## ğŸ“‹ è®¾å¤‡å…¼å®¹æ€§æ£€æŸ¥æ¸…å•

### å¼€å‘é˜¶æ®µæ£€æŸ¥æ¸…å•

#### åè®®é€‚é…å™¨å¼€å‘
- [ ] å®ç° `ProtocolAdapter` æ¥å£çš„æ‰€æœ‰æ–¹æ³•
- [ ] åˆ›å»ºå®Œæ•´çš„åè®®æ¶ˆæ¯å®ä½“ç±»
- [ ] å®ç°åè®®å¤´è§£æå’Œæ„å»ºé€»è¾‘
- [ ] å®ç°ä¸šåŠ¡æ•°æ®å¤„ç†æ–¹æ³•
- [ ] æ·»åŠ å¿…è¦çš„éªŒè¯å’Œé”™è¯¯å¤„ç†
- [ ] å®Œæˆæ—¥å¿—è®°å½•å’Œæ€§èƒ½ç›‘æ§

#### æ¶ˆæ¯å¤„ç†
- [ ] æ”¯æŒäºŒè¿›åˆ¶æ•°æ®è§£æ
- [ ] æ”¯æŒåå…­è¿›åˆ¶å­—ç¬¦ä¸²è§£æ
- [ ] å®ç°æ•°æ®å®Œæ•´æ€§éªŒè¯
- [ ] å¤„ç†ç½‘ç»œå­—èŠ‚åºè½¬æ¢
- [ ] å®ç°æ•°æ®å‹ç¼©å’Œè§£å‹ç¼©ï¼ˆå¦‚éœ€è¦ï¼‰

#### ä¸šåŠ¡é›†æˆ
- [ ] ä¸å¯¹åº”ä¸šåŠ¡æ¨¡å—æœåŠ¡é›†æˆ
- [ ] å®ç°å‚å•†ç‰¹è‰²åŠŸèƒ½
- [ ] æ”¯æŒå¼‚æ­¥ä¸šåŠ¡å¤„ç†
- [ ] å®ç°äº‹åŠ¡ç®¡ç†
- [ ] æ·»åŠ å¿…è¦çš„ç¼“å­˜ä¼˜åŒ–

#### æµ‹è¯•éªŒè¯
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•ç”¨ä¾‹
- [ ] ç¼–å†™é›†æˆæµ‹è¯•ç”¨ä¾‹
- [ ] è¿›è¡Œæ€§èƒ½æµ‹è¯•
- [ ] è¿›è¡Œç¨³å®šæ€§æµ‹è¯•
- [ ] éªŒè¯å¤šè®¾å¤‡å¹¶å‘å¤„ç†

### éƒ¨ç½²é˜¶æ®µæ£€æŸ¥æ¸…å•

#### é…ç½®éªŒè¯
- [ ] åè®®é€‚é…å™¨æ­£ç¡®æ³¨å†Œåˆ°å·¥å‚
- [ ] è®¾å¤‡å‹å·æ˜ å°„é…ç½®æ­£ç¡®
- [ ] è®¾å¤‡å‚æ•°é…ç½®å®Œæ•´
- [ ] ç½‘ç»œè¿æ¥é…ç½®æ­£ç¡®
- [ ] ç¼“å­˜é…ç½®åˆç†

#### åŠŸèƒ½éªŒè¯
- [ ] è®¾å¤‡è¿æ¥å’Œé€šä¿¡æ­£å¸¸
- [ ] æ¶ˆæ¯è§£æå’Œæ„å»ºæ­£ç¡®
- [ ] ä¸šåŠ¡å¤„ç†é€»è¾‘æ­£å¸¸
- [ ] é”™è¯¯å¤„ç†æœºåˆ¶æœ‰æ•ˆ
- [ ] ç›‘æ§æŒ‡æ ‡æ­£å¸¸

#### æ€§èƒ½éªŒè¯
- [ ] æ¶ˆæ¯å¤„ç†å»¶è¿Ÿè¾¾æ ‡
- [ ] å¹¶å‘å¤„ç†èƒ½åŠ›è¾¾æ ‡
- [ ] å†…å­˜ä½¿ç”¨åˆç†
- [ ] CPUä½¿ç”¨åˆç†
- [ ] ç½‘ç»œå¸¦å®½ä½¿ç”¨åˆç†

## ğŸš€ å¿«é€Ÿæ¥å…¥æ¨¡æ¿

### æ–°å‚å•†åè®®æ¥å…¥æ¨¡æ¿

```java
/**
 * {å‚å•†}{ä¸šåŠ¡}åè®®V{ç‰ˆæœ¬å·}é€‚é…å™¨
 *
 * @author IOE-DREAM Team
 * @version 1.0.0
 * @since {åˆ›å»ºæ—¥æœŸ}
 */
@Slf4j
@Component
public class {Vendor}{Business}Adapter implements ProtocolAdapter {

    // ==================== åè®®å¸¸é‡å®šä¹‰ ====================

    /** åè®®ç±»å‹æ ‡è¯† */
    private static final String PROTOCOL_TYPE = "{BUSINESS}_{VENDOR}_V{VERSION}";

    /** æ”¯æŒçš„è®¾å¤‡å‹å· */
    private static final String[] SUPPORTED_DEVICE_MODELS = {
        "{MODEL1}", "{MODEL2}", "{MODEL3}"
    };

    // ==================== åè®®æ ‡è¯†æ¥å£å®ç° ====================

    @Override
    public String getProtocolType() {
        return PROTOCOL_TYPE;
    }

    @Override
    public String getManufacturer() {
        return "{å‚å•†}";
    }

    @Override
    public String getVersion() {
        return "V{VERSION}";
    }

    @Override
    public String[] getSupportedDeviceModels() {
        return SUPPORTED_DEVICE_MODELS.clone();
    }

    @Override
    public boolean isDeviceModelSupported(String deviceModel) {
        return Arrays.asList(SUPPORTED_DEVICE_MODELS).contains(deviceModel.toUpperCase());
    }

    // ==================== æ¶ˆæ¯å¤„ç†æ ¸å¿ƒæ¥å£å®ç° ====================

    @Override
    public ProtocolMessage parseDeviceMessage(byte[] rawData, Long deviceId) throws ProtocolParseException {
        log.debug("[{å‚å•†}{ä¸šåŠ¡}åè®®] å¼€å§‹è§£æè®¾å¤‡æ¶ˆæ¯, deviceId={}, dataLength={}", deviceId, rawData.length);

        try {
            // 1. åŸºç¡€æ•°æ®éªŒè¯
            validateRawData(rawData);

            // 2. è§£æåè®®å¤´
            {Vendor}{Business}Message message = parseProtocolHeader(rawData);

            // 3. æ ¹æ®æ¶ˆæ¯ç±»å‹è§£æä¸šåŠ¡æ•°æ®
            parseBusinessData(rawData, message);

            log.debug("[{å‚å•†}{ä¸šåŠ¡}åè®®] æ¶ˆæ¯è§£æå®Œæˆ, messageType={}, deviceSn={}",
                message.getMessageTypeName(), message.getDeviceId());

            return message;

        } catch (Exception e) {
            log.error("[{å‚å•†}{ä¸šåŠ¡}åè®®] æ¶ˆæ¯è§£æå¤±è´¥, deviceId={}", deviceId, e);
            throw new ProtocolParseException("æ¶ˆæ¯è§£æå¤±è´¥: " + e.getMessage(), e);
        }
    }

    // ==================== ç§æœ‰è¾…åŠ©æ–¹æ³• ====================

    private void validateRawData(byte[] rawData) throws ProtocolParseException {
        if (rawData == null || rawData.length < MIN_MESSAGE_LENGTH) {
            throw new ProtocolParseException("æ•°æ®é•¿åº¦ä¸è¶³ï¼Œæ— æ³•è§£æåè®®å¤´");
        }
    }

    private {Vendor}{Business}Message parseProtocolHeader(byte[] rawData) {
        // æ ¹æ®å‚å•†åè®®æ ¼å¼è§£æåè®®å¤´
        ByteBuffer buffer = ByteBuffer.wrap(rawData).order(ByteOrder.LITTLE_ENDIAN);

        {Vendor}{Business}Message message = new {Vendor}{Business}Message();

        // è§£æåè®®æ ‡è¯†ã€ç‰ˆæœ¬ã€è®¾å¤‡IDç­‰
        // TODO: å®ç°å…·ä½“çš„åè®®å¤´è§£æé€»è¾‘

        return message;
    }

    private void parseBusinessData(byte[] rawData, {Vendor}{Business}Message message) {
        // æ ¹æ®æ¶ˆæ¯ç±»å‹è§£æä¸šåŠ¡æ•°æ®
        switch (message.getMessageTypeCode()) {
            case MSG_TYPE_{BUSINESS}_EVENT:
                parse{Business}Event(rawData, message);
                break;
            case MSG_TYPE_DEVICE_STATUS:
                parseDeviceStatus(rawData, message);
                break;
            // å…¶ä»–æ¶ˆæ¯ç±»å‹...
        }
    }

    // TODO: å®ç°å…¶ä»–å¿…è¦æ–¹æ³•
    @Override
    public byte[] buildDeviceResponse(String messageType, Map<String, Object> businessData, Long deviceId) throws ProtocolBuildException {
        // å®ç°å“åº”æ¶ˆæ¯æ„å»º
        return new byte[0];
    }

    @Override
    public Future<ProtocolProcessResult> process{Business}Business(String businessType, Map<String, Object> businessData, Long deviceId) {
        // å®ç°ä¸šåŠ¡å¤„ç†é€»è¾‘
        return CompletableFuture.completedFuture(new ProtocolProcessResult());
    }

    // å…¶ä»–æ¥å£æ–¹æ³•å®ç°...
}
```

è¿™ä¸ªè®¾å¤‡å…¼å®¹å¼€å‘æŒ‡å—ä¸ºIOE-DREAMæ™ºæ…§å›­åŒºä¸€å¡é€šç®¡ç†å¹³å°æä¾›äº†å®Œæ•´ã€æ ‡å‡†åŒ–çš„è®¾å¤‡æ¥å…¥æµç¨‹ï¼Œç¡®ä¿å„ä¸ªä¸šåŠ¡æ¨¡å—èƒ½å¤Ÿå¿«é€Ÿã€è§„èŒƒåœ°å…¼å®¹ä¸åŒå‚å•†çš„è®¾å¤‡ï¼Œå®ç°çœŸæ­£çš„å‚å•†æ— å…³æ€§ã€‚