# è€ƒå‹¤æœåŠ¡ä¸“å®¶æŠ€èƒ½
## Attendance Service Specialist

**ğŸ¯ æŠ€èƒ½å®šä½**: IOE-DREAMæ™ºæ…§å›­åŒºè€ƒå‹¤ç®¡ç†ä¸šåŠ¡ä¸“å®¶ï¼Œç²¾é€šè€ƒå‹¤è§„åˆ™ã€æ’ç­ç®¡ç†ã€ç»Ÿè®¡åˆ†æç­‰æ ¸å¿ƒä¸šåŠ¡

**âš¡ æŠ€èƒ½ç­‰çº§**: â˜…â˜…â˜…â˜…â˜…â˜… (é¡¶çº§ä¸“å®¶)
**ğŸ¯ é€‚ç”¨åœºæ™¯**: è€ƒå‹¤æœåŠ¡å¼€å‘ã€æ’ç­ç³»ç»Ÿå»ºè®¾ã€ç»Ÿè®¡åˆ†ææŠ¥è¡¨ã€å¼‚å¸¸å¤„ç†ä¼˜åŒ–
**ğŸ“Š æŠ€èƒ½è¦†ç›–**: è€ƒå‹¤æ‰“å¡ | æ’ç­ç®¡ç† | è¯·å‡å®¡æ‰¹ | ç»Ÿè®¡åˆ†æ | å¼‚å¸¸å¤„ç† | æŠ¥è¡¨ç³»ç»Ÿ
**ğŸ”§ æŠ€æœ¯æ ˆ**: Spring Boot 3.5.8 + MyBatis-Plus + Redis + ClickHouse

---

## ğŸ“‹ æŠ€èƒ½æ¦‚è¿°

### **æ ¸å¿ƒä¸“é•¿**
- **è€ƒå‹¤è§„åˆ™å¼•æ“**: å¤æ‚è€ƒå‹¤è§„åˆ™è®¾è®¡å’Œå®ç°ï¼ˆå¼¹æ€§å·¥ä½œåˆ¶ã€è½®ç­åˆ¶ã€è®¡ä»¶åˆ¶ç­‰ï¼‰
- **æ™ºèƒ½æ’ç­ç³»ç»Ÿ**: è‡ªåŠ¨åŒ–æ’ç­ç®—æ³•ã€äººåŠ›èµ„æºä¼˜åŒ–ã€å†²çªæ£€æµ‹
- **å¤šè®¾å¤‡æ•°æ®èåˆ**: äººè„¸è¯†åˆ«ã€æŒ‡çº¹ã€å·¥ç‰Œã€APPç­‰å¤šè€ƒå‹¤æ–¹å¼æ•°æ®ç»Ÿä¸€å¤„ç†
- **å¼‚å¸¸æ£€æµ‹å’Œå¤„ç†**: è€ƒå‹¤å¼‚å¸¸æ™ºèƒ½æ£€æµ‹ã€è‡ªåŠ¨å¤„ç†ã€äººå·¥å®¡æ ¸æµç¨‹
- **ç»Ÿè®¡åˆ†æç³»ç»Ÿ**: å¤šç»´åº¦è€ƒå‹¤æ•°æ®ç»Ÿè®¡ã€å¯è§†åŒ–æŠ¥è¡¨ã€è¶‹åŠ¿åˆ†æ
- **åˆè§„æ€§ç®¡ç†**: åŠ³åŠ¨æ³•è§„åˆè§„æ€§æ£€æŸ¥ã€å·¥æ—¶ç»Ÿè®¡ã€åŠ ç­ç®¡æ§

### **è§£å†³èƒ½åŠ›**
- **è€ƒå‹¤æœåŠ¡æ¶æ„**: é«˜å¯ç”¨ã€é«˜æ€§èƒ½çš„è€ƒå‹¤æœåŠ¡æ¶æ„è®¾è®¡å’Œå®ç°
- **è€ƒå‹¤ç®—æ³•ä¼˜åŒ–**: è€ƒå‹¤è®¡ç®—ç®—æ³•ä¼˜åŒ–ï¼Œç¡®ä¿å‡†ç¡®æ€§å’Œæ€§èƒ½
- **æ•°æ®ä¸€è‡´æ€§**: å¤šæ•°æ®æºçš„è€ƒå‹¤æ•°æ®ä¸€è‡´æ€§ä¿è¯å’Œå†²çªè§£å†³
- **å¼‚å¸¸å¤„ç†æœºåˆ¶**: æ™ºèƒ½å¼‚å¸¸æ£€æµ‹ã€è‡ªåŠ¨å¤„ç†æµç¨‹ã€äººå·¥å®¡æ ¸ç³»ç»Ÿ
- **æŠ¥è¡¨ç³»ç»Ÿè®¾è®¡**: çµæ´»çš„è€ƒå‹¤æŠ¥è¡¨ç³»ç»Ÿï¼Œæ”¯æŒè‡ªå®šä¹‰æŠ¥è¡¨å’Œæ•°æ®å¯¼å‡º

---

## ğŸ¯ ä¸šåŠ¡åœºæ™¯è¦†ç›–

### â° è€ƒå‹¤æ‰“å¡å¤„ç†
```java
// è€ƒå‹¤æ‰“å¡å¤„ç† (Spring Boot 3.5.8 + MyBatis-Plus)
import jakarta.annotation.Resource;
import jakarta.validation.Valid;
import jakarta.transaction.Transactional;
import com.baomidou.mybatisplus.annotation.TableName;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.FieldFill;
import com.baomidou.mybatisplus.annotation.TableLogic;
import com.baomidou.mybatisplus.annotation.Version;
import lombok.Data;

// Controllerå±‚ - RESTæ¥å£
@RestController
@RequestMapping("/api/v1/attendance")
@Tag(name = "è€ƒå‹¤æ‰“å¡", description = "è€ƒå‹¤æ‰“å¡å’Œè®°å½•å¤„ç†")
public class AttendanceController {

    @Resource
    private AttendanceService attendanceService;

    /**
     * è€ƒå‹¤æ‰“å¡æ¥å£
     */
    @PostMapping("/check")
    @RateLimiter(name = "attendance-check", fallbackMethod = "checkFallback")
    @ApiOperation(value = "è€ƒå‹¤æ‰“å¡", notes = "å‘˜å·¥è€ƒå‹¤æ‰“å¡æ¥å£")
    public ResponseDTO<AttendanceCheckResultDTO> checkIn(
            @Valid @RequestBody AttendanceCheckRequestDTO request,
            HttpServletRequest httpRequest) {

        log.info("[è€ƒå‹¤æ‰“å¡] å¼€å§‹å¤„ç†, employeeId={}, checkType={}",
                request.getEmployeeId(), request.getCheckType());

        // è¯·æ±‚æ¥æºéªŒè¯
        validateRequestSource(httpRequest);

        AttendanceCheckResultDTO result = attendanceService.processAttendanceCheck(request);

        log.info("[è€ƒå‹¤æ‰“å¡] å¤„ç†å®Œæˆ, employeeId={}, recordId={}, status={}",
                request.getEmployeeId(), result.getRecordId(), result.getStatus());

        return ResponseDTO.ok(result);
    }

    // æœåŠ¡é™çº§å¤„ç†
    public ResponseDTO<AttendanceCheckResultDTO> checkFallback(AttendanceCheckRequestDTO request, Exception ex) {
        log.error("[è€ƒå‹¤æ‰“å¡] æœåŠ¡é™çº§, employeeId={}", request.getEmployeeId(), ex);
        return ResponseDTO.error("SERVICE_DEGRADED", "ç³»ç»Ÿç¹å¿™ï¼Œè¯·ç¨åé‡è¯•");
    }
}

// Serviceå±‚ - ä¸šåŠ¡é€»è¾‘å®ç°
@Service
@Transactional(rollbackFor = Exception.class)
public class AttendanceServiceImpl implements AttendanceService {

    @Resource
    private AttendanceManager attendanceManager;

    @Override
    public AttendanceCheckResultDTO processAttendanceCheck(AttendanceCheckRequestDTO request) {
        try {
            // å‚æ•°éªŒè¯
            validateCheckRequest(request);

            // å§”æ‰˜ç»™Managerå±‚å¤„ç†å¤æ‚ä¸šåŠ¡é€»è¾‘
            AttendanceCheckResult result = attendanceManager.processAttendanceCheck(request);

            return convertToDTO(result);
        } catch (BusinessException e) {
            log.warn("[è€ƒå‹¤æ‰“å¡] ä¸šåŠ¡å¼‚å¸¸, employeeId={}, error={}", request.getEmployeeId(), e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("[è€ƒå‹¤æ‰“å¡] ç³»ç»Ÿå¼‚å¸¸, employeeId={}", request.getEmployeeId(), e);
            throw new BusinessException("ATTENDANCE_CHECK_ERROR", "è€ƒå‹¤æ‰“å¡å¤„ç†å¤±è´¥");
        }
    }

    private void validateCheckRequest(AttendanceCheckRequestDTO request) {
        if (request.getEmployeeId() == null) {
            throw new BusinessException("EMPLOYEE_ID_REQUIRED", "å‘˜å·¥IDä¸èƒ½ä¸ºç©º");
        }
        if (request.getCheckType() == null) {
            throw new BusinessException("CHECK_TYPE_REQUIRED", "æ‰“å¡ç±»å‹ä¸èƒ½ä¸ºç©º");
        }
        if (request.getCheckTime() == null) {
            request.setCheckTime(LocalDateTime.now());
        }
    }
}

// Managerå±‚ - å¤æ‚ä¸šåŠ¡æµç¨‹ç¼–æ’
public class AttendanceManagerImpl implements AttendanceManager {

    private final AttendanceRuleEngine ruleEngine;
    private final DeviceDataService deviceDataService;
    private final AttendanceCalculator calculator;
    private final AttendanceRecordDao attendanceRecordDao;
    private final AnomalyDetector anomalyDetector;
    private final GatewayServiceClient gatewayServiceClient;

    // æ„é€ å‡½æ•°æ³¨å…¥ä¾èµ–
    public AttendanceManagerImpl(
            AttendanceRuleEngine ruleEngine,
            DeviceDataService deviceDataService,
            AttendanceCalculator calculator,
            AttendanceRecordDao attendanceRecordDao,
            AnomalyDetector anomalyDetector,
            GatewayServiceClient gatewayServiceClient) {
        this.ruleEngine = ruleEngine;
        this.deviceDataService = deviceDataService;
        this.calculator = calculator;
        this.attendanceRecordDao = attendanceRecordDao;
        this.anomalyDetector = anomalyDetector;
        this.gatewayServiceClient = gatewayServiceClient;
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public AttendanceCheckResult processAttendanceCheck(AttendanceCheckRequestDTO request) {
        // 1. å¤šè®¾å¤‡æ•°æ®èåˆ
        DeviceData deviceData = deviceDataService.getUnifiedData(request);

        // 2. è€ƒå‹¤è§„åˆ™åº”ç”¨
        AttendanceRules rules = ruleEngine.getRulesForEmployee(request.getEmployeeId());

        // 3. è€ƒå‹¤è®°å½•è®¡ç®—
        AttendanceRecord record = calculator.calculateAttendance(deviceData, rules);

        // 4. å¼‚å¸¸æ£€æµ‹
        List<AttendanceAnomaly> anomalies = anomalyDetector.detectAnomalies(record);

        // 5. æŒä¹…åŒ–è€ƒå‹¤è®°å½•
        saveAttendanceRecord(record, anomalies);

        // 6. å®æ—¶é€šçŸ¥å¤„ç†
        sendRealTimeNotification(record, anomalies);

        return buildCheckResult(record, anomalies);
    }

    private void saveAttendanceRecord(AttendanceRecord record, List<AttendanceAnomaly> anomalies) {
        // æŒä¹…åŒ–è€ƒå‹¤è®°å½•
        attendanceRecordDao.insert(record);

        // æŒä¹…åŒ–å¼‚å¸¸è®°å½•
        if (!anomalies.isEmpty()) {
            for (AttendanceAnomaly anomaly : anomalies) {
                attendanceRecordDao.insertAnomaly(anomaly);
            }
        }
    }

    private void sendRealTimeNotification(AttendanceRecord record, List<AttendanceAnomaly> anomalies) {
        // å¼‚æ­¥å‘é€å®æ—¶é€šçŸ¥
        CompletableFuture.runAsync(() -> {
            try {
                // å‘é€è€ƒå‹¤æˆåŠŸé€šçŸ¥
                if (anomalies.isEmpty()) {
                    sendAttendanceNotification(record, "SUCCESS");
                } else {
                    sendAttendanceNotification(record, "ANOMALY_DETECTED");
                }
            } catch (Exception e) {
                log.error("[å®æ—¶é€šçŸ¥] å‘é€å¤±è´¥, recordId={}", record.getId(), e);
            }
        });
    }
}

// DAOå±‚ - æ•°æ®è®¿é—®
@Mapper
public interface AttendanceRecordDao extends BaseMapper<AttendanceRecordEntity> {

    @Transactional(readOnly = true)
    List<AttendanceRecordEntity> selectByEmployeeIdAndDateRange(
        @Param("employeeId") Long employeeId,
        @Param("startDate") LocalDate startDate,
        @Param("endDate") LocalDate endDate
    );

    @Transactional(readOnly = true)
    AttendanceRecordEntity selectLastCheckIn(@Param("employeeId") Long employeeId, @Param("checkDate") LocalDate checkDate);

    @Transactional(rollbackFor = Exception.class)
    int insertAnomaly(@Param("anomaly") AttendanceAnomalyEntity anomaly);

    @Transactional(readOnly = true)
    List<AttendanceStatisticsEntity> selectMonthlyStatistics(
        @Param("employeeId") Long employeeId,
        @Param("yearMonth") String yearMonth
    );
}

// å®ä½“ç±» - è€ƒå‹¤è®°å½•
@Data
@EqualsAndHashCode(callSuper = true)
@TableName("t_attendance_record")
public class AttendanceRecordEntity extends BaseEntity {

    @TableId(type = IdType.ASSIGN_ID)
    private String recordId;

    @TableField("employee_id")
    private Long employeeId;

    @TableField("check_type")
    private Integer checkType;  // 1-ä¸Šç­ 2-ä¸‹ç­

    @TableField("check_time")
    private LocalDateTime checkTime;

    @TableField("device_id")
    private String deviceId;

    @TableField("location")
    private String location;

    @TableField("biometric_data")
    private String biometricData;

    @TableField("work_shift_id")
    private Long workShiftId;

    @TableField("schedule_start_time")
    private LocalDateTime scheduleStartTime;

    @TableField("schedule_end_time")
    private LocalDateTime scheduleEndTime;

    @TableField("is_late")
    private Boolean isLate;

    @TableField("is_early_leave")
    private Boolean isEarlyLeave;

    @TableField("late_minutes")
    private Integer lateMinutes;

    @TableField("early_leave_minutes")
    private Integer earlyLeaveMinutes;

    @TableField("overtime_minutes")
    private Integer overtimeMinutes;

    @TableField("work_hours")
    private BigDecimal workHours;

    @TableField("attendance_status")
    private Integer attendanceStatus;  // 1-æ­£å¸¸ 2-è¿Ÿåˆ° 3-æ—©é€€ 4-æ—·å·¥ 5-å¼‚å¸¸

    @TableField("remark")
    private String remark;

    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;

    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;

    @TableLogic
    @TableField("deleted_flag")
    private Integer deletedFlag;

    @Version
    private Integer version;
}
```

### ğŸ“… æ™ºèƒ½æ’ç­ç®¡ç†
```java
// æ™ºèƒ½æ’ç­ç®¡ç† (Jakarta EE 3.0+)
import jakarta.annotation.Resource;
import jakarta.validation.Valid;
import jakarta.transaction.Transactional;

// Controllerå±‚ - RESTæ¥å£
@RestController
@RequestMapping("/api/v1/attendance/scheduling")
@Tag(name = "æ™ºèƒ½æ’ç­", description = "æ™ºèƒ½æ’ç­å’Œå·¥æ—¶ç®¡ç†")
public class SchedulingController {

    @Resource
    private SchedulingService schedulingService;

    /**
     * ç”Ÿæˆæœ€ä¼˜æ’ç­
     */
    @PostMapping("/generate")
    @PreAuthorize("hasRole('SCHEDULE_ADMIN')")
    @RateLimiter(name = "scheduling-generate", fallbackMethod = "generateFallback")
    @ApiOperation(value = "ç”Ÿæˆæ’ç­", notes = "æ™ºèƒ½ç”Ÿæˆæœ€ä¼˜æ’ç­æ–¹æ¡ˆ")
    public ResponseDTO<ScheduleResultDTO> generateOptimalSchedule(
            @Valid @RequestBody SchedulingRequestDTO request) {

        log.info("[æ™ºèƒ½æ’ç­] å¼€å§‹ç”Ÿæˆæ’ç­, departmentId={}, startDate={}, endDate={}",
                request.getDepartmentId(), request.getStartDate(), request.getEndDate());

        ScheduleResultDTO result = schedulingService.generateOptimalSchedule(request);

        log.info("[æ™ºèƒ½æ’ç­] æ’ç­ç”Ÿæˆå®Œæˆ, departmentId={}, scheduleCount={}, conflictsResolved={}",
                request.getDepartmentId(), result.getScheduleCount(), result.getConflictsResolved());

        return ResponseDTO.ok(result);
    }

    /**
     * æ’ç­å†²çªæ£€æµ‹
     */
    @PostMapping("/conflict-detect")
    @PreAuthorize("hasRole('SCHEDULE_ADMIN')")
    @ApiOperation(value = "å†²çªæ£€æµ‹", notes = "æ£€æµ‹æ’ç­å†²çª")
    public ResponseDTO<List<ScheduleConflictDTO>> detectConflicts(
            @Valid @RequestBody ConflictDetectionRequestDTO request) {

        List<ScheduleConflictDTO> conflicts = schedulingService.detectScheduleConflicts(request);

        return ResponseDTO.ok(conflicts);
    }

    // æœåŠ¡é™çº§å¤„ç†
    public ResponseDTO<ScheduleResultDTO> generateFallback(SchedulingRequestDTO request, Exception ex) {
        log.error("[æ™ºèƒ½æ’ç­] æœåŠ¡é™çº§, departmentId={}", request.getDepartmentId(), ex);
        return ResponseDTO.error("SERVICE_DEGRADED", "ç³»ç»Ÿç¹å¿™ï¼Œè¯·ç¨åé‡è¯•");
    }
}

// Serviceå±‚ - ä¸šåŠ¡é€»è¾‘å®ç°
@Service
@Transactional(rollbackFor = Exception.class)
public class SchedulingServiceImpl implements SchedulingService {

    @Resource
    private SchedulingManager schedulingManager;

    @Override
    public ScheduleResultDTO generateOptimalSchedule(SchedulingRequestDTO request) {
        try {
            // å‚æ•°éªŒè¯
            validateSchedulingRequest(request);

            // å§”æ‰˜ç»™Managerå±‚å¤„ç†å¤æ‚ä¸šåŠ¡é€»è¾‘
            ScheduleResult result = schedulingManager.generateOptimalSchedule(request);

            return convertToDTO(result);
        } catch (BusinessException e) {
            log.warn("[æ™ºèƒ½æ’ç­] ä¸šåŠ¡å¼‚å¸¸, departmentId={}, error={}", request.getDepartmentId(), e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("[æ™ºèƒ½æ’ç­] ç³»ç»Ÿå¼‚å¸¸, departmentId={}", request.getDepartmentId(), e);
            throw new BusinessException("SCHEDULING_ERROR", "æ’ç­ç”Ÿæˆå¤±è´¥");
        }
    }

    @Override
    public List<ScheduleConflictDTO> detectScheduleConflicts(ConflictDetectionRequestDTO request) {
        try {
            List<ScheduleConflict> conflicts = schedulingManager.detectScheduleConflicts(request);
            return conflicts.stream()
                    .map(this::convertConflictToDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            log.error("[å†²çªæ£€æµ‹] æ£€æµ‹å¤±è´¥", e);
            throw new BusinessException("CONFLICT_DETECTION_ERROR", "æ’ç­å†²çªæ£€æµ‹å¤±è´¥");
        }
    }

    private void validateSchedulingRequest(SchedulingRequestDTO request) {
        if (request.getDepartmentId() == null) {
            throw new BusinessException("DEPARTMENT_ID_REQUIRED", "éƒ¨é—¨IDä¸èƒ½ä¸ºç©º");
        }
        if (request.getStartDate() == null || request.getEndDate() == null) {
            throw new BusinessException("DATE_RANGE_REQUIRED", "å¼€å§‹æ—¶é—´å’Œç»“æŸæ—¶é—´ä¸èƒ½ä¸ºç©º");
        }
        if (request.getStartDate().isAfter(request.getEndDate())) {
            throw new BusinessException("INVALID_DATE_RANGE", "å¼€å§‹æ—¶é—´ä¸èƒ½æ™šäºç»“æŸæ—¶é—´");
        }
    }
}

// Managerå±‚ - å¤æ‚ä¸šåŠ¡æµç¨‹ç¼–æ’
public class SchedulingManagerImpl implements SchedulingManager {

    private final BusinessRulesAnalyzer businessRulesAnalyzer;
    private final EmployeeMatchingService employeeMatchingService;
    private final SchedulingOptimizer schedulingOptimizer;
    private final ConflictResolver conflictResolver;
    private final WorkShiftDao workShiftDao;
    private final EmployeeDao employeeDao;
    private final GatewayServiceClient gatewayServiceClient;

    // æ„é€ å‡½æ•°æ³¨å…¥ä¾èµ–
    public SchedulingManagerImpl(
            BusinessRulesAnalyzer businessRulesAnalyzer,
            EmployeeMatchingService employeeMatchingService,
            SchedulingOptimizer schedulingOptimizer,
            ConflictResolver conflictResolver,
            WorkShiftDao workShiftDao,
            EmployeeDao employeeDao,
            GatewayServiceClient gatewayServiceClient) {
        this.businessRulesAnalyzer = businessRulesAnalyzer;
        this.employeeMatchingService = employeeMatchingService;
        this.schedulingOptimizer = schedulingOptimizer;
        this.conflictResolver = conflictResolver;
        this.workShiftDao = workShiftDao;
        this.employeeDao = employeeDao;
        this.gatewayServiceClient = gatewayServiceClient;
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public ScheduleResult generateOptimalSchedule(SchedulingRequestDTO request) {
        // 1. ä¸šåŠ¡è§„åˆ™åˆ†æ
        BusinessRules rules = analyzeBusinessRules(request.getDepartmentId());

        // 2. å‘˜å·¥æŠ€èƒ½å’Œå¯ç”¨æ€§åŒ¹é…
        List<Employee> availableEmployees = findAvailableEmployees(request);

        // 3. æ™ºèƒ½æ’ç­ç®—æ³•
        Schedule schedule = optimizeScheduling(availableEmployees, rules, request);

        // 4. å†²çªæ£€æµ‹å’Œè§£å†³
        ConflictResolutionResult conflictResult = resolveScheduleConflicts(schedule);

        // 5. æ’ç­ç»“æœæŒä¹…åŒ–
        saveScheduleResult(schedule, conflictResult);

        // 6. å‘é€æ’ç­é€šçŸ¥
        sendScheduleNotification(schedule);

        return buildScheduleResult(schedule, conflictResult);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public List<ScheduleConflict> detectScheduleConflicts(ConflictDetectionRequestDTO request) {
        // è·å–å¾…æ£€æµ‹çš„æ’ç­æ•°æ®
        List<WorkShiftEntity> workShifts = getWorkShiftsForConflictDetection(request);

        List<ScheduleConflict> conflicts = new ArrayList<>();

        // 1. å‘˜å·¥æ—¶é—´å†²çªæ£€æµ‹
        conflicts.addAll(detectEmployeeTimeConflicts(workShifts));

        // 2. æŠ€èƒ½åŒ¹é…å†²çªæ£€æµ‹
        conflicts.addAll(detectSkillMatchingConflicts(workShifts));

        // 3. å·¥æ—¶åˆè§„å†²çªæ£€æµ‹
        conflicts.addAll(detectWorkHourComplianceConflicts(workShifts));

        // 4. èµ„æºåˆ†é…å†²çªæ£€æµ‹
        conflicts.addAll(detectResourceAllocationConflicts(workShifts));

        return conflicts;
    }

    private BusinessRules analyzeBusinessRules(Long departmentId) {
        // é€šè¿‡ç½‘å…³è°ƒç”¨OAæœåŠ¡è·å–éƒ¨é—¨ä¸šåŠ¡è§„åˆ™
        ResponseDTO<DepartmentRulesDTO> result = gatewayServiceClient.callOAService(
            "/api/v1/department/" + departmentId + "/scheduling-rules",
            HttpMethod.GET,
            null,
            DepartmentRulesDTO.class
        );

        if (result.getCode() == 200) {
            return businessRulesAnalyzer.analyzeRules(result.getData());
        }

        throw new BusinessException("DEPARTMENT_RULES_NOT_FOUND", "éƒ¨é—¨æ’ç­è§„åˆ™æœªæ‰¾åˆ°");
    }

    private List<Employee> findAvailableEmployees(SchedulingRequestDTO request) {
        // é€šè¿‡ç½‘å…³è°ƒç”¨å…¬å…±æœåŠ¡è·å–å‘˜å·¥ä¿¡æ¯
        ResponseDTO<List<EmployeeDTO>> result = gatewayServiceClient.callCommonService(
            "/api/v1/employee/available-for-scheduling",
            HttpMethod.POST,
            Map.of(
                "departmentId", request.getDepartmentId(),
                "startDate", request.getStartDate(),
                "endDate", request.getEndDate(),
                "requiredSkills", request.getRequiredSkills()
            ),
            new ParameterizedTypeReference<ResponseDTO<List<EmployeeDTO>>>() {}
        );

        if (result.getCode() == 200) {
            return employeeMatchingService.matchEmployees(result.getData(), request.getRequiredSkills());
        }

        throw new BusinessException("EMPLOYEE_QUERY_FAILED", "å‘˜å·¥ä¿¡æ¯æŸ¥è¯¢å¤±è´¥");
    }

    private Schedule optimizeScheduling(List<Employee> employees, BusinessRules rules, SchedulingRequestDTO request) {
        SchedulingOptimizationRequest optimizationRequest = SchedulingOptimizationRequest.builder()
            .employees(employees)
            .businessRules(rules)
            .timeRange(TimeRange.builder()
                .startDate(request.getStartDate())
                .endDate(request.getEndDate())
                .build())
            .constraints(request.getConstraints())
            .build();

        return schedulingOptimizer.optimize(optimizationRequest);
    }

    private ConflictResolutionResult resolveScheduleConflicts(Schedule schedule) {
        List<ScheduleConflict> conflicts = detectScheduleConflicts(
            ConflictDetectionRequestDTO.builder()
                .workShiftIds(schedule.getWorkShiftIds())
                .build()
        );

        if (conflicts.isEmpty()) {
            return ConflictResolutionResult.success();
        }

        return conflictResolver.resolveConflicts(schedule, conflicts);
    }

    private void saveScheduleResult(Schedule schedule, ConflictResolutionResult conflictResult) {
        // æ‰¹é‡ä¿å­˜ç­æ¬¡ä¿¡æ¯
        List<WorkShiftEntity> workShifts = schedule.getWorkShifts();
        if (!workShifts.isEmpty()) {
            workShiftDao.insertBatch(workShifts);
        }

        // ä¿å­˜å†²çªè§£å†³è®°å½•
        if (!conflictResult.getResolvedConflicts().isEmpty()) {
            workShiftDao.insertConflictResolutionBatch(conflictResult.getResolvedConflicts());
        }
    }

    private void sendScheduleNotification(Schedule schedule) {
        // å¼‚æ­¥å‘é€æ’ç­é€šçŸ¥
        CompletableFuture.runAsync(() -> {
            try {
                // å‘é€æ’ç­é€šçŸ¥ç»™ç›¸å…³å‘˜å·¥
                for (Employee employee : schedule.getAssignedEmployees()) {
                    sendScheduleNotificationToEmployee(employee, schedule);
                }
            } catch (Exception e) {
                log.error("[æ’ç­é€šçŸ¥] å‘é€å¤±è´¥, scheduleId={}", schedule.getId(), e);
            }
        });
    }
}

// DAOå±‚ - æ•°æ®è®¿é—®
@Mapper
public interface WorkShiftDao extends BaseMapper<WorkShiftEntity> {

    @Transactional(readOnly = true)
    List<WorkShiftEntity> selectByDepartmentIdAndDateRange(
        @Param("departmentId") Long departmentId,
        @Param("startDate") LocalDate startDate,
        @Param("endDate") LocalDate endDate
    );

    @Transactional(readOnly = true)
    List<WorkShiftEntity> selectByEmployeeIdAndDateRange(
        @Param("employeeId") Long employeeId,
        @Param("startDate") LocalDate startDate,
        @Param("endDate") LocalDate endDate
    );

    @Transactional(rollbackFor = Exception.class)
    int insertBatch(@Param("workShifts") List<WorkShiftEntity> workShifts);

    @Transactional(rollbackFor = Exception.class)
    int insertConflictResolutionBatch(@Param("resolutions") List<ConflictResolutionEntity> resolutions);

    @Transactional(readOnly = true)
    List<ConflictStatisticsEntity> selectConflictStatistics(
        @Param("departmentId") Long departmentId,
        @Param("startDate") LocalDate startDate,
        @Param("endDate") LocalDate endDate
    );
}

// å®ä½“ç±» - å·¥ä½œç­æ¬¡
@Data
@EqualsAndHashCode(callSuper = true)
@TableName("t_work_shift")
public class WorkShiftEntity extends BaseEntity {

    @TableId(type = IdType.ASSIGN_ID)
    private String shiftId;

    @TableField("shift_name")
    private String shiftName;

    @TableField("department_id")
    private Long departmentId;

    @TableField("employee_id")
    private Long employeeId;

    @TableField("shift_date")
    private LocalDate shiftDate;

    @TableField("start_time")
    private LocalTime startTime;

    @TableField("end_time")
    private LocalTime endTime;

    @TableField("break_duration")
    private Integer breakDuration;  // ä¼‘æ¯æ—¶é•¿(åˆ†é’Ÿ)

    @TableField("work_hours")
    private BigDecimal workHours;

    @TableField("shift_type")
    private Integer shiftType;  // 1-æ­£å¸¸ç­ 2-å¤œç­ 3-åŠ ç­ 4-ä¸´æ—¶

    @TableField("skill_requirements")
    private String skillRequirements;  // æŠ€èƒ½è¦æ±‚(JSONæ ¼å¼)

    @TableField("priority_level")
    private Integer priorityLevel;  // ä¼˜å…ˆçº§

    @TableField("auto_generated")
    private Boolean autoGenerated;  // æ˜¯å¦è‡ªåŠ¨ç”Ÿæˆ

    @TableField("conflict_resolved")
    private Boolean conflictResolved;  // å†²çªæ˜¯å¦å·²è§£å†³

    @TableField("status")
    private Integer status;  // 1-æ­£å¸¸ 2-å·²å–æ¶ˆ 3-å·²ä¿®æ”¹

    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;

    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;

    @TableLogic
    @TableField("deleted_flag")
    private Integer deletedFlag;

    @Version
    private Integer version;
}
```

### ğŸ“Š ç»Ÿè®¡åˆ†ææŠ¥è¡¨
```java
@Service
public class AttendanceReportService {

    public AttendanceStatistics generateStatistics(ReportRequest request) {
        // 1. æ•°æ®èšåˆè®¡ç®—
        Map<String, Object> rawData = aggregateAttendanceData(request);

        // 2. å¤šç»´åº¦åˆ†æ
        MultiDimensionAnalysis analysis = performMultiDimensionAnalysis(rawData);

        // 3. è¶‹åŠ¿åˆ†æ
        TrendAnalysis trends = calculateTrends(rawData, request.getTimeRange());

        // 4. åˆè§„æ€§æ£€æŸ¥
        ComplianceCheck compliance = checkLaborLawCompliance(rawData);

        return buildComprehensiveReport(analysis, trends, compliance);
    }
}
```

---

## ğŸ”§ æŠ€æœ¯æ ˆå’Œå·¥å…·

### æ ¸å¿ƒæŠ€æœ¯
- **Spring Boot 3.x**: å¾®æœåŠ¡æ¡†æ¶
- **Spring Batch**: æ‰¹å¤„ç†æ¡†æ¶ï¼ˆè€ƒå‹¤æ•°æ®æ‰¹é‡å¤„ç†ï¼‰
- **Quartz**: å®šæ—¶ä»»åŠ¡è°ƒåº¦
- **Redis**: ç¼“å­˜å’Œåˆ†å¸ƒå¼é”
- **Elasticsearch**: å¤§æ•°æ®æœç´¢å’Œåˆ†æ

### æ•°æ®å¤„ç†
- **Apache Kafka**: è€ƒå‹¤äº‹ä»¶æµå¤„ç†
- **Apache Flink**: å®æ—¶æµè®¡ç®—
- **Apache Spark**: å¤§æ•°æ®æ‰¹é‡åˆ†æ
- **ClickHouse**: æ—¶åºæ•°æ®åº“ï¼ˆè€ƒå‹¤æ•°æ®å­˜å‚¨ï¼‰

### ç®—æ³•åº“
- **æ—¶é—´åºåˆ—åˆ†æ**: è€ƒå‹¤è¶‹åŠ¿åˆ†æå’Œé¢„æµ‹
- **ä¼˜åŒ–ç®—æ³•**: æ’ç­ä¼˜åŒ–å’Œèµ„æºåˆ†é…
- **æœºå™¨å­¦ä¹ **: å¼‚å¸¸æ£€æµ‹å’Œæ¨¡å¼è¯†åˆ«
- **ç»Ÿè®¡è®¡ç®—**: å¤šç»´åº¦ç»Ÿè®¡åˆ†æå’ŒæŠ¥è¡¨

---

## ğŸ“Š æ€§èƒ½æŒ‡æ ‡

### å“åº”æ—¶é—´è¦æ±‚
- **è€ƒå‹¤æ‰“å¡å¤„ç†**: â‰¤ 1s (95%åˆ†ä½)
- **æ’ç­è®¡ç®—**: â‰¤ 30s (95%åˆ†ä½)
- **æŠ¥è¡¨ç”Ÿæˆ**: â‰¤ 10s (95%åˆ†ä½)
- **æ•°æ®å¯¼å‡º**: â‰¤ 60s (95%åˆ†ä½)

### æ•°æ®å¤„ç†èƒ½åŠ›
- **å¹¶å‘æ‰“å¡æ•°**: â‰¥ 50,000/åˆ†é’Ÿ
- **æ’ç­ç®—æ³•å¤„ç†**: â‰¥ 10,000å‘˜å·¥/æ¬¡
- **æŠ¥è¡¨æ•°æ®é‡**: â‰¥ 1äº¿æ¡è€ƒå‹¤è®°å½•
- **å®æ—¶åˆ†æå»¶è¿Ÿ**: â‰¤ 5s

### å­˜å‚¨å’ŒæŸ¥è¯¢
- **è€ƒå‹¤è®°å½•å­˜å‚¨**: æ”¯æŒè‡³å°‘5å¹´æ•°æ®
- **æŸ¥è¯¢å“åº”æ—¶é—´**: â‰¤ 2s (å¤æ‚æŸ¥è¯¢)
- **æ•°æ®å‹ç¼©ç‡**: â‰¥ 70%
- **å¤‡ä»½æ¢å¤æ—¶é—´**: â‰¤ 2h

---

## ğŸ“‹ æ ¸å¿ƒä¸šåŠ¡è§„åˆ™

### è€ƒå‹¤è§„åˆ™å¼•æ“
```java
@Component
public class AttendanceRuleEngine {

    public AttendanceRules getRulesForEmployee(Long employeeId) {
        // 1. è·å–å‘˜å·¥åŸºç¡€ä¿¡æ¯
        Employee employee = employeeService.getById(employeeId);

        // 2. è·å–éƒ¨é—¨è€ƒå‹¤åˆ¶åº¦
        DepartmentAttendanceConfig config = departmentService.getAttendanceConfig(employee.getDepartmentId());

        // 3. æ„å»ºä¸ªæ€§åŒ–è§„åˆ™
        return AttendanceRules.builder()
                .workSchedule(config.getWorkSchedule())
                .flexibleRules(config.getFlexibleRules())
                .overtimeRules(config.getOvertimeRules())
                .leaveRules(config.getLeaveRules())
                .build();
    }

    public boolean validateAttendance(AttendanceRecord record, AttendanceRules rules) {
        // 1. å·¥ä½œæ—¶é—´éªŒè¯
        if (!isWithinWorkHours(record.getCheckTime(), rules.getWorkSchedule())) {
            return false;
        }

        // 2. åœ°ç†ä½ç½®éªŒè¯
        if (rules.isLocationRestrictionEnabled()) {
            if (!isValidLocation(record.getLocation(), rules.getAllowedLocations())) {
                return false;
            }
        }

        // 3. è®¾å¤‡æœ‰æ•ˆæ€§éªŒè¯
        if (!isValidDevice(record.getDeviceId(), rules.getAllowedDevices())) {
            return false;
        }

        return true;
    }
}
```

### å¼‚å¸¸æ£€æµ‹ç®—æ³•
```java
@Component
public class AnomalyDetector {

    public List<AttendanceAnomaly> detectAnomalies(AttendanceRecord record) {
        List<AttendanceAnomaly> anomalies = new ArrayList<>();

        // 1. æ—¶é—´å¼‚å¸¸æ£€æµ‹
        if (isTimeAnomaly(record)) {
            anomalies.add(new TimeAnomaly(record));
        }

        // 2. è¡Œä¸ºå¼‚å¸¸æ£€æµ‹
        if (isBehaviorAnomaly(record)) {
            anomalies.add(new BehaviorAnomaly(record));
        }

        // 3. è®¾å¤‡å¼‚å¸¸æ£€æµ‹
        if (isDeviceAnomaly(record)) {
            anomalies.add(new DeviceAnomaly(record));
        }

        return anomalies;
    }

    private boolean isTimeAnomaly(AttendanceRecord record) {
        // ä½¿ç”¨æœºå™¨å­¦ä¹ æ¨¡å‹æ£€æµ‹æ—¶é—´å¼‚å¸¸
        double anomalyScore = timeAnomalyModel.predict(record);
        return anomalyScore > ANOMALY_THRESHOLD;
    }
}
```

---

## ğŸ“ˆ ç»Ÿè®¡åˆ†æåŠŸèƒ½

### å¤šç»´åº¦åˆ†æ
```java
@Service
public class AttendanceAnalysisService {

    public AnalysisResult performMultiDimensionAnalysis(AnalysisRequest request) {
        // 1. æ—¶é—´ç»´åº¦åˆ†æï¼ˆæ—¥ã€å‘¨ã€æœˆã€å­£ã€å¹´ï¼‰
        TimeAnalysis timeAnalysis = analyzeTimeDimension(request);

        // 2. ç»„ç»‡ç»´åº¦åˆ†æï¼ˆéƒ¨é—¨ã€å›¢é˜Ÿã€ä¸ªäººï¼‰
        OrganizationAnalysis orgAnalysis = analyzeOrganizationDimension(request);

        // 3. ä¸šåŠ¡ç»´åº¦åˆ†æï¼ˆå‡ºå‹¤ç‡ã€åŠ ç­ç‡ã€è¯·å‡ç‡ï¼‰
        BusinessAnalysis businessAnalysis = analyzeBusinessDimension(request);

        // 4. è¶‹åŠ¿ç»´åº¦åˆ†æï¼ˆåŒæ¯”ã€ç¯æ¯”ã€é¢„æµ‹ï¼‰
        TrendAnalysis trendAnalysis = analyzeTrendDimension(request);

        return AnalysisResult.builder()
                .timeAnalysis(timeAnalysis)
                .organizationAnalysis(orgAnalysis)
                .businessAnalysis(businessAnalysis)
                .trendAnalysis(trendAnalysis)
                .build();
    }
}
```

### å¯è§†åŒ–æŠ¥è¡¨
```java
@RestController
@RequestMapping("/api/v1/attendance/reports")
public class AttendanceReportController {

    @PostMapping("/dashboard")
    public ResponseDTO<DashboardData> generateDashboard(@Valid @RequestBody DashboardRequest request) {
        DashboardData dashboard = reportService.generateDashboard(request);
        return ResponseDTO.ok(dashboard);
    }

    @PostMapping("/export")
    public ResponseDTO<byte[]> exportReport(@Valid @RequestBody ExportRequest request) {
        byte[] reportData = reportService.exportReport(request);
        return ResponseDTO.ok(reportData);
    }
}
```

---

## ğŸ›¡ï¸ æ•°æ®å®‰å…¨å’Œåˆè§„

### æ•°æ®éšç§ä¿æŠ¤
```java
@Entity
public class AttendanceRecord {

    @Convert(converter = EncryptedStringConverter.class)
    private String deviceId;        // è®¾å¤‡IDåŠ å¯†

    @Column(columnDefinition = "POINT")
    private Point location;          // åœ°ç†ä½ç½®è„±æ•å­˜å‚¨

    @Convert(converter = EncryptedStringConverter.class)
    private String employeePhoto;     // å‘˜å·¥ç…§ç‰‡åŠ å¯†
}

// APIæ•°æ®è„±æ•
@RestController
public class AttendanceController {

    @GetMapping("/records")
    public ResponseDTO<List<AttendanceRecordDTO>> getRecords(AttendanceQueryRequest request) {
        List<AttendanceRecord> records = attendanceService.queryRecords(request);

        // æ•°æ®è„±æ•å¤„ç†
        List<AttendanceRecordDTO> dtoRecords = records.stream()
                .map(this::maskSensitiveData)
                .collect(Collectors.toList());

        return ResponseDTO.ok(dtoRecords);
    }

    private AttendanceRecordDTO maskSensitiveData(AttendanceRecord record) {
        AttendanceRecordDTO dto = new AttendanceRecordDTO(record);
        dto.setDeviceId(maskDeviceId(record.getDeviceId()));
        dto.setLocation(maskLocation(record.getLocation()));
        return dto;
    }
}
```

### åˆè§„æ€§æ£€æŸ¥
```java
@Service
public class ComplianceCheckService {

    public ComplianceReport checkLaborLawCompliance(ComplianceCheckRequest request) {
        // 1. å·¥æ—¶åˆè§„æ£€æŸ¥
        WorkHourCompliance workHourCompliance = checkWorkHourCompliance(request);

        // 2. åŠ ç­æ—¶é—´åˆè§„æ£€æŸ¥
        OvertimeCompliance overtimeCompliance = checkOvertimeCompliance(request);

        // 3. ä¼‘å‡æƒç›Šåˆè§„æ£€æŸ¥
        LeaveCompliance leaveCompliance = checkLeaveCompliance(request);

        return ComplianceReport.builder()
                .workHourCompliance(workHourCompliance)
                .overtimeCompliance(overtimeCompliance)
                .leaveCompliance(leaveCompliance)
                .overallScore(calculateOverallComplianceScore(workHourCompliance, overtimeCompliance, leaveCompliance))
                .build();
    }
}
```

---

## ğŸ“‹ å¼€å‘æ£€æŸ¥æ¸…å•

### åŠŸèƒ½å¼€å‘æ£€æŸ¥
- [ ] è€ƒå‹¤è§„åˆ™å¼•æ“å®ç°
- [ ] å¤šè®¾å¤‡æ•°æ®èåˆ
- [ ] æ™ºèƒ½æ’ç­ç®—æ³•
- [ ] å¼‚å¸¸æ£€æµ‹ç³»ç»Ÿ
- [ ] ç»Ÿè®¡åˆ†ææŠ¥è¡¨

### æ€§èƒ½æ£€æŸ¥
- [ ] å¤§æ•°æ®é‡å¤„ç†ä¼˜åŒ–
- [ ] å®æ—¶è®¡ç®—æ€§èƒ½
- [ ] æ•°æ®åº“ç´¢å¼•ä¼˜åŒ–
- [ ] ç¼“å­˜ç­–ç•¥å®ç°
- [ ] å¹¶å‘å¤„ç†èƒ½åŠ›

### åˆè§„æ€§æ£€æŸ¥
- [ ] æ•°æ®è„±æ•å®ç°
- [ ] éšç§ä¿æŠ¤æªæ–½
- [ ] åŠ³åŠ¨æ³•è§„åˆè§„
- [ ] å®¡è®¡æ—¥å¿—è®°å½•
- [ ] æ•°æ®åŠ å¯†å­˜å‚¨

---

## ğŸ”— ç›¸å…³æŠ€èƒ½æ–‡æ¡£

- **scheduling-algorithm-specialist**: æ’ç­ç®—æ³•ä¸“å®¶
- **data-processing-specialist**: æ•°æ®å¤„ç†ä¸“å®¶
- **security-protection-specialist**: å®‰å…¨é˜²æŠ¤ä¸“å®¶
- **performance-optimization-specialist**: æ€§èƒ½ä¼˜åŒ–ä¸“å®¶
- **compliance-check-specialist**: åˆè§„æ£€æŸ¥ä¸“å®¶

---

## ğŸ“ è”ç³»å’Œæ”¯æŒ

**æŠ€èƒ½è´Ÿè´£äºº**: è€ƒå‹¤æœåŠ¡å¼€å‘å›¢é˜Ÿ
**æŠ€æœ¯æ”¯æŒ**: æ¶æ„å¸ˆå›¢é˜Ÿ + åˆè§„å›¢é˜Ÿ
**é—®é¢˜åé¦ˆ**: é€šè¿‡é¡¹ç›®ç®¡ç†ç³»ç»Ÿæäº¤

**ç‰ˆæœ¬ä¿¡æ¯**:
- **åˆ›å»ºæ—¶é—´**: 2025-12-02
- **æœ€åæ›´æ–°**: 2025-12-02
- **ç‰ˆæœ¬**: v1.0.0

---

**ğŸ’¡ é‡è¦æé†’**: æœ¬æŠ€èƒ½ä¸“æ³¨äºè€ƒå‹¤ç®¡ç†çš„æ ¸å¿ƒä¸šåŠ¡ï¼Œéœ€è¦ç»“åˆæ’ç­ç®—æ³•ã€æ•°æ®å¤„ç†ã€æ€§èƒ½ä¼˜åŒ–ç­‰ç›¸å…³æŠ€èƒ½ä¸€èµ·ä½¿ç”¨ï¼Œç¡®ä¿ç³»ç»Ÿçš„å‡†ç¡®æ€§å’Œé«˜æ€§èƒ½ã€‚