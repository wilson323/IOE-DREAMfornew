# ç”Ÿç‰©è¯†åˆ«æœåŠ¡ä¸“å®¶æŠ€èƒ½
## Biometric Service Specialist

**ğŸ¯ æŠ€èƒ½å®šä½**: IOE-DREAMæ™ºæ…§å›­åŒºç”Ÿç‰©è¯†åˆ«ä¸šåŠ¡ä¸“å®¶ï¼Œç²¾é€šæ¨¡æ¿ç®¡ç†ã€ç‰¹å¾æå–ã€è®¾å¤‡åŒæ­¥ã€æƒé™æ§åˆ¶ã€å®‰å…¨é˜²æŠ¤ç­‰æ ¸å¿ƒç”Ÿç‰©è¯†åˆ«åŠŸèƒ½

**âš¡ æŠ€èƒ½ç­‰çº§**: â˜…â˜…â˜…â˜…â˜…â˜… (é¡¶çº§ä¸“å®¶)
**ğŸ¯ é€‚ç”¨åœºæ™¯**: ç”Ÿç‰©è¯†åˆ«ç³»ç»Ÿå¼€å‘ã€æ¨¡æ¿ç®¡ç†ã€è®¾å¤‡é›†æˆã€æƒé™æ§åˆ¶ã€å®‰å…¨é˜²æŠ¤
**ğŸ“Š æŠ€èƒ½è¦†ç›–**: æ¨¡æ¿ç®¡ç† | ç‰¹å¾æå– | è®¾å¤‡åŒæ­¥ | æƒé™æ§åˆ¶ | å®‰å…¨é˜²æŠ¤ | æ€§èƒ½ä¼˜åŒ–
**ğŸ”§ æŠ€æœ¯æ ˆ**: Spring Boot 3.5.8 + Redis + RabbitMQ + AIç®—æ³•SDK + è®¾å¤‡åè®®

---

## ğŸ“‹ æŠ€èƒ½æ¦‚è¿°

### **æ ¸å¿ƒä¸“é•¿**
- **æ¨¡æ¿ç®¡ç†ä½“ç³»**: ç”Ÿç‰©ç‰¹å¾æ¨¡æ¿æå–ã€å­˜å‚¨ã€ç‰ˆæœ¬ç®¡ç†ã€ç”Ÿå‘½å‘¨æœŸæ§åˆ¶
- **ç‰¹å¾æå–ç®—æ³•**: äººè„¸ã€æŒ‡çº¹ã€è™¹è†œã€æŒçº¹ç­‰å¤šç§ç”Ÿç‰©ç‰¹å¾è¯†åˆ«ç®—æ³•
- **è®¾å¤‡åŒæ­¥æœºåˆ¶**: æ¨¡æ¿ä¸‹å‘ç”Ÿç‰©è¯†åˆ«è®¾å¤‡ã€è®¾å¤‡çŠ¶æ€ç›‘æ§ã€æƒé™åŒæ­¥
- **æƒé™è”åŠ¨æ§åˆ¶**: åŸºäºç”¨æˆ·æƒé™çš„æ¨¡æ¿åˆ†å‘ã€è®¾å¤‡è®¿é—®æ§åˆ¶ã€åŒºåŸŸé™åˆ¶
- **å®‰å…¨é˜²æŠ¤ä½“ç³»**: ç”Ÿç‰©ç‰¹å¾åŠ å¯†ä¼ è¾“ã€æ¨¡æ¿å®‰å…¨å­˜å‚¨ã€é˜²ç¯¡æ”¹æœºåˆ¶
- **é«˜æ€§èƒ½å¤„ç†**: é«˜å¹¶å‘ç‰¹å¾æå–ã€æ‰¹é‡æ¨¡æ¿å¤„ç†ã€å®æ—¶æ€§èƒ½ç›‘æ§

### **è§£å†³èƒ½åŠ›**
- **ç”Ÿç‰©è¯†åˆ«ç³»ç»Ÿ**: å®Œæ•´çš„ä¼ä¸šçº§ç”Ÿç‰©è¯†åˆ«ç®¡ç†ç³»ç»Ÿå®ç°
- **æ¨¡æ¿ç®¡ç†å¹³å°**: ç»Ÿä¸€çš„å¤šæ¨¡æ€ç”Ÿç‰©ç‰¹å¾æ¨¡æ¿ç®¡ç†
- **è®¾å¤‡é›†æˆå¹³å°**: å¤šå‚å•†ç”Ÿç‰©è¯†åˆ«è®¾å¤‡çš„ç»Ÿä¸€æ¥å…¥å’Œç®¡ç†
- **æƒé™æ§åˆ¶ç³»ç»Ÿ**: åŸºäºç”Ÿç‰©è¯†åˆ«çš„è®¿é—®æ§åˆ¶å’Œæƒé™ç®¡ç†
- **å®‰å…¨è®¤è¯ä½“ç³»**: å¤šé‡ç”Ÿç‰©è¯†åˆ«å› å­å’Œå®‰å…¨è®¤è¯æœºåˆ¶

---

## ğŸ¯ ä¸šåŠ¡åœºæ™¯è¦†ç›–

### ğŸ§¬ æ¨¡æ¿ç®¡ç†ç³»ç»Ÿ

```java
// ç”Ÿç‰©ç‰¹å¾æ¨¡æ¿ç®¡ç†æ ¸å¿ƒæµç¨‹
@Service
@Transactional(rollbackFor = Exception.class)
public class BiometricTemplateServiceImpl implements BiometricTemplateService {

    @Resource
    private BiometricTemplateManager templateManager;

    @Resource
    private FeatureExtractionService featureExtractionService;

    @Resource
    private DeviceSyncService deviceSyncService;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public BiometricTemplateVO createTemplate(CreateTemplateRequestDTO request) {
        try {
            // 1. éªŒè¯ç”¨æˆ·å’Œç”Ÿç‰©ç‰¹å¾ç±»å‹
            validateUserAndBiometricType(request.getUserId(), request.getBiometricType());

            // 2. æå–ç”Ÿç‰©ç‰¹å¾å‘é‡
            BiometricFeatureVector featureVector = featureExtractionService.extractFeature(
                request.getBiometricData(), request.getBiometricType());

            // 3. åˆ›å»ºæ¨¡æ¿è®°å½•
            BiometricTemplateEntity template = createTemplateEntity(request, featureVector);
            biometricTemplateDao.insert(template);

            // 4. ç”Ÿæˆæ¨¡æ¿ç‰ˆæœ¬
            templateManager.generateTemplateVersion(template.getTemplateId());

            // 5. æŸ¥æ‰¾ç”¨æˆ·æœ‰æƒé™çš„è®¾å¤‡
            List<DeviceEntity> authorizedDevices = getAuthorizedDevices(request.getUserId());

            // 6. åŒæ­¥æ¨¡æ¿åˆ°è®¾å¤‡
            deviceSyncService.syncTemplateToDevices(template, authorizedDevices);

            // 7. æ›´æ–°ç”¨æˆ·ç”Ÿç‰©è¯†åˆ«çŠ¶æ€
            updateUserBiometricStatus(request.getUserId(), request.getBiometricType(), true);

            // 8. å‘é€æ¨¡æ¿åˆ›å»ºäº‹ä»¶
            publishTemplateCreatedEvent(template);

            return convertToTemplateVO(template);

        } catch (Exception e) {
            log.error("ç”Ÿç‰©æ¨¡æ¿åˆ›å»ºå¤±è´¥: userId={}, biometricType={}",
                request.getUserId(), request.getBiometricType(), e);
            throw new BusinessException(ErrorCode.BIOMETRIC_TEMPLATE_CREATE_FAILED,
                "ç”Ÿç‰©æ¨¡æ¿åˆ›å»ºå¤±è´¥", e);
        }
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void deleteTemplate(Long templateId, Long userId) {
        try {
            // 1. éªŒè¯æ¨¡æ¿å½’å±å’Œæƒé™
            BiometricTemplateEntity template = validateTemplateOwnership(templateId, userId);

            // 2. ä»æ‰€æœ‰è®¾å¤‡ä¸­åˆ é™¤æ¨¡æ¿
            deviceSyncService.deleteTemplateFromAllDevices(templateId);

            // 3. æ ‡è®°æ¨¡æ¿ä¸ºå·²åˆ é™¤
            template.setStatus(TemplateStatusEnum.DELETED.getCode());
            biometricTemplateDao.updateById(template);

            // 4. æ›´æ–°æ¨¡æ¿ç‰ˆæœ¬
            templateManager.archiveTemplateVersion(templateId);

            // 5. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦è¿˜æœ‰å…¶ä»–æ¨¡æ¿
            if (!hasActiveTemplates(userId, template.getBiometricType())) {
                updateUserBiometricStatus(userId, template.getBiometricType(), false);
            }

            // 6. å‘é€æ¨¡æ¿åˆ é™¤äº‹ä»¶
            publishTemplateDeletedEvent(template);

        } catch (Exception e) {
            log.error("ç”Ÿç‰©æ¨¡æ¿åˆ é™¤å¤±è´¥: templateId={}, userId={}", templateId, userId, e);
            throw new BusinessException(ErrorCode.BIOMETRIC_TEMPLATE_DELETE_FAILED,
                "ç”Ÿç‰©æ¨¡æ¿åˆ é™¤å¤±è´¥", e);
        }
    }
}
```

### ğŸ” ç‰¹å¾æå–ä¸éªŒè¯

```java
// ç”Ÿç‰©ç‰¹å¾æå–å’ŒéªŒè¯å¼•æ“
@Service
public class BiometricFeatureExtractionService {

    @Resource
    private FaceRecognitionEngine faceRecognitionEngine;

    @Resource
    private FingerprintRecognitionEngine fingerprintEngine;

    @Resource
    private IrisRecognitionEngine irisRecognitionEngine;

    @Resource
    private PalmPrintRecognitionEngine palmPrintEngine;

    @Resource
    private TemplateQualityChecker qualityChecker;

    /**
     * æå–ç”Ÿç‰©ç‰¹å¾å‘é‡
     */
    public BiometricFeatureVector extractFeature(byte[] biometricData,
                                                 BiometricTypeEnum biometricType) {
        try {
            // 1. æ•°æ®é¢„å¤„ç†
            byte[] processedData = preprocessBiometricData(biometricData, biometricType);

            // 2. è´¨é‡æ£€æŸ¥
            QualityCheckResult qualityResult = qualityChecker.checkQuality(processedData, biometricType);
            if (!qualityResult.isAcceptable()) {
                throw new BusinessException(ErrorCode.BIOMETRIC_QUALITY_LOW,
                    "ç”Ÿç‰©ç‰¹å¾è´¨é‡è¿‡ä½: " + qualityResult.getFailureReason());
            }

            // 3. ç‰¹å¾æå–
            BiometricFeatureVector featureVector;
            switch (biometricType) {
                case FACE:
                    featureVector = faceRecognitionEngine.extractFeature(processedData);
                    break;
                case FINGERPRINT:
                    featureVector = fingerprintEngine.extractFeature(processedData);
                    break;
                case IRIS:
                    featureVector = irisRecognitionEngine.extractFeature(processedData);
                    break;
                case PALM_PRINT:
                    featureVector = palmPrintEngine.extractFeature(processedData);
                    break;
                default:
                    throw new BusinessException(ErrorCode.BIOMETRIC_TYPE_NOT_SUPPORTED,
                        "ä¸æ”¯æŒçš„ç”Ÿç‰©è¯†åˆ«ç±»å‹: " + biometricType);
            }

            // 4. ç‰¹å¾éªŒè¯
            validateFeatureVector(featureVector, biometricType);

            // 5. ç‰¹å¾åŠ å¯†
            byte[] encryptedFeature = encryptFeature(featureVector.getData());

            return BiometricFeatureVector.builder()
                .biometricType(biometricType)
                .featureData(encryptedFeature)
                .featureLength(featureVector.getData().length)
                .algorithmVersion(getCurrentAlgorithmVersion(biometricType))
                .qualityScore(qualityResult.getQualityScore())
                .extractTime(LocalDateTime.now())
                .build();

        } catch (Exception e) {
            log.error("ç”Ÿç‰©ç‰¹å¾æå–å¤±è´¥: biometricType={}", biometricType, e);
            throw new BusinessException(ErrorCode.BIOMETRIC_FEATURE_EXTRACTION_FAILED,
                "ç”Ÿç‰©ç‰¹å¾æå–å¤±è´¥", e);
        }
    }

    /**
     * 1:N ç”Ÿç‰©è¯†åˆ«éªŒè¯
     */
    public BiometricMatchResult verifyOneToN(byte[] biometricData,
                                             List<BiometricTemplateEntity> candidateTemplates) {
        try {
            // 1. æå–æŸ¥è¯¢ç‰¹å¾
            BiometricFeatureVector queryFeature = extractFeature(
                biometricData, candidateTemplates.get(0).getBiometricType());

            // 2. å¹¶è¡ŒåŒ¹é…
            List<BiometricMatchResult> matchResults = candidateTemplates.parallelStream()
                .map(template -> matchFeature(queryFeature, template))
                .sorted((a, b) -> Double.compare(b.getSimilarity(), a.getSimilarity()))
                .collect(Collectors.toList());

            // 3. è·å–æœ€ä½³åŒ¹é…
            BiometricMatchResult bestMatch = matchResults.get(0);

            // 4. åˆ¤æ–­æ˜¯å¦åŒ¹é…æˆåŠŸ
            boolean isMatched = bestMatch.getSimilarity() >= getMatchingThreshold(
                queryFeature.getBiometricType());

            return bestMatch.toBuilder()
                .isMatched(isMatched)
                .totalCandidates(candidateTemplates.size())
                .processingTime(System.currentTimeMillis())
                .build();

        } catch (Exception e) {
            log.error("1:Nç”Ÿç‰©è¯†åˆ«éªŒè¯å¤±è´¥: candidates={}", candidateTemplates.size(), e);
            throw new BusinessException(ErrorCode.BIOMETRIC_VERIFICATION_FAILED,
                "ç”Ÿç‰©è¯†åˆ«éªŒè¯å¤±è´¥", e);
        }
    }

    private BiometricMatchResult matchFeature(BiometricFeatureVector queryFeature,
                                            BiometricTemplateEntity template) {
        // è§£å¯†æ¨¡æ¿ç‰¹å¾
        byte[] templateFeatureData = decryptFeature(template.getFeatureData());

        // è®¡ç®—ç›¸ä¼¼åº¦
        double similarity = calculateSimilarity(
            queryFeature.getData(),
            templateFeatureData,
            queryFeature.getBiometricType());

        return BiometricMatchResult.builder()
            .templateId(template.getTemplateId())
            .userId(template.getUserId())
            .similarity(similarity)
            .biometricType(template.getBiometricType())
            .templateVersion(template.getTemplateVersion())
            .build();
    }
}
```

### ğŸ“¡ è®¾å¤‡åŒæ­¥ç®¡ç†

```java
// ç”Ÿç‰©è¯†åˆ«è®¾å¤‡åŒæ­¥ç®¡ç†
@Service
public class BiometricDeviceSyncServiceImpl implements BiometricDeviceSyncService {

    @Resource
    private DeviceCommunicationManager deviceCommManager;

    @Resource
    private AreaDeviceManager areaDeviceManager;

    @Resource
    private RedisTemplate<String, Object> redisTemplate;

    @Override
    @Async
    public CompletableFuture<Void> syncTemplateToDevices(BiometricTemplateEntity template,
                                                      List<DeviceEntity> devices) {
        return CompletableFuture.runAsync(() -> {
            try {
                log.info("å¼€å§‹åŒæ­¥æ¨¡æ¿åˆ°è®¾å¤‡: templateId={}, deviceCount={}",
                    template.getTemplateId(), devices.size());

                // 1. æŒ‰è®¾å¤‡ç±»å‹åˆ†ç»„
                Map<String, List<DeviceEntity>> devicesByType = devices.stream()
                    .collect(Collectors.groupingBy(DeviceEntity::getDeviceType));

                // 2. å¹¶è¡ŒåŒæ­¥åˆ°ä¸åŒç±»å‹è®¾å¤‡
                List<CompletableFuture<DeviceSyncResult>> syncTasks = new ArrayList<>();

                for (Map.Entry<String, List<DeviceEntity>> entry : devicesByType.entrySet()) {
                    String deviceType = entry.getKey();
                    List<DeviceEntity> typedDevices = entry.getValue();

                    CompletableFuture<DeviceSyncResult> syncTask = syncToDeviceType(
                        template, deviceType, typedDevices);
                    syncTasks.add(syncTask);
                }

                // 3. ç­‰å¾…æ‰€æœ‰åŒæ­¥å®Œæˆ
                CompletableFuture.allOf(syncTasks.toArray(new CompletableFuture[0])).join();

                // 4. ç»Ÿè®¡åŒæ­¥ç»“æœ
                DeviceSyncStatistics statistics = calculateSyncStatistics(syncTasks);

                // 5. æ›´æ–°åŒæ­¥çŠ¶æ€
                updateTemplateSyncStatus(template.getTemplateId(), statistics);

                // 6. è®°å½•åŒæ­¥æ—¥å¿—
                logSyncResult(template, statistics);

                log.info("æ¨¡æ¿åŒæ­¥å®Œæˆ: templateId={}, success={}, failed={}",
                    template.getTemplateId(), statistics.getSuccessCount(), statistics.getFailedCount());

            } catch (Exception e) {
                log.error("æ¨¡æ¿åŒæ­¥å¤±è´¥: templateId={}", template.getTemplateId(), e);
                throw new BusinessException(ErrorCode.BIOMETRIC_TEMPLATE_SYNC_FAILED,
                    "æ¨¡æ¿åŒæ­¥å¤±è´¥", e);
            }
        });
    }

    private CompletableFuture<DeviceSyncResult> syncToDeviceType(BiometricTemplateEntity template,
                                                              String deviceType,
                                                              List<DeviceEntity> devices) {
        return CompletableFuture.supplyAsync(() -> {
            DeviceSyncResult result = DeviceSyncResult.builder()
                .deviceType(deviceType)
                .templateId(template.getTemplateId())
                .startTime(System.currentTimeMillis())
                .build();

            int successCount = 0;
            int failedCount = 0;
            List<String> failedDeviceIds = new ArrayList<>();

            for (DeviceEntity device : devices) {
                try {
                    boolean syncSuccess = syncToSingleDevice(template, device);
                    if (syncSuccess) {
                        successCount++;
                    } else {
                        failedCount++;
                        failedDeviceIds.add(device.getDeviceId());
                    }
                } catch (Exception e) {
                    failedCount++;
                    failedDeviceIds.add(device.getDeviceId());
                    log.warn("å•ä¸ªè®¾å¤‡åŒæ­¥å¤±è´¥: deviceId={}, error={}",
                        device.getDeviceId(), e.getMessage());
                }
            }

            return result.toBuilder()
                .successCount(successCount)
                .failedCount(failedCount)
                .failedDeviceIds(failedDeviceIds)
                .endTime(System.currentTimeMillis())
                .build();
        });
    }

    private boolean syncToSingleDevice(BiometricTemplateEntity template, DeviceEntity device) {
        try {
            // 1. æ„å»ºåŒæ­¥è¯·æ±‚
            BiometricSyncRequestDTO syncRequest = BiometricSyncRequestDTO.builder()
                .templateId(template.getTemplateId())
                .userId(template.getUserId())
                .biometricType(template.getBiometricType())
                .featureData(template.getFeatureData())
                .templateVersion(template.getTemplateVersion())
                .validFrom(template.getValidFrom())
                .validTo(template.getValidTo())
                .build();

            // 2. è°ƒç”¨è®¾å¤‡åŒæ­¥æ¥å£
            ResponseDTO<BiometricSyncResultDTO> response = deviceCommManager.callDevice(
                device.getDeviceId(), "/biometric/sync", HttpMethod.POST, syncRequest,
                new TypeReference<ResponseDTO<BiometricSyncResultDTO>>() {});

            if (response.isSuccess() && response.getData() != null) {
                BiometricSyncResultDTO syncResult = response.getData();
                if (syncResult.isSuccess()) {
                    // 3. è®°å½•è®¾å¤‡åŒæ­¥æ—¥å¿—
                    recordDeviceSyncLog(device.getDeviceId(), template.getTemplateId(), true, null);
                    return true;
                } else {
                    recordDeviceSyncLog(device.getDeviceId(), template.getTemplateId(),
                        false, syncResult.getErrorMessage());
                    return false;
                }
            } else {
                recordDeviceSyncLog(device.getDeviceId(), template.getTemplateId(),
                    false, response.getMessage());
                return false;
            }

        } catch (Exception e) {
            recordDeviceSyncLog(device.getDeviceId(), template.getTemplateId(), false, e.getMessage());
            log.error("åŒæ­¥åˆ°è®¾å¤‡å¤±è´¥: deviceId={}, templateId={}",
                device.getDeviceId(), template.getTemplateId(), e);
            return false;
        }
    }
}
```

---

## ğŸ—ï¸ æ¶æ„è®¾è®¡è§„èŒƒ

### å››å±‚æ¶æ„å®ç°

#### Controllerå±‚ - æ¥å£æ§åˆ¶å±‚
```java
@RestController
@RequestMapping("/api/v1/biometric")
@Tag(name = "ç”Ÿç‰©è¯†åˆ«ç®¡ç†")
@Validated
public class BiometricController {

    @Resource
    private BiometricTemplateService templateService;

    @Resource
    private BiometricVerificationService verificationService;

    @PostMapping("/template/create")
    @Operation(summary = "åˆ›å»ºç”Ÿç‰©æ¨¡æ¿")
    public ResponseDTO<BiometricTemplateVO> createTemplate(@Valid @RequestBody CreateTemplateRequestDTO request) {
        BiometricTemplateVO template = templateService.createTemplate(request);
        return ResponseDTO.ok(template);
    }

    @PostMapping("/verification/verify")
    @Operation(summary = "ç”Ÿç‰©ç‰¹å¾éªŒè¯")
    public ResponseDTO<BiometricVerificationResultVO> verify(@Valid @RequestBody BiometricVerificationRequestDTO request) {
        BiometricVerificationResultVO result = verificationService.verify(request);
        return ResponseDTO.ok(result);
    }
}
```

#### Serviceå±‚ - æ ¸å¿ƒä¸šåŠ¡å±‚
```java
@Service
@Transactional(rollbackFor = Exception.class)
public class BiometricTemplateServiceImpl implements BiometricTemplateService {

    @Resource
    private BiometricTemplateManager templateManager;

    @Override
    public BiometricTemplateVO createTemplate(CreateTemplateRequestDTO request) {
        // ä¸šåŠ¡è§„åˆ™éªŒè¯
        validateCreateTemplateRequest(request);

        // æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
        return templateManager.createTemplate(request);
    }

    private void validateCreateTemplateRequest(CreateTemplateRequestDTO request) {
        // éªŒè¯ç”¨æˆ·çŠ¶æ€
        if (!userStatusService.isActive(request.getUserId())) {
            throw new BusinessException(ErrorCode.USER_INACTIVE, "ç”¨æˆ·çŠ¶æ€ä¸æ­£å¸¸");
        }

        // éªŒè¯ç”Ÿç‰©ç‰¹å¾ç±»å‹æ”¯æŒ
        if (!isBiometricTypeSupported(request.getBiometricType())) {
            throw new BusinessException(ErrorCode.BIOMETRIC_TYPE_NOT_SUPPORTED,
                "ä¸æ”¯æŒçš„ç”Ÿç‰©è¯†åˆ«ç±»å‹");
        }
    }
}
```

---

## ğŸ“Š æŠ€èƒ½è´¨é‡æŒ‡æ ‡ä½“ç³»

### æ ¸å¿ƒè´¨é‡æŒ‡æ ‡
| æŒ‡æ ‡åç§° | ç›®æ ‡å€¼ | è¯´æ˜ | æµ‹é‡æ–¹æ³• |
|---------|--------|------|----------|
| **ç‰¹å¾æå–å‡†ç¡®ç‡** | â‰¥99.5% | ç”Ÿç‰©ç‰¹å¾æå–çš„å‡†ç¡®ç‡ | ç®—æ³•æµ‹è¯•éªŒè¯ |
| **è¯†åˆ«å“åº”æ—¶é—´** | â‰¤500ms | 1:Nè¯†åˆ«å“åº”æ—¶é—´ | æ€§èƒ½ç›‘æ§ |
| **æ¨¡æ¿åŒæ­¥æˆåŠŸç‡** | â‰¥99.9% | æ¨¡æ¿åŒæ­¥åˆ°è®¾å¤‡çš„æˆåŠŸç‡ | åŒæ­¥ç›‘æ§ |
| **è¯†åˆ«å‡†ç¡®ç‡** | â‰¥99.8% | ç”Ÿç‰©è¯†åˆ«åŒ¹é…å‡†ç¡®ç‡ | è¯†åˆ«æµ‹è¯• |
| **ç³»ç»Ÿå¯ç”¨æ€§** | â‰¥99.95% | ç”Ÿç‰©è¯†åˆ«ç³»ç»Ÿå¯ç”¨æ€§ | ç³»ç»Ÿç›‘æ§ |

### æ€§èƒ½æŒ‡æ ‡
| æŒ‡æ ‡åç§° | ç›®æ ‡å€¼ | è¯´æ˜ | æµ‹é‡æ–¹æ³• |
|---------|--------|------|----------|
| **å¹¶å‘è¯†åˆ«å¤„ç†èƒ½åŠ›** | â‰¥1000 TPS | åŒæ—¶å¤„ç†è¯†åˆ«æ•° | å¹¶å‘æ€§èƒ½æµ‹è¯• |
| **æ¨¡æ¿æå–å“åº”æ—¶é—´** | â‰¤200ms | æ¨¡æ¿ç‰¹å¾æå–æ—¶é—´ | æå–æ€§èƒ½æµ‹è¯• |
| **è®¾å¤‡åŒæ­¥å»¶è¿Ÿ** | â‰¤5s | æ¨¡æ¿åŒæ­¥åˆ°è®¾å¤‡æ—¶é—´ | åŒæ­¥ç›‘æ§ |
| **å­˜å‚¨æŸ¥è¯¢å“åº”æ—¶é—´** | â‰¤50ms | æ¨¡æ¿æ•°æ®åº“æŸ¥è¯¢æ—¶é—´ | æŸ¥è¯¢æ€§èƒ½æµ‹è¯• |

### å®‰å…¨æŒ‡æ ‡
| æŒ‡æ ‡åç§° | ç›®æ ‡å€¼ | è¯´æ˜ | æµ‹é‡æ–¹æ³• |
|---------|--------|------|----------|
| **ç‰¹å¾æ•°æ®åŠ å¯†ç‡** | 100% | æ•æ„Ÿç‰¹å¾æ•°æ®åŠ å¯†æ¯”ä¾‹ | å®‰å…¨æ£€æŸ¥ |
| **é˜²æ”»å‡»æˆåŠŸç‡** | â‰¥99.9% | é˜²ä¼ªé˜²æ”»å‡»æˆåŠŸæ¯”ä¾‹ | å®‰å…¨æµ‹è¯• |
| **æƒé™éªŒè¯å‡†ç¡®ç‡** | 100% | æƒé™æ§åˆ¶éªŒè¯å‡†ç¡®ç‡ | æƒé™å®¡è®¡ |
| **æ•°æ®ä¼ è¾“å®‰å…¨** | 100% | æ•°æ®ä¼ è¾“åŠ å¯†æ¯”ä¾‹ | ä¼ è¾“å®‰å…¨å®¡è®¡ |

---

## ğŸ”— ç›¸å…³æ–‡æ¡£å‚è€ƒ

### æ ¸å¿ƒæ¶æ„æ–‡æ¡£
- **ğŸ“‹ CLAUDE.md**: å…¨å±€æ¶æ„è§„èŒƒ (å¼ºåˆ¶éµå¾ª)
- **ğŸ—ï¸ å››å±‚æ¶æ„è¯¦è§£**: Controllerâ†’Serviceâ†’Managerâ†’DAOæ¶æ„æ¨¡å¼
- **ğŸ”§ ä¾èµ–æ³¨å…¥è§„èŒƒ**: ç»Ÿä¸€ä½¿ç”¨@Resourceæ³¨è§£
- **ğŸ“¦ DAOå±‚è§„èŒƒ**: ç»Ÿä¸€ä½¿ç”¨Daoåç¼€å’Œ@Mapperæ³¨è§£

### æŠ€æœ¯æ ˆæ–‡æ¡£
- **Spring Boot 3.5.8**: å¾®æœåŠ¡æ¡†æ¶æ–‡æ¡£
- **AIç®—æ³•SDK**: ç”Ÿç‰©è¯†åˆ«ç®—æ³•é›†æˆæ–‡æ¡£
- **Redis**: åˆ†å¸ƒå¼ç¼“å­˜å’Œç‰¹å¾å­˜å‚¨æ–‡æ¡£
- **RabbitMQ**: æ¨¡æ¿åŒæ­¥æ¶ˆæ¯é˜Ÿåˆ—æ–‡æ¡£

### ä¸šåŠ¡æ¨¡å—æ–‡æ¡£
- **ğŸ§¬ ç”Ÿç‰©è¯†åˆ«ç³»ç»Ÿ**: ç”Ÿç‰©ç‰¹å¾è¯†åˆ«ç›¸å…³ä¸šåŠ¡
- **ğŸ“¡ è®¾å¤‡ç®¡ç†ç³»ç»Ÿ**: ç”Ÿç‰©è¯†åˆ«è®¾å¤‡é›†æˆä¸šåŠ¡
- **ğŸ” å®‰å…¨è®¤è¯ä½“ç³»**: ç”Ÿç‰©è¯†åˆ«å®‰å…¨è®¤è¯æ–‡æ¡£

### å®‰å…¨è§„èŒƒæ–‡æ¡£
- **ğŸ”’ ç”Ÿç‰©ç‰¹å¾å®‰å…¨è§„èŒƒ**: ç”Ÿç‰©ç‰¹å¾æ•°æ®å®‰å…¨è¦æ±‚
- **ğŸ›¡ï¸ åæ”»å‡»é˜²æŠ¤è§„èŒƒ**: ç”Ÿç‰©è¯†åˆ«é˜²æ”»å‡»æªæ–½
- **ğŸ“‹ æ•°æ®ä¼ è¾“å®‰å…¨è§„èŒƒ**: ç‰¹å¾æ•°æ®ä¼ è¾“å®‰å…¨

---

**ğŸ“‹ é‡è¦æé†’**:
1. æœ¬æŠ€èƒ½ä¸¥æ ¼éµå¾ªIOE-DREAMå››å±‚æ¶æ„è§„èŒƒ
2. æ‰€æœ‰ä»£ç ç¤ºä¾‹ä½¿ç”¨Jakarta EE 3.0+åŒ…åè§„èŒƒ
3. ç»Ÿä¸€ä½¿ç”¨@Resourceä¾èµ–æ³¨å…¥ï¼Œç¦æ­¢ä½¿ç”¨@Autowired
4. ç»Ÿä¸€ä½¿ç”¨@Mapperæ³¨è§£å’ŒDaoåç¼€å‘½å
5. é‡ç‚¹å…³æ³¨ç”Ÿç‰©ç‰¹å¾æ•°æ®å®‰å…¨å’Œéšç§ä¿æŠ¤
6. å¿…é¡»æ”¯æŒé«˜å¹¶å‘å’Œé«˜æ€§èƒ½çš„ç”Ÿç‰©è¯†åˆ«å¤„ç†
7. ä¸¥æ ¼éµå¾ªç”Ÿç‰©è¯†åˆ«å®‰å…¨å’Œåæ¬ºè¯ˆè¦æ±‚

**è®©æˆ‘ä»¬ä¸€èµ·å»ºè®¾å®‰å…¨ã€é«˜æ•ˆçš„ç”Ÿç‰©è¯†åˆ«è®¤è¯ä½“ç³»ï¼** ğŸš€

---
**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0 - IOE-DREAMä¸ƒå¾®æœåŠ¡ä¸“ä¸šç‰ˆ
**åˆ›å»ºæ—¶é—´**: 2025-12-22
**æŠ€èƒ½ç­‰çº§**: â˜…â˜…â˜…â˜…â˜…â˜… (é¡¶çº§ä¸“å®¶)
**é€‚ç”¨æ¶æ„**: Spring Boot 3.5.8 + AIç®—æ³•SDK + Redis + RabbitMQ