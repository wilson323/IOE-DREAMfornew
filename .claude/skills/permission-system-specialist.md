# æƒé™ç³»ç»Ÿä¸šåŠ¡ä¸“å®¶
## Permission System Business Specialist

**ğŸ¯ æŠ€èƒ½å®šä½**: IOE-DREAMæ™ºæ…§å›­åŒºæƒé™ç³»ç»Ÿå’Œè®¤è¯æˆæƒä¸“å®¶ï¼Œç²¾é€šSa-Tokenæ¡†æ¶ã€RBACæƒé™æ¨¡å‹ã€æƒé™æ³¨è§£ä½“ç³»

**âš¡ æŠ€èƒ½ç­‰çº§**: â˜…â˜…â˜… (é«˜çº§ä¸“å®¶)
**ğŸ¯ é€‚ç”¨åœºæ™¯**: æƒé™ç³»ç»Ÿå¼€å‘ã€è®¤è¯æˆæƒä¼˜åŒ–ã€RBACæ¨¡å‹è®¾è®¡ã€æƒé™æ³¨è§£ä½¿ç”¨ã€å®‰å…¨è®¿é—®æ§åˆ¶
**ğŸ“Š æŠ€èƒ½è¦†ç›–**: Sa-Tokené›†æˆ | RBACæƒé™æ¨¡å‹ | æƒé™æ³¨è§£ | è§’è‰²ç®¡ç† | æƒé™éªŒè¯ | å®‰å…¨å®¡è®¡

---

## ğŸ“‹ æŠ€èƒ½æ¦‚è¿°

### **æ ¸å¿ƒä¸“é•¿**
- **Sa-Tokenæ¡†æ¶ç²¾é€š**: æ·±åº¦æŒæ¡Sa-Token v1.37+ç‰ˆæœ¬çš„å…¨éƒ¨åŠŸèƒ½å’Œæœ€ä½³å®è·µ
- **RBACæƒé™æ¨¡å‹**: åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶è®¾è®¡å’Œå®ç°
- **æƒé™æ³¨è§£ä½“ç³»**: @SaCheckPermissionã€@SaCheckRoleã€@SaCheckLoginç­‰æ³¨è§£ä½¿ç”¨
- **åŠ¨æ€æƒé™ç®¡ç†**: è¿è¡Œæ—¶æƒé™é…ç½®å’Œæƒé™çƒ­æ›´æ–°
- **å¤šç«¯è®¤è¯ç»Ÿä¸€**: Webç«¯ã€ç§»åŠ¨ç«¯ã€APIç«¯çš„ç»Ÿä¸€è®¤è¯æ–¹æ¡ˆ
- **å®‰å…¨å®¡è®¡æ—¥å¿—**: æƒé™æ“ä½œå®¡è®¡å’Œå®‰å…¨ç›‘æ§

### **è§£å†³èƒ½åŠ›**
- **æƒé™ç³»ç»Ÿæ¶æ„**: è®¾è®¡å’Œå®ç°ä¼ä¸šçº§æƒé™ç®¡ç†ç³»ç»Ÿ
- **è®¤è¯æˆæƒä¼˜åŒ–**: ä¼˜åŒ–ç™»å½•æµç¨‹å’Œæƒé™éªŒè¯æ€§èƒ½
- **æƒé™æ•°æ®æ¨¡å‹**: è®¾è®¡é«˜æ•ˆçš„æƒé™æ•°æ®å­˜å‚¨ç»“æ„
- **å®‰å…¨æ¼æ´é˜²æŠ¤**: é˜²æ­¢æƒé™ç»•è¿‡ã€ä¼šè¯åŠ«æŒç­‰å®‰å…¨å¨èƒ
- **æƒé™ç²’åº¦æ§åˆ¶**: å®ç°é¡µé¢çº§ã€æŒ‰é’®çº§ã€æ•°æ®çº§æƒé™æ§åˆ¶
- **è·¨ç³»ç»Ÿå•ç‚¹ç™»å½•**: å®ç°å¤šä¸ªç³»ç»Ÿé—´çš„ç»Ÿä¸€è®¤è¯

---

## ğŸ› ï¸ æŠ€æœ¯èƒ½åŠ›çŸ©é˜µ

### **æƒé™ç³»ç»Ÿæ¶æ„åˆ†æ**
```
ğŸ”´ æ ¸å¿ƒæƒé™æ¨¡å— (å¿…é¡»æŒæ¡)
â”œâ”€â”€ ç”¨æˆ·è®¤è¯ (User Authentication)
â”‚   â”œâ”€â”€ ç™»å½•è®¤è¯æµç¨‹
â”‚   â”œâ”€â”€ å¤šå› å­è®¤è¯(MFA)
â”‚   â”œâ”€â”€ ä¼šè¯ç®¡ç†
â”‚   â””â”€â”€ ç™»å½•è®¾å¤‡ç®¡ç†
â”œâ”€â”€ æƒé™æ§åˆ¶ (Access Control)
â”‚   â”œâ”€â”€ RBACæƒé™æ¨¡å‹
â”‚   â”œâ”€â”€ æƒé™æ³¨è§£éªŒè¯
â”‚   â”œâ”€â”€ åŠ¨æ€æƒé™åŠ è½½
â”‚   â””â”€â”€ æƒé™ç»§æ‰¿æœºåˆ¶
â”œâ”€â”€ è§’è‰²ç®¡ç† (Role Management)
â”‚   â”œâ”€â”€ è§’è‰²å®šä¹‰å’Œåˆ†é…
â”‚   â”œâ”€â”€ è§’è‰²ç»§æ‰¿å…³ç³»
â”‚   â”œâ”€â”€ ä¸´æ—¶è§’è‰²æˆæƒ
â”‚   â””â”€â”€ è§’è‰²æƒé™åŒæ­¥
â””â”€â”€ å®‰å…¨å®¡è®¡ (Security Audit)
    â”œâ”€â”€ æƒé™æ“ä½œæ—¥å¿—
    â”œâ”€â”€ å¼‚å¸¸è®¿é—®ç›‘æ§
    â”œâ”€â”€ å®‰å…¨äº‹ä»¶å‘Šè­¦
    â””â”€â”€ å®¡è®¡æŠ¥è¡¨ç”Ÿæˆ
```

### **é«˜é¢‘ä½¿ç”¨çš„æ ¸å¿ƒåŒ…**
```
net.lab1024.sa.base.common.annoation/           # æƒé™æ³¨è§£åŒ… âœ… å·²ä¿®å¤åŒ…å
â”œâ”€â”€ SaCheckPermission.java                    # æƒé™æ£€æŸ¥æ³¨è§£
â”œâ”€â”€ SaCheckRole.java                          # è§’è‰²æ£€æŸ¥æ³¨è§£
â”œâ”€â”€ SaCheckLogin.java                         # ç™»å½•æ£€æŸ¥æ³¨è§£
â””â”€â”€ SaCheckDisable.java                       # ç¦ç”¨æ£€æŸ¥æ³¨è§£

net.lab1024.sa.admin.module.system/          # ç³»ç»Ÿç®¡ç†æ¨¡å—
â”œâ”€â”€ controller/                               # ç³»ç»Ÿç®¡ç†æ¥å£
â”‚   â”œâ”€â”€ UserController.java                  # ç”¨æˆ·ç®¡ç†
â”‚   â”œâ”€â”€ RoleController.java                   # è§’è‰²ç®¡ç†
â”‚   â”œâ”€â”€ MenuController.java                   # èœå•ç®¡ç†
â”‚   â””â”€â”€ EmployeeController.java              # å‘˜å·¥ç®¡ç†
â”œâ”€â”€ service/                                  # ä¸šåŠ¡é€»è¾‘å±‚
â”‚   â”œâ”€â”€ UserAuthService.java                  # ç”¨æˆ·è®¤è¯æœåŠ¡
â”‚   â”œâ”€â”€ PermissionService.java                # æƒé™ç®¡ç†æœåŠ¡
â”‚   â””â”€â”€ RoleMenuService.java                  # è§’è‰²èœå•æœåŠ¡
â””â”€â”€ manager/                                  # å¤æ‚ä¸šåŠ¡å±‚
    â”œâ”€â”€ MenuManager.java                      # èœå•ç®¡ç†
    â””â”€â”€ PermissionManager.java                # æƒé™ç®¡ç†å™¨
```

---

## ğŸ”§ æ ¸å¿ƒå¼€å‘æŠ€èƒ½

### **1. Sa-Tokenæƒé™æ³¨è§£ä½¿ç”¨**

#### **åŸºç¡€æƒé™æ³¨è§£åº”ç”¨**
```java
@RestController
@RequestMapping("/api/system/user")
@Tag(name = "ç”¨æˆ·ç®¡ç†", description = "ç³»ç»Ÿç”¨æˆ·ç®¡ç†ç›¸å…³æ“ä½œ")
@SaCheckLogin                              // æ£€æŸ¥æ˜¯å¦ç™»å½•
public class UserController {

    @Resource
    private UserService userService;

    @PostMapping("/add")
    @Operation(summary = "æ–°å¢ç”¨æˆ·")
    @SaCheckPermission("system:user:add")     // æ£€æŸ¥æƒé™
    public ResponseDTO<String> addUser(@RequestBody @Valid UserAddForm form) {
        // ç”¨æˆ·æ·»åŠ é€»è¾‘
        String userId = userService.addUser(form);
        return ResponseDTO.ok(userId);
    }

    @PostMapping("/delete")
    @Operation(summary = "åˆ é™¤ç”¨æˆ·")
    @SaCheckPermission("system:user:delete")  // æ£€æŸ¥æƒé™
    @SaCheckRole("admin")                     // æ£€æŸ¥è§’è‰²
    public ResponseDTO<String> deleteUser(@RequestBody @Valid IdForm idForm) {
        // ç”¨æˆ·åˆ é™¤é€»è¾‘
        userService.deleteUser(idForm.getId());
        return ResponseDTO.ok();
    }

    @PostMapping("/batch/delete")
    @Operation(summary = "æ‰¹é‡åˆ é™¤ç”¨æˆ·")
    @SaCheckPermission("system:user:delete")  // æ£€æŸ¥æƒé™
    @SaCheckDisable("comment")                // ç¦ç”¨è¯„è®ºåŠŸèƒ½
    public ResponseDTO<String> batchDeleteUsers(@RequestBody @Valid IdBatchForm form) {
        // æ‰¹é‡åˆ é™¤é€»è¾‘
        userService.batchDeleteUsers(form.getIds());
        return ResponseDTO.ok();
    }

    @GetMapping("/list")
    @Operation(summary = "æŸ¥è¯¢ç”¨æˆ·åˆ—è¡¨")
    @SaCheckPermission("system:user:query")   // æ£€æŸ¥æƒé™
    public ResponseDTO<PageResult<UserVO>> listUsers(@Valid UserQueryForm queryForm) {
        // ç”¨æˆ·åˆ—è¡¨æŸ¥è¯¢
        PageResult<UserVO> result = userService.queryUserList(queryForm);
        return ResponseDTO.ok(result);
    }
}
```

#### **åŠ¨æ€æƒé™éªŒè¯**
```java
@Service
@Slf4j
public class DynamicPermissionService {

    @Resource
    private UnifiedCacheService unifiedCacheService;

    @Resource
    private PermissionDao permissionDao;

    /**
     * åŠ¨æ€æ£€æŸ¥ç”¨æˆ·æƒé™
     */
    public boolean checkUserPermission(Long userId, String permission) {
        // 1. ä»ç¼“å­˜è·å–ç”¨æˆ·æƒé™åˆ—è¡¨
        Set<String> userPermissions = getUserPermissionsFromCache(userId);

        // 2. æ£€æŸ¥æƒé™æ˜¯å¦åŒ¹é…
        boolean hasPermission = userPermissions.contains(permission);

        // 3. æ£€æŸ¥æƒé™é€šé…ç¬¦
        if (!hasPermission) {
            hasPermission = checkWildcardPermission(userPermissions, permission);
        }

        log.debug("æƒé™æ£€æŸ¥ç»“æœ, userId: {}, permission: {}, hasPermission: {}",
                 userId, permission, hasPermission);

        return hasPermission;
    }

    /**
     * æ£€æŸ¥æƒé™é€šé…ç¬¦åŒ¹é…
     */
    private boolean checkWildcardPermission(Set<String> userPermissions, String permission) {
        return userPermissions.stream()
                .anyMatch(userPerm -> {
                    if (userPerm.endsWith("*")) {
                        String prefix = userPerm.substring(0, userPerm.length() - 1);
                        return permission.startsWith(prefix);
                    }
                    return false;
                });
    }

    /**
     * ä»ç¼“å­˜è·å–ç”¨æˆ·æƒé™
     */
    private Set<String> getUserPermissionsFromCache(Long userId) {
        String cacheKey = userId.toString();

        return unifiedCacheService.getOrSet(
            CacheModule.SYSTEM,
            "permission",
            cacheKey,
            () -> loadUserPermissionsFromDatabase(userId),
            Set.class,
            BusinessDataType.USER_PERMISSIONS  // 15åˆ†é’ŸTTLï¼Œæƒé™å˜åŒ–ç›¸å¯¹ä¸é¢‘ç¹
        );
    }

    private Set<String> loadUserPermissionsFromDatabase(Long userId) {
        // 1. è·å–ç”¨æˆ·è§’è‰²
        List<RoleEntity> userRoles = roleDao.selectByUserId(userId);

        // 2. è·å–è§’è‰²æƒé™
        Set<String> permissions = new HashSet<>();
        for (RoleEntity role : userRoles) {
            List<PermissionEntity> rolePermissions = permissionDao.selectByRoleId(role.getRoleId());
            permissions.addAll(rolePermissions.stream()
                    .map(PermissionEntity::getPermissionCode)
                    .collect(Collectors.toSet()));
        }

        return permissions;
    }

    /**
     * æ¸…é™¤ç”¨æˆ·æƒé™ç¼“å­˜
     */
    public void clearUserPermissionCache(Long userId) {
        String cacheKey = userId.toString();
        unifiedCacheService.delete(CacheModule.SYSTEM, "permission", cacheKey);

        log.info("å·²æ¸…é™¤ç”¨æˆ·æƒé™ç¼“å­˜, userId: {}", userId);
    }
}
```

### **2. è‡ªå®šä¹‰æƒé™éªŒè¯å™¨**

#### **Sa-Tokenæƒé™éªŒè¯å™¨æ‰©å±•**
```java
@Component
public class CustomSaTokenDao implements StpInterface {

    @Resource
    private UserService userService;

    @Resource
    private RoleService roleService;

    /**
     * è¿”å›ä¸€ä¸ªè´¦å·æ‰€æ‹¥æœ‰çš„æƒé™ç é›†åˆ
     */
    @Override
    public List<String> getPermissionList(Object loginId, String loginType) {
        Long userId = Long.valueOf(loginId.toString());

        // è·å–ç”¨æˆ·æƒé™åˆ—è¡¨
        Set<String> permissions = userService.getUserPermissions(userId);

        return new ArrayList<>(permissions);
    }

    /**
     * è¿”å›ä¸€ä¸ªè´¦å·æ‰€æ‹¥æœ‰çš„è§’è‰²æ ‡è¯†é›†åˆ
     */
    @Override
    public List<String> getRoleList(Object loginId, String loginType) {
        Long userId = Long.valueOf(loginId.toString());

        // è·å–ç”¨æˆ·è§’è‰²åˆ—è¡¨
        Set<String> roles = roleService.getUserRoles(userId);

        return new ArrayList<>(roles);
    }
}
```

#### **æƒé™éªŒè¯åˆ‡é¢å¢å¼º**
```java
@Aspect
@Component
@Slf4j
public class PermissionCheckAspect {

    @Resource
    private DynamicPermissionService dynamicPermissionService;

    @Resource
    private SecurityAuditService securityAuditService;

    @Around("@annotation(com.zoe.philosophy.core.common.annotation.SaCheckPermission)")
    public Object checkPermission(ProceedingJoinPoint joinPoint) throws Throwable {
        // 1. è·å–å½“å‰ç”¨æˆ·
        Long userId = StpUtil.getLoginIdAsLong();

        // 2. è·å–æƒé™æ³¨è§£
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        SaCheckPermission annotation = method.getAnnotation(SaCheckPermission.class);

        // 3. æƒé™éªŒè¯
        String[] permissions = annotation.value();
        boolean hasPermission = false;

        for (String permission : permissions) {
            if (dynamicPermissionService.checkUserPermission(userId, permission)) {
                hasPermission = true;
                break;
            }
        }

        if (!hasPermission) {
            // 4. è®°å½•æƒé™æ‹’ç»æ—¥å¿—
            securityAuditService.recordPermissionDenied(
                    userId,
                    method.getDeclaringClass().getName() + "." + method.getName(),
                    Arrays.toString(permissions)
            );

            throw new NotPermissionException("æ— è®¿é—®æƒé™", Arrays.toString(permissions));
        }

        // 5. è®°å½•æƒé™é€šè¿‡æ—¥å¿—
        securityAuditService.recordPermissionSuccess(
                userId,
                method.getDeclaringClass().getName() + "." + method.getName()
        );

        // 6. æ‰§è¡Œç›®æ ‡æ–¹æ³•
        return joinPoint.proceed();
    }
}
```

### **3. è§’è‰²æƒé™ç®¡ç†**

#### **è§’è‰²æƒé™åˆ†é…æœåŠ¡**
```java
@Service
@Transactional(rollbackFor = Exception.class)
@Slf4j
public class RolePermissionServiceImpl implements RolePermissionService {

    @Resource
    private RoleDao roleDao;

    @Resource
    private PermissionDao permissionDao;

    @Resource
    private RolePermissionDao rolePermissionDao;

    @Resource
    private UnifiedCacheService unifiedCacheService;

    @Override
    public void assignPermissionsToRole(Long roleId, List<Long> permissionIds) {
        log.info("å¼€å§‹ä¸ºè§’è‰²åˆ†é…æƒé™, roleId: {}, permissionIds: {}", roleId, permissionIds);

        try {
            // 1. éªŒè¯è§’è‰²å­˜åœ¨
            RoleEntity role = roleDao.selectById(roleId);
            if (role == null) {
                throw new BusinessException("ROLE_NOT_FOUND", "è§’è‰²ä¸å­˜åœ¨");
            }

            // 2. éªŒè¯æƒé™å­˜åœ¨
            List<PermissionEntity> permissions = permissionDao.selectBatchIds(permissionIds);
            if (permissions.size() != permissionIds.size()) {
                throw new BusinessException("PERMISSION_NOT_FOUND", "éƒ¨åˆ†æƒé™ä¸å­˜åœ¨");
            }

            // 3. åˆ é™¤ç°æœ‰æƒé™
            rolePermissionDao.deleteByRoleId(roleId);

            // 4. åˆ†é…æ–°æƒé™
            if (!permissionIds.isEmpty()) {
                List<RolePermissionEntity> rolePermissions = permissionIds.stream()
                        .map(permissionId -> {
                            RolePermissionEntity entity = new RolePermissionEntity();
                            entity.setRoleId(roleId);
                            entity.setPermissionId(permissionId);
                            return entity;
                        })
                        .collect(Collectors.toList());

                rolePermissionDao.insertBatch(rolePermissions);
            }

            // 5. æ¸…é™¤ç›¸å…³ç¼“å­˜
            clearRolePermissionCache(roleId);

            log.info("è§’è‰²æƒé™åˆ†é…å®Œæˆ, roleId: {}, assignedPermissions: {}",
                    roleId, permissions.size());

        } catch (Exception e) {
            log.error("è§’è‰²æƒé™åˆ†é…å¤±è´¥, roleId: {}, permissionIds: {}", roleId, permissionIds, e);
            throw new BusinessException("ASSIGN_PERMISSION_FAILED", "æƒé™åˆ†é…å¤±è´¥");
        }
    }

    @Override
    public List<PermissionVO> getRolePermissions(Long roleId) {
        String cacheKey = roleId.toString();

        return unifiedCacheService.getOrSet(
            CacheModule.SYSTEM,
            "role:permission",
                cacheKey,
                () -> this.loadRolePermissionsFromDatabase(roleId),
                new TypeReference<List<PermissionVO>>() {},
                BusinessDataType.ROLE_PERMISSIONS  // 30åˆ†é’ŸTTLï¼Œè§’è‰²æƒé™ç›¸å¯¹ç¨³å®š
        );
    }

    private List<PermissionVO> loadRolePermissionsFromDatabase(Long roleId) {
        List<PermissionEntity> permissions = permissionDao.selectByRoleId(roleId);
        return permissions.stream()
                .map(entity -> SmartBeanUtil.copy(entity, PermissionVO.class))
                .collect(Collectors.toList());
    }

    private void clearRolePermissionCache(Long roleId) {
        String cacheKey = roleId.toString();
        unifiedCacheService.delete(CacheModule.SYSTEM, "role:permission", cacheKey);

        // æ¸…é™¤ç›¸å…³ç”¨æˆ·æƒé™ç¼“å­˜
        List<Long> userIds = roleDao.selectUserIdsByRoleId(roleId);
        for (Long userId : userIds) {
            unifiedCacheService.delete(CacheModule.SYSTEM, "permission", userId.toString());
        }
    }
}
```

### **4. èœå•æƒé™ç®¡ç†**

#### **åŠ¨æ€èœå•åŠ è½½æœåŠ¡**
```java
@Service
@Slf4j
public class MenuServiceImpl implements MenuService {

    @Resource
    private MenuDao menuDao;

    @Resource
    private RoleMenuDao roleMenuDao;

    @Resource
    private UnifiedCacheService unifiedCacheService;

    @Override
    public List<MenuTreeVO> getUserMenuTree(Long userId) {
        String cacheKey = userId.toString();

        return unifiedCacheService.getOrSet(
            CacheModule.SYSTEM,
            "menu:tree",
            cacheKey,
            () -> this.buildUserMenuTree(userId),
            new TypeReference<List<MenuTreeVO>>() {},
            BusinessDataType.USER_MENU  // 15åˆ†é’ŸTTLï¼Œèœå•å˜åŒ–ç›¸å¯¹ä¸é¢‘ç¹
        );
    }

    private List<MenuTreeVO> buildUserMenuTree(Long userId) {
        // 1. è·å–ç”¨æˆ·è§’è‰²
        List<Long> roleIds = roleDao.selectRoleIdsByUserId(userId);

        // 2. è·å–è§’è‰²èœå•
        Set<Long> menuIds = new HashSet<>();
        for (Long roleId : roleIds) {
            List<Long> roleMenuIds = roleMenuDao.selectMenuIdsByRoleId(roleId);
            menuIds.addAll(roleMenuIds);
        }

        // 3. è·å–èœå•å®ä½“
        List<MenuEntity> allMenus = menuDao.selectBatchIds(new ArrayList<>(menuIds));

        // 4. è¿‡æ»¤å‡ºå¯ç”¨çš„èœå•
        List<MenuEntity> enabledMenus = allMenus.stream()
                .filter(menu -> menu.getStatus() == 1)
                .collect(Collectors.toList());

        // 5. æ„å»ºèœå•æ ‘
        return buildMenuTree(enabledMenus);
    }

    private List<MenuTreeVO> buildMenuTree(List<MenuEntity> menus) {
        // 1. è½¬æ¢ä¸ºVOå¯¹è±¡
        List<MenuTreeVO> menuVOs = menus.stream()
                .map(menu -> {
                    MenuTreeVO vo = SmartBeanUtil.copy(menu, MenuTreeVO.class);
                    vo.setChildren(new ArrayList<>());
                    return vo;
                })
                .collect(Collectors.toList());

        // 2. æ„å»ºçˆ¶å­å…³ç³»
        Map<Long, MenuTreeVO> menuMap = menuVOs.stream()
                .collect(Collectors.toMap(MenuTreeVO::getMenuId, Function.identity()));

        List<MenuTreeVO> rootMenus = new ArrayList<>();

        for (MenuTreeVO menu : menuVOs) {
            if (menu.getParentId() == 0 || menu.getParentId() == null) {
                rootMenus.add(menu);
            } else {
                MenuTreeVO parent = menuMap.get(menu.getParentId());
                if (parent != null) {
                    parent.getChildren().add(menu);
                }
            }
        }

        // 3. æ’åº
        sortMenus(rootMenus);

        return rootMenus;
    }

    private void sortMenus(List<MenuTreeVO> menus) {
        menus.sort((m1, m2) -> {
            if (m1.getSortOrder() == null && m2.getSortOrder() == null) {
                return 0;
            }
            if (m1.getSortOrder() == null) {
                return 1;
            }
            if (m2.getSortOrder() == null) {
                return -1;
            }
            return m1.getSortOrder().compareTo(m2.getSortOrder());
        });

        menus.forEach(menu -> {
            if (!menu.getChildren().isEmpty()) {
                sortMenus(menu.getChildren());
            }
        });
    }
}
```

---

## ğŸ” æƒé™ç³»ç»Ÿæœ€ä½³å®è·µ

### **æƒé™è®¾è®¡åŸåˆ™**

#### **1. æœ€å°æƒé™åŸåˆ™**
```markdown
âœ… ç”¨æˆ·åªè·å¾—å®Œæˆå·¥ä½œæ‰€å¿…éœ€çš„æœ€å°æƒé™
âœ… è§’è‰²æƒé™åŸºäºå²—ä½èŒè´£è®¾è®¡
âœ… æƒé™åˆ†é…æœ‰æ˜ç¡®çš„å®¡æ‰¹æµç¨‹
âœ… å®šæœŸå®¡æŸ¥å’Œæ¸…ç†ä¸å¿…è¦çš„æƒé™
âŒ ç¦æ­¢ç»™ç”¨æˆ·åˆ†é…è¿‡åº¦æƒé™
âŒ ç¦æ­¢ä½¿ç”¨è¶…çº§ç®¡ç†å‘˜è´¦å·è¿›è¡Œæ—¥å¸¸æ“ä½œ
âŒ ç¦æ­¢æƒé™åˆ†é…ç¼ºä¹å®¡æ‰¹å’Œè®°å½•
```

#### **2. èŒè´£åˆ†ç¦»åŸåˆ™**
```markdown
âœ… å…³é”®æ“ä½œéœ€è¦å¤šä¸ªè§’è‰²åä½œå®Œæˆ
âœ… å¼€å‘ã€æµ‹è¯•ã€ç”Ÿäº§ç¯å¢ƒæƒé™åˆ†ç¦»
âœ… æ•°æ®æƒé™å’ŒåŠŸèƒ½æƒé™åˆ†ç¦»ç®¡ç†
âœ… ä¸´æ—¶æƒé™æœ‰æ˜ç¡®çš„ä½¿ç”¨æ—¶é™
âŒ ç¦æ­¢å•ä¸€è´¦å·æ‹¥æœ‰æ‰€æœ‰æƒé™
âŒ ç¦æ­¢å¼€å‘å’Œç”Ÿäº§ä½¿ç”¨ç›¸åŒè´¦å·
âŒ ç¦æ­¢ä¸´æ—¶æƒé™æ— æœŸé™ä½¿ç”¨
```

#### **3. æƒé™ç»§æ‰¿åŸåˆ™**
```markdown
âœ… é«˜çº§è§’è‰²åŒ…å«ä½çº§è§’è‰²çš„æƒé™
âœ… æƒé™ç»§æ‰¿å…³ç³»æ¸…æ™°å¯è¿½æº¯
âœ… è§’è‰²ç»§æ‰¿å±‚æ¬¡ä¸è¶…è¿‡3å±‚
âœ… æƒé™å†²çªæ—¶æœ‰æ˜ç¡®çš„è§£å†³è§„åˆ™
âŒ ç¦æ­¢å¾ªç¯æƒé™ç»§æ‰¿
âŒ ç¦æ­¢æƒé™ç»§æ‰¿å±‚æ¬¡è¿‡æ·±
âŒ ç¦æ­¢æƒé™å†²çªæ—¶ä½¿ç”¨æ¨¡ç³Šè§„åˆ™
```

### **æƒé™ç²’åº¦æ§åˆ¶**

#### **1. é¡µé¢çº§æƒé™æ§åˆ¶**
```java
// é¡µé¢æƒé™æ£€æŸ¥
@SaCheckPermission("system:user:view")
@GetMapping("/user")
public String userPage() {
    return "system/user/list";
}

@SaCheckPermission("system:role:view")
@GetMapping("/role")
public String rolePage() {
    return "system/role/list";
}
```

#### **2. æŒ‰é’®çº§æƒé™æ§åˆ¶**
```html
<!-- å‰ç«¯æŒ‰é’®æƒé™æ§åˆ¶ -->
<button v-if="hasPermission('system:user:add')"
        @click="showAddModal">æ–°å¢ç”¨æˆ·</button>

<button v-if="hasPermission('system:user:edit')"
        @click="editUser(userId)">ç¼–è¾‘</button>

<button v-if="hasPermission('system:user:delete')"
        @click="deleteUser(userId)">åˆ é™¤</button>
```

```javascript
// å‰ç«¯æƒé™æ£€æŸ¥æ–¹æ³•
function hasPermission(permission) {
    const userPermissions = getUserPermissions();
    return userPermissions.includes(permission);
}
```

#### **3. æ•°æ®çº§æƒé™æ§åˆ¶**
```java
// æ•°æ®æƒé™è¿‡æ»¤å™¨
@Component
public class DataPermissionFilter {

    @Resource
    private UserDataScopeService userDataScopeService;

    public void applyDataPermission(QueryWrapper<?> queryWrapper, String dataScopeField) {
        Long userId = StpUtil.getLoginIdAsLong();

        // è·å–ç”¨æˆ·æ•°æ®æƒé™èŒƒå›´
        DataScope dataScope = userDataScopeService.getUserDataScope(userId);

        switch (dataScope.getType()) {
            case ALL:
                // å…¨éƒ¨æ•°æ®æƒé™ï¼Œä¸æ·»åŠ è¿‡æ»¤æ¡ä»¶
                break;
            case DEPARTMENT:
                // æœ¬éƒ¨é—¨æ•°æ®æƒé™
                queryWrapper.eq(dataScopeField, dataScope.getDepartmentId());
                break;
            case PERSONAL:
                // ä¸ªäººæ•°æ®æƒé™
                queryWrapper.eq(dataScopeField, userId);
                break;
            default:
                queryWrapper.eq(dataScopeField, -1); // æ— æƒé™
        }
    }
}
```

---

## ğŸš¨ å®‰å…¨é˜²æŠ¤æœºåˆ¶

### **ä¼šè¯å®‰å…¨**

#### **1. ä¼šè¯ç®¡ç†**
```java
@Service
public class SessionSecurityService {

    /**
     * ç™»å½•æ—¶è®¾ç½®ä¼šè¯ä¿¡æ¯
     */
    public void setLoginSession(LoginUser loginUser) {
        StpUtil.login(loginUser.getUserId());

        // è®¾ç½®ä¼šè¯ä¿¡æ¯
        StpUtil.getTokenSession().set("loginUser", loginUser);
        StpUtil.getTokenSession().set("loginTime", System.currentTimeMillis());
        StpUtil.getTokenSession().set("loginIp", StpUtil.getClientIP());
        StpUtil.getTokenSession().set("userAgent", StpUtil.getClientUserAgent());
    }

    /**
     * æ£€æŸ¥ä¼šè¯å®‰å…¨æ€§
     */
    public boolean checkSessionSecurity(String tokenValue) {
        Object loginTime = StpUtil.getTokenSessionByToken(tokenValue).get("loginTime");
        Object loginIp = StpUtil.getTokenSessionByToken(tokenValue).get("loginIp");
        Object userAgent = StpUtil.getTokenSessionByToken(tokenValue).get("userAgent");

        String currentIp = StpUtil.getClientIP();
        String currentUserAgent = StpUtil.getClientUserAgent();

        // IPåœ°å€æ£€æŸ¥
        if (loginIp != null && !loginIp.equals(currentIp)) {
            log.warn("æ£€æµ‹åˆ°IPåœ°å€å˜æ›´, token: {}, originalIp: {}, currentIp: {}",
                    tokenValue, loginIp, currentIp);
            return false;
        }

        // User-Agentæ£€æŸ¥
        if (userAgent != null && !userAgent.equals(currentUserAgent)) {
            log.warn("æ£€æµ‹åˆ°User-Agentå˜æ›´, token: {}, originalUserAgent: {}, currentUserAgent: {}",
                    tokenValue, userAgent, currentUserAgent);
            return false;
        }

        return true;
    }
}
```

#### **2. å¹¶å‘ç™»å½•æ§åˆ¶**
```java
@Configuration
public class SaTokenConfig {

    /**
     * é…ç½®Sa-Token
     */
    @Bean
    public SaTokenConfig getSaTokenConfig() {
        SaTokenConfig config = new SaTokenConfig();

        // åŒä¸€ä¸ªè´¦å·åªèƒ½ç™»å½•ä¸€ä¸ªè®¾å¤‡
        config.setIsConcurrent(false);

        // é…ç½®Redisä½œä¸ºç¼“å­˜
        config.setTokenName("satoken");
        config.setTimeout(30 * 60); // 30åˆ†é’Ÿè¶…æ—¶
        config.setActiveTimeout(-1); // æŒä¹…åŒ–
        config.setIsLog(true);
        config.setIsPrintStackTrace(false);

        return config;
    }
}
```

### **æƒé™éªŒè¯å¢å¼º**

#### **1. åŠ¨æ€æƒé™éªŒè¯**
```java
@Component
public class DynamicPermissionValidator {

    @Resource
    private PermissionService permissionService;

    @Resource
    private SecurityAuditService securityAuditService;

    public boolean validatePermission(Long userId, String permission, String operation) {
        // 1. åŸºç¡€æƒé™æ£€æŸ¥
        boolean hasPermission = permissionService.checkUserPermission(userId, permission);

        if (!hasPermission) {
            // 2. è®°å½•æƒé™æ‹’ç»
            securityAuditService.recordPermissionDenied(userId, permission, operation);

            // 3. æ£€æŸ¥æ˜¯å¦ä¸ºå¼‚å¸¸è®¿é—®æ¨¡å¼
            checkAbnormalAccessPattern(userId, permission);

            return false;
        }

        // 4. è®°å½•æƒé™é€šè¿‡
        securityAuditService.recordPermissionSuccess(userId, permission, operation);

        return true;
    }

    private void checkAbnormalAccessPattern(Long userId, String permission) {
        // æ£€æŸ¥çŸ­æ—¶é—´å†…æ˜¯å¦æœ‰å¤§é‡æƒé™æ‹’ç»
        String key = "permission:deny:" + userId;
        long currentMinute = System.currentTimeMillis() / (60 * 1000);

        // è®°å½•æ‹’ç»æ¬¡æ•°
        Long denyCount = redisTemplate.opsForValue().increment(key + ":" + currentMinute);
        redisTemplate.expire(key + ":" + currentMinute, 2, TimeUnit.MINUTES);

        // å¦‚æœæ‹’ç»æ¬¡æ•°è¿‡å¤šï¼Œè§¦å‘å‘Šè­¦
        if (denyCount > 10) {
            securityAuditService.triggerAbnormalAccessAlert(userId, permission, denyCount);
        }
    }
}
```

---

## ğŸ“Š æƒé™ç›‘æ§å’Œå®¡è®¡

### **æƒé™æ“ä½œå®¡è®¡**

#### **1. æƒé™å®¡è®¡æœåŠ¡**
```java
@Service
@Slf4j
public class SecurityAuditServiceImpl implements SecurityAuditService {

    @Resource
    private SecurityAuditLogDao auditLogDao;

    @Override
    public void recordPermissionSuccess(Long userId, String resource, String operation) {
        SecurityAuditLogEntity log = buildAuditLog(userId, resource, operation, "SUCCESS", null);
        auditLogDao.insert(log);

        log.info("æƒé™é€šè¿‡å®¡è®¡, userId: {}, resource: {}, operation: {}",
                userId, resource, operation);
    }

    @Override
    public void recordPermissionDenied(Long userId, String resource, String operation) {
        SecurityAuditLogEntity log = buildAuditLog(userId, resource, operation, "DENIED", null);
        auditLogDao.insert(log);

        log.warn("æƒé™æ‹’ç»å®¡è®¡, userId: {}, resource: {}, operation: {}",
                userId, resource, operation);
    }

    @Override
    public void recordLoginAttempt(Long userId, String result, String details) {
        SecurityAuditLogEntity log = SecurityAuditLogEntity.builder()
                .userId(userId)
                .resource("LOGIN")
                .operation("ATTEMPT")
                .result(result)
                .details(details)
                .ipAddress(StpUtil.getClientIP())
                .userAgent(StpUtil.getClientUserAgent())
                .createTime(LocalDateTime.now())
                .build();

        auditLogDao.insert(log);

        if ("FAILED".equals(result)) {
            log.warn("ç™»å½•å¤±è´¥å®¡è®¡, userId: {}, details: {}", userId, details);
        }
    }

    private SecurityAuditLogEntity buildAuditLog(Long userId, String resource,
                                                 String operation, String result, String details) {
        return SecurityAuditLogEntity.builder()
                .userId(userId)
                .resource(resource)
                .operation(operation)
                .result(result)
                .details(details)
                .ipAddress(StpUtil.getClientIP())
                .userAgent(StpUtil.getClientUserAgent())
                .createTime(LocalDateTime.now())
                .build();
    }
}
```

#### **2. å¼‚å¸¸è®¿é—®æ£€æµ‹**
```java
@Component
@Slf4j
public class AbnormalAccessDetector {

    @Resource
    private UnifiedCacheService unifiedCacheService;

    @Resource
    private SecurityAuditService securityAuditService;

    /**
     * æ£€æµ‹å¼‚å¸¸è®¿é—®æ¨¡å¼
     */
    public void detectAbnormalAccess(Long userId, String permission, boolean accessResult) {
        String key = "access:pattern:" + userId;

        // è·å–è®¿é—®å†å²è®°å½•
        List<AccessRecord> accessHistory = getAccessHistory(key);

        // æ·»åŠ å½“å‰è®¿é—®è®°å½•
        AccessRecord currentRecord = AccessRecord.builder()
                .userId(userId)
                .permission(permission)
                .accessTime(System.currentTimeMillis())
                .accessResult(accessResult)
                .ipAddress(StpUtil.getClientIP())
                .build();

        accessHistory.add(currentRecord);

        // åªä¿ç•™æœ€è¿‘100æ¡è®°å½•
        if (accessHistory.size() > 100) {
            accessHistory = accessHistory.subList(accessHistory.size() - 100, accessHistory.size());
        }

        // æ£€æµ‹å¼‚å¸¸æ¨¡å¼
        detectPatterns(userId, accessHistory);

        // æ›´æ–°ç¼“å­˜
        unifiedCacheService.set(
            CacheModule.SYSTEM,
            "access:history",
            key,
            accessHistory,
            List.class,
            BusinessDataType.ACCESS_HISTORY  // 60åˆ†é’ŸTTL
        );
    }

    private void detectPatterns(Long userId, List<AccessRecord> accessHistory) {
        // 1. æ£€æµ‹æƒé™æ‹’ç»ç‡è¿‡é«˜
        long recentDenials = accessHistory.stream()
                .filter(record -> !record.isAccessResult())
                .count();

        if (recentDenials > 20) {
            securityAuditService.triggerHighDenialRateAlert(userId, recentDenials);
        }

        // 2. æ£€æµ‹å¼‚å¸¸æ—¶é—´æ®µè®¿é—®
        detectAbnormalTimeAccess(userId, accessHistory);

        // 3. æ£€æµ‹å¼‚å¸¸IPè®¿é—®
        detectAbnormalIpAccess(userId, accessHistory);
    }

    private List<AccessRecord> getAccessHistory(String key) {
        try {
            return unifiedCacheService.get(
                CacheModule.SYSTEM,
                "access:history",
                key,
                List.class
            );
        } catch (Exception e) {
            return new ArrayList<>();
        }
    }
}
```

---

## ğŸ“‹ å¼€å‘æ£€æŸ¥æ¸…å•

### **æƒé™åŠŸèƒ½å¼€å‘æ£€æŸ¥**
- [ ] æƒé™æ³¨è§£æ˜¯å¦æ­£ç¡®ä½¿ç”¨ï¼Ÿ
- [ ] è§’è‰²æƒé™åˆ†é…æ˜¯å¦åˆç†ï¼Ÿ
- [ ] æƒé™ç»§æ‰¿å…³ç³»æ˜¯å¦æ¸…æ™°ï¼Ÿ
- [ ] åŠ¨æ€æƒé™éªŒè¯æ˜¯å¦å®ç°ï¼Ÿ
- [ ] æƒé™ç¼“å­˜æœºåˆ¶æ˜¯å¦ä¼˜åŒ–ï¼Ÿ

### **å®‰å…¨ä¿éšœæ£€æŸ¥**
- [ ] ä¼šè¯å®‰å…¨æœºåˆ¶æ˜¯å¦å®Œå–„ï¼Ÿ
- [ ] å¹¶å‘ç™»å½•æ§åˆ¶æ˜¯å¦é…ç½®ï¼Ÿ
- [ ] æƒé™å®¡è®¡æ—¥å¿—æ˜¯å¦è®°å½•ï¼Ÿ
- [ ] å¼‚å¸¸è®¿é—®æ£€æµ‹æ˜¯å¦å®ç°ï¼Ÿ
- [ ] æ•æ„Ÿæ“ä½œæ˜¯å¦æœ‰äºŒæ¬¡éªŒè¯ï¼Ÿ

### **æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥**
- [ ] æƒé™æŸ¥è¯¢æ˜¯å¦ä½¿ç”¨ç¼“å­˜ï¼Ÿ
- [ ] æƒé™éªŒè¯æ˜¯å¦å¼‚æ­¥å¤„ç†ï¼Ÿ
- [ ] æƒé™æ•°æ®ç»“æ„æ˜¯å¦ä¼˜åŒ–ï¼Ÿ
- [ ] æ‰¹é‡æƒé™æ£€æŸ¥æ˜¯å¦å®ç°ï¼Ÿ
- [ ] æƒé™ç¼“å­˜ç­–ç•¥æ˜¯å¦åˆç†ï¼Ÿ

### **æµ‹è¯•éªŒè¯æ£€æŸ¥**
- [ ] æ­£å¸¸æƒé™æµç¨‹æ˜¯å¦æµ‹è¯•ï¼Ÿ
- [ ] æƒé™æ‹’ç»åœºæ™¯æ˜¯å¦éªŒè¯ï¼Ÿ
- [ ] æƒé™ç»§æ‰¿é€»è¾‘æ˜¯å¦æµ‹è¯•ï¼Ÿ
- [ ] å¼‚å¸¸æƒé™æƒ…å†µæ˜¯å¦å¤„ç†ï¼Ÿ
- [ ] æ€§èƒ½å‹åŠ›æµ‹è¯•æ˜¯å¦é€šè¿‡ï¼Ÿ

---

## ğŸ“ æ”¯æŒå’Œåä½œ

### **æŠ€æœ¯æ”¯æŒ**
- **æŠ€æœ¯å’¨è¯¢**: permission-system-technical@company.com
- **å®‰å…¨å’¨è¯¢**: permission-security@company.com
- **ç´§æ€¥æ”¯æŒ**: 24å°æ—¶æƒé™çƒ­çº¿

### **å›¢é˜Ÿåä½œ**
- **å¼€å‘å›¢é˜Ÿ**: æƒé™ç³»ç»Ÿå¼€å‘ç»„
- **å®‰å…¨å›¢é˜Ÿ**: ä¿¡æ¯å®‰å…¨ç»„
- **æµ‹è¯•å›¢é˜Ÿ**: æƒé™æµ‹è¯•ç»„
- **è¿ç»´å›¢é˜Ÿ**: ç³»ç»Ÿè¿ç»´ç»„

---

**æŒæ¡æ­¤æŠ€èƒ½ï¼Œæ‚¨å°†æˆä¸ºæƒé™ç³»ç»Ÿä¸“å®¶ï¼Œèƒ½å¤Ÿè®¾è®¡ã€å¼€å‘å’Œç»´æŠ¤ä¼ä¸šçº§æƒé™ç®¡ç†ç³»ç»Ÿï¼Œç¡®ä¿ç³»ç»Ÿå®‰å…¨æ€§å’Œè®¿é—®æ§åˆ¶çš„æœ‰æ•ˆæ€§ã€‚**