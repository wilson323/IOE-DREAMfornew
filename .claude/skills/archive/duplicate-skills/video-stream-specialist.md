# è§†é¢‘æµæŠ€æœ¯ä¸“å®¶ (Video Stream Specialist)

**æŠ€èƒ½ç­‰çº§**: â˜…â˜…â˜… é«˜çº§
**é€‚ç”¨è§’è‰²**: è§†é¢‘ç›‘æ§å·¥ç¨‹å¸ˆã€æµåª’ä½“å¼€å‘å·¥ç¨‹å¸ˆã€IOTè§†é¢‘ç³»ç»Ÿæ¶æ„å¸ˆ
**å‰ç½®æŠ€èƒ½**: å¤šåè®®è®¾å¤‡é€‚é…ä¸“å®¶ã€å®æ—¶é€šè®¯æŠ€æœ¯ã€éŸ³è§†é¢‘ç¼–è§£ç ã€ç½‘ç»œä¼ è¾“ä¼˜åŒ–
**é¢„è®¡å­¦æ—¶**: 45å°æ—¶

---

## ğŸ“‹ æŠ€èƒ½æ¦‚è¿°

è§†é¢‘æµæŠ€æœ¯ä¸“å®¶ä¸“æ³¨äºä¼ä¸šçº§è§†é¢‘ç›‘æ§ç³»ç»Ÿçš„æ ¸å¿ƒæŠ€æœ¯å®ç°ï¼ŒåŒ…æ‹¬RTSP/WebRTC/RTMPç­‰æµåª’ä½“åè®®ã€H.264/H.265è§†é¢‘ç¼–è§£ç ã€å®æ—¶éŸ³è§†é¢‘ä¼ è¾“ã€äº‘å°æ§åˆ¶(PTZ)ã€è§†é¢‘å­˜å‚¨ä¸å›æ”¾ç­‰å…³é”®æŠ€æœ¯çš„æ·±åº¦åº”ç”¨ã€‚åŸºäºIOE-DREAMè§†é¢‘ç›‘æ§ä¸šåŠ¡éœ€æ±‚ï¼ŒæŒæ¡ç™¾ä¸‡çº§è§†é¢‘è®¾å¤‡æ¥å…¥çš„ä¼ä¸šçº§è§£å†³æ–¹æ¡ˆã€‚

---

## ğŸ¯ æ ¸å¿ƒèƒ½åŠ›è¦æ±‚

### ğŸ¥ è§†é¢‘æµåè®®æŒæ¡
- **RTSPåè®®**: å®æ—¶æµä¼ è¾“åè®®ã€ä¼šè¯ç®¡ç†ã€RTP/RTCPä¼ è¾“æ§åˆ¶
- **WebRTCåè®®**: æµè§ˆå™¨å®æ—¶é€šè®¯ã€P2Pè¿æ¥ã€åª’ä½“åå•†ã€NATç©¿é€
- **RTMPåè®®**: å®æ—¶æ¶ˆæ¯ä¼ è¾“åè®®ã€ç›´æ’­æ¨æµã€æµåª’ä½“åˆ†å‘
- **ONVIFåè®®**: IPæ‘„åƒå¤´æ ‡å‡†ã€è®¾å¤‡å‘ç°ã€PTZæ§åˆ¶ã€åª’ä½“é…ç½®
- **HLS/DASH**: HTTPè‡ªé€‚åº”æµåª’ä½“ã€åˆ†ç‰‡ä¼ è¾“ã€ç ç‡è‡ªé€‚åº”

### ğŸ¬ éŸ³è§†é¢‘ç¼–è§£ç 
- **H.264/H.265**: è§†é¢‘å‹ç¼©æ ‡å‡†ã€ç¼–ç ä¼˜åŒ–ã€è´¨é‡æ§åˆ¶
- **AAC/MP3**: éŸ³é¢‘å‹ç¼©ç¼–ç ã€å£°é“é…ç½®ã€æ¯”ç‰¹ç‡æ§åˆ¶
- **FFmpeg**: éŸ³è§†é¢‘è½¬ç ã€æ ¼å¼è½¬æ¢ã€æ»¤é•œå¤„ç†
- **GStreamer**: æµåª’ä½“ç®¡é“ã€å®æ—¶å¤„ç†ã€æ’ä»¶æ‰©å±•
- **WebCodecs**: æµè§ˆå™¨åŸç”Ÿç¼–è§£ç ã€ç¡¬ä»¶åŠ é€Ÿ

### ğŸŒ ç½‘ç»œä¼ è¾“ä¼˜åŒ–
- **CDNåˆ†å‘**: å†…å®¹åˆ†å‘ç½‘ç»œã€è¾¹ç¼˜èŠ‚ç‚¹ã€ç¼“å­˜ç­–ç•¥
- **QoSæ§åˆ¶**: æœåŠ¡è´¨é‡æ§åˆ¶ã€å¸¦å®½ç®¡ç†ã€ä¼˜å…ˆçº§è°ƒåº¦
- **è´Ÿè½½å‡è¡¡**: æµåª’ä½“è´Ÿè½½ã€è¿æ¥è°ƒåº¦ã€æ•…éšœè½¬ç§»
- **P2Pç½‘ç»œ**: ç‚¹å¯¹ç‚¹ä¼ è¾“ã€ç½‘ç»œæ‹“æ‰‘ä¼˜åŒ–ã€å¸¦å®½èŠ‚çœ

---

## ğŸ› ï¸ æ“ä½œæ­¥éª¤

### ç¬¬ä¸€é˜¶æ®µï¼šRTSPè§†é¢‘æµå¤„ç† (12å°æ—¶)

#### 1.1 RTSPæœåŠ¡å™¨æ­å»º
**ç›®æ ‡**: å®ç°ä¼ä¸šçº§RTSPæµåª’ä½“æœåŠ¡å™¨

**æ“ä½œæ­¥éª¤**:
```java
// 1. ä¼ä¸šçº§RTSPæœåŠ¡å™¨å®ç°
@Component
@Slf4j
public class EnterpriseRTSPServer {

    @Resource
    private VideoStreamManager streamManager;

    @Resource
    private ConnectionPoolManager connectionPool;

    private EventLoopGroup bossGroup;
    private EventLoopGroup workerGroup;
    private ServerBootstrap bootstrap;

    @PostConstruct
    public void initialize() throws InterruptedException {
        // åˆ›å»ºäº‹ä»¶å¾ªç¯ç»„
        bossGroup = new NioEventLoopGroup(1);
        workerGroup = new NioEventLoopGroup(Runtime.getRuntime().availableProcessors());

        // é…ç½®æœåŠ¡å™¨
        bootstrap = new ServerBootstrap();
        bootstrap.group(bossGroup, workerGroup)
            .channel(NioServerSocketChannel.class)
            .childHandler(new RTSPServerInitializer())
            .option(ChannelOption.SO_BACKLOG, 1024)
            .childOption(ChannelOption.SO_KEEPALIVE, true);

        // å¯åŠ¨æœåŠ¡å™¨
        ChannelFuture future = bootstrap.bind(8554).sync();
        log.info("RTSPæœåŠ¡å™¨å¯åŠ¨æˆåŠŸï¼Œç›‘å¬ç«¯å£: 8554");
    }

    /**
     * RTSPåè®®å¤„ç†å™¨
     */
    public class RTSPServerInitializer extends ChannelInitializer<SocketChannel> {
        @Override
        protected void initChannel(SocketChannel ch) {
            ChannelPipeline pipeline = ch.pipeline();

            // RTSPè§£ç å™¨
            pipeline.addLast("rtspDecoder", new RTSPDecoder());
            pipeline.addLast("rtspEncoder", new RTSPEncoder());

            // HTTPéš§é“æ”¯æŒ
            pipeline.addLast("httpTunnel", new HttpTunnelHandler());

            // è§†é¢‘æµå¤„ç†
            pipeline.addLast("streamHandler", new RTSPStreamHandler());

            // å¼‚å¸¸å¤„ç†
            pipeline.addLast("exceptionHandler", new RTSPExceptionHandler());
        }
    }

    /**
     * RTSPæµå¤„ç†å™¨
     */
    public class RTSPStreamHandler extends SimpleChannelInboundHandler<RTSPRequest> {
        @Override
        protected void channelRead0(ChannelHandlerContext ctx, RTSPRequest request) {
            try {
                switch (request.getMethod()) {
                    case OPTIONS:
                        handleOptions(ctx, request);
                        break;
                    case DESCRIBE:
                        handleDescribe(ctx, request);
                        break;
                    case SETUP:
                        handleSetup(ctx, request);
                        break;
                    case PLAY:
                        handlePlay(ctx, request);
                        break;
                    case PAUSE:
                        handlePause(ctx, request);
                        break;
                    case TEARDOWN:
                        handleTeardown(ctx, request);
                        break;
                    default:
                        sendErrorResponse(ctx, 405, "Method Not Allowed");
                }
            } catch (Exception e) {
                log.error("RTSPè¯·æ±‚å¤„ç†å¤±è´¥", e);
                sendErrorResponse(ctx, 500, "Internal Server Error");
            }
        }
    }
}
```

#### 1.2 è§†é¢‘æµç®¡ç†å™¨
**ç›®æ ‡**: å®ç°é«˜æ€§èƒ½è§†é¢‘æµç®¡ç†

**æ“ä½œæ­¥éª¤**:
```java
// 2. ä¼ä¸šçº§è§†é¢‘æµç®¡ç†å™¨
@Component
public class VideoStreamManager {

    private final Map<String, VideoStream> activeStreams = new ConcurrentHashMap<>();
    private final Map<String, StreamStatistics> streamStats = new ConcurrentHashMap<>();
    private final ScheduledExecutorService streamExecutor = Executors.newScheduledThreadPool(10);

    /**
     * åˆ›å»ºè§†é¢‘æµ
     */
    public CompletableFuture<StreamResult> createStream(String deviceId, StreamConfig config) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // 1. éªŒè¯è®¾å¤‡
                VideoDevice device = validateDevice(deviceId);
                if (device == null) {
                    return StreamResult.failure("è®¾å¤‡ä¸å­˜åœ¨: " + deviceId);
                }

                // 2. é…ç½®æµå‚æ•°
                StreamConfig streamConfig = configureStream(device, config);

                // 3. å»ºç«‹RTSPè¿æ¥
                RTSPConnection connection = establishRTSPConnection(device, streamConfig);

                // 4. åˆ›å»ºè§†é¢‘æµ
                VideoStream videoStream = VideoStream.builder()
                    .streamId(generateStreamId(deviceId))
                    .deviceId(deviceId)
                    .connection(connection)
                    .config(streamConfig)
                    .status(StreamStatus.INITIALIZING)
                    .createTime(System.currentTimeMillis())
                    .build();

                // 5. å¯åŠ¨æµå¤„ç†
                startStreamProcessing(videoStream);

                // 6. æ³¨å†Œæµç®¡ç†
                activeStreams.put(videoStream.getStreamId(), videoStream);
                streamStats.put(videoStream.getStreamId(), new StreamStatistics());

                // 7. å¯åŠ¨ç›‘æ§
                startStreamMonitoring(videoStream);

                return StreamResult.success(videoStream.getStreamId());

            } catch (Exception e) {
                log.error("åˆ›å»ºè§†é¢‘æµå¤±è´¥: {}", deviceId, e);
                return StreamResult.failure(e.getMessage());
            }
        });
    }

    /**
     * å¯åŠ¨æµå¤„ç†
     */
    private void startStreamProcessing(VideoStream videoStream) {
        CompletableFuture.runAsync(() -> {
            try {
                RTSPConnection connection = videoStream.getConnection();

                // å‘é€DESCRIBEè¯·æ±‚
                RTSPRequest describeRequest = RTSPRequest.builder()
                    .method(RTSPMethod.DESCRIBE)
                    .uri(videoStream.getConfig().getStreamUri())
                    .build();

                RTSPResponse describeResponse = connection.sendRequest(describeRequest);

                if (describeResponse.getStatusCode() == 200) {
                    // è§£æSDPä¿¡æ¯
                    SDPInfo sdpInfo = parseSDP(describeResponse.getContent());

                    // å‘é€SETUPè¯·æ±‚
                    setupVideoStream(videoStream, sdpInfo);

                    // å‘é€PLAYè¯·æ±‚
                    playVideoStream(videoStream);

                    // æ›´æ–°æµçŠ¶æ€
                    videoStream.setStatus(StreamStatus.PLAYING);
                    videoStream.setStartTime(System.currentTimeMillis());
                }

            } catch (Exception e) {
                log.error("è§†é¢‘æµå¤„ç†å¤±è´¥: {}", videoStream.getStreamId(), e);
                videoStream.setStatus(StreamStatus.ERROR);
                videoStream.setErrorMessage(e.getMessage());
            }
        });
    }

    /**
     * è§†é¢‘æµè´¨é‡ç›‘æ§
     */
    @Scheduled(fixedRate = 5000)
    public void monitorStreamQuality() {
        activeStreams.values().parallelStream().forEach(stream -> {
            try {
                StreamStatistics stats = streamStats.get(stream.getStreamId());
                if (stats != null) {
                    // è®¡ç ç‡ç›‘æ§
                    calculateBitrate(stream, stats);

                    // ä¸¢åŒ…ç‡ç›‘æ§
                    calculatePacketLoss(stream, stats);

                    // å»¶è¿Ÿç›‘æ§
                    calculateLatency(stream, stats);

                    // è¿æ¥çŠ¶æ€ç›‘æ§
                    monitorConnectionHealth(stream, stats);

                    // è´¨é‡å‘Šè­¦
                    checkQualityAlerts(stream, stats);
                }
            } catch (Exception e) {
                log.error("æµè´¨é‡ç›‘æ§å¤±è´¥: {}", stream.getStreamId(), e);
            }
        });
    }
}
```

**è´¨é‡è¦æ±‚**:
- âœ… æµå¤„ç†èƒ½åŠ›ï¼šæ”¯æŒ1000+å¹¶å‘è§†é¢‘æµ
- âœ… å»¶è¿Ÿæ§åˆ¶ï¼šç«¯åˆ°ç«¯å»¶è¿Ÿ < 200ms
- âœ… ç¨³å®šæ€§ï¼šæµæ–­çº¿é‡è¿æ—¶é—´ < 5ç§’
- âœ… èµ„æºä¼˜åŒ–ï¼šCPUä½¿ç”¨ç‡ < 30%ï¼Œå†…å­˜ä½¿ç”¨ < 2GB

### ç¬¬äºŒé˜¶æ®µï¼šWebRTCå®æ—¶é€šè®¯ (10å°æ—¶)

#### 2.1 WebRTCä¿¡ä»¤æœåŠ¡å™¨
**ç›®æ ‡**: å®ç°WebRTCä¿¡ä»¤åå•†å’Œåª’ä½“ä¼ è¾“

**æ“ä½œæ­¥éª¤**:
```java
// 3. WebRTCä¿¡ä»¤æœåŠ¡å™¨å®ç°
@Component
@Slf4j
public class WebRTCSignalingServer {

    @Resource
    private WebSocketSessionManager sessionManager;

    @Resource
    private PeerConnectionManager peerConnectionManager;

    /**
     * WebSocketä¿¡ä»¤å¤„ç†
     */
    @OnOpen
    public void onOpen(Session session) {
        sessionManager.addSession(session.getId(), session);
        log.info("WebRTCä¼šè¯å»ºç«‹: {}", session.getId());
    }

    @OnMessage
    public void onMessage(String message, Session session) {
        try {
            // è§£æä¿¡ä»¤æ¶ˆæ¯
            WebRTCSignal signal = WebRTCSignal.fromJson(message);

            switch (signal.getType()) {
                case OFFER:
                    handleOffer(session, signal);
                    break;
                case ANSWER:
                    handleAnswer(session, signal);
                    break;
                case ICE_CANDIDATE:
                    handleIceCandidate(session, signal);
                    break;
                case HANGUP:
                    handleHangup(session, signal);
                    break;
                default:
                    log.warn("æœªçŸ¥ä¿¡ä»¤ç±»å‹: {}", signal.getType());
            }
        } catch (Exception e) {
            log.error("WebRTCä¿¡ä»¤å¤„ç†å¤±è´¥", e);
            sendError(session, "ä¿¡ä»¤å¤„ç†å¤±è´¥: " + e.getMessage());
        }
    }

    /**
     * å¤„ç†Offerä¿¡ä»¤
     */
    private void handleOffer(Session session, WebRTCSignal signal) {
        CompletableFuture.runAsync(() -> {
            try {
                String roomId = signal.getRoomId();
                String userId = signal.getUserId();

                // è·å–æˆ–åˆ›å»ºæˆ¿é—´
                WebRTCRoom room = getOrCreateRoom(roomId);

                // åˆ›å»ºPeerConnection
                PeerConnection peerConnection = peerConnectionManager.createPeerConnection(
                    userId, roomId);

                // è®¾ç½®è¿œç¨‹æè¿°
                SessionDescription remoteDesc = new SessionDescription(
                    SessionDescription.Type.OFFER,
                    signal.getSdp());

                peerConnection.setRemoteDescription(remoteDesc);

                // åˆ›å»ºåº”ç­”
                SessionDescription answer = peerConnection.createAnswer();

                // è®¾ç½®æœ¬åœ°æè¿°
                peerConnection.setLocalDescription(answer);

                // å‘é€Answerä¿¡ä»¤
                WebRTCSignal answerSignal = WebRTCSignal.builder()
                    .type(SignalType.ANSWER)
                    .roomId(roomId)
                    .userId(userId)
                    .sdp(answer.getDescription())
                    .build();

                sendMessage(session, answerSignal);

                // æ·»åŠ åˆ°æˆ¿é—´
                room.addParticipant(userId, peerConnection);

            } catch (Exception e) {
                log.error("å¤„ç†Offerä¿¡ä»¤å¤±è´¥", e);
                sendError(session, "Offerå¤„ç†å¤±è´¥: " + e.getMessage());
            }
        });
    }

    /**
     * å¤„ç†ICEå€™é€‰
     */
    private void handleIceCandidate(Session session, WebRTCSignal signal) {
        CompletableFuture.runAsync(() -> {
            try {
                String roomId = signal.getRoomId();
                String userId = signal.getUserId();

                WebRTCRoom room = getRoom(roomId);
                if (room != null) {
                    // è½¬å‘ICEå€™é€‰ç»™æˆ¿é—´å†…å…¶ä»–ç”¨æˆ·
                    for (String otherUserId : room.getParticipants()) {
                        if (!otherUserId.equals(userId)) {
                            PeerConnection otherPeer = room.getPeerConnection(otherUserId);
                            if (otherPeer != null) {
                                IceCandidate candidate = new IceCandidate(
                                    signal.getCandidate().getSdpMid(),
                                    signal.getCandidate().getSdpMLineIndex(),
                                    signal.getCandidate().getCandidate());

                                otherPeer.addIceCandidate(candidate);

                                // è½¬å‘ä¿¡ä»¤
                                Session otherSession = sessionManager.getSession(otherUserId);
                                if (otherSession != null && otherSession.isOpen()) {
                                    sendMessage(otherSession, signal);
                                }
                            }
                        }
                    }
                }
            } catch (Exception e) {
                log.error("å¤„ç†ICEå€™é€‰å¤±è´¥", e);
            }
        });
    }
}
```

#### 2.2 PeerConnectionç®¡ç†å™¨
**ç›®æ ‡**: å®ç°WebRTCç‚¹å¯¹ç‚¹è¿æ¥ç®¡ç†

**æ“ä½œæ­¥éª¤**:
```java
// 4. WebRTC PeerConnectionç®¡ç†å™¨
@Component
public class PeerConnectionManager {

    private final Map<String, PeerConnection> peerConnections = new ConcurrentHashMap<>();
    private final Map<String, WebRTCRoom> rooms = new ConcurrentHashMap<>();

    @Resource
    private MediaStreamManager mediaStreamManager;

    /**
     * åˆ›å»ºPeerConnection
     */
    public PeerConnection createPeerConnection(String userId, String roomId) {
        try {
            // åˆ›å»ºPeerConnectionFactory
            PeerConnectionFactory factory = new PeerConnectionFactory();

            // åˆ›å»ºPeerConnection
            PeerConnection peerConnection = factory.createPeerConnection(
                createPeerConnectionObserver(userId, roomId));

            // æ·»åŠ åª’ä½“æµ
            addMediaStreams(peerConnection);

            // ç¼“å­˜è¿æ¥
            String connectionId = generateConnectionId(userId, roomId);
            peerConnections.put(connectionId, peerConnection);

            return peerConnection;

        } catch (Exception e) {
            log.error("åˆ›å»ºPeerConnectionå¤±è´¥: userId={}, roomId={}", userId, roomId, e);
            throw new WebRTCException("PeerConnectionåˆ›å»ºå¤±è´¥", e);
        }
    }

    /**
     * åˆ›å»ºè¿æ¥è§‚å¯Ÿè€…
     */
    private PeerConnection.Observer createPeerConnectionObserver(String userId, String roomId) {
        return new PeerConnection.Observer() {
            @Override
            public void onSignalingChange(PeerConnection.SignalingState newState) {
                log.info("ä¿¡ä»¤çŠ¶æ€å˜æ›´: userId={}, roomId={}, state={}",
                    userId, roomId, newState);
            }

            @Override
            public void onIceConnectionChange(PeerConnection.IceConnectionState newState) {
                log.info("ICEè¿æ¥çŠ¶æ€å˜æ›´: userId={}, roomId={}, state={}",
                    userId, roomId, newState);

                if (newState == PeerConnection.IceConnectionState.CONNECTED) {
                    onPeerConnected(userId, roomId);
                } else if (newState == PeerConnection.IceConnectionState.DISCONNECTED) {
                    onPeerDisconnected(userId, roomId);
                }
            }

            @Override
            public void onIceCandidate(IceCandidate candidate) {
                log.debug("ICEå€™é€‰: userId={}, roomId={}, candidate={}",
                    userId, roomId, candidate);

                // è½¬å‘ICEå€™é€‰
                forwardIceCandidate(userId, roomId, candidate);
            }

            @Override
            public void onAddStream(MediaStream mediaStream) {
                log.info("æ”¶åˆ°åª’ä½“æµ: userId={}, roomId={}, stream={}",
                    userId, roomId, mediaStream.getId());

                // å¤„ç†è¿œç«¯åª’ä½“æµ
                handleRemoteMediaStream(userId, roomId, mediaStream);
            }

            @Override
            public void onIceConnectionReceivingChange(PeerConnection.IceConnectionReceivingState newState) {
                log.debug("ICEæ¥æ”¶çŠ¶æ€å˜æ›´: userId={}, roomId={}, state={}",
                    userId, roomId, newState);
            }
        };
    }

    /**
     * æ€§èƒ½ç›‘æ§
     */
    @Scheduled(fixedRate = 10000)
    public void monitorPeerConnections() {
        int totalConnections = peerConnections.size();
        int connectedCount = (int) peerConnections.values().stream()
            .map(pc -> pc.getIceConnectionState())
            .filter(state -> state == PeerConnection.IceConnectionState.CONNECTED)
            .count();

        double connectionRate = totalConnections > 0 ? (double) connectedCount / totalConnections : 0;

        log.info("WebRTCè¿æ¥çŠ¶æ€ - æ€»è¿æ¥: {}, å·²è¿æ¥: {}, è¿æ¥ç‡: {:.2%}",
            totalConnections, connectedCount, connectionRate * 100);

        // æ€§èƒ½å‘Šè­¦
        if (connectionRate < 0.8) {
            log.warn("WebRTCè¿æ¥ç‡è¿‡ä½: {:.2%}", connectionRate * 100);
        }
    }
}
```

**è´¨é‡è¦æ±‚**:
- âœ… å¹¶å‘è¿æ¥ï¼šæ”¯æŒ10000+åŒæ—¶åœ¨çº¿PeerConnection
- âœ… è¿æ¥å»ºç«‹æ—¶é—´ï¼šP95 < 3ç§’
- âœ… è§†é¢‘è´¨é‡ï¼šæ”¯æŒ720p/1080på®æ—¶ä¼ è¾“
- âœ… å»¶è¿Ÿæ§åˆ¶ï¼šç«¯åˆ°ç«¯å»¶è¿Ÿ < 150ms

### ç¬¬ä¸‰é˜¶æ®µï¼šè§†é¢‘å­˜å‚¨ä¸å›æ”¾ (10å°æ—¶)

#### 3.1 è§†é¢‘å½•åˆ¶æœåŠ¡
**ç›®æ ‡**: å®ç°ä¼ä¸šçº§è§†é¢‘å½•åˆ¶å’Œå­˜å‚¨

**æ“ä½œæ­¥éª¤**:
```java
// 5. ä¼ä¸šçº§è§†é¢‘å½•åˆ¶æœåŠ¡
@Component
public class VideoRecordingService {

    @Resource
    private VideoStorageManager storageManager;

    @Resource
    private VideoTranscoder transcoder;

    @Resource
    private RecordingScheduler recordingScheduler;

    /**
     * å¼€å§‹è§†é¢‘å½•åˆ¶
     */
    public CompletableFuture<RecordingResult> startRecording(String deviceId, RecordingConfig config) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // 1. éªŒè¯å½•åˆ¶é…ç½®
                validateRecordingConfig(config);

                // 2. åˆ›å»ºå½•åˆ¶ä¼šè¯
                RecordingSession session = RecordingSession.builder()
                    .sessionId(generateSessionId())
                    .deviceId(deviceId)
                    .config(config)
                    .status(RecordingStatus.INITIALIZING)
                    .startTime(System.currentTimeMillis())
                    .build();

                // 3. é…ç½®å½•åˆ¶å‚æ•°
                VideoCapture capture = setupVideoCapture(deviceId, config);

                // 4. å¼€å§‹å½•åˆ¶
                capture.startRecording(session);

                // 5. å­˜å‚¨ç®¡ç†
                storageManager.allocateStorage(session);

                // 6. è½¬ç ä»»åŠ¡
                if (config.isEnableTranscoding()) {
                    scheduleTranscoding(session);
                }

                // 7. å½•åˆ¶è°ƒåº¦
                recordingScheduler.scheduleRecording(session);

                return RecordingResult.success(session.getSessionId());

            } catch (Exception e) {
                log.error("å¼€å§‹è§†é¢‘å½•åˆ¶å¤±è´¥: {}", deviceId, e);
                return RecordingResult.failure(e.getMessage());
            }
        });
    }

    /**
     * å®æ—¶è§†é¢‘å¤„ç†
     */
    private void processRealTimeVideo(String deviceId, byte[] frameData, RecordingSession session) {
        CompletableFuture.runAsync(() -> {
            try {
                // 1. è§†é¢‘å¸§è§£ç 
                VideoFrame frame = decodeFrame(frameData, session.getConfig());

                // 2. å½•åˆ¶å­˜å‚¨
                if (session.getStatus() == RecordingStatus.RECORDING) {
                    storageManager.storeFrame(session, frame);
                }

                // 3. å®æ—¶è½¬ç 
                if (session.getConfig().isRealTimeTranscoding()) {
                    transcoder.transcodeFrame(frame, session);
                }

                // 4. è¿åŠ¨æ£€æµ‹
                if (session.getConfig().isMotionDetection()) {
                    detectMotion(frame, session);
                }

                // 5. å½•åˆ¶ç»Ÿè®¡
                updateRecordingStatistics(session, frame);

            } catch (Exception e) {
                log.error("å®æ—¶è§†é¢‘å¤„ç†å¤±è´¥: {}", deviceId, e);
                handleRecordingError(session, e);
            }
        });
    }

    /**
     * å½•åˆ¶å­˜å‚¨ç®¡ç†
     */
    @Component
    public static class VideoStorageManager {

        @Resource
        private FileStorageService fileStorage;

        @Resource
        private CloudStorageService cloudStorage;

        private final Map<String, StorageSession> storageSessions = new ConcurrentHashMap<>();

        /**
         * åˆ†é…å­˜å‚¨ç©ºé—´
         */
        public void allocateStorage(RecordingSession session) {
            try {
                String storagePath = buildStoragePath(session);

                StorageSession storageSession = StorageSession.builder()
                    .sessionId(session.getSessionId())
                    .storagePath(storagePath)
                    .totalCapacity(calculateRequiredCapacity(session))
                    .usedCapacity(0)
                    .createTime(System.currentTimeMillis())
                    .build();

                storageSessions.put(session.getSessionId(), storageSession);

                // åˆ›å»ºæœ¬åœ°å­˜å‚¨ç›®å½•
                createStorageDirectory(storagePath);

                log.info("å½•åˆ¶å­˜å‚¨åˆ†é…å®Œæˆ: sessionId={}, path={}",
                    session.getSessionId(), storagePath);

            } catch (Exception e) {
                log.error("å­˜å‚¨åˆ†é…å¤±è´¥: {}", session.getSessionId(), e);
                throw new StorageException("å­˜å‚¨åˆ†é…å¤±è´¥", e);
            }
        }

        /**
         * å­˜å‚¨è§†é¢‘å¸§
         */
        public void storeFrame(RecordingSession session, VideoFrame frame) {
            try {
                StorageSession storageSession = storageSessions.get(session.getSessionId());
                if (storageSession == null) {
                    return;
                }

                // ç”Ÿæˆæ–‡ä»¶å
                String fileName = generateFrameFileName(session, frame);
                String filePath = storageSession.getStoragePath() + "/" + fileName;

                // å­˜å‚¨è§†é¢‘å¸§
                fileStorage.storeFrame(frame, filePath);

                // æ›´æ–°å­˜å‚¨ä½¿ç”¨æƒ…å†µ
                storageSession.setUsedCapacity(storageSession.getUsedCapacity() + frame.getSize());

                // äº‘å­˜å‚¨å¤‡ä»½
                if (session.getConfig().isCloudBackup()) {
                    cloudStorage.backupFile(filePath);
                }

            } catch (Exception e) {
                log.error("è§†é¢‘å¸§å­˜å‚¨å¤±è´¥: {}", session.getSessionId(), e);
            }
        }

        /**
         * å­˜å‚¨æ¸…ç†
         */
        @Scheduled(fixedRate = 3600000) // æ¯å°æ—¶æ‰§è¡Œ
        public void cleanupStorage() {
            storageSessions.values().parallelStream().forEach(session -> {
                try {
                    // æ¸…ç†è¿‡æœŸçš„å½•åˆ¶æ–‡ä»¶
                    cleanupExpiredFiles(session);

                    // æ£€æŸ¥å­˜å‚¨ç©ºé—´
                    checkStorageSpace(session);

                } catch (Exception e) {
                    log.error("å­˜å‚¨æ¸…ç†å¤±è´¥: {}", session.getSessionId(), e);
                }
            });
        }
    }
}
```

**è´¨é‡è¦æ±‚**:
- âœ… å½•åˆ¶è´¨é‡ï¼šæ”¯æŒ4K/30fpsé«˜è´¨é‡å½•åˆ¶
- âœ… å­˜å‚¨æ•ˆç‡ï¼šH.265ç¼–ç ï¼Œå­˜å‚¨ç©ºé—´èŠ‚çœ50%
- âœ… å­˜å‚¨å®¹é‡ï¼šæ”¯æŒPBçº§æµ·é‡å­˜å‚¨
- âœ… æ£€ç´¢é€Ÿåº¦ï¼šè§†é¢‘æ£€ç´¢å“åº”æ—¶é—´ < 1ç§’

### ç¬¬å››é˜¶æ®µï¼šç³»ç»Ÿé›†æˆä¸ä¼˜åŒ– (8å°æ—¶)

#### 4.1 è§†é¢‘ç›‘æ§ç³»ç»Ÿé›†æˆ
**ç›®æ ‡**: å®ç°å®Œæ•´çš„è§†é¢‘ç›‘æ§ç³»ç»Ÿé›†æˆ

**æ“ä½œæ­¥éª¤**:
```java
// 6. è§†é¢‘ç›‘æ§ç³»ç»Ÿé›†æˆæ§åˆ¶å™¨
@RestController
@RequestMapping("/api/video")
@Slf4j
@Validated
public class VideoMonitoringController {

    @Resource
    private VideoStreamService streamService;

    @Resource
    private VideoRecordingService recordingService;

    @Resource
    private VideoPlaybackService playbackService;

    @Resource
    private PTZControlService ptzService;

    /**
     * è·å–è§†é¢‘æµURL
     */
    @GetMapping("/stream/{deviceId}")
    @Operation(summary = "è·å–è§†é¢‘æµURL", description = "è·å–æŒ‡å®šè®¾å¤‡çš„è§†é¢‘æ’­æ”¾åœ°å€")
    public ResponseDTO<StreamURLResponse> getStreamUrl(
            @PathVariable String deviceId,
            @RequestParam(defaultValue = "RTSP") String protocol,
            @RequestParam(defaultValue = "MAIN") String channel) {

        try {
            StreamURLResponse streamUrl = streamService.getStreamUrl(deviceId, protocol, channel);
            return ResponseDTO.ok(streamUrl);

        } catch (Exception e) {
            log.error("è·å–è§†é¢‘æµURLå¤±è´¥: deviceId={}", deviceId, e);
            return ResponseDTO.error(ResponseCode.ERROR, "è·å–è§†é¢‘æµå¤±è´¥: " + e.getMessage());
        }
    }

    /**
     * å¼€å§‹å½•åˆ¶
     */
    @PostMapping("/recording/{deviceId}/start")
    @Operation(summary = "å¼€å§‹å½•åˆ¶", description = "å¼€å§‹å½•åˆ¶æŒ‡å®šè®¾å¤‡çš„è§†é¢‘")
    public ResponseDTO<RecordingResponse> startRecording(
            @PathVariable String deviceId,
            @Valid @RequestBody RecordingRequest recordingRequest) {

        try {
            RecordingResponse recording = recordingService.startRecording(deviceId, recordingRequest);
            return ResponseDTO.ok(recording);

        } catch (Exception e) {
            log.error("å¼€å§‹å½•åˆ¶å¤±è´¥: deviceId={}", deviceId, e);
            return ResponseDTO.error(ResponseCode.ERROR, "å¼€å§‹å½•åˆ¶å¤±è´¥: " + e.getMessage());
        }
    }

    /**
     * PTZæ§åˆ¶
     */
    @PostMapping("/ptz/{deviceId}/control")
    @Operation(summary = "PTZæ§åˆ¶", description = "æ§åˆ¶æ‘„åƒå¤´çš„äº‘å°è½¬åŠ¨")
    public ResponseDTO<PTZResponse> controlPTZ(
            @PathVariable String deviceId,
            @Valid @RequestBody PTZRequest ptzRequest) {

        try {
            PTZResponse ptzResponse = ptzService.controlPTZ(deviceId, ptzRequest);
            return ResponseDTO.ok(ptzResponse);

        } catch (Exception e) {
            log.error("PTZæ§åˆ¶å¤±è´¥: deviceId={}", deviceId, e);
            return ResponseDTO.error(ResponseCode.ERROR, "PTZæ§åˆ¶å¤±è´¥: " + e.getMessage());
        }
    }

    /**
     * è§†é¢‘å›æ”¾
     */
    @GetMapping("/playback/{recordingId}")
    @Operation(summary = "è§†é¢‘å›æ”¾", description = "å›æ”¾æŒ‡å®šçš„å½•åˆ¶è§†é¢‘")
    public ResponseDTO<PlaybackURLResponse> getPlaybackUrl(
            @PathVariable String recordingId,
            @RequestParam(defaultValue = "MP4") String format,
            @RequestParam(defaultValue = "0") long startTime,
            @RequestParam(defaultValue = "-1") long endTime) {

        try {
            PlaybackURLResponse playbackUrl = playbackService.getPlaybackUrl(
                recordingId, format, startTime, endTime);
            return ResponseDTO.ok(playbackUrl);

        } catch (Exception e) {
            log.error("è·å–å›æ”¾URLå¤±è´¥: recordingId={}", recordingId, e);
            return ResponseDTO.error(ResponseCode.ERROR, "è·å–å›æ”¾URLå¤±è´¥: " + e.getMessage());
        }
    }
}
```

#### 4.2 æ€§èƒ½ç›‘æ§ä¸ä¼˜åŒ–
**ç›®æ ‡**: å»ºç«‹å®Œæ•´çš„è§†é¢‘ç›‘æ§ç³»ç»Ÿæ€§èƒ½ç›‘æ§

**æ“ä½œæ­¥éª¤**:
```java
// 7. è§†é¢‘ç³»ç»Ÿæ€§èƒ½ç›‘æ§
@Component
public class VideoSystemMonitor {

    @Resource
    private MeterRegistry meterRegistry;

    private final Timer streamProcessingTimer;
    private final Counter streamErrorCounter;
    private final Gauge activeStreamsGauge;
    private final Gauge totalBandwidthGauge;

    public VideoSystemMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.streamProcessingTimer = Timer.builder("video.stream.processing.time")
            .description("è§†é¢‘æµå¤„ç†æ—¶é—´")
            .register(meterRegistry);
        this.streamErrorCounter = Counter.builder("video.stream.errors")
            .description("è§†é¢‘æµé”™è¯¯æ¬¡æ•°")
            .register(meterRegistry);
        this.activeStreamsGauge = Gauge.builder("video.streams.active")
            .description("æ´»è·ƒè§†é¢‘æµæ•°é‡")
            .register(meterRegistry, this, VideoSystemMonitor::getActiveStreamCount);
        this.totalBandwidthGauge = Gauge.builder("video.bandwidth.total")
            .description("æ€»å¸¦å®½ä½¿ç”¨")
            .register(meterRegistry, this, VideoSystemMonitor::getTotalBandwidth);
    }

    /**
     * è®°å½•æµå¤„ç†æ—¶é—´
     */
    public void recordStreamProcessingTime(String streamType, long duration) {
        streamProcessingTimer.record(duration, TimeUnit.MILLISECONDS,
            Tags.of("type", streamType));
    }

    /**
     * è®°å½•æµé”™è¯¯
     */
    public void recordStreamError(String streamType, String errorType) {
        streamErrorCounter.increment(Tags.of("type", streamType, "error", errorType));
    }

    /**
     * æ€§èƒ½å‘Šè­¦
     */
    @Scheduled(fixedRate = 60000)
    public void checkPerformanceAlerts() {
        // æ£€æŸ¥æ´»è·ƒæµæ•°é‡
        int activeStreams = getActiveStreamCount();
        if (activeStreams > 1000) {
            log.warn("æ´»è·ƒè§†é¢‘æµæ•°é‡è¿‡å¤š: {}, å»ºè®®æ‰©å®¹", activeStreams);
            sendAlert("é«˜å¹¶å‘å‘Šè­¦", "æ´»è·ƒè§†é¢‘æµæ•°é‡: " + activeStreams);
        }

        // æ£€æŸ¥é”™è¯¯ç‡
        double errorRate = calculateErrorRate();
        if (errorRate > 0.05) { // 5%
            log.warn("è§†é¢‘æµé”™è¯¯ç‡è¿‡é«˜: {:.2%}%, å»ºè®®æ£€æŸ¥ç½‘ç»œå’Œè®¾å¤‡çŠ¶æ€", errorRate * 100);
            sendAlert("é”™è¯¯ç‡å‘Šè­¦", "è§†é¢‘æµé”™è¯¯ç‡: " + String.format("%.2f%%", errorRate * 100));
        }

        // æ£€æŸ¥å¸¦å®½ä½¿ç”¨
        double totalBandwidth = getTotalBandwidth();
        if (totalBandwidth > 1000 * 1024 * 1024) { // 1GB/s
            log.warn("å¸¦å®½ä½¿ç”¨è¿‡é«˜: {:.2f}GB/s, å»ºè®®ä¼˜åŒ–ä¼ è¾“ç­–ç•¥", totalBandwidth / 1024 / 1024 / 1024);
            sendAlert("å¸¦å®½å‘Šè­¦", "å¸¦å®½ä½¿ç”¨: " + String.format("%.2fGB/s", totalBandwidth / 1024 / 1024 / 1024));
        }
    }
}
```

**è´¨é‡è¦æ±‚**:
- âœ… ç³»ç»Ÿç›‘æ§ï¼š100%è¦†ç›–å…³é”®æ€§èƒ½æŒ‡æ ‡
- âœ… å‘Šè­¦åŠæ—¶ï¼šå¼‚å¸¸å‘ç°åˆ°å‘Šè­¦æ—¶é—´ < 1åˆ†é’Ÿ
- âœ… æ‰©å±•æ€§ï¼šæ”¯æŒæ°´å¹³æ‰©å±•å’Œè´Ÿè½½å‡è¡¡
- âœ… å¯ç”¨æ€§ï¼šç³»ç»Ÿå¯ç”¨æ€§ â‰¥ 99.9%

---

## âš ï¸ æ³¨æ„äº‹é¡¹

### ğŸ” å®‰å…¨è¦æ±‚
- **è®¿é—®æ§åˆ¶**: è§†é¢‘æµè®¿é—®éœ€è¦ä¸¥æ ¼çš„æƒé™éªŒè¯
- **æ•°æ®åŠ å¯†**: æ•æ„Ÿè§†é¢‘æ•°æ®ä¼ è¾“éœ€è¦ç«¯åˆ°ç«¯åŠ å¯†
- **éšç§ä¿æŠ¤**: å½•åƒæ•°æ®å­˜å‚¨éœ€è¦ç¬¦åˆéšç§ä¿æŠ¤æ³•è§„
- **å®¡è®¡æ—¥å¿—**: å®Œæ•´çš„è§†é¢‘æ“ä½œå®¡è®¡æ—¥å¿—

### ğŸš€ æ€§èƒ½è¦æ±‚
- **å»¶è¿Ÿæ§åˆ¶**: å®æ—¶è§†é¢‘å»¶è¿Ÿ < 200ms
- **å¸¦å®½ä¼˜åŒ–**: é‡‡ç”¨è‡ªé€‚åº”ç ç‡å’Œç½‘ç»œä¼˜åŒ–
- **å­˜å‚¨æ•ˆç‡**: è§†é¢‘å‹ç¼©æ¯” â‰¥ 100:1
- **å¹¶å‘å¤„ç†**: æ”¯æŒ1000+å¹¶å‘è§†é¢‘æµ

### ğŸ›¡ï¸ å¯é æ€§è¦æ±‚
- **æ•…éšœæ¢å¤**: è‡ªåŠ¨æ•…éšœæ£€æµ‹å’Œæ¢å¤æœºåˆ¶
- **æ•°æ®å®Œæ•´æ€§**: è§†é¢‘æ•°æ®å®Œæ•´æ€§æ ¡éªŒå’Œä¿®å¤
- **å¤‡ä»½ç­–ç•¥**: å¤šå±‚æ¬¡æ•°æ®å¤‡ä»½å’Œç¾éš¾æ¢å¤
- **è´Ÿè½½å‡è¡¡**: æ™ºèƒ½è´Ÿè½½å‡è¡¡å’Œæµé‡è°ƒåº¦

---

## ğŸ“Š è¯„ä¼°æ ‡å‡†

### æ“ä½œæ—¶é—´è¦æ±‚
- **è§†é¢‘æµæ¥å…¥**: 30åˆ†é’Ÿ/è®¾å¤‡ç±»å‹
- **WebRTCé›†æˆ**: 2å¤©/ç³»ç»Ÿ
- **å½•åˆ¶ç³»ç»Ÿ**: 3å¤©/å®Œæ•´å®ç°
- **æ€§èƒ½ä¼˜åŒ–**: 1å¤©/æ¨¡å—

### æŠ€æœ¯æŒ‡æ ‡è¦æ±‚
- **è§†é¢‘è´¨é‡**: æ”¯æŒ4K/30fpså®æ—¶ä¼ è¾“
- **å¹¶å‘èƒ½åŠ›**: 1000+å¹¶å‘è§†é¢‘æµ
- **å­˜å‚¨æ•ˆç‡**: H.265ç¼–ç å‹ç¼©æ¯” â‰¥ 100:1
- **æ£€ç´¢é€Ÿåº¦**: è§†é¢‘æ£€ç´¢å“åº”æ—¶é—´ < 1ç§’

### è´¨é‡æ ‡å‡†
- **ç³»ç»Ÿå¯ç”¨æ€§**: â‰¥ 99.9%
- **è§†é¢‘å»¶è¿Ÿ**: P95 < 200ms
- **å­˜å‚¨ç©ºé—´**: æ”¯æŒPBçº§æ‰©å±•
- **æ£€ç´¢æ€§èƒ½**: 1ç§’å†…å“åº”

---

## ğŸ¯ åº”ç”¨åœºæ™¯

### å…¸å‹åº”ç”¨åœºæ™¯
1. **å®æ—¶ç›‘æ§**: ä¼ä¸šå®‰é˜²ã€å·¥å‚ç›‘æ§ã€å›­åŒºç®¡ç†
2. **è§†é¢‘ä¼šè®®**: è¿œç¨‹ä¼šè®®ã€åœ¨çº¿æ•™è‚²ã€åŒ»ç–—è¯Šæ–­
3. **ç›´æ’­æ¨æµ**: æ´»åŠ¨ç›´æ’­ã€äº§å“å‘å¸ƒã€åœ¨çº¿æ•™è‚²
4. **å½•åƒå­˜å‚¨**: ç›‘æ§å½•åƒã€è¯æ®ä¿å…¨ã€åˆè§„å­˜å‚¨

### æœ€ä½³å®è·µç¤ºä¾‹
```java
// æœ€ä½³å®è·µï¼šè‡ªé€‚åº”ç ç‡æ§åˆ¶
@Component
public class AdaptiveBitrateController {

    /**
     * è‡ªé€‚åº”ç ç‡è°ƒæ•´
     */
    public VideoQuality adjustBitrate(VideoStream stream, NetworkCondition condition) {
        VideoQuality currentQuality = stream.getCurrentQuality();
        VideoQuality targetQuality = calculateTargetQuality(currentQuality, condition);

        if (targetQuality != currentQuality) {
            try {
                // è°ƒæ•´ç¼–ç å‚æ•°
                adjustEncodingParameters(stream, targetQuality);

                // é€šçŸ¥å®¢æˆ·ç«¯ç ç‡å˜æ›´
                notifyBitrateChange(stream.getStreamId(), targetQuality);

                log.info("è‡ªé€‚åº”ç ç‡è°ƒæ•´: streamId={}, {} -> {}",
                    stream.getStreamId(), currentQuality, targetQuality);

            } catch (Exception e) {
                log.error("è‡ªé€‚åº”ç ç‡è°ƒæ•´å¤±è´¥", e);
            }
        }

        return targetQuality;
    }

    /**
     * è®¡ç®—ç›®æ ‡è´¨é‡
     */
    private VideoQuality calculateTargetQuality(VideoQuality currentQuality, NetworkCondition condition) {
        int bandwidth = condition.getBandwidth(); // kbps
        int packetLoss = condition.getPacketLoss(); // %
        int latency = condition.getLatency(); // ms

        // æ ¹æ®ç½‘ç»œæ¡ä»¶è®¡ç®—æœ€åˆé€‚çš„è§†é¢‘è´¨é‡
        if (bandwidth < 500 || packetLoss > 5 || latency > 1000) {
            return VideoQuality.LOW;
        } else if (bandwidth < 1500 || packetLoss > 2 || latency > 500) {
            return VideoQuality.MEDIUM;
        } else if (bandwidth < 3000 || packetLoss > 1 || latency > 200) {
            return VideoQuality.HIGH;
        } else {
            return VideoQuality.ULTRA_HIGH;
        }
    }
}
```

---

**ğŸ’¡ ä¸“ä¸šæç¤º**: è§†é¢‘æµæŠ€æœ¯ä¸“å®¶éœ€è¦å…·å¤‡æ·±åšçš„éŸ³è§†é¢‘æŠ€æœ¯åŠŸåº•å’Œä¸°å¯Œçš„å®æˆ˜ç»éªŒï¼Œèƒ½å¤Ÿå¤„ç†å¤æ‚çš„è§†é¢‘æµä¼ è¾“ã€ç¼–è§£ç ã€å­˜å‚¨å’Œä¼˜åŒ–é—®é¢˜ï¼Œç¡®ä¿ä¼ä¸šçº§è§†é¢‘ç›‘æ§ç³»ç»Ÿçš„é«˜è´¨é‡ã€é«˜å¯ç”¨å’Œé«˜æ€§èƒ½è¡¨ç°ã€‚