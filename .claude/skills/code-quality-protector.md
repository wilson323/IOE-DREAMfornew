# ä»£ç è´¨é‡å®ˆæŠ¤ä¸“å®¶æŠ€èƒ½
## Code Quality Protector

**ğŸ¯ æŠ€èƒ½å®šä½**: IOE-DREAMæ™ºæ…§å›­åŒºä»£ç è´¨é‡å®ˆæŠ¤ä¸“å®¶ï¼Œç¡®ä¿ä»£ç ç¬¦åˆä¼ä¸šçº§è´¨é‡æ ‡å‡†ï¼Œé¢„é˜²è´¨é‡é—®é¢˜ï¼Œç»´æŠ¤ä»£ç å¥åº·åº¦

**âš¡ æŠ€èƒ½ç­‰çº§**: â˜…â˜…â˜…â˜…â˜… (é¡¶çº§ä¸“å®¶)
**ğŸ¯ é€‚ç”¨åœºæ™¯**: ä»£ç è´¨é‡æ£€æŸ¥ã€è§„èŒƒå®¡æŸ¥ã€è´¨é‡åŸ¹è®­ã€é‡æ„æŒ‡å¯¼ã€è´¨é‡åº¦é‡
**ğŸ“Š æŠ€èƒ½è¦†ç›–**: ä»£ç è§„èŒƒ | è´¨é‡æ£€æµ‹ | é‡æ„æŒ‡å¯¼ | æ€§èƒ½ä¼˜åŒ– | å®‰å…¨æ£€æŸ¥ | æµ‹è¯•è¦†ç›–

---

## ğŸ“‹ æŠ€èƒ½æ¦‚è¿°

### **æ ¸å¿ƒä¸“é•¿**
- **ä»£ç è§„èŒƒæ£€æŸ¥**: UTF-8ç¼–ç ã€å‘½åè§„èŒƒã€æ ¼å¼åŒ–æ ‡å‡†ã€æ³¨é‡Šå®Œæ•´æ€§
- **ä»£ç è´¨é‡åº¦é‡**: åœˆå¤æ‚åº¦ã€ä»£ç é‡å¤ç‡ã€æ–¹æ³•é•¿åº¦ã€ç±»è¡Œæ•°æ§åˆ¶
- **æ€§èƒ½ä¼˜åŒ–æŒ‡å¯¼**: SQLä¼˜åŒ–ã€ç¼“å­˜ç­–ç•¥ã€ç®—æ³•æ•ˆç‡ã€å†…å­˜ç®¡ç†
- **å®‰å…¨æ¼æ´æ£€æµ‹**: SQLæ³¨å…¥ã€XSSæ”»å‡»ã€æ•æ„Ÿä¿¡æ¯æ³„éœ²ã€æƒé™æ§åˆ¶
- **æµ‹è¯•è¦†ç›–åˆ†æ**: å•å…ƒæµ‹è¯•è¦†ç›–ç‡ã€é›†æˆæµ‹è¯•ã€è¾¹ç•Œæµ‹è¯•
- **é‡æ„å»ºè®®æä¾›**: ä»£ç å¼‚å‘³è¯†åˆ«ã€é‡æ„æ¨¡å¼ã€æœ€ä½³å®è·µåº”ç”¨

### **è§£å†³èƒ½åŠ›**
- **è´¨é‡æ ‡å‡†æ‰§è¡Œ**: ä¸¥æ ¼æ‰§è¡Œä¼ä¸šçº§ä»£ç è´¨é‡æ ‡å‡†
- **è´¨é‡é—®é¢˜é¢„é˜²**: åœ¨å¼€å‘é˜¶æ®µé¢„é˜²è´¨é‡é—®é¢˜çš„äº§ç”Ÿ
- **è´¨é‡é—®é¢˜ä¿®å¤**: ç³»ç»Ÿæ€§è¯†åˆ«å’Œä¿®å¤ä»£ç è´¨é‡é—®é¢˜
- **è´¨é‡åŸ¹è®­æŒ‡å¯¼**: å›¢é˜Ÿä»£ç è´¨é‡æ„è¯†å’ŒæŠ€èƒ½æå‡
- **è´¨é‡ç›‘æ§åº¦é‡**: æŒç»­ç›‘æ§ä»£ç è´¨é‡æŒ‡æ ‡å’Œè¶‹åŠ¿

---

## ğŸ¯ ä»£ç è´¨é‡æ ‡å‡†ä½“ç³»

### ğŸ“ è´¨é‡æŒ‡æ ‡å®šä¹‰

#### æ ¸å¿ƒè´¨é‡æŒ‡æ ‡
| æŒ‡æ ‡åç§° | ç›®æ ‡å€¼ | è¯´æ˜ | æ£€æŸ¥æ–¹å¼ |
|---------|--------|------|----------|
| **ä»£ç è¦†ç›–ç‡** | â‰¥80% | å•å…ƒæµ‹è¯•è¦†ç›–ç‡è¦†ç›–ç‡ | JaCoCoæµ‹è¯•è¦†ç›–ç‡åˆ†æ |
| **æ ¸å¿ƒä¸šåŠ¡è¦†ç›–ç‡** | =100% | å…³é”®ä¸šåŠ¡é€»è¾‘æµ‹è¯•è¦†ç›–ç‡ | ä¸šåŠ¡é‡è¦æ€§åˆ†æ |
| **é‡å¤ä»£ç ç‡** | â‰¤3% | é‡å¤ä»£ç å—æ¯”ä¾‹ | Simiané‡å¤ä»£ç æ£€æµ‹ |
| **åœˆå¤æ‚åº¦** | â‰¤10 | æ–¹æ³•å¤æ‚åº¦æ§åˆ¶ | PMDåœˆå¤æ‚åº¦æ£€æŸ¥ |
| **æ–¹æ³•è¡Œæ•°** | â‰¤50 | å•ä¸ªæ–¹æ³•ä»£ç è¡Œæ•°é™åˆ¶ | è¡Œæ•°ç»Ÿè®¡æ£€æŸ¥ |
| **ç±»è¡Œæ•°** | â‰¤500 | å•ä¸ªç±»ä»£ç è¡Œæ•°é™åˆ¶ | ç±»å¤§å°åˆ†æ |

#### ç¼–ç è§„èŒƒæŒ‡æ ‡
| è§„èŒƒé¡¹ | è¦æ±‚ | è¿è§„å½±å“ | æ£€æŸ¥å·¥å…· |
|--------|------|----------|----------|
| **ç¼–ç æ ¼å¼** | UTF-8ç¼–ç  | ä¹±ç é—®é¢˜ | æ–‡ä»¶ç¼–ç æ£€æŸ¥ |
| **å‘½åè§„èŒƒ** | é©¼å³°å‘½åæ³• | å¯è¯»æ€§å·® | å‘½åè§„èŒƒæ£€æŸ¥ |
| **æ³¨é‡Šå®Œæ•´æ€§** | å…¬å…±APIå¿…æ³¨é‡Š | ç»´æŠ¤å›°éš¾ | æ³¨é‡Šè¦†ç›–æ£€æŸ¥ |
| **ç©ºè¡Œè§„èŒƒ** | åˆç†ç©ºè¡Œåˆ†éš” | æ ¼å¼æ··ä¹± | ä»£ç æ ¼å¼æ£€æŸ¥ |
| **å¼‚å¸¸å¤„ç†** | å®Œæ•´å¼‚å¸¸å¤„ç† | ç¨‹åºç¨³å®šæ€§ | å¼‚å¸¸å¤„ç†æ£€æŸ¥ |

### ğŸ›¡ï¸ å®‰å…¨è´¨é‡æŒ‡æ ‡
| å®‰å…¨æŒ‡æ ‡ | ç›®æ ‡å€¼ | è¯´æ˜ | æ£€æŸ¥æ–¹å¼ |
|---------|--------|------|----------|
| **SQLæ³¨å…¥é˜²æŠ¤** | 100% | å‚æ•°åŒ–æŸ¥è¯¢ä½¿ç”¨ | ä»£ç å®‰å…¨æ‰«æ |
| **XSSæ”»å‡»é˜²æŠ¤** | 100% | è¾“å…¥è¾“å‡ºç¼–ç  | å®‰å…¨æ¼æ´æ£€æµ‹ |
| **æ•æ„Ÿä¿¡æ¯ä¿æŠ¤** | 100% | æ•æ„Ÿæ•°æ®è„±æ• | æ•æ„Ÿä¿¡æ¯æ‰«æ |
| **æƒé™æ§åˆ¶æ£€æŸ¥** | 100% | æƒé™éªŒè¯å®Œæ•´æ€§ | æƒé™æ§åˆ¶å®¡æŸ¥ |

---

## ğŸ” ä»£ç è´¨é‡æ£€æµ‹å·¥å…·

### ä»£ç è§„èŒƒæ£€æŸ¥å™¨
```java
// ä»£ç è´¨é‡æ£€æŸ¥æ ¸å¿ƒç»„ä»¶
@Component
@Slf4j
public class CodeQualityChecker {

    private final JavaParser javaParser;
    private final MetricCalculator metricCalculator;
    private final CodeStyleChecker codeStyleChecker;

    /**
     * æ‰§è¡Œå…¨é¢çš„ä»£ç è´¨é‡æ£€æŸ¥
     */
    public CodeQualityReport checkCodeQuality(String projectPath) {
        log.info("å¼€å§‹ä»£ç è´¨é‡æ£€æŸ¥: projectPath={}", projectPath);

        CodeQualityReport report = new CodeQualityReport();

        try {
            // 1. æ‰«ææ‰€æœ‰Javaæ–‡ä»¶
            List<File> javaFiles = scanJavaFiles(projectPath);
            log.info("å‘ç°Javaæ–‡ä»¶æ•°é‡: {}", javaFiles.size());

            // 2. å¯¹æ¯ä¸ªæ–‡ä»¶æ‰§è¡Œè´¨é‡æ£€æŸ¥
            for (File javaFile : javaFiles) {
                checkFileQuality(javaFile, report);
            }

            // 3. è®¡ç®—æ•´ä½“è´¨é‡æŒ‡æ ‡
            calculateOverallMetrics(report);

            // 4. ç”Ÿæˆè´¨é‡è¯„åˆ†
            generateQualityScore(report);

            log.info("ä»£ç è´¨é‡æ£€æŸ¥å®Œæˆ: æ€»ä½“è¯„åˆ†={}", report.getOverallScore());

        } catch (Exception e) {
            log.error("ä»£ç è´¨é‡æ£€æŸ¥å¤±è´¥", e);
            report.addError("CODE_QUALITY_CHECK_FAILED", "ä»£ç è´¨é‡æ£€æŸ¥æ‰§è¡Œå¤±è´¥: " + e.getMessage());
        }

        return report;
    }

    private void checkFileQuality(File javaFile, CodeQualityReport report) {
        try {
            String filePath = javaFile.getAbsolutePath();
            String content = Files.readString(javaFile.toPath());

            // 1. ç¼–ç æ£€æŸ¥
            checkFileEncoding(javaFile, report);

            // 2. è§£æJavaä»£ç 
            CompilationUnit cu = javaParser.parse(content);

            // 3. æ£€æŸ¥ä»£ç é£æ ¼
            checkCodeStyle(cu, filePath, report);

            // 4. æ£€æŸ¥å¤æ‚åº¦æŒ‡æ ‡
            checkComplexityMetrics(cu, filePath, report);

            // 5. æ£€æŸ¥å‘½åè§„èŒƒ
            checkNamingConventions(cu, filePath, report);

            // 6. æ£€æŸ¥æ³¨é‡Šå®Œæ•´æ€§
            checkCommentCompleteness(cu, filePath, report);

            // 7. æ£€æŸ¥å®‰å…¨æ¼æ´
            checkSecurityVulnerabilities(cu, filePath, report);

        } catch (Exception e) {
            log.warn("æ£€æŸ¥æ–‡ä»¶è´¨é‡å¤±è´¥: {}", javaFile.getPath(), e);
            report.addError("FILE_CHECK_FAILED", "æ–‡ä»¶æ£€æŸ¥å¤±è´¥: " + javaFile.getPath());
        }
    }

    private void checkFileEncoding(File javaFile, CodeQualityReport report) {
        try {
            String encoding = detectFileEncoding(javaFile);
            if (!"UTF-8".equals(encoding)) {
                report.addViolation(new CodeQualityViolation(
                    javaFile.getAbsolutePath(),
                    1,
                    ViolationType.ENCODING_VIOLATION,
                    "æ–‡ä»¶ç¼–ç å¿…é¡»æ˜¯UTF-8ï¼Œå½“å‰ç¼–ç : " + encoding,
                    ViolationSeverity.HIGH
                ));
            }
        } catch (IOException e) {
            log.warn("æ£€æµ‹æ–‡ä»¶ç¼–ç å¤±è´¥: {}", javaFile.getPath(), e);
        }
    }

    private void checkCodeStyle(CompilationUnit cu, String filePath, CodeQualityReport report) {
        // 1. æ£€æŸ¥ç±»åè§„èŒƒ
        cu.getTypes().forEach(type -> {
            if (type instanceof ClassOrInterfaceDeclaration) {
                ClassOrInterfaceDeclaration clazz = (ClassOrInterfaceDeclaration) type;

                // æ£€æŸ¥ç±»åå‘½åè§„èŒƒ
                String className = clazz.getName().asString();
                if (!isValidClassName(className)) {
                    report.addViolation(new CodeQualityViolation(
                        filePath,
                        clazz.getBegin().get().line,
                        ViolationType.NAMING_VIOLATION,
                        "ç±»åä¸ç¬¦åˆè§„èŒƒ: " + className,
                        ViolationSeverity.MEDIUM
                    ));
                }

                // æ£€æŸ¥ç±»è¡Œæ•°
                int classLines = getClassLineCount(clazz);
                if (classLines > 500) {
                    report.addViolation(new CodeQualityViolation(
                        filePath,
                        clazz.getBegin().get().line,
                        ViolationType.SIZE_VIOLATION,
                        "ç±»è¡Œæ•°è¿‡å¤š: " + classLines + " è¡Œ (å»ºè®®â‰¤500è¡Œ)",
                        ViolationSeverity.HIGH
                    ));
                }

                // æ£€æŸ¥æ–¹æ³•
                checkMethods(clazz, filePath, report);
            }
        });
    }

    private void checkMethods(ClassOrInterfaceDeclaration clazz, String filePath, CodeQualityReport report) {
        clazz.getMethods().forEach(method -> {
            // æ£€æŸ¥æ–¹æ³•å‘½åè§„èŒƒ
            String methodName = method.getName().asString();
            if (!isValidMethodName(methodName)) {
                report.addViolation(new CodeQualityViolation(
                    filePath,
                    method.getBegin().get().line,
                    ViolationType.NAMING_VIOLATION,
                    "æ–¹æ³•åä¸ç¬¦åˆè§„èŒƒ: " + methodName,
                    ViolationSeverity.MEDIUM
                ));
            }

            // æ£€æŸ¥æ–¹æ³•è¡Œæ•°
            int methodLines = getMethodLineCount(method);
            if (methodLines > 50) {
                report.addViolation(new CodeQualityViolation(
                    filePath,
                    method.getBegin().get().line,
                    ViolationType.SIZE_VIOLATION,
                    "æ–¹æ³•è¡Œæ•°è¿‡å¤š: " + methodLines + " è¡Œ (å»ºè®®â‰¤50è¡Œ)",
                    ViolationSeverity.HIGH
                ));
            }

            // æ£€æŸ¥åœˆå¤æ‚åº¦
            int cyclomaticComplexity = calculateCyclomaticComplexity(method);
            if (cyclomaticComplexity > 10) {
                report.addViolation(new CodeQualityViolation(
                    filePath,
                    method.getBegin().get().line,
                    ViolationType.COMPLEXITY_VIOLATION,
                    "åœˆå¤æ‚åº¦è¿‡é«˜: " + cyclomaticComplexity + " (å»ºè®®â‰¤10)",
                    ViolationSeverity.HIGH
                ));
            }

            // æ£€æŸ¥å‚æ•°æ•°é‡
            int parameterCount = method.getParameters().size();
            if (parameterCount > 5) {
                report.addViolation(new CodeQualityViolation(
                    filePath,
                    method.getBegin().get().line,
                    ViolationType.PARAMETER_VIOLATION,
                    "å‚æ•°æ•°é‡è¿‡å¤š: " + parameterCount + " (å»ºè®®â‰¤5ä¸ª)",
                    ViolationSeverity.MEDIUM
                ));
            }
        });
    }

    private void checkSecurityVulnerabilities(CompilationUnit cu, String filePath, CodeQualityReport report) {
        SecurityVulnerabilityScanner scanner = new SecurityVulnerabilityScanner();
        List<SecurityVulnerability> vulnerabilities = scanner.scan(cu);

        for (SecurityVulnerability vuln : vulnerabilities) {
            report.addViolation(new CodeQualityViolation(
                filePath,
                vuln.getLineNumber(),
                ViolationType.SECURITY_VIOLATION,
                vuln.getDescription(),
                ViolationSeverity.CRITICAL
            ));
        }
    }
}
```

### å®‰å…¨æ¼æ´æ£€æµ‹å™¨
```java
// å®‰å…¨æ¼æ´æ‰«æå™¨
@Component
public class SecurityVulnerabilityScanner {

    /**
     * æ‰«æä»£ç ä¸­çš„å®‰å…¨æ¼æ´
     */
    public List<SecurityVulnerability> scan(CompilationUnit cu) {
        List<SecurityVulnerability> vulnerabilities = new ArrayList<>();

        cu.accept(new VoidVisitorAdapter<List<SecurityVulnerability>>() {
            @Override
            public void visit(MethodDeclaration n, List<SecurityVulnerability> vulnerabilities) {
                super.visit(n, vulnerabilities);

                // 1. æ£€æŸ¥SQLæ³¨å…¥é£é™©
                checkSQLInjection(n, vulnerabilities);

                // 2. æ£€æŸ¥ç¡¬ç¼–ç å¯†ç 
                checkHardcodedPassword(n, vulnerabilities);

                // 3. æ£€æŸ¥æ•æ„Ÿä¿¡æ¯æ³„éœ²
                checkSensitiveInfoLeakage(n, vulnerabilities);

                // 4. æ£€æŸ¥XSSæ”»å‡»é£é™©
                checkXSSVulnerability(n, vulnerabilities);
            }

            @Override
            public void visit(VariableDeclarator n, List<SecurityVulnerability> vulnerabilities) {
                super.visit(n, vulnerabilities);

                // æ£€æŸ¥å˜é‡å‘½åä¸­çš„æ•æ„Ÿä¿¡æ¯
                checkVariableNaming(n, vulnerabilities);
            }
        }, vulnerabilities);

        return vulnerabilities;
    }

    private void checkSQLInjection(MethodDeclaration method, List<SecurityVulnerability> vulnerabilities) {
        method.getBody().ifPresent(body -> {
            body.accept(new VoidVisitorAdapter<Void>() {
                @Override
                public void visit(MethodCallExpr n, Void arg) {
                    super.visit(n, arg);

                    String methodName = n.getNameAsString();
                    List<String> sqlKeywords = Arrays.asList("executeQuery", "executeUpdate", "createStatement");

                    if (sqlKeywords.contains(methodName)) {
                        // æ£€æŸ¥æ˜¯å¦ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
                        if (!isParameterizedQuery(n)) {
                            vulnerabilities.add(new SecurityVulnerability(
                                "SQLæ³¨å…¥é£é™©",
                                "æ–¹æ³•ä½¿ç”¨äº†éå‚æ•°åŒ–æŸ¥è¯¢ï¼Œå­˜åœ¨SQLæ³¨å…¥é£é™©",
                                n.getBegin().get().line,
                                SecurityVulnerabilityType.SQL_INJECTION
                            ));
                        }
                    }
                }
            }, null);
        });
    }

    private void checkHardcodedPassword(MethodDeclaration method, List<SecurityVulnerability> vulnerabilities) {
        method.getBody().ifPresent(body -> {
            body.accept(new VoidVisitorAdapter<Void>() {
                @Override
                public void visit(StringLiteralExpr n, Void arg) {
                    super.visit(n, arg);

                    String value = n.getValue();
                    if (isPasswordVariable(n) && looksLikePassword(value)) {
                        vulnerabilities.add(new SecurityVulnerability(
                            "ç¡¬ç¼–ç å¯†ç ",
                            "æ–¹æ³•ä¸­åŒ…å«ç¡¬ç¼–ç å¯†ç ï¼Œå­˜åœ¨å®‰å…¨é£é™©",
                            n.getBegin().get().line,
                            SecurityVulnerabilityType.HARDCODED_PASSWORD
                        ));
                    }
                }

                @Override
                public void visit(VariableDeclarator n, Void arg) {
                    super.visit(n, arg);

                    String variableName = n.getNameAsString();
                    if (isPasswordVariable(variableName)) {
                        // æ£€æŸ¥å˜é‡åˆå§‹åŒ–å€¼
                        if (n.getInitializer().isPresent()) {
                            Expression initializer = n.getInitializer().get();
                            if (initializer instanceof StringLiteralExpr) {
                                StringLiteralExpr strLiteral = (StringLiteralExpr) initializer;
                                if (looksLikePassword(strLiteral.getValue())) {
                                    vulnerabilities.add(new SecurityVulnerability(
                                        "ç¡¬ç¼–ç å¯†ç ",
                                        "å˜é‡åŒ…å«ç¡¬ç¼–ç å¯†ç : " + variableName,
                                        n.getBegin().get().line,
                                        SecurityVulnerabilityType.HARDCODED_PASSWORD
                                    ));
                                }
                            }
                        }
                    }
                }
            }, null);
        });
    }

    private void checkXSSVulnerability(MethodDeclaration method, List<SecurityVulnerability> vulnerabilities) {
        method.getBody().ifPresent(body -> {
            body.accept(new VoidVisitorAdapter<Void>() {
                @Override
                public void visit(MethodCallExpr n, Void arg) {
                    super.visit(n, arg);

                    String methodName = n.getNameAsString();
                    if ("write".equals(methodName) || "append".equals(methodName)) {
                        // æ£€æŸ¥æ˜¯å¦è¿›è¡Œäº†è¾“å‡ºç¼–ç 
                        if (!isOutputEncoded(n)) {
                            vulnerabilities.add(new SecurityVulnerability(
                                "XSSæ”»å‡»é£é™©",
                                "æ–¹æ³•è¾“å‡ºæœªè¿›è¡Œç¼–ç ï¼Œå­˜åœ¨XSSæ”»å‡»é£é™©",
                                n.getBegin().get().line,
                                SecurityVulnerabilityType.XSS_VULNERABILITY
                            ));
                        }
                    }
                }
            }, null);
        });
    }

    private boolean isParameterizedQuery(MethodCallExpr n) {
        // æ£€æŸ¥æ˜¯å¦ä½¿ç”¨äº†PreparedStatement
        return n.getScope().map(scope ->
            scope.toString().contains("PreparedStatement") ||
            scope.toString().contains("ParameterizedQuery")
        ).orElse(false);
    }

    private boolean isPasswordVariable(Expression expr) {
        // æ£€æŸ¥å˜é‡åæ˜¯å¦åŒ…å«å¯†ç ç›¸å…³çš„å…³é”®è¯
        String variableName = expr.toString().toLowerCase();
        return variableName.contains("password") ||
               variableName.contains("passwd") ||
               variableName.contains("pwd") ||
               variableName.contains("secret") ||
               variableName.contains("key");
    }

    private boolean looksLikePassword(String value) {
        if (value == null || value.length() < 6) {
            return false;
        }

        // æ£€æŸ¥æ˜¯å¦çœ‹èµ·æ¥åƒå¯†ç ï¼ˆåŒ…å«æ•°å­—ã€å­—æ¯ã€ç‰¹æ®Šå­—ç¬¦çš„ç»„åˆï¼‰
        boolean hasLetter = value.matches(".*[a-zA-Z].*");
        boolean hasDigit = value.matches(".*\\d.*");
        boolean hasSpecialChar = value.matches(".*[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>/?].*");

        return hasLetter && (hasDigit || hasSpecialChar) && !value.toLowerCase().contains("test");
    }

    private boolean isOutputEncoded(MethodCallExpr n) {
        // æ£€æŸ¥æ˜¯å¦è¿›è¡Œäº†HTML/JSç¼–ç 
        return n.getScope().map(scope ->
            scope.toString().contains("escapeHtml") ||
            scope.toString().contains("escapeJavaScript") ||
            scope.toString().contains("encode")
        ).orElse(false);
    }
}
```

### ä»£ç é‡æ„å»ºè®®å™¨
```java
// ä»£ç é‡æ„å»ºè®®ç”Ÿæˆå™¨
@Component
public class RefactoringSuggestionGenerator {

    /**
     * ç”Ÿæˆé‡æ„å»ºè®®
     */
    public List<RefactoringSuggestion> generateSuggestions(CodeQualityReport report) {
        List<RefactoringSuggestion> suggestions = new ArrayList<>();

        // 1. åˆ†æé‡å¤ä»£ç 
        suggestions.addAll(analyzeDuplicateCode(report));

        // 2. åˆ†æé•¿æ–¹æ³•
        suggestions.addAll(analyzeLongMethods(report));

        // 3. åˆ†æå¤§ç±»
        suggestions.addAll(analyzeLargeClasses(report));

        // 4. åˆ†æå¤æ‚æ¡ä»¶
        suggestions.addAll(analyzeComplexConditions(report));

        // 5. åˆ†æé­”æ³•æ•°å­—
        suggestions.addAll(analyzeMagicNumbers(report));

        // 6. åˆ†æå¼‚å¸¸å¤„ç†
        suggestions.addAll(analyzeExceptionHandling(report));

        return suggestions;
    }

    private List<RefactoringSuggestion> analyzeDuplicateCode(CodeQualityReport report) {
        List<RefactoringSuggestion> suggestions = new ArrayList<>();

        for (CodeQualityViolation violation : report.getViolations()) {
            if (violation.getType() == ViolationType.DUPLICATE_CODE) {
                suggestions.add(RefactoringSuggestion.builder()
                    .type(RefactoringType.EXTRACT_METHOD)
                    .title("æå–é‡å¤ä»£ç ä¸ºæ–¹æ³•")
                    .description("æ£€æµ‹åˆ°é‡å¤ä»£ç å—ï¼Œå»ºè®®æå–ä¸ºå…¬å…±æ–¹æ³•ä»¥å‡å°‘ä»£ç é‡å¤")
                    .priority(RefactoringPriority.HIGH)
                    .filePath(violation.getFilePath())
                    .lineNumber(violation.getLineNumber())
                    .example("// æå–å‰\n" + violation.getOriginalCode() + "\n\n" +
                              "// æå–å\n" + generateExtractedMethodExample(violation.getOriginalCode()))
                    .benefits(Arrays.asList(
                        "å‡å°‘ä»£ç é‡å¤",
                        "æé«˜ä»£ç å¯ç»´æŠ¤æ€§",
                        "é™ä½ç»´æŠ¤æˆæœ¬"
                    ))
                    .build());
            }
        }

        return suggestions;
    }

    private List<RefactoringSuggestion> analyzeLongMethods(CodeQualityReport report) {
        List<RefactoringSuggestion> suggestions = new ArrayList<>();

        for (CodeQualityViolation violation : report.getViolations()) {
            if (violation.getType() == ViolationType.SIZE_VIOLATION &&
                violation.getMessage().contains("æ–¹æ³•è¡Œæ•°è¿‡å¤š")) {

                suggestions.add(RefactoringSuggestion.builder()
                    .type(RefactoringType.EXTRACT_METHOD)
                    .title("æ‹†åˆ†é•¿æ–¹æ³•")
                    .description("æ–¹æ³•è¡Œæ•°è¿‡å¤šï¼Œå»ºè®®æ‹†åˆ†ä¸ºå¤šä¸ªå°æ–¹æ³•ä»¥æé«˜å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§")
                    .priority(RefactoringPriority.MEDIUM)
                    .filePath(violation.getFilePath())
                    .lineNumber(violation.getLineNumber())
                    .example("// æ‹†åˆ†å‰ï¼šé•¿æ–¹æ³•\n" +
                              "public void processOrder(Order order) {\n" +
                              "    // 100+ è¡Œä»£ç \n" +
                              "}\n\n" +
                              "// æ‹†åˆ†åï¼šå¤šä¸ªå°æ–¹æ³•\n" +
                              "public void processOrder(Order order) {\n" +
                              "    validateOrder(order);\n" +
                              "    calculatePrice(order);\n" +
                              "    saveOrder(order);\n" +
                              "    sendNotification(order);\n" +
                              "}\n")
                    .benefits(Arrays.asList(
                        "æé«˜ä»£ç å¯è¯»æ€§",
                        "ä¾¿äºå•å…ƒæµ‹è¯•",
                        "é™ä½åœˆå¤æ‚åº¦"
                    ))
                    .build());
            }
        }

        return suggestions;
    }

    private List<RefactoringSuggestion> analyzeMagicNumbers(CodeQualityReport report) {
        List<RefactoringSuggestion> suggestions = new ArrayList<>();

        for (CodeQualityViolation violation : report.getViolations()) {
            if (violation.getType() == ViolationType.MAGIC_NUMBER) {
                suggestions.add(RefactoringSuggestion.builder()
                    .type(RefactoringType.INTRODUCE_CONSTANT)
                    .title("å¼•å…¥å¸¸é‡æ›¿æ¢é­”æ³•æ•°å­—")
                    .description("ä»£ç ä¸­åŒ…å«é­”æ³•æ•°å­—ï¼Œå»ºè®®å®šä¹‰ä¸ºå¸¸é‡ä»¥æé«˜ä»£ç å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§")
                    .priority(RefactoringPriority.LOW)
                    .filePath(violation.getFilePath())
                    .lineNumber(violation.getLineNumber())
                    .example("// ä¿®æ”¹å‰\n" +
                              "if (user.getAge() > 18) {\n" +
                              "    // ...\n" +
                              "}\n\n" +
                              "// ä¿®æ”¹å\n" +
                              "public static final int ADULT_AGE = 18;\n" +
                              "if (user.getAge() > ADULT_AGE) {\n" +
                              "    // ...\n" +
                              "}\n")
                    .benefits(Arrays.asList(
                        "æé«˜ä»£ç å¯è¯»æ€§",
                        "ä¾¿äºç»Ÿä¸€ä¿®æ”¹",
                        "é¿å…ç¡¬ç¼–ç "
                    ))
                    .build());
            }
        }

        return suggestions;
    }
}
```

---

## ğŸ“Š è´¨é‡åº¦é‡ä½“ç³»

### ä»£ç è´¨é‡è¯„åˆ†æ¨¡å‹
```java
// ä»£ç è´¨é‡è¯„åˆ†è®¡ç®—å™¨
@Component
public class CodeQualityScoreCalculator {

    /**
     * è®¡ç®—ä»£ç è´¨é‡è¯„åˆ† (0-100åˆ†)
     */
    public QualityScore calculateScore(CodeQualityReport report) {
        QualityScore score = new QualityScore();

        // 1. åŸºç¡€åˆ†æ•°è®¡ç®—
        double baseScore = calculateBaseScore(report);
        score.setBaseScore(baseScore);

        // 2. è§„èŒƒæ€§è¯„åˆ†
        double standardScore = calculateStandardScore(report);
        score.setStandardScore(standardScore);

        // 3. å¤æ‚åº¦è¯„åˆ†
        double complexityScore = calculateComplexityScore(report);
        score.setComplexityScore(complexityScore);

        // 4. å®‰å…¨æ€§è¯„åˆ†
        double securityScore = calculateSecurityScore(report);
        score.setSecurityScore(securityScore);

        // 5. å¯ç»´æŠ¤æ€§è¯„åˆ†
        double maintainabilityScore = calculateMaintainabilityScore(report);
        score.setMaintainabilityScore(maintainabilityScore);

        // 6. ç»¼åˆè¯„åˆ†
        double overallScore = (baseScore * 0.2 + standardScore * 0.3 +
                             complexityScore * 0.2 + securityScore * 0.15 +
                             maintainabilityScore * 0.15);
        score.setOverallScore(overallScore);

        // 7. ç­‰çº§è¯„å®š
        score.setGrade(determineGrade(overallScore));

        // 8. æ”¹è¿›å»ºè®®
        score.setImprovementSuggestions(generateImprovementSuggestions(score));

        return score;
    }

    private double calculateBaseScore(CodeQualityReport report) {
        int totalFiles = report.getTotalFiles();
        if (totalFiles == 0) return 100.0;

        int violations = report.getViolationsBySeverity(ViolationSeverity.CRITICAL).size() +
                       report.getViolationsBySeverity(ViolationSeverity.HIGH).size();

        // åŸºç¡€åˆ†æ•°ï¼šä¸¥é‡è¿è§„è¶Šå°‘ï¼Œåˆ†æ•°è¶Šé«˜
        double violationRate = (double) violations / totalFiles;
        return Math.max(0, 100 - violationRate * 20);
    }

    private double calculateStandardScore(CodeQualityReport report) {
        int totalViolations = report.getViolations().size();
        int standardViolations = (int) report.getViolations().stream()
            .filter(v -> v.getType() == ViolationType.NAMING_VIOLATION ||
                           v.getType() == ViolationType.ENCODING_VIOLATION ||
                           v.getType() == ViolationType.FORMAT_VIOLATION)
            .count();

        if (totalViolations == 0) return 100.0;

        double standardViolationRate = (double) standardViolations / totalViolations;
        return Math.max(0, 100 - standardViolationRate * 30);
    }

    private double calculateComplexityScore(CodeQualityReport report) {
        List<CodeQualityViolation> complexityViolations = report.getViolations().stream()
            .filter(v -> v.getType() == ViolationType.COMPLEXITY_VIOLATION)
            .collect(Collectors.toList());

        if (complexityViolations.isEmpty()) return 100.0;

        // è®¡ç®—å¹³å‡åœˆå¤æ‚åº¦
        double avgComplexity = complexityViolations.stream()
            .mapToInt(v -> extractComplexityValue(v.getMessage()))
            .average()
            .orElse(10.0);

        // å¤æ‚åº¦è¯„åˆ†ï¼šå¹³å‡å¤æ‚åº¦è¶Šä½ï¼Œåˆ†æ•°è¶Šé«˜
        return Math.max(0, 100 - (avgComplexity - 1) * 8);
    }

    private double calculateSecurityScore(CodeQualityReport report) {
        int securityViolations = (int) report.getViolations().stream()
            .filter(v -> v.getType() == ViolationType.SECURITY_VIOLATION)
            .count();

        int totalFiles = report.getTotalFiles();
        if (totalFiles == 0) return 100.0;

        // å®‰å…¨è¯„åˆ†ï¼šå®‰å…¨è¿è§„è¶Šå°‘ï¼Œåˆ†æ•°è¶Šé«˜
        double securityViolationRate = (double) securityViolations / totalFiles;
        return Math.max(0, 100 - securityViolationRate * 50);
    }

    private QualityGrade determineGrade(double score) {
        if (score >= 90) return QualityGrade.EXCELLENT;
        if (score >= 80) return QualityGrade.GOOD;
        if (score >= 70) return QualityGrade.ACCEPTABLE;
        if (score >= 60) return QualityGrade.NEEDS_IMPROVEMENT;
        return QualityGrade.POOR;
    }

    private List<String> generateImprovementSuggestions(QualityScore score) {
        List<String> suggestions = new ArrayList<>();

        if (score.getStandardScore() < 80) {
            suggestions.add("åŠ å¼ºä»£ç è§„èŒƒæ€§ï¼Œéµå¾ªå‘½åå’Œæ ¼å¼æ ‡å‡†");
        }

        if (score.getComplexityScore() < 80) {
            suggestions.add("é™ä½æ–¹æ³•å¤æ‚åº¦ï¼Œæ‹†åˆ†é•¿æ–¹æ³•");
        }

        if (score.getSecurityScore() < 80) {
            suggestions.add("ä¿®å¤å®‰å…¨æ¼æ´ï¼ŒåŠ å¼ºè¾“å…¥éªŒè¯å’Œè¾“å‡ºç¼–ç ");
        }

        if (score.getMaintainabilityScore() < 80) {
            suggestions.add("å‡å°‘ä»£ç é‡å¤ï¼Œæé«˜ä»£ç å¯ç»´æŠ¤æ€§");
        }

        if (score.getOverallScore() < 70) {
            suggestions.add("å»ºè®®è¿›è¡Œå…¨é¢çš„ä»£ç é‡æ„");
        }

        return suggestions;
    }
}
```

---

## ğŸ› ï¸ å¼€å‘è§„èŒƒå’Œæœ€ä½³å®è·µ

### ç¼–ç è§„èŒƒæ£€æŸ¥æ¸…å•
```java
// ç¼–ç è§„èŒƒæ£€æŸ¥å·¥å…·
@Component
public class CodeStandardsChecker {

    /**
     * ç¼–ç è§„èŒƒæ£€æŸ¥æ¸…å•
     */
    public CodeStandardsReport checkStandards(String projectPath) {
        CodeStandardsReport report = new CodeStandardsReport();

        List<File> javaFiles = scanJavaFiles(projectPath);

        for (File javaFile : javaFiles) {
            checkFileStandards(javaFile, report);
        }

        return report;
    }

    private void checkFileStandards(File javaFile, CodeStandardsReport report) {
        try {
            String content = Files.readString(javaFile.toPath());
            String[] lines = content.split("\n");

            // 1. æ£€æŸ¥UTF-8ç¼–ç 
            checkUTF8Encoding(javaFile, report);

            // 2. æ£€æŸ¥è¡Œå°¾ç©ºæ ¼
            checkTrailingSpaces(lines, javaFile, report);

            // 3. æ£€æŸ¥ç©ºè¡Œè§„èŒƒ
            checkEmptyLineRules(lines, javaFile, report);

            // 4. æ£€æŸ¥æ‹¬å·è§„èŒƒ
            checkBracketRules(lines, javaFile, report);

            // 5. æ£€æŸ¥å‘½åè§„èŒƒ
            checkNamingRules(content, javaFile, report);

            // 6. æ£€æŸ¥æ³¨é‡Šè§„èŒƒ
            checkCommentRules(content, javaFile, report);

        } catch (IOException e) {
            log.warn("æ£€æŸ¥æ–‡ä»¶è§„èŒƒå¤±è´¥: {}", javaFile.getPath(), e);
        }
    }

    private void checkUTF8Encoding(File javaFile, CodeStandardsReport report) {
        try {
            byte[] bytes = Files.readAllBytes(javaFile.toPath());
            String encoding = detectEncoding(bytes);

            if (!"UTF-8".equals(encoding)) {
                report.addViolation(new StandardsViolation(
                    javaFile.getPath(),
                    1,
                    "æ–‡ä»¶ç¼–ç å¿…é¡»ä¸ºUTF-8ï¼Œå½“å‰ä¸º: " + encoding,
                    StandardsType.ENCODING
                ));
            }
        } catch (IOException e) {
            log.warn("æ£€æµ‹æ–‡ä»¶ç¼–ç å¤±è´¥: {}", javaFile.getPath(), e);
        }
    }

    private void checkTrailingSpaces(String[] lines, File javaFile, CodeStandardsReport report) {
        for (int i = 0; i < lines.length; i++) {
            String line = lines[i];
            if (line.endsWith(" ") || line.endsWith("\t")) {
                report.addViolation(new StandardsViolation(
                    javaFile.getPath(),
                    i + 1,
                    "è¡Œå°¾åŒ…å«å¤šä½™çš„ç©ºæ ¼æˆ–åˆ¶è¡¨ç¬¦",
                    StandardsType.TRAILING_SPACES
                ));
            }
        }
    }

    private void checkNamingRules(String content, File javaFile, CodeStandardsReport report) {
        // æ£€æŸ¥ç±»åï¼ˆå¤§é©¼å³°ï¼‰
        Pattern classPattern = Pattern.compile("class\\s+([A-Z][a-zA-Z0-9]*)");
        Matcher classMatcher = classPattern.matcher(content);
        while (classMatcher.find()) {
            String className = classMatcher.group(1);
            if (!isValidClassName(className)) {
                report.addViolation(new StandardsViolation(
                    javaFile.getPath(),
                    findLineNumber(content, classMatcher.start()),
                    "ç±»åä¸ç¬¦åˆå¤§é©¼å³°è§„èŒƒ: " + className,
                    StandardsType.CLASS_NAMING
                ));
            }
        }

        // æ£€æŸ¥æ–¹æ³•åï¼ˆå°é©¼å³°ï¼‰
        Pattern methodPattern = Pattern.compile("(?:public|private|protected)\\s+(?:static\\s+)?(?:\\w+\\s+)?(\\w+)\\s*\\(");
        Matcher methodMatcher = methodPattern.matcher(content);
        while (methodMatcher.find()) {
            String methodName = methodMatcher.group(1);
            if (!isValidMethodName(methodName)) {
                report.addViolation(new StandardsViolation(
                    javaFile.getPath(),
                    findLineNumber(content, methodMatcher.start()),
                    "æ–¹æ³•åä¸ç¬¦åˆå°é©¼å³°è§„èŒƒ: " + methodName,
                    StandardsType.METHOD_NAMING
                ));
            }
        }
    }

    private boolean isValidClassName(String className) {
        return className.matches("^[A-Z][a-zA-Z0-9]*$");
    }

    private boolean isValidMethodName(String methodName) {
        return methodName.matches("^[a-z][a-zA-Z0-9]*$");
    }

    private int findLineNumber(String content, int position) {
        String beforePosition = content.substring(0, position);
        return beforePosition.split("\n").length;
    }
}
```

---

## ğŸ”— ç›¸å…³æ–‡æ¡£å‚è€ƒ

### æ ¸å¿ƒæ¶æ„æ–‡æ¡£
- **ğŸ“‹ CLAUDE.md**: å…¨å±€æ¶æ„è§„èŒƒ (å¼ºåˆ¶éµå¾ª)
- **ğŸ—ï¸ å››å±‚æ¶æ„è¯¦è§£**: Controllerâ†’Serviceâ†’Managerâ†’DAOæ¶æ„æ¨¡å¼
- **ğŸ”§ ä¾èµ–æ³¨å…¥è§„èŒƒ**: ç»Ÿä¸€ä½¿ç”¨@Resourceæ³¨è§£
- **ğŸ“¦ DAOå±‚è§„èŒƒ**: ç»Ÿä¸€ä½¿ç”¨Daoåç¼€å’Œ@Mapperæ³¨è§£

### è´¨é‡ä¿éšœæ–‡æ¡£
- **ğŸ“Š ä»£ç è´¨é‡è§„èŒƒ**: ä¼ä¸šçº§ä»£ç ç¼–å†™è§„èŒƒ
- **ğŸ” ä»£ç å®¡æŸ¥æ¸…å•**: ä»£ç å®¡æŸ¥æ ‡å‡†å’Œæ£€æŸ¥æ¸…å•
- **ğŸ› ï¸ é‡æ„æœ€ä½³å®è·µ**: ä»£ç é‡æ„æŒ‡å¯¼åŸåˆ™
- **ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–æŒ‡å—**: ä»£ç æ€§èƒ½ä¼˜åŒ–å»ºè®®

### å¼€å‘å·¥å…·æ–‡æ¡£
- **Checkstyle**: ä»£ç é£æ ¼æ£€æŸ¥å·¥å…·
- **PMD**: ä»£ç è´¨é‡åˆ†æå·¥å…·
- **FindBugs/SpotBugs**: ç¼ºé™·æ£€æµ‹å·¥å…·
- **SonarQube**: ä»£ç è´¨é‡åˆ†æå¹³å°

---

**ğŸ“‹ é‡è¦æé†’**:
1. æœ¬æŠ€èƒ½ä¸¥æ ¼å®ˆæŠ¤IOE-DREAMä»£ç è´¨é‡æ ‡å‡†
2. æ‰€æœ‰ä»£ç å¿…é¡»ç¬¦åˆä¼ä¸šçº§è´¨é‡è¦æ±‚
3. æŒç»­è¿›è¡Œä»£ç è´¨é‡ç›‘æ§å’Œæ”¹è¿›
4. å®šæœŸè¿›è¡Œä»£ç å®¡æŸ¥å’Œé‡æ„
5. å»ºç«‹è´¨é‡åº¦é‡å’Œè¯„åˆ†ä½“ç³»
6. é‡è§†å®‰å…¨æ¼æ´ä¿®å¤å’Œé¢„é˜²
7. ä¿æŒæµ‹è¯•è¦†ç›–ç‡å’Œè´¨é‡

**è®©æˆ‘ä»¬ä¸€èµ·å»ºè®¾é«˜è´¨é‡ã€é«˜æ ‡å‡†çš„ä»£ç ä½“ç³»ï¼** ğŸš€

---
**æ–‡æ¡£ç‰ˆæœ¬**: v2.0.0 - IOE-DREAMä¸ƒå¾®æœåŠ¡ä¸“ä¸šç‰ˆ
**åˆ›å»ºæ—¶é—´**: 2025-12-08
**æœ€åæ›´æ–°**: 2025-12-08
**æŠ€èƒ½ç­‰çº§**: â˜…â˜…â˜…â˜…â˜…â˜… (é¡¶çº§ä¸“å®¶)
**é€‚ç”¨æ¶æ„**: ä¼ä¸šçº§Javaä»£ç è´¨é‡ä¿éšœä½“ç³»