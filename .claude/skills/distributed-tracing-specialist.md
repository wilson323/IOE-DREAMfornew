# ğŸ” åˆ†å¸ƒå¼è¿½è¸ªä¸“å®¶æŠ€èƒ½
## Distributed Tracing Specialist

**ğŸ¯ æŠ€èƒ½å®šä½**: IOE-DREAMé¡¹ç›®åˆ†å¸ƒå¼è¿½è¸ªä¸“å®¶ï¼Œç²¾é€šé“¾è·¯è¿½è¸ªã€æ€§èƒ½ç›‘æ§ã€æ•…éšœè¯Šæ–­ã€å¾®æœåŠ¡è°ƒç”¨åˆ†æç­‰æ ¸å¿ƒè¿½è¸ªæŠ€èƒ½

**âš¡ æŠ€èƒ½ç­‰çº§**: â˜…â˜…â˜…â˜…â˜… (é¡¶çº§ä¸“å®¶)
**ğŸ¯ é€‚ç”¨åœºæ™¯**: åˆ†å¸ƒå¼é“¾è·¯è¿½è¸ªã€æœåŠ¡è°ƒç”¨ç›‘æ§ã€æ€§èƒ½ç“¶é¢ˆåˆ†æã€æ•…éšœå¿«é€Ÿå®šä½ã€å¾®æœåŠ¡æ²»ç†
**ğŸ“Š æŠ€èƒ½è¦†ç›–**: é“¾è·¯è¿½è¸ª | æ€§èƒ½ç›‘æ§ | æ•…éšœè¯Šæ–­ | è°ƒç”¨åˆ†æ | åˆ†å¸ƒå¼æ—¥å¿— | ç›‘æ§å‘Šè­¦

**ğŸ“‹ æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0 - IOE-DREAMä¼ä¸šçº§è¿½è¸ªç‰ˆ
**ğŸ“… åˆ›å»ºæ—¶é—´**: 2025-12-02
**ğŸ“… æœ€åæ›´æ–°**: 2025-12-02
**ğŸ‘¥ ä½œè€…**: åˆ†å¸ƒå¼è¿½è¸ªä¸“å®¶å›¢é˜Ÿ
**ğŸ‘¥ å®¡æ‰¹äºº**: å¾®æœåŠ¡æ¶æ„å§”å‘˜ä¼š
**ğŸ”„ å˜æ›´ç±»å‹**: MAJOR (P0çº§åŸºç¡€è®¾æ–½ç¼ºå¤±è§£å†³)

---

## ğŸ“‹ å˜æ›´å†å²

| ç‰ˆæœ¬ | æ—¥æœŸ | å˜æ›´å†…å®¹ | å˜æ›´äºº | å®¡æ‰¹äºº | å˜æ›´ç±»å‹ |
|------|------|----------|--------|--------|----------|
| v1.0.0 | 2025-12-02 | åˆå§‹ç‰ˆæœ¬ï¼Œè§£å†³22ä¸ªå¾®æœåŠ¡é“¾è·¯è¿½è¸ªP0çº§ç¼ºå¤±é—®é¢˜ | åˆ†å¸ƒå¼è¿½è¸ªä¸“å®¶å›¢é˜Ÿ | å¾®æœåŠ¡æ¶æ„å§”å‘˜ä¼š | MAJOR |

---

## ğŸ“Š æŠ€èƒ½è´¨é‡æŒ‡æ ‡

| æŒ‡æ ‡åç§° | ç›®æ ‡å€¼ | å½“å‰å€¼ | çŠ¶æ€ |
|---------|--------|--------|------|
| **é“¾è·¯è¿½è¸ªè¦†ç›–ç‡** | 100% | 0% | ğŸ”´ P0çº§ç¼ºå¤± |
| **æœåŠ¡è°ƒç”¨å¯è§‚æµ‹æ€§** | 100% | 48% | ğŸ”´ ä¸¥é‡ä¸è¶³ |
| **æ•…éšœå®šä½æ—¶é—´** | â‰¤5min | â‰¥60min | ğŸ”´ æåº¦ä½æ•ˆ |
| **æ€§èƒ½ç“¶é¢ˆè¯†åˆ«** | â‰¥95% | 20% | ğŸ”´ æ— æ³•è¯†åˆ« |
| **ç›‘æ§å‘Šè­¦è¦†ç›–ç‡** | â‰¥90% | 35% | ğŸ”´ å‘Šè­¦ç›²åŒº |

---

## ğŸš¨ P0çº§åŸºç¡€è®¾æ–½ç¼ºå¤±åˆ†æ

### **å½“å‰è¿½è¸ªçŠ¶å†µ**ï¼ˆåŸºäº2025-12-01å…¨å±€æ¶æ„æ·±åº¦åˆ†æï¼‰

**ğŸ”´ ä¸¥é‡åŸºç¡€è®¾æ–½ç¼ºå¤±**ï¼š
- **22ä¸ªå¾®æœåŠ¡ç¼ºå¤±é“¾è·¯è¿½è¸ª**: æ‰€æœ‰å¾®æœåŠ¡éƒ½æ²¡æœ‰å®ç°åˆ†å¸ƒå¼è¿½è¸ª
- **ç›‘æ§ç»´åº¦è¯„åˆ†52/100**: è¿œä½äºä¼ä¸šçº§æ ‡å‡†90åˆ†
- **æ•…éšœå®šä½æ—¶é—´â‰¥60åˆ†é’Ÿ**: æ— æ³•å¿«é€Ÿå®šä½æœåŠ¡è°ƒç”¨é—®é¢˜
- **æ€§èƒ½ç“¶é¢ˆè¯†åˆ«ç‡20%**: æ— æ³•æœ‰æ•ˆè¯†åˆ«æ€§èƒ½ç“¶é¢ˆ

**ğŸ¯ ç«‹å³å»ºè®¾ç›®æ ‡**ï¼š
- âœ… **100%é“¾è·¯è¿½è¸ªè¦†ç›–**: æ‰€æœ‰22ä¸ªå¾®æœåŠ¡å¿…é¡»å®ç°é“¾è·¯è¿½è¸ª
- âœ… **5åˆ†é’Ÿæ•…éšœå®šä½**: æ•…éšœå®šä½æ—¶é—´ä»60åˆ†é’Ÿç¼©çŸ­è‡³5åˆ†é’Ÿ
- âœ… **95%æ€§èƒ½ç“¶é¢ˆè¯†åˆ«**: å»ºç«‹å®Œæ•´çš„æ€§èƒ½ç›‘æ§ä½“ç³»
- âœ… **90%ç›‘æ§å‘Šè­¦è¦†ç›–**: å»ºç«‹å…¨é¢çš„å‘Šè­¦æœºåˆ¶

---

## ğŸ“‹ æŠ€èƒ½æ¦‚è¿°

æœ¬æŠ€èƒ½ä¸“é—¨è§£å†³IOE-DREAMé¡¹ç›®çš„åˆ†å¸ƒå¼è¿½è¸ªåŸºç¡€è®¾æ–½ç¼ºå¤±é—®é¢˜ï¼Œå»ºç«‹ä¼ä¸šçº§çš„å¾®æœåŠ¡å¯è§‚æµ‹æ€§ä½“ç³»ï¼Œç¡®ä¿æ‰€æœ‰æœåŠ¡è°ƒç”¨éƒ½å¯ä»¥è¢«å®Œæ•´è¿½è¸ªå’Œç›‘æ§ã€‚

**æ ¸å¿ƒèƒ½åŠ›**: è®¾è®¡å’Œå®ç°åˆ†å¸ƒå¼è¿½è¸ªæ¶æ„ï¼Œå»ºç«‹æ€§èƒ½ç›‘æ§ä½“ç³»ï¼Œå®ç°æ•…éšœå¿«é€Ÿå®šä½ï¼Œæä¾›å¾®æœåŠ¡è°ƒç”¨æ·±åº¦åˆ†æã€‚

---

## ğŸ—ï¸ åˆ†å¸ƒå¼è¿½è¸ªæ ¸å¿ƒæ¶æ„

### **1. Spring Cloud Sleuth + Zipkin æ¶æ„**

#### **è¿½è¸ªç³»ç»Ÿæ¶æ„å›¾**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å¾®æœåŠ¡A       â”‚    â”‚   å¾®æœåŠ¡B       â”‚    â”‚   å¾®æœåŠ¡C       â”‚
â”‚ ioedream-xxx    â”‚    â”‚ ioedream-yyy    â”‚    â”‚ ioedream-zzz    â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ Sleuth Client   â”‚    â”‚ Sleuth Client   â”‚    â”‚ Sleuth Client   â”‚
â”‚ Trace ID Span   â”‚â”€â”€â”€â–¶â”‚ Trace ID Span   â”‚â”€â”€â”€â–¶â”‚ Trace ID Span   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   API Gateway   â”‚
                    â”‚ ioedream-gatewayâ”‚
                    â”‚   Sleuth +      â”‚
                    â”‚   Gateway Filterâ”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   Zipkin Server â”‚
                    â”‚   æ”¶é›† & å­˜å‚¨   â”‚
                    â”‚   åˆ†æ & å±•ç¤º   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### **Mavenä¾èµ–é…ç½®**
```xml
<!-- pom.xml - åˆ†å¸ƒå¼è¿½è¸ªä¾èµ– -->
<dependencies>
    <!-- Spring Cloud Sleuth -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-sleuth</artifactId>
    </dependency>

    <!-- Spring Cloud Sleuth Zipkin -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-zipkin</artifactId>
    </dependency>

    <!-- Brave Tracing -->
    <dependency>
        <groupId>io.zipkin.brave</groupId>
        <artifactId>brave-bom</artifactId>
        <version>${brave.version}</version>
        <type>pom</type>
        <scope>import</scope>
    </dependency>

    <!-- RabbitMQ Transport -->
    <dependency>
        <groupId>org.springframework.amqp</groupId>
        <artifactId>spring-rabbit</artifactId>
    </dependency>
</dependencies>
```

#### **é…ç½®æ–‡ä»¶æ¨¡æ¿**
```yaml
# application.yml - åˆ†å¸ƒå¼è¿½è¸ªé…ç½®
spring:
  application:
    name: ${SERVICE_NAME:ioedream-access-service}

  # Sleuthé…ç½®
  sleuth:
    sampler:
      probability: 1.0  # 100%é‡‡æ ·ç‡ï¼Œç”Ÿäº§ç¯å¢ƒå¯è°ƒæ•´ä¸º0.1
    zipkin:
      base-url: ${ZIPKIN_BASE_URL:http://localhost:9411}
      sender:
        type: rabbit  # ä½¿ç”¨RabbitMQå‘é€è¿½è¸ªæ•°æ®
      rabbitmq:
        addresses: ${RABBITMQ_ADDRESSES:localhost:5672}
        queue: zipkin
        username: ${RABBITMQ_USERNAME:guest}
        password: ${RABBITMQ_PASSWORD:guest}

  # RabbitMQé…ç½®
  rabbitmq:
    host: ${RABBITMQ_HOST:localhost}
    port: ${RABBITMQ_PORT:5672}
    username: ${RABBITMQ_USERNAME:guest}
    password: ${RABBITMQ_PASSWORD:guest}
    virtual-host: ${RABBITMQ_VHOST:/}

# ç®¡ç†ç«¯ç‚¹é…ç½®
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus,tracing
  endpoint:
    tracing:
      enabled: true
  tracing:
    sampling:
      probability: 1.0
  zipkin:
    tracing:
      endpoint: ${ZIPKIN_BASE_URL:http://localhost:9411}/api/v2/spans
```

### **2. æ ¸å¿ƒè¿½è¸ªç»„ä»¶å®ç°**

#### **è‡ªå®šä¹‰è¿½è¸ªè¿‡æ»¤å™¨**
```java
/**
 * åˆ†å¸ƒå¼è¿½è¸ªè¿‡æ»¤å™¨
 * ä¸ºæ¯ä¸ªè¯·æ±‚ç”ŸæˆTrace IDå’ŒSpan ID
 */
@Component
@Slf4j
public class DistributedTracingFilter implements Filter {

    @Resource
    private Tracer tracer;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {

        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;

        // ç”Ÿæˆæˆ–è·å–Trace ID
        String traceId = getOrCreateTraceId(httpRequest);

        // åˆ›å»ºæ–°çš„Span
        Span span = tracer.nextSpan()
                .name(httpRequest.getMethod() + " " + httpRequest.getRequestURI())
                .tag("http.method", httpRequest.getMethod())
                .tag("http.url", httpRequest.getRequestURL().toString())
                .tag("user.agent", httpRequest.getHeader("User-Agent"))
                .tag("remote.ip", getClientIp(httpRequest))
                .start();

        try (Tracer.SpanInScope ws = tracer.withSpanInScope(span)) {
            // è®¾ç½®MDCç”¨äºæ—¥å¿—
            MDC.put("traceId", span.context().traceId());
            MDC.put("spanId", span.context().spanId());

            // æ·»åŠ è¿½è¸ªå¤´åˆ°å“åº”
            httpResponse.setHeader("X-Trace-Id", span.context().traceId());
            httpResponse.setHeader("X-Span-Id", span.context().spanId());

            // è®°å½•è¯·æ±‚å¼€å§‹
            log.info("è¯·æ±‚å¼€å§‹: method={}, uri={}, traceId={}",
                    httpRequest.getMethod(), httpRequest.getRequestURI(), span.context().traceId());

            long startTime = System.currentTimeMillis();

            try {
                // æ‰§è¡Œè¯·æ±‚
                chain.doFilter(request, response);

                // è®°å½•æˆåŠŸ
                long duration = System.currentTimeMillis() - startTime;
                span.tag("http.status_code", String.valueOf(httpResponse.getStatus()));
                span.tag("duration_ms", String.valueOf(duration));

                if (httpResponse.getStatus() >= 400) {
                    span.tag("error", "true");
                }

                log.info("è¯·æ±‚å®Œæˆ: method={}, uri={}, status={}, duration={}ms, traceId={}",
                        httpRequest.getMethod(), httpRequest.getRequestURI(),
                        httpResponse.getStatus(), duration, span.context().traceId());

            } catch (Exception e) {
                // è®°å½•å¼‚å¸¸
                span.tag("error", "true");
                span.tag("error.message", e.getMessage());

                long duration = System.currentTimeMillis() - startTime;
                log.error("è¯·æ±‚å¼‚å¸¸: method={}, uri={}, error={}, duration={}ms, traceId={}",
                        httpRequest.getMethod(), httpRequest.getRequestURI(),
                        e.getMessage(), duration, span.context().traceId(), e);

                throw e;
            }

        } finally {
            span.end();
            MDC.clear();
        }
    }

    /**
     * è·å–æˆ–åˆ›å»ºTrace ID
     */
    private String getOrCreateTraceId(HttpServletRequest request) {
        String traceId = request.getHeader("X-Trace-Id");
        if (traceId == null || traceId.isEmpty()) {
            traceId = UUID.randomUUID().toString().replace("-", "");
        }
        return traceId;
    }

    /**
     * è·å–å®¢æˆ·ç«¯çœŸå®IP
     */
    private String getClientIp(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }
        return request.getRemoteAddr();
    }
}
```

#### **å¾®æœåŠ¡è°ƒç”¨è¿½è¸ªå¢å¼º**
```java
/**
 * å¾®æœåŠ¡è°ƒç”¨è¿½è¸ªå¢å¼º
 * ä¸ºæœåŠ¡é—´è°ƒç”¨æ·»åŠ é“¾è·¯è¿½è¸ªä¿¡æ¯
 */
@Component
@Slf4j
public class ServiceCallTracingInterceptor implements ClientInterceptor {

    @Resource
    private Tracer tracer;

    @Override
    public <REQ, RESP> ClientCall<REQ, RESP> interceptCall(
            MethodDescriptor<REQ, RESP> method,
            CallOptions callOptions,
            Channel next) {

        return new ForwardingClientCall.SimpleForwardingClientCall<>(next.newCall(method, callOptions)) {

            @Override
            public void start(Listener<RESP> responseListener, Metadata headers) {
                // æ·»åŠ è¿½è¸ªå¤´
                Span currentSpan = tracer.currentSpan();
                if (currentSpan != null) {
                    TraceContext context = currentSpan.context();
                    headers.put(Metadata.Key.of("X-Trace-Id", Metadata.ASCII_STRING_MARSHALLER),
                            context.traceId());
                    headers.put(Metadata.Key.of("X-Span-Id", Metadata.ASCII_STRING_MARSHALLER),
                            context.spanId());
                    headers.put(Metadata.Key.of("X-Parent-Span-Id", Metadata.ASCII_STRING_MARSHALLER),
                            context.parentId() != null ? context.parentId() : "");
                }

                super.start(responseListener, headers);
            }
        };
    }
}

/**
 * æœåŠ¡è°ƒç”¨è¿½è¸ªå·¥å…·ç±»
 */
@Component
@Slf4j
public class ServiceCallTracer {

    @Resource
    private Tracer tracer;

    /**
     * è¿½è¸ªæœåŠ¡è°ƒç”¨
     */
    public <T> T traceServiceCall(String serviceName, String operation, Supplier<T> call) {
        Span span = tracer.nextSpan()
                .name("service-call")
                .tag("service.name", serviceName)
                .tag("service.operation", operation)
                .tag("call.type", "service-to-service")
                .start();

        try (Tracer.SpanInScope ws = tracer.withSpanInScope(span)) {
            log.info("å¼€å§‹æœåŠ¡è°ƒç”¨: service={}, operation={}, traceId={}",
                    serviceName, operation, span.context().traceId());

            long startTime = System.currentTimeMillis();

            try {
                T result = call.get();

                long duration = System.currentTimeMillis() - startTime;
                span.tag("duration_ms", String.valueOf(duration));
                span.tag("call.success", "true");

                log.info("æœåŠ¡è°ƒç”¨æˆåŠŸ: service={}, operation={}, duration={}ms, traceId={}",
                        serviceName, operation, duration, span.context().traceId());

                return result;

            } catch (Exception e) {
                long duration = System.currentTimeMillis() - startTime;
                span.tag("duration_ms", String.valueOf(duration));
                span.tag("call.success", "false");
                span.tag("error.message", e.getMessage());
                span.tag("error.type", e.getClass().getSimpleName());

                log.error("æœåŠ¡è°ƒç”¨å¤±è´¥: service={}, operation={}, error={}, duration={}ms, traceId={}",
                        serviceName, operation, e.getMessage(), duration, span.context().traceId(), e);

                throw new ServiceCallException("æœåŠ¡è°ƒç”¨å¤±è´¥: " + e.getMessage(), e);
            }

        } finally {
            span.end();
        }
    }

    /**
     * è¿½è¸ªå¼‚æ­¥æœåŠ¡è°ƒç”¨
     */
    public <T> CompletableFuture<T> traceAsyncServiceCall(
            String serviceName, String operation, Supplier<CompletableFuture<T>> asyncCall) {

        Span span = tracer.nextSpan()
                .name("async-service-call")
                .tag("service.name", serviceName)
                .tag("service.operation", operation)
                .tag("call.type", "async")
                .start();

        try (Tracer.SpanInScope ws = tracer.withSpanInScope(span)) {
            log.info("å¼€å§‹å¼‚æ­¥æœåŠ¡è°ƒç”¨: service={}, operation={}, traceId={}",
                    serviceName, operation, span.context().traceId());

            long startTime = System.currentTimeMillis();

            return asyncCall.get()
                    .whenComplete((result, throwable) -> {
                        long duration = System.currentTimeMillis() - startTime;
                        span.tag("duration_ms", String.valueOf(duration));

                        if (throwable != null) {
                            span.tag("call.success", "false");
                            span.tag("error.message", throwable.getMessage());
                            span.tag("error.type", throwable.getClass().getSimpleName());

                            log.error("å¼‚æ­¥æœåŠ¡è°ƒç”¨å¤±è´¥: service={}, operation={}, error={}, duration={}ms, traceId={}",
                                    serviceName, operation, throwable.getMessage(), duration, span.context().traceId());
                        } else {
                            span.tag("call.success", "true");
                            log.info("å¼‚æ­¥æœåŠ¡è°ƒç”¨æˆåŠŸ: service={}, operation={}, duration={}ms, traceId={}",
                                    serviceName, operation, duration, span.context().traceId());
                        }

                        span.end();
                    })
                    .contextCopy(span.context());  // ç¡®ä¿å¼‚æ­¥çº¿ç¨‹ä¹Ÿèƒ½è·å–è¿½è¸ªä¸Šä¸‹æ–‡
        }
    }
}
```

### **3. ç½‘å…³æœåŠ¡è¿½è¸ªå¢å¼º**

#### **Gatewayè¿½è¸ªè¿‡æ»¤å™¨**
```java
/**
 * ç½‘å…³åˆ†å¸ƒå¼è¿½è¸ªè¿‡æ»¤å™¨
 * åœ¨APIç½‘å…³å±‚ç»Ÿä¸€å¤„ç†é“¾è·¯è¿½è¸ª
 */
@Component
@Slf4j
public class GatewayTracingFilter implements GlobalFilter, Ordered {

    @Resource
    private Tracer tracer;

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();

        // ç”Ÿæˆæˆ–è·å–Trace ID
        String traceId = getOrCreateTraceId(request);

        // åˆ›å»ºæ ¹Span
        Span span = tracer.nextSpan()
                .name("gateway-request")
                .tag("component", "spring-gateway")
                .tag("gateway.request.id", exchange.getRequest().getId())
                .tag("http.method", request.getMethod().name())
                .tag("http.url", request.getURI().toString())
                .tag("http.scheme", request.getURI().getScheme())
                .tag("http.host", request.getURI().getHost())
                .tag("http.port", String.valueOf(request.getURI().getPort()))
                .tag("user.agent", request.getHeaders().getFirst("User-Agent"))
                .start();

        try (Tracer.SpanInScope ws = tracer.withSpanInScope(span)) {
            // è®¾ç½®MDC
            MDC.put("traceId", span.context().traceId());
            MDC.put("spanId", span.context().spanId());

            long startTime = System.currentTimeMillis();

            // æ·»åŠ è¿½è¸ªå¤´åˆ°ä¸‹æ¸¸æœåŠ¡
            ServerHttpRequest mutatedRequest = request.mutate()
                    .header("X-Trace-Id", span.context().traceId())
                    .header("X-Span-Id", span.context().spanId())
                    .header("X-Parent-Span-Id", span.context().parentId() != null ? span.context().parentId() : "")
                    .build();

            ServerWebExchange mutatedExchange = exchange.mutate()
                    .request(mutatedRequest)
                    .build();

            log.info("ç½‘å…³è¯·æ±‚å¼€å§‹: method={}, uri={}, traceId={}",
                    request.getMethod(), request.getURI(), span.context().traceId());

            return chain.filter(mutatedExchange)
                    .doOnSuccess(response -> {
                        long duration = System.currentTimeMillis() - startTime;
                        span.tag("http.status_code", String.valueOf(response.getStatusCode().value()));
                        span.tag("duration_ms", String.valueOf(duration));
                        span.tag("gateway.response.success", "true");

                        // æ·»åŠ è¿½è¸ªå¤´åˆ°å“åº”
                        response.getHeaders().set("X-Trace-Id", span.context().traceId());

                        log.info("ç½‘å…³è¯·æ±‚å®Œæˆ: method={}, uri={}, status={}, duration={}ms, traceId={}",
                                request.getMethod(), request.getURI(), response.getStatusCode(), duration, span.context().traceId());
                    })
                    .doOnError(error -> {
                        long duration = System.currentTimeMillis() - startTime;
                        span.tag("duration_ms", String.valueOf(duration));
                        span.tag("gateway.response.success", "false");
                        span.tag("error.message", error.getMessage());
                        span.tag("error.type", error.getClass().getSimpleName());

                        log.error("ç½‘å…³è¯·æ±‚å¼‚å¸¸: method={}, uri={}, error={}, duration={}ms, traceId={}",
                                request.getMethod(), request.getURI(), error.getMessage(), duration, span.context().traceId(), error);
                    })
                    .doFinally(signalType -> {
                        span.end();
                        MDC.clear();
                    });
        }
    }

    @Override
    public int getOrder() {
        return Ordered.HIGHEST_PRECEDENCE;  // æœ€é«˜ä¼˜å…ˆçº§
    }

    private String getOrCreateTraceId(ServerHttpRequest request) {
        String traceId = request.getHeaders().getFirst("X-Trace-Id");
        if (traceId == null || traceId.isEmpty()) {
            traceId = UUID.randomUUID().toString().replace("-", "");
        }
        return traceId;
    }
}
```

---

## ğŸ“Š åˆ†å¸ƒå¼è¿½è¸ªæœ€ä½³å®è·µ

### **1. è¿½è¸ªæ•°æ®é‡‡æ ·ç­–ç•¥**

#### **æ™ºèƒ½é‡‡æ ·é…ç½®**
```java
/**
 * æ™ºèƒ½é‡‡æ ·ç­–ç•¥
 * æ ¹æ®è¯·æ±‚ç‰¹å¾åŠ¨æ€è°ƒæ•´é‡‡æ ·ç‡
 */
@Component
public class IntelligentSamplingStrategy {

    /**
     * é‡‡æ ·ç‡è®¡ç®—
     */
    public double calculateSamplingRate(ServerHttpRequest request) {
        // 1. é”™è¯¯è¯·æ±‚100%é‡‡æ ·
        String errorHeader = request.getHeaders().getFirst("X-Error");
        if (errorHeader != null) {
            return 1.0;
        }

        // 2. å…³é”®æ¥å£100%é‡‡æ ·
        String uri = request.getURI().getPath();
        if (isCriticalEndpoint(uri)) {
            return 1.0;
        }

        // 3. é«˜å¹¶å‘æ¥å£é™ä½é‡‡æ ·ç‡
        if (isHighTrafficEndpoint(uri)) {
            return 0.01;  // 1%é‡‡æ ·
        }

        // 4. æ™®é€šæ¥å£æ ¹æ®æ—¶é—´è°ƒæ•´é‡‡æ ·ç‡
        return getTimeBasedSamplingRate();
    }

    private boolean isCriticalEndpoint(String uri) {
        String[] criticalEndpoints = {
            "/api/v1/auth/login",
            "/api/v1/payment/process",
            "/api/v1/order/create",
            "/api/v1/access/grant"
        };

        return Arrays.stream(criticalEndpoints)
                .anyMatch(uri::contains);
    }

    private boolean isHighTrafficEndpoint(String uri) {
        String[] highTrafficEndpoints = {
            "/api/v1/health",
            "/actuator/health",
            "/api/v1/metrics"
        };

        return Arrays.stream(highTrafficEndpoints)
                .anyMatch(uri::contains);
    }

    private double getTimeBasedSamplingRate() {
        LocalTime now = LocalTime.now();

        // ä¸šåŠ¡é«˜å³°æœŸæé«˜é‡‡æ ·ç‡
        if (now.isAfter(LocalTime.of(9, 0)) && now.isBefore(LocalTime.of(18, 0))) {
            return 0.1;  // 10%é‡‡æ ·
        }

        // éä¸šåŠ¡æ—¶é—´é™ä½é‡‡æ ·ç‡
        return 0.05;  // 5%é‡‡æ ·
    }
}
```

### **2. æ€§èƒ½ç›‘æ§é›†æˆ**

#### **æ€§èƒ½æŒ‡æ ‡æ”¶é›†**
```java
/**
 * è¿½è¸ªæ€§èƒ½æŒ‡æ ‡æ”¶é›†å™¨
 * æ”¶é›†é“¾è·¯è¿½è¸ªç›¸å…³çš„æ€§èƒ½æŒ‡æ ‡
 */
@Component
@Slf4j
public class TracingMetricsCollector {

    private final MeterRegistry meterRegistry;
    private final Counter traceCounter;
    private final Timer traceDurationTimer;
    private final Gauge activeSpansGauge;

    public TracingMetricsCollector(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;

        this.traceCounter = Counter.builder("tracing.spans.created")
                .description("Number of spans created")
                .register(meterRegistry);

        this.traceDurationTimer = Timer.builder("tracing.span.duration")
                .description("Duration of spans")
                .register(meterRegistry);

        this.activeSpansGauge = Gauge.builder("tracing.active.spans")
                .description("Number of active spans")
                .register(meterRegistry, this, TracingMetricsCollector::getActiveSpanCount);
    }

    /**
     * è®°å½•Spanåˆ›å»ºæŒ‡æ ‡
     */
    public void recordSpanCreated(String serviceName, String operation) {
        traceCounter.increment(
            Tags.of(
                Tag.of("service", serviceName),
                Tag.of("operation", operation)
            )
        );
    }

    /**
     * è®°å½•SpanæŒç»­æ—¶é—´
     */
    public void recordSpanDuration(String serviceName, String operation, long durationMs) {
        traceDurationTimer.record(durationMs, TimeUnit.MILLISECONDS,
            Tags.of(
                Tag.of("service", serviceName),
                Tag.of("operation", operation)
            )
        );
    }

    /**
     * è®°å½•Spané”™è¯¯
     */
    public void recordSpanError(String serviceName, String operation, String errorType) {
        Counter.builder("tracing.spans.errors")
                .description("Number of span errors")
                .tag("service", serviceName)
                .tag("operation", operation)
                .tag("error.type", errorType)
                .register(meterRegistry)
                .increment();
    }

    private double getActiveSpanCount() {
        // å®ç°è·å–å½“å‰æ´»è·ƒSpanæ•°é‡çš„é€»è¾‘
        return tracer.currentSpan() != null ? 1 : 0;
    }
}
```

### **3. æ•…éšœè¯Šæ–­å¢å¼º**

#### **å¼‚å¸¸è¿½è¸ªå¢å¼º**
```java
/**
 * å¼‚å¸¸è¿½è¸ªå¢å¼ºå™¨
 * ä¸ºå¼‚å¸¸æ·»åŠ è¯¦ç»†çš„è¿½è¸ªä¿¡æ¯
 */
@Component
@Slf4j
public class ExceptionTracingEnhancer {

    @Resource
    private Tracer tracer;

    /**
     * è¿½è¸ªå¼‚å¸¸å †æ ˆ
     */
    public void traceException(Exception exception, Map<String, Object> context) {
        Span span = tracer.nextSpan()
                .name("exception")
                .tag("exception.type", exception.getClass().getSimpleName())
                .tag("exception.message", exception.getMessage())
                .tag("exception.stacktrace", getStackTraceString(exception))
                .start();

        try (Tracer.SpanInScope ws = tracer.withSpanInScope(span)) {
            // æ·»åŠ ä¸Šä¸‹æ–‡ä¿¡æ¯
            if (context != null) {
                context.forEach((key, value) -> {
                    if (value != null) {
                        span.tag("context." + key, value.toString());
                    }
                });
            }

            // è®°å½•å¼‚å¸¸çº§åˆ«
            span.tag("exception.level", determineExceptionLevel(exception));

            // è®°å½•å¼‚å¸¸æ¥æº
            span.tag("exception.source", determineExceptionSource(exception));

            log.error("å¼‚å¸¸è¿½è¸ª: type={}, message={}, traceId={}",
                    exception.getClass().getSimpleName(),
                    exception.getMessage(),
                    span.context().traceId());

        } finally {
            span.end();
        }
    }

    private String getStackTraceString(Exception exception) {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        exception.printStackTrace(pw);
        return sw.toString();
    }

    private String determineExceptionLevel(Exception exception) {
        if (exception instanceof RuntimeException) {
            return "runtime";
        } else if (exception instanceof IOException) {
            return "io";
        } else if (exception instanceof SQLException) {
            return "sql";
        } else {
            return "checked";
        }
    }

    private String determineExceptionSource(Exception exception) {
        StackTraceElement[] stackTrace = exception.getStackTrace();
        if (stackTrace.length > 0) {
            StackTraceElement topElement = stackTrace[0];
            return topElement.getClassName() + "." + topElement.getMethodName();
        }
        return "unknown";
    }
}
```

---

## ğŸ“‹ åˆ†å¸ƒå¼è¿½è¸ªæ£€æŸ¥æ¸…å•

### **âœ… åŸºç¡€è®¾æ–½éƒ¨ç½²æ£€æŸ¥ï¼ˆå¿…é¡»100%å®Œæˆï¼‰**

#### **ZipkinæœåŠ¡å™¨éƒ¨ç½²**
- [ ] ZipkinæœåŠ¡å™¨å®‰è£…é…ç½®å®Œæˆ
- [ ] RabbitMQæ¶ˆæ¯é˜Ÿåˆ—é…ç½®å®Œæˆ
- [ ] Elasticsearchå­˜å‚¨é…ç½®å®Œæˆï¼ˆå¯é€‰ï¼‰
- [ ] Zipkin UIè®¿é—®æ­£å¸¸
- [ ] æ•°æ®æŒä¹…åŒ–é…ç½®æ­£ç¡®

#### **è¿½è¸ªä¾èµ–é›†æˆ**
- [ ] æ‰€æœ‰22ä¸ªå¾®æœåŠ¡æ·»åŠ Sleuthä¾èµ–
- [ ] æ‰€æœ‰22ä¸ªå¾®æœåŠ¡æ·»åŠ Zipkinä¾èµ–
- [ ] æ‰€æœ‰22ä¸ªå¾®æœåŠ¡é…ç½®è¿½è¸ªå‚æ•°
- [ ] ç½‘å…³æœåŠ¡è¿½è¸ªè¿‡æ»¤å™¨é…ç½®
- [ ] æœåŠ¡é—´è°ƒç”¨è¿½è¸ªå¢å¼ºé…ç½®

### **âœ… è¿½è¸ªåŠŸèƒ½éªŒè¯æ£€æŸ¥ï¼ˆå¿…é¡»100%é€šè¿‡ï¼‰**

#### **åŸºç¡€è¿½è¸ªåŠŸèƒ½**
- [ ] HTTPè¯·æ±‚è¿½è¸ªæ­£å¸¸å·¥ä½œ
- [ ] æœåŠ¡é—´è°ƒç”¨è¿½è¸ªå®Œæ•´
- [ ] Trace IDå’ŒSpan IDæ­£ç¡®ä¼ é€’
- [ ] å¼‚æ­¥è°ƒç”¨è¿½è¸ªæ­£å¸¸
- [ ] æ•°æ®åº“æ“ä½œè¿½è¸ªå®Œæ•´

#### **ç›‘æ§é›†æˆ**
- [ ] è¿½è¸ªæ•°æ®æ­£å¸¸å‘é€åˆ°Zipkin
- [ ] Zipkin UIæ­£å¸¸æ˜¾ç¤ºè°ƒç”¨é“¾
- [ ] æ€§èƒ½æŒ‡æ ‡æ­£å¸¸æ”¶é›†
- [ ] å¼‚å¸¸è¿½è¸ªæ­£å¸¸å·¥ä½œ
- [ ] å‘Šè­¦æœºåˆ¶æ­£å¸¸è§¦å‘

### **âœ… æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥ï¼ˆå¿…é¡»è¾¾åˆ°ç›®æ ‡ï¼‰**

#### **é‡‡æ ·ç­–ç•¥ä¼˜åŒ–**
- [ ] æ™ºèƒ½é‡‡æ ·ç­–ç•¥å®ç°
- [ ] é‡‡æ ·ç‡åŠ¨æ€è°ƒæ•´æ­£å¸¸
- [ ] å…³é”®è¯·æ±‚100%é‡‡æ ·
- [ ] é«˜å¹¶å‘æ¥å£é‡‡æ ·ä¼˜åŒ–
- [ ] è¿½è¸ªæ€§èƒ½å½±å“æœ€å°åŒ–

#### **å­˜å‚¨ä¼˜åŒ–**
- [ ] è¿½è¸ªæ•°æ®å­˜å‚¨ç­–ç•¥ä¼˜åŒ–
- [ ] å†å²æ•°æ®æ¸…ç†ç­–ç•¥
- [ ] å­˜å‚¨ç©ºé—´ç›‘æ§å‘Šè­¦
- [ ] æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–
- [ ] æ•°æ®å¤‡ä»½ç­–ç•¥å®Œå–„

---

## ğŸš¨ è¿½è¸ªç³»ç»Ÿç›‘æ§å‘Šè­¦

### **å…³é”®ç›‘æ§æŒ‡æ ‡**

#### **è¿½è¸ªç³»ç»Ÿå¥åº·æŒ‡æ ‡**
- **è¿½è¸ªæ•°æ®æ¥æ”¶ç‡**: â‰¥95%
- **æœåŠ¡è¿½è¸ªè¦†ç›–ç‡**: 100%
- **Traceä¸¢å¤±ç‡**: â‰¤1%
- **ZipkinæœåŠ¡å¯ç”¨æ€§**: â‰¥99.9%
- **å­˜å‚¨ç³»ç»Ÿå¯ç”¨æ€§**: â‰¥99.9%

#### **æ€§èƒ½æŒ‡æ ‡**
- **å¹³å‡è¿½è¸ªå»¶è¿Ÿ**: â‰¤100ms
- **è¿½è¸ªæ•°æ®ç”ŸæˆQPS**: ç›‘æ§ç³»ç»Ÿè´Ÿè½½
- **å­˜å‚¨å†™å…¥å»¶è¿Ÿ**: â‰¤200ms
- **æŸ¥è¯¢å“åº”æ—¶é—´**: â‰¤2s
- **ç³»ç»Ÿèµ„æºä½¿ç”¨ç‡**: â‰¤80%

### **å‘Šè­¦è§„åˆ™é…ç½®**

#### **Prometheuså‘Šè­¦è§„åˆ™**
```yaml
groups:
  - name: distributed_tracing_alerts
    rules:
      - alert: ZipkinServiceDown
        expr: up{job="zipkin"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "ZipkinæœåŠ¡å®•æœº"
          description: "ZipkinæœåŠ¡å·²å®•æœºè¶…è¿‡1åˆ†é’Ÿï¼Œåˆ†å¸ƒå¼è¿½è¸ªåŠŸèƒ½ä¸å¯ç”¨"

      - alert: TraceDataLoss
        expr: rate(zipkin_collector_messages_total[5m]) < 10
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "è¿½è¸ªæ•°æ®ä¸¢å¤±"
          description: "è¿‡å»5åˆ†é’Ÿå†…è¿½è¸ªæ•°æ®æ¥æ”¶ç‡è¿‡ä½ï¼Œå¯èƒ½å­˜åœ¨æ•°æ®ä¸¢å¤±"

      - alert: ServiceTracingCoverageLow
        expr: service_tracing_coverage < 0.95
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "æœåŠ¡è¿½è¸ªè¦†ç›–ç‡ä½"
          description: "æœåŠ¡è¿½è¸ªè¦†ç›–ç‡ä½äº95%ï¼Œå­˜åœ¨è¿½è¸ªç›²åŒº"

      - alert: HighLatencySpans
        expr: histogram_quantile(0.95, rate(zipkin_span_duration_ms_bucket[5m])) > 5000
        for: 3m
        labels:
          severity: warning
        annotations:
          summary: "é«˜å»¶è¿ŸSpanå‘Šè­¦"
          description: "95%çš„Spanå»¶è¿Ÿè¶…è¿‡5ç§’ï¼Œç³»ç»Ÿæ€§èƒ½å¼‚å¸¸"
```

---

## ğŸ”— ç›¸å…³æŠ€èƒ½æ–‡æ¡£

- **microservice-architecture-specialist**: å¾®æœåŠ¡æ¶æ„ä¸“å®¶
- **performance-optimization-specialist**: æ€§èƒ½ä¼˜åŒ–ä¸“å®¶
- **monitoring-system-specialist**: ç›‘æ§ç³»ç»Ÿä¸“å®¶
- **observability-platform-specialist**: å¯è§‚æµ‹æ€§å¹³å°ä¸“å®¶
- **nacos-service-discovery-specialist**: NacosæœåŠ¡å‘ç°ä¸“å®¶

---

## ğŸ“ è”ç³»å’Œæ”¯æŒ

**æŠ€èƒ½è´Ÿè´£äºº**: åˆ†å¸ƒå¼è¿½è¸ªä¸“å®¶å›¢é˜Ÿ
**æŠ€æœ¯æ”¯æŒ**: æ¶æ„å¸ˆå›¢é˜Ÿ + è¿ç»´å›¢é˜Ÿ
**ç³»ç»Ÿç›‘æ§**: 7x24å°æ—¶ç›‘æ§

**è”ç³»æ–¹å¼**:
- **è¿½è¸ªç³»ç»Ÿæ•…éšœ**: tracing-support@ioedream.com
- **æ€§èƒ½é—®é¢˜å’¨è¯¢**: tracing-performance@ioedream.com
- **æŠ€æœ¯æ”¯æŒçƒ­çº¿**: tracing-hotline@ioedream.com

**ç‰ˆæœ¬ä¿¡æ¯**:
- **åˆ›å»ºæ—¶é—´**: 2025-12-02
- **æœ€åæ›´æ–°**: 2025-12-02
- **ç‰ˆæœ¬**: v1.0.0
- **å®æ–½ç­‰çº§**: P0çº§åŸºç¡€è®¾æ–½

---

## ğŸš¨ ç´§æ€¥å®æ–½è®¡åˆ’

**ç«‹å³æ‰§è¡Œï¼ˆ24å°æ—¶å†…å®Œæˆï¼‰**ï¼š
1. **éƒ¨ç½²ZipkinæœåŠ¡å™¨**: å»ºç«‹åˆ†å¸ƒå¼è¿½è¸ªåŸºç¡€è®¾æ–½
2. **é›†æˆåŸºç¡€ä¾èµ–**: ä¸ºæ‰€æœ‰22ä¸ªå¾®æœåŠ¡æ·»åŠ Sleuthå’ŒZipkinä¾èµ–
3. **é…ç½®åŸºç¡€è¿½è¸ª**: å®ç°HTTPè¯·æ±‚å’ŒæœåŠ¡é—´è°ƒç”¨çš„åŸºç¡€è¿½è¸ª

**ä¸€å‘¨å†…å®Œæˆ**ï¼š
1. **å®Œå–„è¿½è¸ªåŠŸèƒ½**: å®ç°æ•°æ®åº“æ“ä½œã€å¼‚æ­¥è°ƒç”¨çš„å®Œæ•´è¿½è¸ª
2. **æ€§èƒ½ç›‘æ§é›†æˆ**: é›†æˆPrometheuså’ŒGrafanaç›‘æ§
3. **å‘Šè­¦ç³»ç»Ÿé…ç½®**: é…ç½®è¿½è¸ªç³»ç»Ÿç›‘æ§å‘Šè­¦

**ä¸¤å‘¨å†…å®Œæˆ**ï¼š
1. **æ™ºèƒ½é‡‡æ ·ä¼˜åŒ–**: å®ç°æ™ºèƒ½é‡‡æ ·ç­–ç•¥ï¼Œé™ä½æ€§èƒ½å½±å“
2. **æ•…éšœè¯Šæ–­å¢å¼º**: å®Œå–„å¼‚å¸¸è¿½è¸ªå’Œæ•…éšœè¯Šæ–­åŠŸèƒ½
3. **å›¢é˜ŸåŸ¹è®­**: å¯¹å¼€å‘å›¢é˜Ÿè¿›è¡Œåˆ†å¸ƒå¼è¿½è¸ªä½¿ç”¨åŸ¹è®­

---

**ğŸ’¡ æœ€é‡è¦æé†’**: æœ¬æŠ€èƒ½è§£å†³IOE-DREAMé¡¹ç›®æœ€ä¸¥é‡çš„P0çº§åŸºç¡€è®¾æ–½ç¼ºå¤±é—®é¢˜ã€‚22ä¸ªå¾®æœåŠ¡çš„åˆ†å¸ƒå¼è¿½è¸ªå¿…é¡»åœ¨72å°æ—¶å†…å®ŒæˆåŸºç¡€éƒ¨ç½²ï¼Œå¦åˆ™å°†æ— æ³•æœ‰æ•ˆç›‘æ§å’Œç®¡ç†å¾®æœåŠ¡æ¶æ„ã€‚åˆ†å¸ƒå¼è¿½è¸ªæ˜¯å¾®æœåŠ¡æ²»ç†çš„åŸºç¡€ï¼Œå¿…é¡»ç«‹å³å®æ–½ï¼