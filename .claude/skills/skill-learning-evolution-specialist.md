# ğŸ§  æŠ€èƒ½å­¦ä¹ è¿›åŒ–ä¸“å®¶

> **ç‰ˆæœ¬**: v1.0.0 - è‡ªå­¦ä¹ è¿›åŒ–ç³»ç»Ÿ
> **æ›´æ–°æ—¶é—´**: 2025-11-23
> **åˆ†ç±»**: æŠ€èƒ½ç®¡ç†æŠ€èƒ½ > å­¦ä¹ è¿›åŒ–
> **æ ‡ç­¾**: ["æœºå™¨å­¦ä¹ ", "è‡ªé€‚åº”ä¼˜åŒ–", "çŸ¥è¯†å›¾è°±", "æ™ºèƒ½è¿›åŒ–"]
> **æŠ€èƒ½ç­‰çº§**: â˜…â˜…â˜… ä¸“å®¶çº§
> **é€‚ç”¨è§’è‰²**: AIç³»ç»Ÿæ¶æ„å¸ˆã€æœºå™¨å­¦ä¹ ä¸“å®¶ã€æŠ€èƒ½ä½“ç³»è®¾è®¡å¸ˆ

---

## ğŸ“‹ æŠ€èƒ½æ¦‚è¿°

æœ¬æŠ€èƒ½ä¸“é—¨å»ºç«‹æŠ€èƒ½çš„è‡ªå­¦ä¹ å’Œè¿›åŒ–æœºåˆ¶ï¼Œé€šè¿‡æœºå™¨å­¦ä¹ ç®—æ³•å’ŒçŸ¥è¯†å›¾è°±æŠ€æœ¯ï¼Œä½¿æŠ€èƒ½ä½“ç³»èƒ½å¤Ÿä»æ‰§è¡Œç»éªŒä¸­å­¦ä¹ ï¼ŒæŒç»­ä¼˜åŒ–è‡ªèº«æ€§èƒ½å’Œé€‚åº”æ–°çš„é¡¹ç›®éœ€æ±‚ã€‚

**æ ¸å¿ƒèƒ½åŠ›**: å»ºç«‹å®Œæ•´çš„æŠ€èƒ½å­¦ä¹ é—­ç¯ï¼Œå®ç°ä»ç»éªŒç§¯ç´¯åˆ°æ™ºèƒ½ä¼˜åŒ–çš„è‡ªåŠ¨åŒ–è¿›åŒ–ã€‚

## ğŸš¨ å½“å‰æŠ€èƒ½å­¦ä¹ é—®é¢˜åˆ†æ

### 1. æŠ€èƒ½ç¼ºä¹è‡ªé€‚åº”èƒ½åŠ›
**é—®é¢˜ç°è±¡**:
```bash
# æŠ€èƒ½æ‰§è¡Œç­–ç•¥å›ºåŒ–ï¼Œä¸ä¼šæ ¹æ®é¡¹ç›®ç‰¹ç‚¹è°ƒæ•´
Skill("code-quality-protector")
# æ— è®ºä»€ä¹ˆé¡¹ç›®ï¼Œéƒ½ä½¿ç”¨ç›¸åŒçš„ä¿®å¤ç­–ç•¥
```

**æ ¹æœ¬åŸå› **:
- ç¼ºä¹é¡¹ç›®ç‰¹å¾è¯†åˆ«èƒ½åŠ›
- æ²¡æœ‰è‡ªé€‚åº”çš„æ‰§è¡Œç­–ç•¥
- ç¼ºä¹æœºå™¨å­¦ä¹ æ¨¡å‹æ”¯æŒ

### 2. æ— æ³•ç§¯ç´¯ç»éªŒçŸ¥è¯†
**é—®é¢˜ç°è±¡**:
```bash
# åŒæ ·çš„é”™è¯¯é‡å¤å‡ºç°ï¼ŒæŠ€èƒ½ä¸ä¼šå­¦ä¹ 
# ç¬¬ä¸€æ¬¡é‡åˆ°javaxåŒ…é—®é¢˜ï¼ŒèŠ±äº†5åˆ†é’Ÿä¿®å¤
# ç¬¬äºŒæ¬¡é‡åˆ°åŒæ ·é—®é¢˜ï¼Œè¿˜æ˜¯èŠ±äº†5åˆ†é’Ÿ
```

**æ ¹æœ¬åŸå› **:
- ç¼ºä¹ç»éªŒçŸ¥è¯†åº“
- æ²¡æœ‰æ¡ˆä¾‹å­¦ä¹ å’Œæ¨ç†æœºåˆ¶
- ç¼ºä¹çŸ¥è¯†å›¾è°±æ„å»º

### 3. æŠ€èƒ½æ— æ³•è¿›åŒ–å‡çº§
**é—®é¢˜ç°è±¡**:
```bash
# æŠ€èƒ½ç‰ˆæœ¬å›ºå®šï¼Œæ— æ³•è‡ªåŠ¨æ”¹è¿›
# code-quality-protector v1.0 å§‹ç»ˆä¿æŒåŸæœ‰èƒ½åŠ›
# æ— æ³•æ ¹æ®æ–°çš„é¡¹ç›®éœ€æ±‚è‡ªåŠ¨å‡çº§
```

**æ ¹æœ¬åŸå› **:
- ç¼ºä¹æŠ€èƒ½ç‰ˆæœ¬ç®¡ç†æœºåˆ¶
- æ²¡æœ‰è‡ªåŠ¨åŒ–æµ‹è¯•å’ŒéªŒè¯
- ç¼ºä¹æŠ€èƒ½èåˆå’Œåˆ›æ–°èƒ½åŠ›

## ğŸ› ï¸ æŠ€èƒ½å­¦ä¹ è¿›åŒ–ç³»ç»Ÿè®¾è®¡

### 1. é¡¹ç›®ç‰¹å¾è¯†åˆ«å™¨
```java
/**
 * é¡¹ç›®ç‰¹å¾è¯†åˆ«å™¨
 */
@Component
@Slf4j
public class ProjectFeatureExtractor {

    @Resource
    private CodeAnalyzer codeAnalyzer;

    @Resource
    private DependencyAnalyzer dependencyAnalyzer;

    @Resource
    private ArchitectureAnalyzer architectureAnalyzer;

    /**
     * æå–é¡¹ç›®ç‰¹å¾
     */
    public ProjectFeatures extractFeatures(String projectPath) {
        ProjectFeatures features = new ProjectFeatures();

        // ä»£ç ç‰¹å¾
        CodeFeatures codeFeatures = extractCodeFeatures(projectPath);
        features.setCodeFeatures(codeFeatures);

        // æ¶æ„ç‰¹å¾
        ArchitectureFeatures archFeatures = extractArchitectureFeatures(projectPath);
        features.setArchitectureFeatures(archFeatures);

        // æŠ€æœ¯æ ˆç‰¹å¾
        TechStackFeatures techFeatures = extractTechStackFeatures(projectPath);
        features.setTechStackFeatures(techFeatures);

        // è´¨é‡ç‰¹å¾
        QualityFeatures qualityFeatures = extractQualityFeatures(projectPath);
        features.setQualityFeatures(qualityFeatures);

        // å†å²ç‰¹å¾
        HistoryFeatures historyFeatures = extractHistoryFeatures(projectPath);
        features.setHistoryFeatures(historyFeatures);

        log.info("é¡¹ç›®ç‰¹å¾æå–å®Œæˆ: {}", features);
        return features;
    }

    private CodeFeatures extractCodeFeatures(String projectPath) {
        CodeFeatures features = new CodeFeatures();

        // ç»Ÿè®¡ä»£ç è§„æ¨¡
        int totalFiles = countJavaFiles(projectPath);
        int totalLines = countLinesOfCode(projectPath);
        int totalClasses = countJavaClasses(projectPath);

        features.setTotalFiles(totalFiles);
        features.setTotalLines(totalLines);
        features.setTotalClasses(totalClasses);

        // è®¡ç®—å¤æ‚åº¦æŒ‡æ ‡
        double avgCyclomaticComplexity = calculateAverageComplexity(projectPath);
        features.setAverageCyclomaticComplexity(avgCyclomaticComplexity);

        // ç»Ÿè®¡è¯­è¨€ç‰¹æ€§ä½¿ç”¨
        Map<String, Integer> languageFeatures = countLanguageFeatures(projectPath);
        features.setLanguageFeatures(languageFeatures);

        // ä»£ç é£æ ¼åˆ†æ
        CodeStyleFeatures styleFeatures = analyzeCodeStyle(projectPath);
        features.setStyleFeatures(styleFeatures);

        return features;
    }

    private ArchitectureFeatures extractArchitectureFeatures(String projectPath) {
        ArchitectureFeatures features = new ArchitectureFeatures();

        // æ¶æ„æ¨¡å¼è¯†åˆ«
        String architecturePattern = identifyArchitecturePattern(projectPath);
        features.setArchitecturePattern(architecturePattern);

        // åˆ†å±‚ç»“æ„åˆ†æ
        LayerStructure layerStructure = analyzeLayerStructure(projectPath);
        features.setLayerStructure(layerStructure);

        // æ¨¡å—è€¦åˆåº¦
        double couplingScore = calculateCouplingScore(projectPath);
        features.setCouplingScore(couplingScore);

        // è®¾è®¡æ¨¡å¼ä½¿ç”¨
        Set<String> usedPatterns = identifyUsedDesignPatterns(projectPath);
        features.setUsedDesignPatterns(usedPatterns);

        return features;
    }

    private TechStackFeatures extractTechStackFeatures(String projectPath) {
        TechStackFeatures features = new TechStackFeatures();

        // æ¡†æ¶è¯†åˆ«
        Set<String> frameworks = identifyFrameworks(projectPath);
        features.setFrameworks(frameworks);

        // ä¾èµ–åˆ†æ
        Map<String, String> dependencies = analyzeDependencies(projectPath);
        features.setDependencies(dependencies);

        // æ•°æ®åº“ç‰¹å¾
        DatabaseFeatures dbFeatures = analyzeDatabaseUsage(projectPath);
        features.setDatabaseFeatures(dbFeatures);

        // æ„å»ºå·¥å…·ç‰¹å¾
        BuildFeatures buildFeatures = analyzeBuildConfiguration(projectPath);
        features.setBuildFeatures(buildFeatures);

        return features;
    }

    private QualityFeatures extractQualityFeatures(String projectPath) {
        QualityFeatures features = new QualityFeatures();

        // ç¼–è¯‘çŠ¶æ€
        int compilationErrors = countCompilationErrors(projectPath);
        features.setCompilationErrorCount(compilationErrors);

        // æµ‹è¯•è¦†ç›–ç‡
        double testCoverage = calculateTestCoverage(projectPath);
        features.setTestCoverage(testCoverage);

        // ä»£ç è´¨é‡æŒ‡æ ‡
        Map<String, Double> qualityMetrics = calculateQualityMetrics(projectPath);
        features.setQualityMetrics(qualityMetrics);

        // å®‰å…¨ç‰¹å¾
        SecurityFeatures securityFeatures = analyzeSecurityFeatures(projectPath);
        features.setSecurityFeatures(securityFeatures);

        return features;
    }

    private HistoryFeatures extractHistoryFeatures(String projectPath) {
        HistoryFeatures features = new HistoryFeatures();

        // Gitå†å²åˆ†æ
        GitHistoryFeatures gitFeatures = analyzeGitHistory(projectPath);
        features.setGitFeatures(gitFeatures);

        // é—®é¢˜å†å²
        IssueHistoryFeatures issueFeatures = analyzeIssueHistory(projectPath);
        features.setIssueFeatures(issueFeatures);

        // æŠ€èƒ½æ‰§è¡Œå†å²
        SkillExecutionHistoryFeatures skillFeatures = analyzeSkillExecutionHistory(projectPath);
        features.setSkillFeatures(skillFeatures);

        return features;
    }

    // è¾…åŠ©æ–¹æ³•å®ç°...
    private int countJavaFiles(String projectPath) {
        return codeAnalyzer.countFiles(projectPath, "*.java");
    }

    private int countLinesOfCode(String projectPath) {
        return codeAnalyzer.countLines(projectPath, "*.java");
    }

    private double calculateAverageComplexity(String projectPath) {
        return codeAnalyzer.calculateAverageComplexity(projectPath);
    }

    private String identifyArchitecturePattern(String projectPath) {
        return architectureAnalyzer.identifyPattern(projectPath);
    }

    private Set<String> identifyFrameworks(String projectPath) {
        return dependencyAnalyzer.identifyFrameworks(projectPath);
    }
}
```

### 2. æŠ€èƒ½å­¦ä¹ å¼•æ“
```java
/**
 * æŠ€èƒ½å­¦ä¹ å¼•æ“
 */
@Component
@Slf4j
public class SkillLearningEngine {

    @Resource
    private ProjectFeatureExtractor featureExtractor;

    @Resource
    private SkillKnowledgeGraph knowledgeGraph;

    @Resource
    private MachineLearningModel mlModel;

    // æŠ€èƒ½ç­–ç•¥åº“
    private final Map<String, SkillStrategy> skillStrategies = new ConcurrentHashMap<>();

    @PostConstruct
    public void initLearningEngine() {
        // åˆå§‹åŒ–æœºå™¨å­¦ä¹ æ¨¡å‹
        initializeMLModels();

        // åŠ è½½ç°æœ‰æŠ€èƒ½ç­–ç•¥
        loadExistingSkillStrategies();

        log.info("æŠ€èƒ½å­¦ä¹ å¼•æ“åˆå§‹åŒ–å®Œæˆ");
    }

    /**
     * å­¦ä¹ å’Œä¼˜åŒ–æŠ€èƒ½ç­–ç•¥
     */
    public SkillOptimizationResult learnAndOptimize(String skillName, List<ExecutionExperience> experiences) {
        try {
            log.info("å¼€å§‹å­¦ä¹ æŠ€èƒ½: {}, ç»éªŒæ•°é‡: {}", skillName, experiences.size());

            // 1. ç‰¹å¾æå–
            List<ProjectFeatures> features = experiences.stream()
                .map(exp -> featureExtractor.extractFeatures(exp.getProjectPath()))
                .collect(Collectors.toList());

            // 2. æ¨¡å¼è¯†åˆ«
            ExecutionPatterns patterns = identifyExecutionPatterns(features, experiences);

            // 3. ç­–ç•¥ä¼˜åŒ–
            SkillStrategy optimizedStrategy = optimizeSkillStrategy(skillName, patterns);

            // 4. æ•ˆæœé¢„æµ‹
            double expectedImprovement = predictImprovement(skillName, optimizedStrategy);

            // 5. ç­–ç•¥éªŒè¯
            ValidationResult validation = validateStrategy(optimizedStrategy);

            SkillOptimizationResult result = new SkillOptimizationResult();
            result.setSkillName(skillName);
            result.setOptimizedStrategy(optimizedStrategy);
            result.setExpectedImprovement(expectedImprovement);
            result.setValidation(validation);
            result.setPatternsIdentified(patterns);

            log.info("æŠ€èƒ½å­¦ä¹ å®Œæˆ: {}, é¢„æœŸæ”¹è¿›: {:.1f}%", skillName, expectedImprovement * 100);

            return result;

        } catch (Exception e) {
            log.error("æŠ€èƒ½å­¦ä¹ å¤±è´¥: {}", skillName, e);
            return SkillOptimizationResult.failure(skillName, e.getMessage());
        }
    }

    /**
     * è‡ªé€‚åº”æŠ€èƒ½æ‰§è¡Œç­–ç•¥
     */
    public AdaptiveExecutionStrategy adaptExecutionStrategy(String skillName, ProjectFeatures currentFeatures) {
        // 1. æŸ¥æ‰¾ç›¸ä¼¼é¡¹ç›®ç»éªŒ
        List<ExecutionExperience> similarExperiences = findSimilarExperiences(currentFeatures);

        // 2. åˆ†ææˆåŠŸæ¨¡å¼
        SuccessPatterns successPatterns = analyzeSuccessPatterns(similarExperiences);

        // 3. ç”Ÿæˆè‡ªé€‚åº”ç­–ç•¥
        AdaptiveExecutionStrategy strategy = new AdaptiveExecutionStrategy();
        strategy.setSkillName(skillName);
        strategy.setProjectFeatures(currentFeatures);
        strategy.setRecommendedSteps(successPatterns.getRecommendedSteps());
        strategy.setParameterTuning(successPatterns.getParameterTuning());
        strategy.setResourceAllocation(successPatterns.getResourceAllocation());
        strategy.setConfidenceScore(calculateConfidenceScore(similarExperiences));

        // 4. å®æ—¶è°ƒæ•´æœºåˆ¶
        strategy.setAdaptationRules(generateAdaptationRules(currentFeatures));

        return strategy;
    }

    /**
     * æŠ€èƒ½çŸ¥è¯†å›¾è°±æ„å»º
     */
    public void buildSkillKnowledgeGraph(List<ExecutionExperience> experiences) {
        log.info("å¼€å§‹æ„å»ºæŠ€èƒ½çŸ¥è¯†å›¾è°±...");

        // 1. æå–å®ä½“å’Œå…³ç³»
        List<KnowledgeTriple> triples = extractKnowledgeTriples(experiences);

        // 2. æ„å»ºå›¾ç»“æ„
        knowledgeGraph.addTriples(triples);

        // 3. æ¨ç†æ–°çŸ¥è¯†
        List<KnowledgeTriple> inferredTriples = inferNewKnowledge(triples);
        knowledgeGraph.addTriples(inferredTriples);

        // 4. æ›´æ–°å›¾ç´¢å¼•
        knowledgeGraph.updateIndex();

        log.info("æŠ€èƒ½çŸ¥è¯†å›¾è°±æ„å»ºå®Œæˆ: {} ä¸ªä¸‰å…ƒç»„", triples.size() + inferredTriples.size());
    }

    private ExecutionPatterns identifyExecutionPatterns(List<ProjectFeatures> features,
                                                      List<ExecutionExperience> experiences) {
        ExecutionPatterns patterns = new ExecutionPatterns();

        // ä½¿ç”¨æœºå™¨å­¦ä¹ è¯†åˆ«æ¨¡å¼
        Patterns mlPatterns = mlModel.identifyPatterns(features, experiences);
        patterns.setMachineLearnedPatterns(mlPatterns);

        // ä½¿ç”¨ç»Ÿè®¡åˆ†æè¯†åˆ«æ¨¡å¼
        Patterns statPatterns = identifyStatisticalPatterns(features, experiences);
        patterns.setStatisticalPatterns(statPatterns);

        // ä½¿ç”¨åºåˆ—æ¨¡å¼æŒ–æ˜
        Patterns sequencePatterns = mineSequencePatterns(experiences);
        patterns.setSequencePatterns(sequencePatterns);

        return patterns;
    }

    private SkillStrategy optimizeSkillStrategy(String skillName, ExecutionPatterns patterns) {
        SkillStrategy currentStrategy = skillStrategies.getOrDefault(skillName, new SkillStrategy());

        // åŸºäºæœºå™¨å­¦ä¹ æ¨¡å¼ä¼˜åŒ–
        optimizeBasedOnMLPatterns(currentStrategy, patterns.getMachineLearnedPatterns());

        // åŸºäºç»Ÿè®¡æ¨¡å¼ä¼˜åŒ–
        optimizeBasedOnStatisticalPatterns(currentStrategy, patterns.getStatisticalPatterns());

        // åŸºäºåºåˆ—æ¨¡å¼ä¼˜åŒ–
        optimizeBasedOnSequencePatterns(currentStrategy, patterns.getSequencePatterns());

        return currentStrategy;
    }

    private double predictImprovement(String skillName, SkillStrategy strategy) {
        // ä½¿ç”¨è®­ç»ƒå¥½çš„æ¨¡å‹é¢„æµ‹æ”¹è¿›æ•ˆæœ
        return mlModel.predictImprovement(skillName, strategy);
    }

    private ValidationResult validateStrategy(SkillStrategy strategy) {
        ValidationResult validation = new ValidationResult();

        // è¯­æ³•éªŒè¯
        boolean syntacticallyValid = validateSyntax(strategy);
        validation.setSyntacticallyValid(syntacticallyValid);

        // è¯­ä¹‰éªŒè¯
        boolean semanticallyValid = validateSemantics(strategy);
        validation.setSemanticallyValid(semanticallyValid);

        // æ€§èƒ½éªŒè¯
        PerformanceMetrics predictedPerformance = predictPerformance(strategy);
        validation.setPredictedPerformance(predictedPerformance);

        // å®‰å…¨éªŒè¯
        boolean securityValid = validateSecurity(strategy);
        validation.setSecurityValid(securityValid);

        validation.setOverallValid(syntacticallyValid && semanticallyValid && securityValid);

        return validation;
    }

    private List<ExecutionExperience> findSimilarExperiences(ProjectFeatures currentFeatures) {
        // ä½¿ç”¨ç›¸ä¼¼åº¦ç®—æ³•æ‰¾åˆ°ç›¸ä¼¼é¡¹ç›®ç»éªŒ
        return knowledgeGraph.findSimilarExperiences(currentFeatures, 0.8);
    }

    private double calculateConfidenceScore(List<ExecutionExperience> experiences) {
        if (experiences.isEmpty()) {
            return 0.0;
        }

        // åŸºäºç»éªŒæ•°é‡å’ŒæˆåŠŸç‡è®¡ç®—ç½®ä¿¡åº¦
        double experienceWeight = Math.min(1.0, experiences.size() / 10.0);
        double successWeight = experiences.stream()
            .mapToDouble(exp -> exp.isSuccessful() ? 1.0 : 0.0)
            .average()
            .orElse(0.5);

        return (experienceWeight + successWeight) / 2.0;
    }

    private AdaptationRules generateAdaptationRules(ProjectFeatures features) {
        AdaptationRules rules = new AdaptationRules();

        // åŸºäºé¡¹ç›®è§„æ¨¡è°ƒæ•´
        if (features.getCodeFeatures().getTotalLines() > 100000) {
            rules.addRule(new AdaptationRule("project_size", "large", "increase_memory_allocation"));
        }

        // åŸºäºä»£ç å¤æ‚åº¦è°ƒæ•´
        if (features.getCodeFeatures().getAverageCyclomaticComplexity() > 10) {
            rules.addRule(new AdaptationRule("complexity", "high", "enable_advanced_analysis"));
        }

        // åŸºäºæŠ€æœ¯æ ˆè°ƒæ•´
        if (features.getTechStackFeatures().getFrameworks().contains("spring-boot")) {
            rules.addRule(new AdaptationRule("framework", "spring-boot", "use_spring_specific_optimizations"));
        }

        return rules;
    }
}
```

### 3. çŸ¥è¯†å›¾è°±ç®¡ç†å™¨
```java
/**
 * æŠ€èƒ½çŸ¥è¯†å›¾è°±ç®¡ç†å™¨
 */
@Component
@Slf4j
public class SkillKnowledgeGraph {

    // å›¾æ•°æ®åº“ï¼ˆç®€åŒ–å®ç°ï¼Œå®é™…å¯ä½¿ç”¨Neo4jç­‰ï¼‰
    private final Map<String, KnowledgeNode> nodes = new ConcurrentHashMap<>();
    private final Map<String, List<KnowledgeEdge>> edges = new ConcurrentHashMap<>();

    // ç´¢å¼•
    private final Map<String, Set<String>> typeIndex = new ConcurrentHashMap<>();
    private final Map<String, Set<String>> attributeIndex = new ConcurrentHashMap<>();

    /**
     * æ·»åŠ çŸ¥è¯†ä¸‰å…ƒç»„
     */
    public void addTriples(List<KnowledgeTriple> triples) {
        for (KnowledgeTriple triple : triples) {
            addTriple(triple);
        }
    }

    /**
     * æŸ¥è¯¢ç›¸ä¼¼ç»éªŒ
     */
    public List<ExecutionExperience> findSimilarExperiences(ProjectFeatures features, double similarityThreshold) {
        List<ExecutionExperience> similarExperiences = new ArrayList<>();

        // 1. æ„å»ºæŸ¥è¯¢ç‰¹å¾å‘é‡
        FeatureVector queryVector = buildFeatureVector(features);

        // 2. æŸ¥æ‰¾ç›¸ä¼¼èŠ‚ç‚¹
        List<KnowledgeNode> experienceNodes = nodes.values().stream()
            .filter(node -> "ExecutionExperience".equals(node.getType()))
            .collect(Collectors.toList());

        for (KnowledgeNode node : experienceNodes) {
            FeatureVector nodeVector = (FeatureVector) node.getAttribute("featureVector");
            double similarity = calculateCosineSimilarity(queryVector, nodeVector);

            if (similarity >= similarityThreshold) {
                ExecutionExperience experience = (ExecutionExperience) node.getAttribute("experience");
                experience.setSimilarityScore(similarity);
                similarExperiences.add(experience);
            }
        }

        // 3. æŒ‰ç›¸ä¼¼åº¦æ’åº
        similarExperiences.sort((e1, e2) -> Double.compare(e2.getSimilarityScore(), e1.getSimilarityScore()));

        return similarExperiences;
    }

    /**
     * æ¨ç†æ–°çŸ¥è¯†
     */
    public List<KnowledgeTriple> inferNewKnowledge(List<KnowledgeTriple> existingTriples) {
        List<KnowledgeTriple> inferredTriples = new ArrayList<>();

        // 1. ä¼ é€’æ€§æ¨ç†
        inferredTriples.addAll(inferTransitiveRelations(existingTriples));

        // 2. å…³è”æ€§æ¨ç†
        inferredTriples.addAll(inferAssociativeRelations(existingTriples));

        // 3. æ¦‚æ‹¬æ€§æ¨ç†
        inferredTriples.addAll(inferGeneralizations(existingTriples));

        // 4. å› æœæ€§æ¨ç†
        inferredTriples.addAll(inferCausalRelations(existingTriples));

        return inferredTriples;
    }

    /**
     * è·å–æŠ€èƒ½æ¨è
     */
    public List<SkillRecommendation> getSkillRecommendations(ProjectFeatures features) {
        List<SkillRecommendation> recommendations = new ArrayList<>();

        // 1. åŸºäºç›¸ä¼¼é¡¹ç›®æ¨è
        List<SkillRecommendation> similarityBasedRecs = getSimilarityBasedRecommendations(features);
        recommendations.addAll(similarityBasedRecs);

        // 2. åŸºäºç‰¹å¾æ¨¡å¼æ¨è
        List<SkillRecommendation> patternBasedRecs = getPatternBasedRecommendations(features);
        recommendations.addAll(patternBasedRecs);

        // 3. åŸºäºçŸ¥è¯†æ¨ç†æ¨è
        List<SkillRecommendation> inferenceBasedRecs = getInferenceBasedRecommendations(features);
        recommendations.addAll(inferenceBasedRecs);

        // 4. å»é‡å’Œæ’åº
        recommendations = deduplicateAndSort(recommendations);

        return recommendations;
    }

    private void addTriple(KnowledgeTriple triple) {
        // æ·»åŠ æˆ–è·å–èŠ‚ç‚¹
        KnowledgeNode subjectNode = getOrCreateNode(triple.getSubject());
        KnowledgeNode objectNode = getOrCreateNode(triple.getObject());

        // æ·»åŠ è¾¹
        KnowledgeEdge edge = new KnowledgeEdge();
        edge.setId(UUID.randomUUID().toString());
        edge.setSubject(subjectNode.getId());
        edge.setPredicate(triple.getPredicate());
        edge.setObject(objectNode.getId());
        edge.setProperties(triple.getProperties());

        edges.computeIfAbsent(edge.getSubject(), k -> new ArrayList<>()).add(edge);

        // æ›´æ–°ç´¢å¼•
        updateIndexes(subjectNode, objectNode, edge);
    }

    private KnowledgeNode getOrCreateNode(String nodeId) {
        return nodes.computeIfAbsent(nodeId, id -> {
            KnowledgeNode node = new KnowledgeNode();
            node.setId(id);
            return node;
        });
    }

    private double calculateCosineSimilarity(FeatureVector v1, FeatureVector v2) {
        double dotProduct = 0.0;
        double norm1 = 0.0;
        double norm2 = 0.0;

        for (String feature : v1.getFeatures()) {
            double val1 = v1.getValue(feature);
            double val2 = v2.getValue(feature);
            dotProduct += val1 * val2;
            norm1 += val1 * val1;
            norm2 += val2 * val2;
        }

        if (norm1 == 0 || norm2 == 0) {
            return 0.0;
        }

        return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
    }

    private List<KnowledgeTriple> inferTransitiveRelations(List<KnowledgeTriple> triples) {
        List<KnowledgeTriple> inferred = new ArrayList<>();

        // æŸ¥æ‰¾ A->B å’Œ B->Cï¼Œæ¨æ–­ A->C
        Map<String, List<KnowledgeTriple>> subjectIndex = triples.stream()
            .collect(Collectors.groupingBy(KnowledgeTriple::getSubject));

        for (KnowledgeTriple triple1 : triples) {
            String object1 = triple1.getObject();
            List<KnowledgeTriple> triplesFromObject = subjectIndex.get(object1);

            if (triplesFromObject != null) {
                for (KnowledgeTriple triple2 : triplesFromObject) {
                    if (isTransitivePredicate(triple1.getPredicate(), triple2.getPredicate())) {
                        KnowledgeTriple inferredTriple = new KnowledgeTriple();
                        inferredTriple.setSubject(triple1.getSubject());
                        inferredTriple.setObject(triple2.getObject());
                        inferredTriple.setPredicate(inferTransitivePredicate(triple1.getPredicate(), triple2.getPredicate()));
                        inferred.setInferred(true);
                        inferred.add(inferredTriple);
                    }
                }
            }
        }

        return inferred;
    }

    private boolean isTransitivePredicate(String pred1, String pred2) {
        // å®šä¹‰å¯ä¼ é€’çš„è°“è¯å…³ç³»
        Set<String> transitivePredicates = Set.of("uses", "requires", "depends_on");
        return transitivePredicates.contains(pred1) && transitivePredicates.contains(pred2);
    }

    private String inferTransitivePredicate(String pred1, String pred2) {
        // ç®€åŒ–çš„ä¼ é€’æ€§æ¨ç†
        if ("uses".equals(pred1) && "uses".equals(pred2)) {
            return "indirectly_uses";
        }
        return "related_to";
    }

    // å…¶ä»–æ¨ç†æ–¹æ³•...
    private List<KnowledgeTriple> inferAssociativeRelations(List<KnowledgeTriple> triples) {
        // å®ç°å…³è”æ€§æ¨ç†é€»è¾‘
        return new ArrayList<>();
    }

    private List<KnowledgeTriple> inferGeneralizations(List<KnowledgeTriple> triples) {
        // å®ç°æ¦‚æ‹¬æ€§æ¨ç†é€»è¾‘
        return new ArrayList<>();
    }

    private List<KnowledgeTriple> inferCausalRelations(List<KnowledgeTriple> triples) {
        // å®ç°å› æœæ€§æ¨ç†é€»è¾‘
        return new ArrayList<>();
    }

    private void updateIndexes(KnowledgeNode subjectNode, KnowledgeNode objectNode, KnowledgeEdge edge) {
        // ç±»å‹ç´¢å¼•æ›´æ–°
        typeIndex.computeIfAbsent(subjectNode.getType(), k -> new HashSet<>()).add(subjectNode.getId());
        typeIndex.computeIfAbsent(objectNode.getType(), k -> new HashSet<>()).add(objectNode.getId());

        // å±æ€§ç´¢å¼•æ›´æ–°
        for (Map.Entry<String, Object> entry : subjectNode.getAttributes().entrySet()) {
            String key = entry.getKey() + ":" + entry.getValue();
            attributeIndex.computeIfAbsent(key, k -> new HashSet<>()).add(subjectNode.getId());
        }
    }

    public void updateIndex() {
        // é‡å»ºç´¢å¼•
        typeIndex.clear();
        attributeIndex.clear();

        for (KnowledgeNode node : nodes.values()) {
            typeIndex.computeIfAbsent(node.getType(), k -> new HashSet<>()).add(node.getId());

            for (Map.Entry<String, Object> entry : node.getAttributes().entrySet()) {
                String key = entry.getKey() + ":" + entry.getValue();
                attributeIndex.computeIfAbsent(key, k -> new HashSet<>()).add(node.getId());
            }
        }

        log.info("çŸ¥è¯†å›¾è°±ç´¢å¼•æ›´æ–°å®Œæˆ: {} èŠ‚ç‚¹, {} ç±»å‹", nodes.size(), typeIndex.size());
    }
}
```

### 4. æŠ€èƒ½è¿›åŒ–é…ç½®
```yaml
# skill-learning-evolution.yml
skill-learning:
  # å­¦ä¹ ç®—æ³•é…ç½®
  learning-algorithms:
    feature-extraction:
      enabled: true
      code-analysis:
        complexity-metrics: true
        style-analysis: true
        dependency-analysis: true
      architecture-analysis:
        pattern-recognition: true
        coupling-analysis: true
        layer-analysis: true

    pattern-recognition:
      algorithm: "hybrid"  # hybrid, statistical, ml
      min-support: 0.1
      min-confidence: 0.7
      max-patterns: 1000

    machine-learning:
      model-type: "ensemble"  # ensemble, neural_network, decision_tree
      training-data-size: 1000
      validation-split: 0.2
      cross-validation-folds: 5

  # çŸ¥è¯†å›¾è°±é…ç½®
  knowledge-graph:
    storage:
      type: "memory"  # memory, neo4j, postgresql
      max-nodes: 100000
      max-edges: 500000

    reasoning:
      transitive-inference: true
      associative-inference: true
      causal-inference: true
      confidence-threshold: 0.8

    indexing:
      full-text-search: true
      attribute-indexing: true
      similarity-index: true

  # è¿›åŒ–ç­–ç•¥é…ç½®
  evolution-strategy:
    adaptive-execution:
      enabled: true
      similarity-threshold: 0.8
      max-similar-experiences: 50
      confidence-threshold: 0.7

    strategy-optimization:
      learning-rate: 0.01
      optimization-iterations: 100
      early-stopping-patience: 10

    skill-fusion:
      enabled: true
      fusion-threshold: 0.9
      max-combination-size: 3

  # è¯„ä¼°å’ŒéªŒè¯é…ç½®
  evaluation:
    metrics:
      - accuracy
      - precision
      - recall
      - f1-score
      - execution-time
      - resource-usage

    validation:
      cross-validation: true
      holdout-validation: true
      a-b-testing: true

    monitoring:
      real-time-metrics: true
      performance-dashboard: true
      alerting: true

  # è‡ªåŠ¨åŒ–é…ç½®
  automation:
    auto-learning: true
    auto-optimization: true
    auto-deployment: false  # éœ€è¦äººå·¥ç¡®è®¤

    scheduling:
      learning-interval: "daily"
      optimization-interval: "weekly"
      evaluation-interval: "monthly"
```

## ğŸ¯ æŠ€èƒ½åº”ç”¨åœºæ™¯

### 1. è‡ªé€‚åº”æŠ€èƒ½æ‰§è¡Œ
- æ ¹æ®é¡¹ç›®ç‰¹å¾è‡ªåŠ¨è°ƒæ•´æŠ€èƒ½ç­–ç•¥
- åŸºäºå†å²ç»éªŒä¼˜åŒ–æ‰§è¡Œæ­¥éª¤
- å®æ—¶è°ƒæ•´å‚æ•°å’Œèµ„æºé…ç½®

### 2. æ™ºèƒ½æŠ€èƒ½æ¨è
- åŸºäºçŸ¥è¯†å›¾è°±çš„ç›¸ä¼¼æ€§æ¨è
- åŸºäºæœºå™¨å­¦ä¹ çš„æ•ˆæœé¢„æµ‹
- åŸºäºæ¨ç†çš„æ–°æŠ€èƒ½å‘ç°

### 3. æŠ€èƒ½è‡ªåŠ¨è¿›åŒ–
- ä»æ‰§è¡Œç»éªŒä¸­å­¦ä¹ ä¼˜åŒ–ç­–ç•¥
- è‡ªåŠ¨å‘ç°å’Œèåˆæ–°çš„æŠ€èƒ½ç»„åˆ
- æŒç»­æ”¹è¿›æŠ€èƒ½æ€§èƒ½å’Œæ•ˆæœ

## ğŸ”§ å­¦ä¹ è¿›åŒ–å·¥å…·

### æŠ€èƒ½å­¦ä¹ è®­ç»ƒCLI
```bash
#!/bin/bash
# skill-learning-trainer.sh

# æŠ€èƒ½å­¦ä¹ è®­ç»ƒCLIå·¥å…·
echo "ğŸ§  IOE-DREAM æŠ€èƒ½å­¦ä¹ è®­ç»ƒç³»ç»Ÿ"

ACTION=${1:-"train"}
SKILL_NAME=${2:-"all"}

case $ACTION in
    "train")
        echo "ğŸ“ å¼€å§‹è®­ç»ƒæŠ€èƒ½æ¨¡å‹..."
        if [ "$SKILL_NAME" = "all" ]; then
            curl -s -X POST "http://localhost:1024/api/skill/learning/train-all" | jq .
        else
            curl -s -X POST "http://localhost:1024/api/skill/learning/train/$SKILL_NAME" | jq .
        fi
        ;;

    "extract-features")
        echo "ğŸ” æå–é¡¹ç›®ç‰¹å¾..."
        project_path=${3:-"."}
        curl -s -X POST "http://localhost:1024/api/skill/learning/extract-features" \
            -H "Content-Type: application/json" \
            -d "{\"project_path\":\"$project_path\"}" | jq .
        ;;

    "build-knowledge-graph")
        echo "ğŸ•¸ï¸  æ„å»ºçŸ¥è¯†å›¾è°±..."
        curl -s -X POST "http://localhost:1024/api/skill/learning/build-knowledge-graph" | jq .
        ;;

    "optimize-strategy")
        if [ -z "$SKILL_NAME" ] || [ "$SKILL_NAME" = "all" ]; then
            echo "âŒ è¯·æŒ‡å®šæŠ€èƒ½åç§°"
            exit 1
        fi
        echo "âš¡ ä¼˜åŒ–æŠ€èƒ½ç­–ç•¥: $SKILL_NAME"
        curl -s -X POST "http://localhost:1024/api/skill/learning/optimize/$SKILL_NAME" | jq .
        ;;

    "evaluate")
        echo "ğŸ“Š è¯„ä¼°å­¦ä¹ æ•ˆæœ..."
        if [ "$SKILL_NAME" = "all" ]; then
            curl -s "http://localhost:1024/api/skill/learning/evaluate-all" | jq .
        else
            curl -s "http://localhost:1024/api/skill/learning/evaluate/$SKILL_NAME" | jq .
        fi
        ;;

    "recommend")
        echo "ğŸ’¡ è·å–æŠ€èƒ½æ¨è..."
        curl -s "http://localhost:1024/api/skill/learning/recommend" | jq .
        ;;

    *)
        echo "ä½¿ç”¨æ–¹æ³•:"
        echo "  $0 train [skill]           # è®­ç»ƒæŠ€èƒ½æ¨¡å‹"
        echo "  $0 extract-features [path] # æå–é¡¹ç›®ç‰¹å¾"
        echo "  $0 build-knowledge-graph   # æ„å»ºçŸ¥è¯†å›¾è°±"
        echo "  $0 optimize-strategy <skill> # ä¼˜åŒ–æŠ€èƒ½ç­–ç•¥"
        echo "  $0 evaluate [skill]        # è¯„ä¼°å­¦ä¹ æ•ˆæœ"
        echo "  $0 recommend               # è·å–æŠ€èƒ½æ¨è"
        exit 1
        ;;
esac
```

## ğŸ“Š å­¦ä¹ æ•ˆæœåº¦é‡

### å­¦ä¹ KPIæŒ‡æ ‡
- **å­¦ä¹ æ•ˆç‡**: æ–°æŠ€èƒ½æŒæ¡çš„é€Ÿåº¦
- **æ³›åŒ–èƒ½åŠ›**: åœ¨æ–°é¡¹ç›®ä¸Šçš„è¡¨ç°
- **é€‚åº”èƒ½åŠ›**: å¯¹é¡¹ç›®å˜åŒ–çš„å“åº”é€Ÿåº¦
- **åˆ›æ–°èƒ½åŠ›**: æ–°æŠ€èƒ½ç»„åˆçš„å‘ç°æ•°é‡

### è¿›åŒ–æŒ‡æ ‡
- **ç­–ç•¥ä¼˜åŒ–ç‡**: æ‰§è¡Œç­–ç•¥æ”¹è¿›çš„ç¨‹åº¦
- **çŸ¥è¯†å¢é•¿ç‡**: çŸ¥è¯†å›¾è°±è§„æ¨¡å¢é•¿
- **æ¨ç†å‡†ç¡®ç‡**: çŸ¥è¯†æ¨ç†çš„æ­£ç¡®æ€§
- **è‡ªåŠ¨åŒ–ç¨‹åº¦**: æ— éœ€äººå·¥å¹²é¢„çš„æ¯”ä¾‹

---

## ğŸš€ æŠ€èƒ½ç­‰çº§è¦æ±‚

### åˆçº§ (â˜…â˜†â˜†)
- äº†è§£æœºå™¨å­¦ä¹ åŸºæœ¬æ¦‚å¿µ
- èƒ½å¤Ÿç†è§£ç‰¹å¾æå–å’Œæ¨¡å¼è¯†åˆ«

### ä¸­çº§ (â˜…â˜…â˜†)
- æŒæ¡çŸ¥è¯†å›¾è°±æ„å»ºæ–¹æ³•
- èƒ½å¤Ÿè®¾è®¡å­¦ä¹ ç®—æ³•å’Œè¯„ä¼°ä½“ç³»

### ä¸“å®¶çº§ (â˜…â˜…â˜…)
- èƒ½å¤Ÿè®¾è®¡å®Œæ•´çš„è‡ªå­¦ä¹ ç³»ç»Ÿ
- æŒæ¡æ·±åº¦å­¦ä¹ å’Œå¼ºåŒ–å­¦ä¹ æŠ€æœ¯
- èƒ½å¤Ÿå»ºç«‹æŠ€èƒ½ç”Ÿæ€è¿›åŒ–æœºåˆ¶

---

**æŠ€èƒ½ä½¿ç”¨æç¤º**: å½“éœ€è¦å»ºç«‹æŠ€èƒ½è‡ªå­¦ä¹ èƒ½åŠ›ã€å®ç°æ™ºèƒ½è¿›åŒ–æˆ–æ„å»ºçŸ¥è¯†é©±åŠ¨å‹æŠ€èƒ½ä½“ç³»æ—¶ï¼Œè°ƒç”¨æ­¤æŠ€èƒ½è·å¾—ä¸“ä¸šçš„å­¦ä¹ è¿›åŒ–æ–¹æ¡ˆã€‚

**è®°å¿†è¦ç‚¹**:
- æœºå™¨å­¦ä¹ æ˜¯æŠ€èƒ½æ™ºèƒ½åŒ–çš„æ ¸å¿ƒ
- çŸ¥è¯†å›¾è°±æä¾›ç»“æ„åŒ–ç»éªŒå­˜å‚¨
- ç‰¹å¾å·¥ç¨‹å†³å®šå­¦ä¹ æ•ˆæœçš„ä¸Šé™
- æŒç»­å­¦ä¹ æ˜¯å®ç°æŠ€èƒ½è¿›åŒ–çš„å…³é”®
- éªŒè¯å’Œè¯„ä¼°ç¡®ä¿å­¦ä¹ è´¨é‡