# 定时任务表设计

<cite>
**本文档引用文件**  
- [14-t_scheduled_job.sql](file://database-scripts/common-service/14-t_scheduled_job.sql)
- [ScheduledJobEntity.java](file://microservices/microservices-common/src/main/java/net/lab1024/sa/common/scheduler/domain/entity/ScheduledJobEntity.java)
- [ScheduledJobDao.java](file://microservices/microservices-common/src/main/java/net/lab1024/sa/common/scheduler/dao/ScheduledJobDao.java)
- [job-api.js](file://smart-admin-web-javascript/src/api/support/job-api.js)
- [job-list.vue](file://smart-admin-web-javascript/src/views/support/job/job-list.vue)
- [BaseEntity.java](file://microservices/microservices-common/src/main/java/net/lab1024/sa/common/entity/BaseEntity.java)
</cite>

## 目录
1. [引言](#引言)
2. [表结构设计](#表结构设计)
3. [核心字段详解](#核心字段详解)
4. [Cron表达式配置](#cron表达式配置)
5. [任务类型与执行策略](#任务类型与执行策略)
6. [实体类与MyBatis-Plus映射](#实体类与mybatis-plus映射)
7. [API接口与调用示例](#api接口与调用示例)
8. [最佳实践](#最佳实践)

## 引言
`t_scheduled_job`表是IOE-DREAM系统中定时任务模块的核心数据表，用于存储和管理所有定时任务的配置信息。该表支持灵活的定时任务调度，能够满足数据同步、报表生成、缓存刷新等多种业务场景的需求。通过与MyBatis-Plus框架的集成，实现了高效的CRUD操作，并提供了丰富的执行策略控制。

**Section sources**
- [14-t_scheduled_job.sql](file://database-scripts/common-service/14-t_scheduled_job.sql)

## 表结构设计
`t_scheduled_job`表的设计遵循了高可用性和可扩展性的原则，包含了任务的基本信息、调度配置、执行策略和审计字段。表结构如下：

```mermaid
erDiagram
t_scheduled_job {
BIGINT job_id PK "任务ID"
VARCHAR(100) job_name "任务名称"
VARCHAR(50) job_group "任务分组"
VARCHAR(500) job_class "任务执行类"
VARCHAR(100) cron_expression "Cron表达式"
TEXT job_params "任务参数JSON格式"
VARCHAR(500) job_description "任务描述"
TINYINT status "状态：1-启用 2-暂停 3-停止"
INT priority "优先级"
INT max_retry "最大重试次数"
INT retry_interval "重试间隔秒"
INT timeout "超时时间秒"
TINYINT concurrent "是否允许并发：0-否 1-是"
TINYINT misfire_policy "错过执行策略：1-立即执行 2-执行一次 3-放弃执行"
DATETIME last_execution_time "最后执行时间"
DATETIME next_execution_time "下次执行时间"
BIGINT execution_count "执行次数"
BIGINT failure_count "失败次数"
DATETIME create_time "创建时间"
DATETIME update_time "更新时间"
BIGINT create_user_id "创建人ID"
BIGINT update_user_id "更新人ID"
TINYINT deleted_flag "删除标记：0-未删除 1-已删除"
}
t_job_execution_log {
BIGINT log_id PK "日志ID"
BIGINT job_id FK "任务ID"
VARCHAR(100) job_name "任务名称"
VARCHAR(50) job_group "任务分组"
TINYINT execution_status "执行状态：1-成功 2-失败 3-超时 4-取消"
DATETIME start_time "开始时间"
DATETIME end_time "结束时间"
BIGINT execution_time "执行时长毫秒"
INT retry_count "重试次数"
TEXT error_message "错误信息"
TEXT stack_trace "堆栈信息"
TEXT execution_result "执行结果JSON格式"
VARCHAR(50) server_ip "执行服务器IP"
VARCHAR(100) server_hostname "执行服务器主机名"
DATETIME create_time "创建时间"
}
t_scheduled_job ||--o{ t_job_execution_log : "包含"
```

**Diagram sources**
- [14-t_scheduled_job.sql](file://database-scripts/common-service/14-t_scheduled_job.sql)
- [15-t_job_execution_log.sql](file://database-scripts/common-service/15-t_job_execution_log.sql)

**Section sources**
- [14-t_scheduled_job.sql](file://database-scripts/common-service/14-t_scheduled_job.sql)

## 核心字段详解
`t_scheduled_job`表的核心字段设计旨在提供灵活的任务配置和精确的执行控制。

### job_id
`job_id`是任务的唯一标识符，采用BIGINT类型并设置为自增主键，确保每个任务都有唯一的ID。

### job_name
`job_name`字段用于存储任务的名称，VARCHAR(100)类型，不允许为空。任务名称在同一个分组内必须唯一，通过唯一索引`uk_job_name_group`保证。

### cron_expression
`cron_expression`字段存储Cron表达式，用于定义任务的执行时间规则。该字段为VARCHAR(100)类型，不允许为空，支持灵活的定时任务配置。

### job_type
虽然表结构中没有直接的`job_type`字段，但通过`job_class`字段可以间接确定任务类型。`job_class`存储任务执行类的完整类名，不同的类名对应不同类型的任务，如数据同步、报表生成等。

### execute_strategy
执行策略由多个字段共同控制：
- `concurrent`：是否允许并发执行，0表示不允许，1表示允许。
- `misfire_policy`：错过执行策略，1表示立即执行，2表示执行一次，3表示放弃执行。
- `max_retry`和`retry_interval`：定义最大重试次数和重试间隔。

**Section sources**
- [14-t_scheduled_job.sql](file://database-scripts/common-service/14-t_scheduled_job.sql)

## Cron表达式配置
Cron表达式是一种用于配置定时任务执行时间的字符串格式。`cron_expression`字段支持标准的Cron表达式，允许用户定义复杂的执行规则。

### Cron表达式格式
Cron表达式由6个或7个字段组成，分别表示秒、分钟、小时、日期、月份、星期和年份（可选）。例如：
- `0 0 12 * * ?`：每天中午12点执行
- `0 15 10 ? * MON-FRI`：工作日上午10:15执行
- `0 0/5 14,18 * * ?`：每天下午2点到6点，每5分钟执行一次

### 配置示例
```sql
-- 每天凌晨1点执行数据同步任务
INSERT INTO t_scheduled_job (job_name, job_class, cron_expression, job_params)
VALUES ('DataSyncJob', 'com.example.DataSyncTask', '0 0 1 * * ?', '{"source": "db1", "target": "db2"}');

-- 每周一上午9点生成周报
INSERT INTO t_scheduled_job (job_name, job_class, cron_expression, job_params)
VALUES ('WeeklyReportJob', 'com.example.WeeklyReportTask', '0 0 9 ? * MON', '{"reportType": "weekly"}');
```

**Section sources**
- [14-t_scheduled_job.sql](file://database-scripts/common-service/14-t_scheduled_job.sql)

## 任务类型与执行策略
### 任务类型
通过`job_class`字段区分不同类型的业务任务：
- **数据同步**：`com.example.DataSyncTask`
- **报表生成**：`com.example.ReportGenerationTask`
- **缓存刷新**：`com.example.CacheRefreshTask`
- **日志清理**：`com.example.LogCleanupTask`

### 执行策略
执行策略通过多个字段组合实现：
- **单机/集群**：通过`concurrent`字段控制，0表示单机模式，1表示集群模式。
- **串行/并行**：`concurrent`字段同样控制任务的串行或并行执行。
- **重试机制**：`max_retry`和`retry_interval`字段定义重试次数和间隔。
- **超时控制**：`timeout`字段定义任务执行的超时时间。

```mermaid
flowchart TD
A[任务触发] --> B{是否允许并发?}
B --> |否| C[等待前一个任务完成]
B --> |是| D[立即执行新任务]
C --> E[执行任务]
D --> E
E --> F{执行成功?}
F --> |否| G{重试次数 < 最大重试?}
G --> |是| H[等待重试间隔后重试]
H --> E
G --> |否| I[记录失败]
F --> |是| J[记录成功]
```

**Diagram sources**
- [14-t_scheduled_job.sql](file://database-scripts/common-service/14-t_scheduled_job.sql)

**Section sources**
- [14-t_scheduled_job.sql](file://database-scripts/common-service/14-t_scheduled_job.sql)

## 实体类与MyBatis-Plus映射
### ScheduledJobEntity
`ScheduledJobEntity`是`t_scheduled_job`表对应的Java实体类，继承自`BaseEntity`，包含了所有数据库字段的映射。

```mermaid
classDiagram
class ScheduledJobEntity {
+Long jobId
+String jobName
+String jobGroup
+String jobClass
+String cronExpression
+String jobParams
+String jobDescription
+Integer status
+Integer priority
+Integer maxRetry
+Integer retryInterval
+Integer timeout
+Integer concurrent
+Integer misfirePolicy
+LocalDateTime lastExecutionTime
+LocalDateTime nextExecutionTime
+Long executionCount
+Long failureCount
}
class BaseEntity {
+LocalDateTime createTime
+LocalDateTime updateTime
+Long createUserId
+Long updateUserId
+Integer deletedFlag
}
ScheduledJobEntity --|> BaseEntity : 继承
```

**Diagram sources**
- [ScheduledJobEntity.java](file://microservices/microservices-common/src/main/java/net/lab1024/sa/common/scheduler/domain/entity/ScheduledJobEntity.java)
- [BaseEntity.java](file://microservices/microservices-common/src/main/java/net/lab1024/sa/common/entity/BaseEntity.java)

### ScheduledJobDao
`ScheduledJobDao`接口继承自MyBatis-Plus的`BaseMapper`，提供了基本的CRUD操作，并定义了两个默认方法用于特定查询。

```mermaid
classDiagram
class ScheduledJobDao {
+selectByJobNameAndGroup(String jobName, String jobGroup) ScheduledJobEntity
+selectByStatus(Integer status) ScheduledJobEntity[]
}
class BaseMapper~T~ {
+insert(T entity) int
+deleteById(Serializable id) int
+updateById(T entity) int
+selectById(Serializable id) T
+selectList(Wrapper~T~ queryWrapper) T[]
}
ScheduledJobDao ..> BaseMapper~ScheduledJobEntity~ : 继承
```

**Diagram sources**
- [ScheduledJobDao.java](file://microservices/microservices-common/src/main/java/net/lab1024/sa/common/scheduler/dao/ScheduledJobDao.java)

**Section sources**
- [ScheduledJobEntity.java](file://microservices/microservices-common/src/main/java/net/lab1024/sa/common/scheduler/domain/entity/ScheduledJobEntity.java)
- [ScheduledJobDao.java](file://microservices/microservices-common/src/main/java/net/lab1024/sa/common/scheduler/dao/ScheduledJobDao.java)

## API接口与调用示例
### 前端API定义
前端通过`job-api.js`定义了与定时任务相关的API接口。

```mermaid
sequenceDiagram
participant Frontend as 前端
participant API as job-api.js
participant Backend as 后端服务
Frontend->>API : queryJob(param)
API->>Backend : POST /support/job/query
Backend-->>API : 返回任务列表
API-->>Frontend : 返回任务列表
Frontend->>API : addJob(param)
API->>Backend : POST /support/job/add
Backend-->>API : 返回创建结果
API-->>Frontend : 返回创建结果
Frontend->>API : updateJob(param)
API->>Backend : POST /support/job/update
Backend-->>API : 返回更新结果
API-->>Frontend : 返回更新结果
Frontend->>API : deleteJob(jobId)
API->>Backend : GET /support/job/delete?jobId=${jobId}
Backend-->>API : 返回删除结果
API-->>Frontend : 返回删除结果
```

**Diagram sources**
- [job-api.js](file://smart-admin-web-javascript/src/api/support/job-api.js)

### 创建新定时任务API调用示例
```javascript
// 创建数据同步任务
const dataSyncJob = {
  jobName: 'DataSyncJob',
  jobGroup: 'DATA_SYNC',
  jobClass: 'com.example.DataSyncTask',
  cronExpression: '0 0 1 * * ?',
  jobParams: JSON.stringify({
    source: 'production_db',
    target: 'analytics_db',
    tables: ['user', 'order', 'product']
  }),
  jobDescription: '每日凌晨1点同步生产库到分析库',
  status: 1,
  priority: 10,
  maxRetry: 3,
  retryInterval: 300,
  timeout: 3600,
  concurrent: 0,
  misfirePolicy: 1
};

jobApi.addJob(dataSyncJob).then(response => {
  console.log('任务创建成功:', response.data);
}).catch(error => {
  console.error('任务创建失败:', error);
});
```

**Section sources**
- [job-api.js](file://smart-admin-web-javascript/src/api/support/job-api.js)
- [job-list.vue](file://smart-admin-web-javascript/src/views/support/job/job-list.vue)

## 最佳实践
### 1. 任务命名规范
- 使用有意义的名称，如`DataSyncJob`、`DailyReportJob`
- 在任务分组中使用业务模块名称，如`DATA_SYNC`、`REPORT_GENERATION`

### 2. Cron表达式优化
- 避免在高峰期执行资源密集型任务
- 使用`?`通配符避免日期和星期的冲突
- 测试Cron表达式以确保预期的执行时间

### 3. 错误处理与重试
- 设置合理的`max_retry`和`retry_interval`
- 记录详细的错误信息和堆栈跟踪
- 实现告警机制，及时通知任务失败

### 4. 性能监控
- 定期检查`execution_count`和`failure_count`统计
- 监控`next_execution_time`确保任务按时触发
- 分析执行日志，优化任务执行时间

### 5. 安全性考虑
- 限制对定时任务管理接口的访问权限
- 对敏感任务参数进行加密存储
- 定期审计任务配置变更

**Section sources**
- [14-t_scheduled_job.sql](file://database-scripts/common-service/14-t_scheduled_job.sql)
- [ScheduledJobEntity.java](file://microservices/microservices-common/src/main/java/net/lab1024/sa/common/scheduler/domain/entity/ScheduledJobEntity.java)
- [job-api.js](file://smart-admin-web-javascript/src/api/support/job-api.js)