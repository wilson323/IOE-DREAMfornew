# 状态监控

<cite>
**本文档引用文件**   
- [AccessMonitorController.java](file://restful_refactor_backup_20251202_014224/microservices_ioedream-access-service_src_main_java_net_lab1024_sa_access_monitor_controller_AccessMonitorController.java)
- [websocket.ts](file://documentation/03-业务模块/门禁/13-前端移动端组件设计.md)
- [smart-realtime.md](file://documentation/technical/smart-realtime.md)
- [AccessServiceMetrics.java](file://documentation/04-部署运维/门禁服务监控告警机制.md)
- [smart-device.md](file://documentation/technical/smart-device.md)
</cite>

## 目录
1. [引言](#引言)
2. [设备状态数据模型](#设备状态数据模型)
3. [实时状态展示机制](#实时状态展示机制)
4. [WebSocket长连接实现](#websocket长连接实现)
5. [状态轮询与事件推送模式](#状态轮询与事件推送模式)
6. [前端组件实现细节](#前端组件实现细节)
7. [性能优化建议](#性能优化建议)
8. [系统架构图](#系统架构图)

## 引言

门禁系统状态监控是智能园区安全管理的核心功能，通过实时监控设备在线状态、门开关状态和报警状态，确保园区安全系统的稳定运行。本系统采用WebSocket长连接与HTTP轮询相结合的方式，实现设备状态的实时更新和高效展示。前端通过状态指示灯、设备列表等组件直观展示设备状态，后端通过事件推送和状态轮询两种模式确保数据的实时性和可靠性。系统还提供了完善的性能优化策略，包括状态缓存、批量更新和分页加载，以应对大规模设备监控的需求。

**Section sources**
- [AccessMonitorController.java](file://restful_refactor_backup_20251202_014224/microservices_ioedream-access-service_src_main_java_net_lab1024_sa_access_monitor_controller_AccessMonitorController.java#L1-L327)

## 设备状态数据模型

门禁系统定义了统一的设备状态数据模型，包含设备ID、状态码、时间戳等核心字段。该模型通过`DeviceStatus`类实现，支持多种设备类型的状态监控。

| 字段名 | 类型 | 说明 | 示例值 |
|-------|------|------|-------|
| deviceId | String | 设备唯一标识 | "CAMERA-001" |
| isOnline | Boolean | 设备在线状态 | true |
| status | Integer | 设备状态码 | 1 |
| lastHeartbeatTime | LocalDateTime | 最后心跳时间 | "2025-12-04T10:30:00" |
| extendedAttributes | Map<String, Object> | 扩展属性（JSON） | {"battery": 85, "temperature": 36.5} |

设备状态码定义如下：
- 0: 离线
- 1: 在线（空闲）
- 2: 在线（工作中）
- 3: 故障

**Section sources**
- [smart-device.md](file://documentation/technical/smart-device.md#L1511-L1803)

## 实时状态展示机制

系统通过多种方式实时展示设备状态，包括状态指示灯、设备列表和统计图表。状态指示灯使用不同颜色表示设备状态：绿色表示在线，红色表示离线，黄色表示故障。设备列表实时刷新，显示设备名称、位置、状态和最后更新时间。

```mermaid
flowchart TD
A[设备心跳] --> B{设备在线?}
B --> |是| C[更新状态为在线]
B --> |否| D[更新状态为离线]
C --> E[更新最后心跳时间]
D --> E
E --> F[通知前端更新]
F --> G[前端刷新UI]
```

**Diagram sources**
- [AccessServiceMetrics.java](file://documentation/04-部署运维/门禁服务监控告警机制.md#L282-L400)

## WebSocket长连接实现

前端通过WebSocket与后端建立长连接，实现实时数据推送。连接建立后，前端发送认证信息并订阅相关主题，后端通过WebSocket推送设备状态更新、访问事件和告警信息。

```mermaid
sequenceDiagram
participant 前端 as 前端应用
participant 后端 as 门禁服务
participant 设备 as 门禁设备
前端->>后端 : 建立WebSocket连接
后端-->>前端 : 连接成功
前端->>后端 : 发送认证信息
后端->>后端 : 验证认证
后端-->>前端 : 认证成功
前端->>后端 : 订阅设备状态
设备->>后端 : 心跳包
后端->>前端 : 推送设备状态更新
设备->>后端 : 触发告警
后端->>前端 : 推送告警信息
```

**Diagram sources**
- [websocket.ts](file://documentation/03-业务模块/门禁/13-前端移动端组件设计.md#L708-L801)

## 状态轮询与事件推送模式

系统支持状态轮询和事件推送两种模式，适用于不同场景。状态轮询适用于低频更新的静态数据，事件推送适用于高频更新的实时数据。

### 状态轮询模式

状态轮询通过定时调用HTTP API获取设备状态，适用于网络环境不稳定或设备数量较少的场景。

```mermaid
flowchart TD
A[前端定时器] --> B{是否到刷新时间?}
B --> |是| C[调用HTTP API]
C --> D[获取设备状态]
D --> E[更新UI]
E --> F[等待下次刷新]
F --> B
B --> |否| G[继续等待]
G --> B
```

**Diagram sources**
- [AccessMonitorController.java](file://restful_refactor_backup_20251202_014224/microservices_ioedream-access-service_src_main_java_net_lab1024_sa_access_monitor_controller_AccessMonitorController.java#L53-L61)

### 事件推送模式

事件推送通过WebSocket长连接实时推送设备状态变化，适用于需要实时响应的高并发场景。

```mermaid
flowchart TD
A[设备状态变化] --> B[后端检测到变化]
B --> C[通过WebSocket推送]
C --> D[前端接收消息]
D --> E[更新UI]
E --> F[完成]
```

**Diagram sources**
- [smart-realtime.md](file://documentation/technical/smart-realtime.md#L1-L26)

## 前端组件实现细节

前端采用Vue 3 + TypeScript技术栈，使用Pinia进行状态管理。核心组件包括状态指示灯、设备列表和告警通知。

### 状态指示灯组件

状态指示灯组件通过颜色变化直观展示设备状态：

```mermaid
classDiagram
class StatusIndicator {
+status : string
+color : string
+getStatusColor() : string
+render() : JSX.Element
}
StatusIndicator --> DeviceStatus : "uses"
```

**Diagram sources**
- [websocket.ts](file://documentation/03-业务模块/门禁/13-前端移动端组件设计.md#L748-L764)

### 设备列表刷新机制

设备列表采用虚拟滚动和分页加载策略，确保大规模设备监控时的性能：

```mermaid
flowchart TD
A[用户滚动] --> B{是否接近底部?}
B --> |是| C[加载下一页]
C --> D[请求API]
D --> E[获取数据]
E --> F[更新列表]
F --> G[完成]
B --> |否| H[继续显示当前页]
H --> G
```

**Section sources**
- [websocket.ts](file://documentation/03-业务模块/门禁/13-前端移动端组件设计.md#L748-L764)

## 性能优化建议

为应对大规模设备监控的性能挑战，系统提供了多种优化策略。

### 状态缓存策略

采用多级缓存策略，减少数据库查询压力：

```mermaid
flowchart TD
A[请求设备状态] --> B{缓存中存在?}
B --> |是| C[返回缓存数据]
B --> |否| D[查询数据库]
D --> E[更新缓存]
E --> F[返回数据]
C --> G[完成]
F --> G
```

**Section sources**
- [AccessServiceMetrics.java](file://documentation/04-部署运维/门禁服务监控告警机制.md#L282-L400)

### 批量更新机制

对于大规模设备状态更新，采用批量处理机制：

```mermaid
flowchart TD
A[批量设备状态更新] --> B[收集更新请求]
B --> C{达到批量阈值?}
C --> |是| D[批量处理]
D --> E[更新数据库]
E --> F[推送更新]
F --> G[完成]
C --> |否| H[继续收集]
H --> B
```

**Section sources**
- [AccessMonitorController.java](file://restful_refactor_backup_20251202_014224/microservices_ioedream-access-service_src_main_java_net_lab1024_sa_access_monitor_controller_AccessMonitorController.java#L53-L61)

### 分页加载方案

大规模设备监控采用分页加载，避免一次性加载过多数据：

```mermaid
flowchart TD
A[请求设备列表] --> B[设置分页参数]
B --> C[调用分页API]
C --> D[获取分页数据]
D --> E[渲染当前页]
E --> F{用户滚动到底部?}
F --> |是| G[加载下一页]
G --> C
F --> |否| H[完成]
```

**Section sources**
- [AccessMonitorController.java](file://restful_refactor_backup_20251202_014224/microservices_ioedream-access-service_src_main_java_net_lab1024_sa_access_monitor_controller_AccessMonitorController.java#L53-L61)

## 系统架构图

```mermaid
graph TD
subgraph "前端"
A[Web应用] --> B[WebSocket客户端]
A --> C[HTTP客户端]
end
subgraph "后端"
D[门禁服务] --> E[WebSocket服务]
D --> F[HTTP API]
D --> G[设备状态服务]
G --> H[Redis缓存]
G --> I[数据库]
end
B --> E
C --> F
E --> B
F --> C
```

**Diagram sources**
- [smart-realtime.md](file://documentation/technical/smart-realtime.md#L1-L26)
- [AccessServiceMetrics.java](file://documentation/04-部署运维/门禁服务监控告警机制.md#L282-L400)