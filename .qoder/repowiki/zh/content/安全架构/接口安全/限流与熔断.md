# 限流与熔断

<cite>
**本文档引用文件**  
- [RESILIENCE4J_DEPENDENCY_FIX.md](file://RESILIENCE4J_DEPENDENCY_FIX.md)
- [templates/secure-application.yml](file://templates/secure-application.yml)
- [FINAL_RESILIENCE4J_FIX_SUMMARY.md](file://FINAL_RESILIENCE4J_FIX_SUMMARY.md)
- [deployment/monitoring/prometheus/rules/protocol_alerts.yml](file://deployment/monitoring/prometheus/rules/protocol_alerts.yml)
- [microservices/ioedream-device-comm-service/src/main/java/net/lab1024/sa/devicecomm/controller/ProtocolController.java](file://microservices/ioedream-device-comm-service/src/main/java/net/lab1024/sa/devicecomm/controller/ProtocolController.java)
- [documentation/01-核心规范/架构规范/全局架构规范.md](file://documentation/01-核心规范/架构规范/全局架构规范.md)
</cite>

## 目录
1. [引言](#引言)
2. [Resilience4j依赖集成](#resilience4j依赖集成)
3. [限流机制实现](#限流机制实现)
4. [熔断机制实现](#熔断机制实现)
5. [网关层流量控制集成](#网关层流量控制集成)
6. [配置策略与阈值设置](#配置策略与阈值设置)
7. [监控指标与告警配置](#监控指标与告警配置)
8. [最佳实践建议](#最佳实践建议)

## 引言

在分布式系统中，接口限流与熔断是保障系统稳定性的关键机制。本文档详细说明基于Resilience4j的限流（RateLimiter）和熔断（CircuitBreaker）实现方案，涵盖配置策略、失败率阈值、自动恢复机制以及在微服务架构中的集成方式。通过合理的流量控制和故障隔离策略，系统能够在高并发场景下保持稳定运行，防止雪崩效应的发生。

## Resilience4j依赖集成

Resilience4j作为轻量级容错库，为Java应用提供了丰富的弹性能力。在本项目中，通过`microservices-common/pom.xml`统一管理Resilience4j相关依赖，确保各微服务模块的一致性。

**核心依赖配置**：
- `resilience4j-spring-boot3`：版本2.3.0，提供Spring Boot3自动配置支持
- `resilience4j-spring6`：版本2.3.0，必需的基础集成依赖
- `resilience4j-circuitbreaker`：熔断器模块
- `resilience4j-retry`：重试机制模块
- `resilience4j-timelimiter`：超时限制模块

在测试环境中，为避免类加载问题，通过`TestApplication.java`中的`excludeName`配置排除Resilience4j自动配置，并在`application-test.yml`中添加相应的自动配置排除规则。

**Section sources**
- [RESILIENCE4J_DEPENDENCY_FIX.md](file://RESILIENCE4J_DEPENDENCY_FIX.md#L1-L127)
- [FINAL_RESILIENCE4J_FIX_SUMMARY.md](file://FINAL_RESILIENCE4J_FIX_SUMMARY.md#L1-L120)

## 限流机制实现

### 基于注解的限流配置

系统采用Resilience4j的`@RateLimiter`注解实现接口级别的限流控制。在关键接口上应用该注解，可有效防止恶意刷接口或突发流量导致的服务过载。

```java
@RateLimiter(name = "protocol-push", fallbackMethod = "receivePushTextFallback")
public ResponseEntity<String> receivePushText(@RequestBody PushData data) {
    // 接口逻辑
}
```

### 限流策略类型

#### 固定窗口限流
固定时间窗口内允许固定数量的请求通过，简单高效，适用于流量平稳的场景。

#### 滑动窗口限流
结合多个时间窗口的统计信息，提供更平滑的限流效果，适合应对突发流量。

### 限流配置示例

在`templates/secure-application.yml`中定义了通用的安全配置模板，其中包含了限流相关的配置项。各微服务可根据具体需求在各自的`application.yml`中进行个性化配置。

**Section sources**
- [templates/secure-application.yml](file://templates/secure-application.yml#L1-L132)
- [microservices/ioedream-device-comm-service/src/main/java/net/lab1024/sa/devicecomm/controller/ProtocolController.java](file://microservices/ioedream-device-comm-service/src/main/java/net/lab1024/sa/devicecomm/controller/ProtocolController.java#L170)

## 熔断机制实现

### 熔断器工作原理

熔断机制通过监控接口的失败率，在达到预设阈值时自动打开熔断器，阻止后续请求直接失败，从而保护下游服务。经过冷却期后，熔断器进入半开状态，尝试恢复服务调用。

### 基于注解的熔断配置

使用`@CircuitBreaker`注解实现服务降级和熔断功能：

```java
@CircuitBreaker(name = "consumeService", fallbackMethod = "consumeFallback")
public ConsumptionResult processConsumption(ConsumptionRequest request) {
    // 业务逻辑
}
```

### 熔断状态转换

熔断器在三种状态间转换：
- **关闭（Closed）**：正常处理请求，统计失败率
- **打开（Open）**：直接拒绝请求，进入冷却期
- **半开（Half-Open）**：允许部分请求通过，验证服务是否恢复

### 自动恢复机制

当熔断器处于打开状态时，经过预设的等待时间（waitDurationInOpenState）后，自动进入半开状态。此时会允许一定数量的请求通过，如果这些请求成功，则关闭熔断器；如果仍然失败，则重新打开。

**Section sources**
- [documentation/01-核心规范/架构规范/全局架构规范.md](file://documentation/01-核心规范/架构规范/全局架构规范.md#L625)
- [microservices/ioedream-device-comm-service/src/main/java/net/lab1024/sa/devicecomm/controller/ProtocolController.java](file://microservices/ioedream-device-comm-service/src/main/java/net/lab1024/sa/devicecomm/controller/ProtocolController.java#L170)

## 网关层流量控制集成

在`ioedream-gateway-service`中集成了Resilience4j的流量控制功能，作为整个系统的入口屏障。通过网关层的统一配置，可以实现全局的流量管理和安全防护。

网关层的限流策略不仅基于客户端IP，还结合了用户身份、请求频率等多维度信息进行综合判断。对于超出限制的请求，网关将直接返回429状态码，无需转发到后端服务，有效减轻系统压力。

**Section sources**
- [microservices/ioedream-gateway-service/src/main/resources/application.yml](file://microservices/ioedream-gateway-service/src/main/resources/application.yml)
- [templates/secure-application.yml](file://templates/secure-application.yml#L1-L132)

## 配置策略与阈值设置

### 业务场景阈值建议

| 业务场景 | 限流阈值 | 熔断失败率阈值 | 熔断等待时间 |
|--------|--------|-------------|-----------|
| 登录接口 | 10次/分钟 | 50% | 30秒 |
| 支付接口 | 5次/秒 | 60% | 60秒 |
| 查询接口 | 100次/秒 | 80% | 10秒 |
| 通知推送 | 20次/秒 | 70% | 30秒 |

### 配置示例

```yaml
resilience4j:
  ratelimiter:
    instances:
      login-api:
        limitForPeriod: 10
        limitRefreshPeriod: 1s
        timeoutDuration: 0s
  circuitbreaker:
    instances:
      consume-service:
        failureRateThreshold: 60
        waitDurationInOpenState: 60s
        ringBufferSizeInHalfOpenState: 2
        ringBufferSizeInClosedState: 4
```

**Section sources**
- [templates/secure-application.yml](file://templates/secure-application.yml#L1-L132)
- [RESILIENCE4J_DEPENDENCY_FIX.md](file://RESILIENCE4J_DEPENDENCY_FIX.md#L1-L127)

## 监控指标与告警配置

### Prometheus监控指标

系统通过Prometheus收集Resilience4j暴露的监控指标，主要包括：
- `resilience4j_circuitbreaker_state`：熔断器状态（0=关闭，1=打开，2=半开）
- `resilience4j_ratelimiter_available_permits`：剩余许可数量
- `resilience4j_circuitbreaker_calls`：调用统计

### 告警规则配置

在`deployment/monitoring/prometheus/rules/protocol_alerts.yml`中定义了熔断器相关的告警规则：

```yaml
- alert: ProtocolCircuitBreakerOpen
  expr: resilience4j_circuitbreaker_state{name=~"access-service|attendance-service|consume-service|common-service"} == 1
  for: 1m
  labels:
    severity: critical
  annotations:
    summary: "熔断器打开 - {{ $labels.name }}"
    description: "{{ $labels.name }} 服务的熔断器已打开，持续1分钟以上"
```

当熔断器持续打开超过1分钟时触发告警，通知运维人员及时排查问题。

**Diagram sources**
- [deployment/monitoring/prometheus/rules/protocol_alerts.yml](file://deployment/monitoring/prometheus/rules/protocol_alerts.yml#L99-L101)

**Section sources**
- [deployment/monitoring/prometheus/rules/protocol_alerts.yml](file://deployment/monitoring/prometheus/rules/protocol_alerts.yml#L99-L101)
- [templates/secure-application.yml](file://templates/secure-application.yml#L112-L124)

## 最佳实践建议

1. **合理设置阈值**：根据业务特性和系统承载能力设置合适的限流和熔断阈值，避免过于严格影响正常业务，或过于宽松失去保护作用。

2. **分级防护策略**：实施多层级的流量控制，包括网关层、服务层和数据访问层，形成纵深防御体系。

3. **监控与告警联动**：将熔断和限流事件与监控系统联动，及时发现和响应异常情况。

4. **定期评估优化**：根据实际运行数据定期评估限流和熔断策略的有效性，持续优化配置参数。

5. **文档化配置**：将所有限流和熔断配置文档化，便于团队成员理解和维护。

6. **测试验证**：在测试环境中模拟高并发和故障场景，验证限流和熔断机制的有效性。