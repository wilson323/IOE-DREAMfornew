# 认证与授权

<cite>
**本文档引用文件**   
- [AuthService.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\service\AuthService.java)
- [AuthServiceImpl.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\service\impl\AuthServiceImpl.java)
- [AuthManager.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\manager\AuthManager.java)
- [JwtTokenUtil.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\util\JwtTokenUtil.java)
- [SecurityConfig.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\config\SecurityConfig.java)
- [UserSessionEntity.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\domain\entity\UserSessionEntity.java)
- [LoginResponseVO.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\domain\vo\LoginResponseVO.java)
- [t_user_session_table.sql](file://database-scripts\common-service\t_user_session_table.sql)
- [smart-permission.md](file://documentation\technical\smart-permission.md)
- [security_hardening_guide.md](file://security\security_hardening_guide.md)
</cite>

## 目录
1. [简介](#简介)
2. [登录流程与Token生成](#登录流程与token生成)
3. [会话管理机制](#会话管理机制)
4. [权限校验实现原理](#权限校验实现原理)
5. [前后端交互方式](#前后端交互方式)
6. [自定义拦截器与权限注解](#自定义拦截器与权限注解)
7. [多端登录与单点登录](#多端登录与单点登录)
8. [临时授权实现](#临时授权实现)
9. [常见问题解决方案](#常见问题解决方案)
10. [性能优化建议](#性能优化建议)

## 简介
本文档详细阐述了基于Sa-Token的认证与授权机制，涵盖了从用户登录到权限校验的完整流程。系统采用JWT（JSON Web Token）作为主要的认证技术，结合Redis和数据库实现企业级的安全特性，包括防暴力破解、令牌轮换、会话管理和多级权限控制。

系统架构遵循分层设计原则，包含Controller、Service、Manager和DAO层，确保了代码的可维护性和扩展性。认证服务被封装在`microservices-common`模块中，实现了微服务间的共享和复用。

**Section sources**
- [AuthService.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\service\AuthService.java#L1-L81)
- [AuthServiceImpl.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\service\impl\AuthServiceImpl.java#L1-L397)

## 登录流程与Token生成
### 登录流程
用户登录流程是一个多步骤的复杂业务过程，由`AuthServiceImpl`和`AuthManager`协同完成。

```mermaid
sequenceDiagram
participant 前端 as 前端应用
participant AuthController as AuthController
participant AuthService as AuthServiceImpl
participant AuthManager as AuthManager
participant JwtUtil as JwtTokenUtil
participant UserDao as UserDao
participant Redis as Redis
participant Database as 数据库
前端->>AuthController : POST /api/auth/login
AuthController->>AuthService : login(LoginRequestDTO)
AuthService->>AuthManager : isUserLocked(username)
AuthManager->>Redis : 查询登录失败次数
AuthManager-->>AuthService : 返回锁定状态
AuthService->>UserDao : selectByUsername(username)
UserDao-->>AuthService : 返回用户信息
AuthService->>PasswordEncoder : 验证密码
PasswordEncoder-->>AuthService : 验证结果
AuthService->>UserDao : selectUserPermissions/roles
UserDao-->>AuthService : 返回权限和角色
AuthService->>JwtUtil : generateAccessToken/refreshToken
JwtUtil-->>AuthService : 生成JWT令牌
AuthService->>AuthManager : manageUserSession(userId, token, deviceInfo)
AuthManager->>Redis : 添加会话到集合
Redis-->>AuthManager : 操作结果
AuthManager->>Database : 插入会话记录
Database-->>AuthManager : 操作结果
AuthManager-->>AuthService : 会话管理完成
AuthService->>UserDao : updateLastLogin
UserDao-->>AuthService : 更新结果
AuthService-->>AuthController : 返回LoginResponseVO
AuthController-->>前端 : 返回登录响应
```

**Diagram sources**
- [AuthServiceImpl.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\service\impl\AuthServiceImpl.java#L81-L157)
- [AuthManager.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\manager\AuthManager.java#L98-L142)

### Token生成与验证机制
系统使用JWT作为认证令牌，通过`JwtTokenUtil`类进行生成和验证。

```mermaid
classDiagram
class JwtTokenUtil {
+String secret
+Long accessTokenExpiration
+Long refreshTokenExpiration
-String CLAIM_KEY_USER_ID
-String CLAIM_KEY_USERNAME
-String CLAIM_KEY_ROLES
-String CLAIM_KEY_PERMISSIONS
-String CLAIM_KEY_TOKEN_TYPE
-String TOKEN_TYPE_ACCESS
-String TOKEN_TYPE_REFRESH
+String generateAccessToken(Long userId, String username, String[] roles, String[] permissions)
+String generateRefreshToken(Long userId, String username)
+boolean validateToken(String token)
+boolean isTokenExpired(String token)
+Claims getClaimsFromToken(String token)
+Date getExpirationDateFromToken(String token)
+Long getRemainingExpiration(String token)
+Long getUserIdFromToken(String token)
+String getUsernameFromToken(String token)
+String[] getRolesFromToken(String token)
+String[] getPermissionsFromToken(String token)
+boolean isAccessToken(String token)
+boolean isRefreshToken(String token)
}
class LoginResponseVO {
+String accessToken
+String refreshToken
+String tokenType
+Long expiresIn
+Long refreshExpiresIn
+Long userId
+String username
+String nickname
+String avatarUrl
+String[] permissions
+String[] roles
}
JwtTokenUtil --> LoginResponseVO : "生成"
```

**Diagram sources**
- [JwtTokenUtil.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\util\JwtTokenUtil.java#L1-L252)
- [LoginResponseVO.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\domain\vo\LoginResponseVO.java#L1-L58)

**Section sources**
- [JwtTokenUtil.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\util\JwtTokenUtil.java#L1-L252)
- [LoginResponseVO.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\domain\vo\LoginResponseVO.java#L1-L58)

## 会话管理机制
### 会话实体与数据库设计
系统通过`UserSessionEntity`实体和`t_user_session`表来持久化用户会话信息，确保会话的可靠性和可审计性。

```mermaid
erDiagram
USER_SESSION {
Long sessionId PK
Long userId
String token
String refreshToken
String deviceInfo
String loginIp
LocalDateTime loginTime
LocalDateTime lastAccessTime
LocalDateTime expiryTime
Integer status
LocalDateTime createTime
LocalDateTime updateTime
Long createUser
Long updateUser
Integer deletedFlag
}
USER_SESSION ||--o{ USER : "属于"
```

**Diagram sources**
- [UserSessionEntity.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\domain\entity\UserSessionEntity.java#L1-L109)
- [t_user_session_table.sql](file://database-scripts\common-service\t_user_session_table.sql#L1-L37)

### 会话管理流程
会话管理由`AuthManager`负责，采用多级缓存策略（Redis + 数据库）以提高性能和可靠性。

```mermaid
flowchart TD
A[开始] --> B{会话数量 >= MAX_SESSIONS?}
B --> |是| C[移除最旧会话]
C --> D[将旧令牌加入黑名单]
D --> E[从Redis移除]
E --> F[从数据库删除]
F --> G[添加新会话到Redis]
G --> H[持久化会话到数据库]
H --> I[结束]
B --> |否| G
```

**Diagram sources**
- [AuthManager.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\manager\AuthManager.java#L98-L142)

**Section sources**
- [UserSessionEntity.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\domain\entity\UserSessionEntity.java#L1-L109)
- [AuthManager.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\manager\AuthManager.java#L98-L142)

## 权限校验实现原理
### 权限校验流程
权限校验是系统安全的核心，通过`AuthService`的`hasPermission`和`hasRole`方法实现。

```mermaid
sequenceDiagram
participant Client as 客户端
participant Controller as 控制器
participant AuthService as AuthServiceImpl
participant JwtUtil as JwtTokenUtil
participant AuthManager as AuthManager
Client->>Controller : 带Token的请求
Controller->>AuthService : hasPermission(token, permission)
AuthService->>AuthService : validateToken(token)
AuthService->>JwtUtil : getPermissionsFromToken(token)
JwtUtil-->>AuthService : 返回权限列表
AuthService-->>Controller : 返回校验结果
Controller-->>Client : 返回响应
```

**Diagram sources**
- [AuthServiceImpl.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\service\impl\AuthServiceImpl.java#L358-L371)

### 5级安全级别权限控制
系统实现了基于5级安全级别的精细化权限控制，支持数据权限隔离和临时权限管理。

```mermaid
classDiagram
class SecurityLevelService {
+SecurityLevelVO[] getAllSecurityLevels()
+Integer getUserSecurityLevel(Long userId)
+void grantUserSecurityLevel(SecurityLevelGrantDTO grantDTO)
+PermissionValidateVO validatePermission(Long userId, String permissionCode, String dataScope)
}
class SecurityLevelManager {
+SecurityLevelVO[] getAllSecurityLevels()
+Integer getUserSecurityLevel(Long userId)
+void grantUserSecurityLevel(SecurityLevelGrantDTO grantDTO)
+Integer getPermissionRequiredLevel(String permissionCode)
}
class PermissionAuditService {
+void recordPermissionLog(Long userId, String permissionCode, String description)
}
class DataPermissionService {
+boolean validateDataPermission(Long userId, String dataScope)
+DataPermissionScope getUserDataPermission(Long userId)
}
SecurityLevelService --> SecurityLevelManager : "调用"
SecurityLevelService --> PermissionAuditService : "调用"
SecurityLevelService --> DataPermissionService : "调用"
```

**Diagram sources**
- [smart-permission.md](file://documentation\technical\smart-permission.md#L353-L430)

**Section sources**
- [smart-permission.md](file://documentation\technical\smart-permission.md#L353-L430)

## 前后端交互方式
### Token传递与刷新策略
前后端通过HTTP Header传递Token，采用双Token机制（访问令牌和刷新令牌）确保安全性和用户体验。

```mermaid
sequenceDiagram
participant 前端 as 前端应用
participant 后端 as 后端服务
participant Redis as Redis
前端->>后端 : 请求 /api/auth/login
后端-->>前端 : 返回 {accessToken, refreshToken}
前端->>后端 : 请求 /api/user/profile
后端->>后端 : validateToken(accessToken)
后端-->>前端 : 返回用户信息
前端->>后端 : 请求 /api/user/profile (accessToken过期)
后端-->>前端 : 401 Unauthorized
前端->>后端 : 请求 /api/auth/refresh
后端->>后端 : validateToken(refreshToken)
后端->>后端 : blacklistToken(oldRefreshToken)
后端-->>前端 : 返回 {newAccessToken, newRefreshToken}
前端->>后端 : 重试 /api/user/profile
后端-->>前端 : 返回用户信息
```

**Diagram sources**
- [AuthServiceImpl.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\service\impl\AuthServiceImpl.java#L176-L232)

### Token失效策略
系统实现了多层次的Token失效策略，包括黑名单机制、会话管理和自动过期。

```mermaid
flowchart TD
A[Token失效] --> B{失效原因}
B --> C[用户登出]
C --> D[调用logout接口]
D --> E[将Token加入Redis黑名单]
E --> F[从用户会话中移除]
B --> G[刷新令牌]
G --> H[旧Token加入黑名单]
H --> I[生成新Token]
B --> J[令牌过期]
J --> K[JWT过期时间检查]
K --> L[自动失效]
B --> M[管理员强制下线]
M --> N[调用forceLogoutUser]
N --> O[加入黑名单并清理会话]
```

**Diagram sources**
- [AuthServiceImpl.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\service\impl\AuthServiceImpl.java#L250-L268)
- [AuthManager.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\manager\AuthManager.java#L416-L438)

**Section sources**
- [AuthServiceImpl.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\service\impl\AuthServiceImpl.java#L250-L268)
- [AuthManager.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\manager\AuthManager.java#L416-L438)

## 自定义拦截器与权限注解
### 自定义拦截器实现
系统通过自定义拦截器实现数据权限控制，确保用户只能访问其权限范围内的数据。

```mermaid
classDiagram
class DataPermissionInterceptor {
+DataPermissionService dataPermissionService
+void beforeQuery(Executor, MappedStatement, Object, RowBounds, ResultHandler, BoundSql)
+String buildPermissionSql(String, DataPermissionScope)
}
class DataPermissionService {
+DataPermissionScope getUserDataPermission(Long userId)
}
DataPermissionInterceptor --> DataPermissionService : "依赖"
```

**Diagram sources**
- [smart-permission.md](file://documentation\technical\smart-permission.md#L902-L953)

### 权限注解使用方法
系统提供了丰富的权限注解，如`@SaCheckLogin`、`@SaCheckPermission`等，简化了权限控制的实现。

```mermaid
classDiagram
class SecurityPermissionAspect {
+Object checkSecurityLevel(ProceedingJoinPoint, SecurityLevel)
+Object checkDataPermission(ProceedingJoinPoint, DataPermission)
-int getUserSecurityLevel(Long userId)
-boolean hasPermission(Long userId, String permission)
-boolean hasDataPermission(Long userId, String dataType, Object dataId)
}
class SecurityLevel {
+int value()
+String[] permissions()
}
class DataPermission {
+String value()
}
SecurityPermissionAspect --> SecurityLevel : "使用"
SecurityPermissionAspect --> DataPermission : "使用"
```

**Diagram sources**
- [smart-permission.md](file://documentation\03-业务模块\智能视频\02-安全级别详细设计.md#L622-L701)

**Section sources**
- [smart-permission.md](file://documentation\technical\smart-permission.md#L902-L953)
- [smart-permission.md](file://documentation\03-业务模块\智能视频\02-安全级别详细设计.md#L622-L701)

## 多端登录与单点登录
### 多端登录控制
系统通过`AuthManager`的并发登录控制功能，限制每个用户最多3个并发会话。

```mermaid
flowchart TD
A[用户登录] --> B{会话数 >= 3?}
B --> |是| C[移除最旧会话]
C --> D[旧Token加入黑名单]
D --> E[清理Redis和数据库会话]
E --> F[创建新会话]
B --> |否| F
F --> G[添加会话到Redis]
G --> H[持久化到数据库]
H --> I[登录成功]
```

**Diagram sources**
- [AuthManager.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\manager\AuthManager.java#L104-L123)

### 单点登录（SSO）实现
虽然当前系统主要基于JWT实现无状态认证，但可以通过中心化的会话管理和Token黑名单机制来实现类似SSO的功能。

```mermaid
sequenceDiagram
participant ClientA as 客户端A
participant ClientB as 客户端B
participant AuthService as AuthServiceImpl
participant AuthManager as AuthManager
participant Redis as Redis
ClientA->>AuthService : 登录
AuthService->>AuthManager : manageUserSession
AuthManager->>Redis : 存储会话
AuthService-->>ClientA : 返回Token
ClientB->>AuthService : 登录
AuthService->>AuthManager : manageUserSession
AuthManager->>Redis : 检查会话数
AuthManager->>Redis : 移除旧会话
AuthManager->>Redis : 存储新会话
AuthService-->>ClientB : 返回新Token
ClientA->>AuthService : 使用旧Token请求
AuthService->>AuthManager : isTokenBlacklisted
AuthManager-->>AuthService : Token已失效
AuthService-->>ClientA : 401 Unauthorized
```

**Diagram sources**
- [AuthManager.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\manager\AuthManager.java#L98-L142)

**Section sources**
- [AuthManager.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\manager\AuthManager.java#L98-L142)

## 临时授权实现
### 临时权限申请流程
系统支持临时权限的申请和审批，满足特殊场景下的权限需求。

```mermaid
sequenceDiagram
participant 用户 as 用户
participant 审批系统 as 审批系统
participant 权限服务 as 权限服务
participant 数据库 as 数据库
用户->>审批系统 : 提交临时权限申请
审批系统->>权限服务 : 调用submitTemporaryApplication
权限服务->>数据库 : 记录申请记录
数据库-->>权限服务 : 操作结果
权限服务-->>审批系统 : 申请成功
审批系统-->>用户 : 申请已提交
审批系统->>审批人 : 通知审批
审批人->>审批系统 : 审批通过
审批系统->>权限服务 : 调用grantTemporaryPermission
权限服务->>数据库 : 授予临时权限
数据库-->>权限服务 : 操作结果
权限服务-->>审批系统 : 授予成功
审批系统-->>用户 : 权限已授予
```

**Section sources**
- [AccessApprovalController.java](file://restful_refactor_backup_20251202_014224\microservices_ioedream-access-service_src_main_java_net_lab1024_sa_access_approval_controller_AccessApprovalController.java#L58-L66)

## 常见问题解决方案
### Token过期处理
前端应实现Token自动刷新机制，在收到401响应后自动使用刷新令牌获取新的访问令牌。

```mermaid
flowchart TD
A[发起请求] --> B{响应状态码}
B --> |200| C[处理成功响应]
B --> |401| D[检查是否有刷新令牌]
D --> |有| E[调用刷新接口]
E --> F{刷新成功?}
F --> |是| G[更新本地Token]
G --> H[重试原请求]
H --> B
F --> |否| I[跳转到登录页]
D --> |无| I
```

### 并发请求认证失败
为避免并发请求因Token刷新导致的认证失败，应使用请求队列或锁机制确保Token刷新的原子性。

```mermaid
classDiagram
class TokenRefreshManager {
-String refreshToken
-AtomicBoolean refreshing
-Queue~Request~ requestQueue
+synchronized refreshToken()
+enqueueRequest(Request)
+dequeueAndRetryAll()
}
class Request {
+String url
+String method
+Object data
+Promise~Response~ promise
}
TokenRefreshManager --> Request : "包含"
```

**Section sources**
- [AuthServiceImpl.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\service\impl\AuthServiceImpl.java#L176-L232)

## 性能优化建议
### 缓存策略
采用多级缓存策略，结合Redis和本地缓存，减少数据库访问。

```mermaid
flowchart TD
A[权限校验] --> B{本地缓存有?}
B --> |是| C[返回缓存结果]
B --> |否| D{Redis有?}
D --> |是| E[返回Redis结果]
E --> F[回填本地缓存]
D --> |否| G[查询数据库]
G --> H[回填Redis和本地缓存]
H --> I[返回结果]
```

### 数据库优化
对`t_user_session`表建立适当的索引，如`user_id`、`token`和`status`字段的组合索引，以提高查询性能。

```sql
CREATE INDEX idx_user_token_status ON t_user_session (user_id, token, status);
```

**Section sources**
- [UserSessionEntity.java](file://microservices\microservices-common\src\main\java\net\lab1024\sa\common\auth\domain\entity\UserSessionEntity.java#L31-L108)
- [t_user_session_table.sql](file://database-scripts\common-service\t_user_session_table.sql#L1-L37)