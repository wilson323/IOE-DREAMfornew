---
alwaysApply: true
---
# ğŸ—ï¸ IOE-DREAMä¼ä¸šçº§æ¶æ„é‡æ„å®Œæ•´æ–¹æ¡ˆ V3.0

**æ–‡æ¡£ç‰ˆæœ¬**: v3.0.0-COMPLETE  
**åˆ¶å®šæ—¥æœŸ**: 2025-12-18  
**è¦†ç›–èŒƒå›´**: 100%å¾®æœåŠ¡ + 100%ä¸šåŠ¡åœºæ™¯  
**æ¶æ„ç›®æ ‡**: ä¼ä¸šçº§ + é«˜æ€§èƒ½ + ä½å†…å­˜ + å¯æ‰©å±• + å…¨åœºæ™¯è¦†ç›–  
**é€‚ç”¨å¯¹è±¡**: æ¶æ„å¸ˆã€æŠ€æœ¯ç»ç†ã€å¼€å‘å›¢é˜Ÿ

---

## ğŸ“‹ **æ–‡æ¡£æ‘˜è¦**

æœ¬æ–¹æ¡ˆæ˜¯IOE-DREAMæ™ºæ…§å›­åŒºä¸€å¡é€šç®¡ç†å¹³å°çš„**å®Œæ•´ä¼ä¸šçº§æ¶æ„é‡æ„æ–¹æ¡ˆ**ï¼Œæ¶µç›–ï¼š

- âœ… **11ä¸ªå¾®æœåŠ¡**å®Œæ•´é‡æ„è®¾è®¡
- âœ… **10ä¸ªå…¬å…±ç»„ä»¶**ä¼ä¸šçº§æ ‡å‡†å®ç°
- âœ… **5å¤§è®¾è®¡æ¨¡å¼**å……åˆ†åº”ç”¨ï¼ˆç­–ç•¥/å·¥å‚/è£…é¥°å™¨/æ¨¡æ¿æ–¹æ³•/ä¾èµ–å€’ç½®ï¼‰
- âœ… **å…¨ä¸šåŠ¡åœºæ™¯**100%è¦†ç›–ï¼ˆé—¨ç¦/è€ƒå‹¤/æ¶ˆè´¹/è®¿å®¢/è§†é¢‘/OAç­‰ï¼‰
- âœ… **5ç§è®¾å¤‡äº¤äº’æ¨¡å¼**â­ çœŸå®ä¸šåŠ¡åœºæ™¯ï¼ˆè¾¹ç¼˜è®¡ç®—/ä¸­å¿ƒéªŒè¯/æ··åˆæ¨¡å¼ï¼‰
- âœ… **æ€§èƒ½ä¼˜åŒ–**æ¶æ„ï¼ˆè¿æ¥æ± /å¯¹è±¡æ± /å¤šçº§ç¼“å­˜/å¼‚æ­¥åŒ–ï¼‰
- âœ… **10å‘¨å®æ–½è·¯çº¿å›¾**ï¼ˆ3-5äººå›¢é˜Ÿï¼‰

---

## ğŸ”‘ **æ ¸å¿ƒæ¶æ„ç†å¿µ**

åŸºäº**çœŸå®è®¾å¤‡äº¤äº’æ¨¡å¼**çš„åˆ†å±‚æ¶æ„è®¾è®¡ï¼š

1. **è¾¹ç¼˜æ™ºèƒ½ä¼˜å…ˆ**: é—¨ç¦è®¾å¤‡ç«¯å®ŒæˆéªŒè¯ï¼Œé™ä½æœåŠ¡å™¨å‹åŠ›
2. **æ•°æ®å®‰å…¨ç¬¬ä¸€**: æ¶ˆè´¹è®¾å¤‡ä¸å­˜ä½™é¢ï¼Œé˜²æ­¢ç¯¡æ”¹
3. **ç¦»çº¿èƒ½åŠ›ä¿éšœ**: å…³é”®åœºæ™¯æ”¯æŒç¦»çº¿å·¥ä½œ
4. **ä¸­å¿ƒè®¡ç®—ç²¾å‡†**: è€ƒå‹¤æ’ç­+è§„åˆ™åœ¨è½¯ä»¶ç«¯ï¼Œçµæ´»å¯æ§
5. **AIè¾¹ç¼˜æ¨ç†**: è§†é¢‘è®¾å¤‡æœ¬åœ°è¯†åˆ«ï¼Œåªä¸Šä¼ ç»“æœï¼ŒåŸºç¡€è§†é¢‘åŠŸèƒ½å¦‚äº‘å°ç­‰åŠŸèƒ½éœ€å®Œå–„ï¼Œå®æ—¶æŸ¥çœ‹è§†é¢‘ç­‰ç­‰


## ğŸ¯ **ä¸€ã€å®Œæ•´å¾®æœåŠ¡æ¶æ„å…¨æ™¯å›¾**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    IOE-DREAM ä¼ä¸šçº§å¾®æœåŠ¡æ¶æ„å…¨æ™¯å›¾                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ æ¥å…¥å±‚ (Gateway Layer) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ioedream-gateway-service (8080)                                 â”‚
â”‚  âœ“ ç»Ÿä¸€è·¯ç”±   âœ“ è®¤è¯é‰´æƒ   âœ“ é™æµç†”æ–­   âœ“ åè®®è½¬æ¢              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ä¸šåŠ¡æœåŠ¡å±‚ (Business Layer) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€ æ ¸å¿ƒä¸šåŠ¡æœåŠ¡ â”€â”€â”€â”  â”Œâ”€â”€â”€ æ‰©å±•ä¸šåŠ¡æœåŠ¡ â”€â”€â”€â”                â”‚
â”‚  â”‚                     â”‚  â”‚                     â”‚                â”‚
â”‚  â”‚ access-service      â”‚  â”‚ consume-service     â”‚                â”‚
â”‚  â”‚ (8090) é—¨ç¦ç®¡ç†     â”‚  â”‚ (8094) æ¶ˆè´¹ç®¡ç†     â”‚                â”‚
â”‚  â”‚                     â”‚  â”‚                     â”‚                â”‚
â”‚  â”‚ attendance-service  â”‚  â”‚ visitor-service     â”‚                â”‚
â”‚  â”‚ (8091) è€ƒå‹¤ç®¡ç†     â”‚  â”‚ (8095) è®¿å®¢ç®¡ç†     â”‚                â”‚
â”‚  â”‚                     â”‚  â”‚                     â”‚                â”‚
â”‚  â”‚ video-service       â”‚  â”‚ oa-service          â”‚                â”‚
â”‚  â”‚ (8092) è§†é¢‘ç›‘æ§     â”‚  â”‚ (8089) OAåŠå…¬       â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ èƒ½åŠ›æœåŠ¡å±‚ (Capability Layer) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                   â”‚
â”‚  biometric-service (8096) ğŸ†•  â”œâ”€ ç”Ÿç‰©æ¨¡æ¿ç®¡ç†æœåŠ¡ï¼ˆä»…å­˜å‚¨+ä¸‹å‘ï¼‰        â”‚
â”‚  device-comm-service (8087)   â”œâ”€ è®¾å¤‡é€šè®¯æœåŠ¡                    â”‚
â”‚  common-service (8088)        â”œâ”€ å…¬å…±ä¸šåŠ¡æœåŠ¡                    â”‚
â”‚  database-service (8093)      â”œâ”€ æ•°æ®åº“ç®¡ç†æœåŠ¡                  â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ å…¬å…±ç»„ä»¶å±‚ (Common Components) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€ ä¸šåŠ¡ç»„ä»¶ â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€ æŠ€æœ¯ç»„ä»¶ â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚                     â”‚  â”‚                      â”‚               â”‚
â”‚  â”‚ common-business     â”‚  â”‚ common-core          â”‚               â”‚
â”‚  â”‚ common-permission   â”‚  â”‚ common-security      â”‚               â”‚
â”‚  â”‚ common-workflow     â”‚  â”‚ common-cache         â”‚               â”‚
â”‚  â”‚ common-export       â”‚  â”‚ common-data          â”‚               â”‚
â”‚  â”‚                     â”‚  â”‚ common-monitor       â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ åŸºç¡€è®¾æ–½å±‚ (Infrastructure) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                   â”‚
â”‚  Nacos (æ³¨å†Œä¸­å¿ƒ)   MySQL (æ•°æ®åº“)    Redis (ç¼“å­˜)              â”‚
â”‚  RabbitMQ (æ¶ˆæ¯)    Prometheus (ç›‘æ§)  Zipkin (é“¾è·¯è¿½è¸ª)        â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸš€ **äºŒã€å®Œæ•´çš„11ä¸ªå¾®æœåŠ¡é‡æ„è®¾è®¡**

### **2.1 ioedream-gateway-service (8080) - APIç½‘å…³**

#### **èŒè´£å®šä½**
- ç»Ÿä¸€å…¥å£ï¼šæ‰€æœ‰å¤–éƒ¨è¯·æ±‚çš„å”¯ä¸€å…¥å£
- è·¯ç”±è½¬å‘ï¼šæ™ºèƒ½è·¯ç”±åˆ°åç«¯11ä¸ªå¾®æœåŠ¡
- è®¤è¯é‰´æƒï¼šTokenéªŒè¯ã€ç”¨æˆ·ä¿¡æ¯ä¼ é€’
- é™æµç†”æ–­ï¼šResilience4jä¿æŠ¤åç«¯æœåŠ¡
- åè®®è½¬æ¢ï¼šHTTP/HTTPS/WebSocketåè®®é€‚é…

#### **æ ¸å¿ƒè®¾è®¡**

**1. è·¯ç”±ç­–ç•¥é…ç½®**
```yaml
# application-routes.yml
spring:
  cloud:
    gateway:
      routes:
        - id: access-service
          uri: lb://ioedream-access-service
          predicates:
            - Path=/api/v1/access/**
          filters:
            - StripPrefix=2
            - name: CircuitBreaker
              args:
                name: accessCB
                fallbackUri: forward:/fallback/access
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 100
                redis-rate-limiter.burstCapacity: 200
        
        - id: biometric-service  # ğŸ†• æ–°å¢
          uri: lb://ioedream-biometric-service
          predicates:
            - Path=/api/v1/biometric/**
          filters:
            - StripPrefix=2
        
        # ... å…¶ä»–9ä¸ªæœåŠ¡è·¯ç”±é…ç½®
```

**2. å…¨å±€è®¤è¯è¿‡æ»¤å™¨**
```java
@Component
@Order(1)
public class GlobalAuthenticationFilter implements GlobalFilter {
    
    @Resource
    private TokenValidator tokenValidator;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String path = request.getPath().value();
        
        // ç™½åå•è·¯å¾„
        if (isWhiteList(path)) {
            return chain.filter(exchange);
        }
        
        // TokenéªŒè¯
        String token = extractToken(request);
        if (!tokenValidator.validate(token)) {
            return unauthorized(exchange);
        }
        
        // ç”¨æˆ·ä¿¡æ¯ä¼ é€’
        UserContext context = tokenValidator.getUserContext(token);
        ServerHttpRequest newRequest = request.mutate()
            .header("X-User-Id", context.getUserId().toString())
            .header("X-User-Name", context.getUserName())
            .header("X-User-Roles", context.getRoles())
            .header("X-Department-Id", context.getDepartmentId().toString())
            .build();
        
        return chain.filter(exchange.mutate().request(newRequest).build());
    }
}
```

**3. é™æµé…ç½®**
```java
@Configuration
public class RateLimitConfiguration {
    
    @Bean
    public KeyResolver userKeyResolver() {
        return exchange -> {
            String userId = exchange.getRequest().getHeaders()
                .getFirst("X-User-Id");
            return Mono.just(userId != null ? userId : "anonymous");
        };
    }
    
    @Bean
    public RedisRateLimiter redisRateLimiter() {
        return new RedisRateLimiter(
            100,  // replenishRate: æ¯ç§’äº§ç”Ÿ100ä¸ªä»¤ç‰Œ
            200   // burstCapacity: æœ€å¤§çªå‘200ä¸ªè¯·æ±‚
        );
    }
}
```

#### **æ€§èƒ½æŒ‡æ ‡**
- å“åº”æ—¶é—´: P99 < 50ms
- å¹¶å‘èƒ½åŠ›: 10000 QPS
- å¯ç”¨æ€§: 99.99%

---

### **2.2 ioedream-access-service (8090) - é—¨ç¦ç®¡ç†æœåŠ¡**

#### **èŒè´£å®šä½**
- æƒé™ç®¡ç†ï¼šç”¨æˆ·åŒºåŸŸæƒé™é…ç½®
- é€šè¡Œæ§åˆ¶ï¼šå¤šæ¨¡æ€ç”Ÿç‰©è¯†åˆ«éªŒè¯
- è®°å½•ç®¡ç†ï¼šé€šè¡Œè®°å½•å­˜å‚¨ä¸åˆ†æ
- å‘Šè­¦è”åŠ¨ï¼šå¼‚å¸¸äº‹ä»¶å®æ—¶å‘Šè­¦

#### **â­ è®¾å¤‡äº¤äº’æ¨¡å¼ï¼šè¾¹ç¼˜è‡ªä¸»éªŒè¯**

```
ã€æ•°æ®ä¸‹å‘ã€‘è½¯ä»¶ â†’ è®¾å¤‡
  â”œâ”€ äººå‘˜ä¿¡æ¯ï¼ˆå§“åã€å·¥å·ï¼‰
  â”œâ”€ ç”Ÿç‰©æ¨¡æ¿ï¼ˆäººè„¸/æŒ‡çº¹ç‰¹å¾å‘é‡ï¼‰
  â””â”€ æƒé™æ•°æ®ï¼ˆæ—¶é—´æ®µã€åŒºåŸŸã€æœ‰æ•ˆæœŸï¼‰

ã€å®æ—¶é€šè¡Œã€‘è®¾å¤‡ç«¯å®Œå…¨è‡ªä¸»
  â”œâ”€ æœ¬åœ°è¯†åˆ«ï¼šè®¾å¤‡å†…åµŒç®—æ³•1:Næ¯”å¯¹
  â”œâ”€ æœ¬åœ°éªŒè¯ï¼šæ£€æŸ¥æœ¬åœ°æƒé™è¡¨
  â””â”€ æœ¬åœ°æ§åˆ¶ï¼šç›´æ¥å¼€é—¨ï¼Œæ— éœ€ç­‰å¾…æœåŠ¡å™¨

ã€äº‹åä¸Šä¼ ã€‘è®¾å¤‡ â†’ è½¯ä»¶
  â””â”€ æ‰¹é‡ä¸Šä¼ é€šè¡Œè®°å½•ï¼ˆæ¯åˆ†é’Ÿæˆ–ç´¯è®¡100æ¡ï¼‰

ã€ä¼˜åŠ¿ã€‘
  âœ… ç¦»çº¿å¯ç”¨ï¼šç½‘ç»œä¸­æ–­æ—¶è®¾å¤‡ä»å¯æ­£å¸¸å·¥ä½œ
  âœ… ç§’çº§å“åº”ï¼šæ— éœ€ç­‰å¾…æœåŠ¡å™¨éªŒè¯
  âœ… é™ä½å‹åŠ›ï¼šæ¯ç§’1000æ¬¡é€šè¡Œï¼ŒæœåŠ¡å™¨åªéœ€å¤„ç†è®°å½•å­˜å‚¨

ã€æŒ‘æˆ˜ã€‘
  âš ï¸ æ•°æ®ä¸€è‡´æ€§ï¼šæƒé™å˜æ›´éœ€å®æ—¶åŒæ­¥åˆ°è®¾å¤‡
  âš ï¸ è®¾å¤‡å­˜å‚¨ï¼šå¤§å‹å›­åŒº10000+äººå‘˜ï¼Œè®¾å¤‡å­˜å‚¨æœ‰é™
```

#### **èŒè´£å®šä½**
- é€šè¡Œç®¡ç†ï¼šé—¨ç¦é€šè¡ŒéªŒè¯ä¸è®°å½•
- æƒé™ç®¡ç†ï¼šç”¨æˆ·-åŒºåŸŸæƒé™ç®¡ç†
- è®¾å¤‡è”åŠ¨ï¼šé—¨ç¦è®¾å¤‡å¼€é—¨æŒ‡ä»¤
- å®¡æ‰¹æµç¨‹ï¼šæƒé™ç”³è¯·å®¡æ‰¹
- äº‹ä»¶é€šçŸ¥ï¼šå®æ—¶é€šè¡Œäº‹ä»¶æ¨é€

#### **æ ¸å¿ƒè®¾è®¡**

**1. é¢†åŸŸæ¨¡å‹ï¼ˆDDDï¼‰**
```java
package net.lab1024.sa.access.domain;

/**
 * é€šè¡Œè®°å½•èšåˆæ ¹
 */
@Data
public class AccessRecordAggregate {
    // é€šè¡Œè®°å½•å®ä½“
    private AccessRecordEntity record;
    
    // è®¤è¯ç»“æœå€¼å¯¹è±¡
    private BiometricAuthResultVO authResult;
    
    // å…³è”åŒºåŸŸ
    private AreaEntity area;
    
    // å…³è”è®¾å¤‡
    private DeviceEntity device;
    
    // å…³è”ç”¨æˆ·
    private UserEntity user;
    
    // æƒé™ç­–ç•¥åˆ—è¡¨
    private List<PermissionPolicyVO> policies;
    
    /**
     * èšåˆæ ¹è¡Œä¸º: éªŒè¯é€šè¡Œæƒé™
     */
    public boolean validateAccessPermission() {
        return policies.stream()
            .anyMatch(policy -> policy.allows(user, area, LocalDateTime.now()));
    }
}
```

**2. ç­–ç•¥æ¨¡å¼ï¼šæƒé™è®¡ç®—**
```java
public interface IAccessPermissionStrategy {
    boolean hasPermission(AccessRequest request);
    int getPriority();
}

@Component
@StrategyMarker(type = "TIME_BASED")
public class TimeBasedAccessStrategy implements IAccessPermissionStrategy {
    
    @Override
    public boolean hasPermission(AccessRequest request) {
        UserAreaPermissionEntity permission = permissionDao.selectByUserAndArea(
            request.getUserId(), request.getAreaId()
        );
        
        if (permission == null) return false;
        
        // æ—¶é—´æ®µéªŒè¯
        LocalTime now = LocalTime.now();
        List<TimeSlot> timeSlots = JSON.parseArray(
            permission.getAllowedTimeSlots(), TimeSlot.class
        );
        
        return timeSlots.stream()
            .anyMatch(slot -> slot.contains(now));
    }
    
    @Override
    public int getPriority() {
        return 100;
    }
}

@Component
@StrategyMarker(type = "GEOFENCE")
public class GeofenceAccessStrategy implements IAccessPermissionStrategy {
    
    @Override
    public boolean hasPermission(AccessRequest request) {
        AreaEntity area = areaDao.selectById(request.getAreaId());
        if (area.getGeofenceData() == null) return true;
        
        // GPSä½ç½®éªŒè¯
        Geofence geofence = JSON.parseObject(
            area.getGeofenceData(), Geofence.class
        );
        return geofence.contains(
            request.getLatitude(), 
            request.getLongitude()
        );
    }
    
    @Override
    public int getPriority() {
        return 90;
    }
}

@Component
@StrategyMarker(type = "ROLE_BASED")
public class RoleBasedAccessStrategy implements IAccessPermissionStrategy {
    
    @Override
    public boolean hasPermission(AccessRequest request) {
        AreaEntity area = areaDao.selectById(request.getAreaId());
        UserEntity user = userDao.selectById(request.getUserId());
        
        // è§’è‰²åŒ¹é…éªŒè¯
        List<String> allowedRoles = JSON.parseArray(
            area.getAllowedRoles(), String.class
        );
        List<String> userRoles = getUserRoles(user.getUserId());
        
        return userRoles.stream()
            .anyMatch(allowedRoles::contains);
    }
    
    @Override
    public int getPriority() {
        return 80;
    }
}
```

**3. æ¨¡æ¿æ–¹æ³•ï¼šé€šè¡Œæµç¨‹**
```java
public abstract class AbstractAccessFlowTemplate {
    
    @Resource
    protected DeviceDao deviceDao;
    
    @Resource
    protected AccessRecordDao accessRecordDao;
    
    @Resource
    protected StrategyFactory<IAccessPermissionStrategy> strategyFactory;
    
    @Resource
    protected DeviceCommandService deviceCommandService;
    
    /**
     * æ¨¡æ¿æ–¹æ³•: é€šè¡Œæµç¨‹
     */
    public final AccessResult processAccess(AccessRequest request) {
        try {
            // 1. å‚æ•°æ ¡éªŒ
            validate(request);
            
            // 2. è®¾å¤‡éªŒè¯
            DeviceEntity device = validateDevice(request.getDeviceId());
            
            // 3. ç”¨æˆ·è¯†åˆ«(æŠ½è±¡æ–¹æ³• - å­ç±»å®ç°)
            UserIdentityResult identity = identifyUser(request);
            if (!identity.isSuccess()) {
                return AccessResult.denied("èº«ä»½è¯†åˆ«å¤±è´¥: " + identity.getMessage());
            }
            
            // 4. æƒé™éªŒè¯(ç­–ç•¥æ¨¡å¼)
            boolean hasPermission = checkPermission(
                identity.getUserId(), 
                request.getAreaId(), 
                request
            );
            if (!hasPermission) {
                recordFailedAccess(identity, device, "æƒé™ä¸è¶³");
                return AccessResult.denied("æƒé™ä¸è¶³");
            }
            
            // 5. å¼€é—¨æŒ‡ä»¤(æŠ½è±¡æ–¹æ³• - å­ç±»å®ç°)
            boolean opened = openDoor(device, request);
            
            // 6. è®°å½•é€šè¡Œ
            recordSuccessAccess(identity, device, request);
            
            // 7. äº‹ä»¶é€šçŸ¥(é’©å­æ–¹æ³•)
            notifyAccessEvent(identity, device, opened);
            
            return opened ? AccessResult.success() : AccessResult.failed("å¼€é—¨å¤±è´¥");
            
        } catch (Exception e) {
            log.error("[é€šè¡Œæµç¨‹å¼‚å¸¸] request={}", request, e);
            return AccessResult.error("ç³»ç»Ÿå¼‚å¸¸: " + e.getMessage());
        }
    }
    
    /**
     * æŠ½è±¡æ–¹æ³•: ç”¨æˆ·è¯†åˆ«
     */
    protected abstract UserIdentityResult identifyUser(AccessRequest request);
    
    /**
     * æŠ½è±¡æ–¹æ³•: å¼€é—¨
     */
    protected abstract boolean openDoor(DeviceEntity device, AccessRequest request);
    
    /**
     * é’©å­æ–¹æ³•: äº‹ä»¶é€šçŸ¥(å¯é€‰è¦†ç›–)
     */
    protected void notifyAccessEvent(UserIdentityResult identity, 
                                     DeviceEntity device, boolean opened) {
        // é»˜è®¤ç©ºå®ç°
    }
    
    /**
     * æƒé™éªŒè¯(ç­–ç•¥æ¨¡å¼)
     */
    private boolean checkPermission(Long userId, Long areaId, AccessRequest request) {
        List<IAccessPermissionStrategy> strategies = strategyFactory.getAll();
        
        // æŒ‰ä¼˜å…ˆçº§æ’åº
        strategies.sort(Comparator.comparingInt(
            IAccessPermissionStrategy::getPriority).reversed()
        );
        
        // ä»»ä¸€ç­–ç•¥é€šè¿‡å³å¯
        return strategies.stream()
            .anyMatch(strategy -> strategy.hasPermission(request));
    }
}
```

**4. å…·ä½“å®ç°ï¼šå¤„ç†è®¾å¤‡ä¸Šä¼ çš„é€šè¡Œè®°å½•** â­ ä¿®æ­£ä¸ºçœŸå®æ¶æ„
```java
/**
 * é—¨ç¦æœåŠ¡ - æ¥æ”¶è®¾å¤‡ä¸Šä¼ çš„é€šè¡Œè®°å½•
 * âš ï¸ æ³¨æ„ï¼šç”Ÿç‰©è¯†åˆ«ç”±è®¾å¤‡ç«¯å®Œæˆï¼Œè½¯ä»¶ç«¯åªå¤„ç†ç»“æœ
 */
@RestController
@RequestMapping("/api/v1/access")
public class AccessRecordController {
    
    @Resource
    private AccessRecordService accessRecordService;
    
    @Resource
    private WebSocketService websocketService;
    
    @Resource
    private RabbitTemplate rabbitTemplate;
    
    /**
     * æ¥æ”¶è®¾å¤‡ä¸Šä¼ çš„é€šè¡Œè®°å½•
     * â­ è®¾å¤‡ç«¯å·²å®Œæˆï¼šè¯†åˆ«+æƒé™éªŒè¯+å¼€é—¨
     * â­ è½¯ä»¶ç«¯åªéœ€ï¼šå­˜å‚¨è®°å½•+äº‹ä»¶æ¨é€+å¼‚å¸¸æ£€æµ‹
     */
    @PostMapping("/device/upload-record")
    public ResponseDTO<Void> uploadAccessRecord(
            @RequestBody @Valid AccessRecordUploadDTO uploadDTO) {
        
        // 1. ä¿å­˜é€šè¡Œè®°å½•
        AccessRecordEntity record = new AccessRecordEntity();
        record.setUserId(uploadDTO.getUserId());
        record.setDeviceId(uploadDTO.getDeviceId());
        record.setAccessTime(uploadDTO.getAccessTime());
        record.setAuthMethod(uploadDTO.getAuthMethod());  // FACE/FINGERPRINT/CARD
        record.setAuthResult(uploadDTO.getAuthResult());  // SUCCESS/FAILED
        record.setMatchScore(uploadDTO.getMatchScore());
        record.setDoorOpened(uploadDTO.getDoorOpened());
        accessRecordService.insert(record);
        
        // 2. å®æ—¶æ¨é€åˆ°ç›‘æ§å¤§å±
        AccessEvent event = AccessEvent.builder()
            .userId(record.getUserId())
            .deviceId(record.getDeviceId())
            .eventType(record.getAuthResult() == AuthResult.SUCCESS 
                ? "ACCESS_GRANTED" : "ACCESS_DENIED")
            .eventTime(record.getAccessTime())
            .build();
        websocketService.sendAccessEvent(event);
        
        // 3. å¼‚å¸¸æ£€æµ‹
        if (record.getAuthResult() == AuthResult.SUCCESS) {
            // æ£€æŸ¥æ˜¯å¦åœ¨æˆæƒæ—¶é—´å¤–é€šè¡Œ
            checkUnauthorizedTimeAccess(record);
        }
        
        // 4. è§†é¢‘è”åŠ¨ï¼ˆæˆåŠŸé€šè¡Œæ—¶å½•åƒ5åˆ†é’Ÿï¼‰
        if (record.getDoorOpened()) {
            rabbitTemplate.convertAndSend(
                "video.linkage.exchange",
                "video.record.route",
                VideoLinkageRequest.builder()
                    .deviceId(record.getDeviceId())
                    .eventType("ACCESS_GRANTED")
                    .duration(Duration.ofMinutes(5))
                    .build()
            );
        }
        
        return ResponseDTO.ok();
    }
    
    /**
     * æ£€æŸ¥éæˆæƒæ—¶é—´é€šè¡Œ
     */
    private void checkUnauthorizedTimeAccess(AccessRecordEntity record) {
        UserAreaPermissionEntity permission = 
            permissionDao.selectByUserAndArea(
                record.getUserId(), 
                record.getAreaId()
            );
        
        if (permission == null) {
            // æ— æƒé™ä½†è®¾å¤‡å…è®¸é€šè¡Œ â†’ å‘Šè­¦
            alarmService.sendAlert(
                "ç”¨æˆ·" + record.getUserId() + "åœ¨æ— æƒé™æƒ…å†µä¸‹é€šè¡Œ",
                AlarmLevel.HIGH
            );
            return;
        }
        
        LocalTime accessTime = record.getAccessTime().toLocalTime();
        boolean inAllowedTime = permission.getAllowedTimeSlots().stream()
            .anyMatch(slot -> 
                !accessTime.isBefore(slot.getStartTime()) &&
                !accessTime.isAfter(slot.getEndTime())
            );
        
        if (!inAllowedTime) {
            // éæˆæƒæ—¶é—´é€šè¡Œ â†’ å‘Šè­¦
            alarmService.sendAlert(
                "ç”¨æˆ·" + record.getUserId() + "åœ¨éæˆæƒæ—¶é—´é€šè¡Œ",
                AlarmLevel.MEDIUM
            );
        }
    }
}

/**
 * ç”Ÿç‰©æ¨¡æ¿ç®¡ç†æœåŠ¡
 * âš ï¸ æ³¨æ„ï¼šåªè´Ÿè´£ç®¡ç†æ¨¡æ¿ï¼Œä¸è´Ÿè´£è¯†åˆ«éªŒè¯
 */
@Service
public class BiometricTemplateService {
    
    @Resource
    private BiometricTemplateDao templateDao;
    
    @Resource
    private DeviceCommServiceClient deviceCommClient;
    
    /**
     * æ·»åŠ ç”Ÿç‰©æ¨¡æ¿ï¼ˆå…¥èŒæ—¶è°ƒç”¨ï¼‰
     * â­ æ ¸å¿ƒï¼šå°†æ¨¡æ¿ä¸‹å‘åˆ°æ‰€æœ‰ç›¸å…³é—¨ç¦è®¾å¤‡
     */
    public void addBiometricTemplate(BiometricTemplateAddDTO addDTO) {
        // 1. ä¿å­˜æ¨¡æ¿åˆ°æ•°æ®åº“
        BiometricTemplateEntity template = new BiometricTemplateEntity();
        template.setUserId(addDTO.getUserId());
        template.setBiometricType(addDTO.getBiometricType());  // FACE/FINGERPRINT
        template.setFeatureData(addDTO.getFeatureData());  // 512ç»´ç‰¹å¾å‘é‡
        template.setTemplateVersion("1.0");
        template.setQualityScore(addDTO.getQualityScore());
        templateDao.insert(template);
        
        // 2. æŸ¥è¯¢è¯¥ç”¨æˆ·æœ‰æƒé™çš„åŒºåŸŸ
        List<UserAreaPermissionEntity> permissions = 
            permissionDao.selectByUserId(addDTO.getUserId());
        
        // 3. æŸ¥è¯¢è¿™äº›åŒºåŸŸçš„æ‰€æœ‰é—¨ç¦è®¾å¤‡
        Set<String> deviceIds = new HashSet<>();
        for (UserAreaPermissionEntity permission : permissions) {
            List<DeviceEntity> devices = 
                deviceDao.selectByAreaIdAndType(
                    permission.getAreaId(), 
                    DeviceType.ACCESS_CONTROL
                );
            devices.forEach(d -> deviceIds.add(d.getDeviceId()));
        }
        
        // 4. å¹¶è¡Œä¸‹å‘æ¨¡æ¿åˆ°æ‰€æœ‰è®¾å¤‡ â­ å…³é”®æ“ä½œ
        List<CompletableFuture<Void>> futures = deviceIds.stream()
            .map(deviceId -> CompletableFuture.runAsync(() -> {
                deviceCommClient.syncBiometricTemplate(
                    deviceId,
                    BiometricTemplateSyncDTO.builder()
                        .userId(addDTO.getUserId())
                        .userName(addDTO.getUserName())
                        .biometricType(addDTO.getBiometricType())
                        .featureData(addDTO.getFeatureData())
                        .build()
                );
            }))
            .collect(Collectors.toList());
        
        // 5. ç­‰å¾…æ‰€æœ‰ä¸‹å‘å®Œæˆ
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .join();
        
        log.info("[æ¨¡æ¿ä¸‹å‘å®Œæˆ] userId={}, deviceCount={}", 
            addDTO.getUserId(), deviceIds.size());
    }
    
    /**
     * åˆ é™¤ç”Ÿç‰©æ¨¡æ¿ï¼ˆç¦»èŒæ—¶è°ƒç”¨ï¼‰
     */
    public void deleteBiometricTemplate(Long userId, BiometricType type) {
        // 1. ä»æ•°æ®åº“åˆ é™¤
        templateDao.deleteByUserIdAndType(userId, type);
        
        // 2. ä»æ‰€æœ‰è®¾å¤‡åˆ é™¤ â­ é˜²æ­¢ç¦»èŒäººå‘˜ä»å¯é€šè¡Œ
        List<DeviceEntity> allAccessDevices = 
            deviceDao.selectByType(DeviceType.ACCESS_CONTROL);
        
        allAccessDevices.parallelStream().forEach(device -> {
            deviceCommClient.deleteBiometricTemplate(
                device.getDeviceId(),
                userId
            );
        });
        
        log.info("[æ¨¡æ¿åˆ é™¤å®Œæˆ] userId={}, deviceCount={}", 
            userId, allAccessDevices.size());
    }
}
```

**5. å…·ä½“å®ç°ï¼šå¡ç‰‡é€šè¡Œ**
```java
@Component("cardAccessFlow")
public class CardAccessFlow extends AbstractAccessFlowTemplate {
    
    @Resource
    private CardService cardService;
    
    @Override
    protected UserIdentityResult identifyUser(AccessRequest request) {
        // å¡å·è¯†åˆ«
        String cardNo = request.getCardNo();
        CardEntity card = cardService.getByCardNo(cardNo);
        
        if (card == null) {
            return UserIdentityResult.failed("å¡ç‰‡ä¸å­˜åœ¨");
        }
        
        if (card.getStatus() != CardStatus.ACTIVE) {
            return UserIdentityResult.failed("å¡ç‰‡å·²åœç”¨");
        }
        
        return UserIdentityResult.success(
            card.getUserId(),
            card.getUserName(),
            100.0  // å¡ç‰‡è¯†åˆ«ç½®ä¿¡åº¦100%
        );
    }
    
    @Override
    protected boolean openDoor(DeviceEntity device, AccessRequest request) {
        // ä¸ç”Ÿç‰©è¯†åˆ«æµç¨‹ç›¸åŒ
        return super.openDoor(device, request);
    }
}
```

#### **æ€§èƒ½ä¼˜åŒ–**

**1. ç¼“å­˜ç­–ç•¥**
```java
@Service
public class AccessPermissionCacheService {
    
    @Resource
    private UnifiedCacheManager cacheManager;
    
    /**
     * å¤šçº§ç¼“å­˜è·å–æƒé™
     */
    public UserAreaPermissionEntity getPermission(Long userId, Long areaId) {
        String cacheKey = "access:permission:" + userId + ":" + areaId;
        
        return cacheManager.get(
            cacheKey,
            UserAreaPermissionEntity.class,
            () -> permissionDao.selectByUserAndArea(userId, areaId)
        );
    }
}
```

**2. æ€§èƒ½æŒ‡æ ‡**
- é€šè¡ŒéªŒè¯: P99 < 100ms
- å¼€é—¨å“åº”: P99 < 200ms
- å¹¶å‘èƒ½åŠ›: 5000 TPS

---

### **2.3 ioedream-biometric-service (8096) - ç”Ÿç‰©æ¨¡æ¿ç®¡ç†æœåŠ¡ ğŸ†•**

#### **èŒè´£å®šä½** â­ ä¿®æ­£ä¸ºçœŸå®æ¶æ„
- æ¨¡æ¿ç®¡ç†ï¼šç”Ÿç‰©ç‰¹å¾æ¨¡æ¿CRUD
- è®¾å¤‡åŒæ­¥ï¼šâ­ æ¨¡æ¿ä¸‹å‘åˆ°è¾¹ç¼˜è®¾å¤‡ï¼ˆæ ¸å¿ƒèŒè´£ï¼‰
- æƒé™è”åŠ¨ï¼šâ­ æ ¹æ®ç”¨æˆ·æƒé™æ™ºèƒ½åŒæ­¥åˆ°ç›¸å…³è®¾å¤‡
- æ¨¡æ¿å‹ç¼©ï¼šç‰¹å¾å‘é‡å‹ç¼©å‚¨å­˜
- ç‰ˆæœ¬ç®¡ç†ï¼šæ¨¡æ¿æ›´æ–°å†å²ç®¡ç†

#### **âš ï¸ é‡è¦è¯´æ˜**
```
â“ è¯¥æœåŠ¡è´Ÿè´£ç”Ÿç‰©è¯†åˆ«å—ï¼Ÿ
âœ–ï¸ ä¸ï¼ç”Ÿç‰©è¯†åˆ«ç”±è®¾å¤‡ç«¯å®Œæˆ

â“ é‚£è¯¥æœåŠ¡åšä»€ä¹ˆï¼Ÿ
âœ… åªç®¡ç†æ¨¡æ¿æ•°æ®ï¼Œå¹¶ä¸‹å‘ç»™è®¾å¤‡

ã€æ­£ç¡®çš„æ¶æ„æµç¨‹ã€‘

1. äººå‘˜å…¥èŒæ—¶ï¼š
   ç”¨æˆ· â†’ ä¸Šä¼ äººè„¸ç…§ç‰‡ â†’ biometric-service
   biometric-service â†’ æå–512ç»´ç‰¹å¾å‘é‡ â†’ å­˜å…¥æ•°æ®åº“
   biometric-service â†’ æŸ¥è¯¢ç”¨æˆ·æœ‰æƒé™çš„åŒºåŸŸ â†’ æ‰¾å‡ºæ‰€æœ‰ç›¸å…³é—¨ç¦è®¾å¤‡
   biometric-service â†’ ä¸‹å‘æ¨¡æ¿åˆ°è¿™äº›è®¾å¤‡ â­ æ ¸å¿ƒ

2. å®æ—¶é€šè¡Œæ—¶ï¼š
   è®¾å¤‡ â†’ é‡‡é›†äººè„¸å›¾åƒ â†’ è®¾å¤‡å†…åµŒç®—æ³•æå–ç‰¹å¾
   è®¾å¤‡ â†’ ä¸æœ¬åœ°å­˜å‚¨çš„6a21æ¿1:Næ¯”å¯¹ â­ å…¨éƒ¨åœ¨è®¾å¤‡ç«¯
   è®¾å¤‡ â†’ åŒ¹é…æˆåŠŸ â†’ æ£€æŸ¥æœ¬åœ°æƒé™è¡¨ â†’ å¼€é—¨
   è®¾å¤‡ â†’ æ‰¹é‡ä¸Šä¼ é€šè¡Œè®°å½•åˆ°è½¯ä»¶

3. äººå‘˜ç¦»èŒæ—¶ï¼š
   biometric-service â†’ ä»æ•°æ®åº“åˆ é™¤æ¨¡æ¿
   biometric-service â†’ ä»æ‰€æœ‰è®¾å¤‡åˆ é™¤æ¨¡æ¿ â­ é˜²æ­¢ç¦»èŒäººå‘˜ä»å¯é€šè¡Œ
```

#### **æ ¸å¿ƒè®¾è®¡**

**1. ç‰¹å¾æå–æœåŠ¡** â­ ä¿®æ­£ï¼šåªç”¨äºå…¥èŒæ—¶å¤„ç†ä¸Šä¼ çš„ç…§ç‰‡
```java
/**
 * ç”Ÿç‰©ç‰¹å¾æå–æœåŠ¡
 * âš ï¸ æ³¨æ„ï¼šåªåœ¨ç”¨æˆ·å…¥èŒ/æ›´æ–°æ¨¡æ¿æ—¶è°ƒç”¨ï¼Œä¸ç”¨äºå®æ—¶è¯†åˆ«
 */
@Service
public class BiometricFeatureExtractionService {
    
    @Resource
    private FaceNetModel faceNetModel;  // æ·±åº¦å­¦ä¹ æ¨¡å‹
    
    @Resource
    private FingerprintExtractor fingerprintExtractor;
    
    /**
     * æå–äººè„¸ç‰¹å¾
     * â­ åœºæ™¯ï¼šç”¨æˆ·ä¸Šä¼ äººè„¸ç…§ç‰‡æ—¶ï¼Œè½¯ä»¶ç«¯æå–ç‰¹å¾å‘é‡
     */
    public FeatureVector extractFaceFeature(MultipartFile photo) {
        // 1. è¯»å–å›¾åƒ
        Mat image = readImageFromFile(photo);
        
        // 2. äººè„¸æ£€æµ‹
        List<Rect> faces = detectFaces(image);
        if (faces.isEmpty()) {
            throw new BusinessException("å›¾ç‰‡ä¸­æœªæ£€æµ‹åˆ°äººè„¸");
        }
        if (faces.size() > 1) {
            throw new BusinessException("å›¾ç‰‡ä¸­æ£€æµ‹åˆ°å¤šä¸ªäººè„¸ï¼Œè¯·ä½¿ç”¨å•äººç…§ç‰‡");
        }
        
        // 3. äººè„¸å¯¹é½
        Mat alignedFace = alignFace(image, faces.get(0));
        
        // 4. ç‰¹å¾æå–(FaceNet 512ç»´å‘é‡)
        float[] embeddings = faceNetModel.extract(alignedFace);
        
        // 5. è´¨é‡æ£€æµ‹
        double qualityScore = assessQuality(alignedFace);
        if (qualityScore < 0.7) {
            throw new BusinessException("ç…§ç‰‡è´¨é‡å¤ªä½ï¼Œè¯·é‡æ–°æ‹æ‘„ï¼ˆå…‰çº¿å……è¶³ã€æ­£é¢ã€æ— é®æŒ¡ï¼‰");
        }
        
        return FeatureVector.builder()
            .biometricType(BiometricType.FACE)
            .dimension(512)
            .data(embeddings)
            .qualityScore(qualityScore)
            .build();
    }
    
    /**
     * æå–æŒ‡çº¹ç‰¹å¾
     */
    public FeatureVector extractFingerprintFeature(MultipartFile fingerprintImage) {
        Mat image = readImageFromFile(fingerprintImage);
        
        // æå–ç»†èŠ‚ç‚¹(Minutiae)
        List<Minutia> minutiae = fingerprintExtractor.extract(image);
        
        if (minutiae.size() < 12) {
            throw new BusinessException("æŒ‡çº¹ç‰¹å¾ç‚¹è¿‡å°‘ï¼Œè¯·é‡æ–°é‡‡é›†");
        }
        
        return FeatureVector.builder()
            .biometricType(BiometricType.FINGERPRINT)
            .dimension(minutiae.size() * 4)
            .data(serializeMinutiae(minutiae))
            .qualityScore(calculateFingerprintQuality(image))
            .build();
    }
}
```

**2. æ¨¡æ¿åŒæ­¥æœåŠ¡** â­ æ ¸å¿ƒæœåŠ¡
```java
@Service
public class BiometricTemplateSyncService {
    
    @Resource
    private BiometricTemplateDao templateDao;
    
    @Resource
    private UserAreaPermissionDao permissionDao;
    
    @Resource
    private DeviceDao deviceDao;
    
    @Resource
    private DeviceCommServiceClient deviceCommClient;
    
    /**
     * æ·»åŠ ç”Ÿç‰©æ¨¡æ¿ï¼ˆäººå‘˜å…¥èŒï¼‰
     * â­ æ ¸å¿ƒæµç¨‹ï¼šå­˜å‚¨æ¨¡æ¿ + æ™ºèƒ½ä¸‹å‘åˆ°ç›¸å…³è®¾å¤‡
     */
    @Transactional(rollbackFor = Exception.class)
    public ResponseDTO<Void> addBiometricTemplate(BiometricTemplateAddDTO addDTO) {
        // 1. ä¿å­˜æ¨¡æ¿åˆ°æ•°æ®åº“
        BiometricTemplateEntity template = new BiometricTemplateEntity();
        template.setUserId(addDTO.getUserId());
        template.setBiometricType(addDTO.getBiometricType());
        template.setFeatureData(addDTO.getFeatureVector().getData());
        template.setQualityScore(addDTO.getFeatureVector().getQualityScore());
        template.setTemplateVersion("1.0");
        templateDao.insert(template);
        
        // 2. æŸ¥è¯¢ç”¨æˆ·æœ‰æƒé™çš„åŒºåŸŸ â­
        List<UserAreaPermissionEntity> permissions = 
            permissionDao.selectByUserId(addDTO.getUserId());
        
        if (permissions.isEmpty()) {
            log.warn("[æ— éœ€åŒæ­¥] ç”¨æˆ·userId={}æ— ä»»ä½•é—¨ç¦æƒé™", addDTO.getUserId());
            return ResponseDTO.ok();
        }
        
        // 3. æŸ¥è¯¢è¿™äº›åŒºåŸŸçš„æ‰€æœ‰é—¨ç¦è®¾å¤‡ â­
        Set<String> targetDeviceIds = new HashSet<>();
        for (UserAreaPermissionEntity permission : permissions) {
            List<DeviceEntity> devices = deviceDao.selectByAreaIdAndType(
                permission.getAreaId(),
                DeviceType.ACCESS_CONTROL  // åªåŒæ­¥åˆ°é—¨ç¦è®¾å¤‡
            );
            devices.forEach(d -> targetDeviceIds.add(d.getDeviceId()));
        }
        
        log.info("[å¼€å§‹åŒæ­¥] userId={}, targetDeviceCount={}", 
            addDTO.getUserId(), targetDeviceIds.size());
        
        // 4. å¹¶è¡Œä¸‹å‘æ¨¡æ¿åˆ°æ‰€æœ‰ç›®æ ‡è®¾å¤‡ â­ å…³é”®æ“ä½œ
        List<CompletableFuture<SyncResult>> futures = targetDeviceIds.stream()
            .map(deviceId -> CompletableFuture.supplyAsync(() -> {
                try {
                    deviceCommClient.syncBiometricTemplate(
                        deviceId,
                        BiometricTemplateSyncDTO.builder()
                            .userId(addDTO.getUserId())
                            .userName(addDTO.getUserName())
                            .biometricType(addDTO.getBiometricType())
                            .featureData(template.getFeatureData())
                            .build()
                    );
                    return SyncResult.success(deviceId);
                } catch (Exception e) {
                    log.error("[åŒæ­¥å¤±è´¥] deviceId={}", deviceId, e);
                    return SyncResult.failed(deviceId, e.getMessage());
                }
            }, syncExecutor))  // ä½¿ç”¨ç‹¬ç«‹çº¿ç¨‹æ± 
            .collect(Collectors.toList());
        
        // 5. ç­‰å¾…æ‰€æœ‰åŒæ­¥å®Œæˆ
        List<SyncResult> results = futures.stream()
            .map(CompletableFuture::join)
            .collect(Collectors.toList());
        
        // 6. ç»Ÿè®¡ç»“æœ
        long successCount = results.stream().filter(SyncResult::isSuccess).count();
        long failedCount = results.size() - successCount;
        
        log.info("[åŒæ­¥å®Œæˆ] userId={}, æˆåŠŸ={}, å¤±è´¥={}", 
            addDTO.getUserId(), successCount, failedCount);
        
        if (failedCount > 0) {
            return ResponseDTO.userErrorParam(
                String.format("éƒ¨åˆ†è®¾å¤‡åŒæ­¥å¤±è´¥ï¼ˆ%d/%dï¼‰", 
                    failedCount, results.size())
            );
        }
        
        return ResponseDTO.ok();
    }
    
    /**
     * åˆ é™¤ç”Ÿç‰©æ¨¡æ¿ï¼ˆäººå‘˜ç¦»èŒï¼‰
     * â­ é‡è¦ï¼šå¿…é¡»ä»æ‰€æœ‰è®¾å¤‡åˆ é™¤ï¼Œé˜²æ­¢ç¦»èŒäººå‘˜ä»å¯é€šè¡Œ
     */
    @Transactional(rollbackFor = Exception.class)
    public ResponseDTO<Void> deleteBiometricTemplate(Long userId, BiometricType type) {
        // 1. ä»æ•°æ®åº“åˆ é™¤
        templateDao.deleteByUserIdAndType(userId, type);
        
        // 2. ä»æ‰€æœ‰é—¨ç¦è®¾å¤‡åˆ é™¤ â­ æ³¨æ„ï¼šæ˜¯æ‰€æœ‰è®¾å¤‡
        List<DeviceEntity> allAccessDevices = 
            deviceDao.selectByType(DeviceType.ACCESS_CONTROL);
        
        allAccessDevices.parallelStream().forEach(device -> {
            try {
                deviceCommClient.deleteBiometricTemplate(
                    device.getDeviceId(),
                    userId
                );
            } catch (Exception e) {
                log.error("[åˆ é™¤å¤±è´¥] deviceId={}, userId={}", 
                    device.getDeviceId(), userId, e);
            }
        });
        
        log.info("[æ¨¡æ¿åˆ é™¤å®Œæˆ] userId={}, è®¾å¤‡æ•°é‡={}", 
            userId, allAccessDevices.size());
        
        return ResponseDTO.ok();
    }
    
    /**
     * æƒé™å˜æ›´æ—¶ï¼ŒåŒæ­¥æ¨¡æ¿åˆ°æ–°è®¾å¤‡/ä»æ—§è®¾å¤‡åˆ é™¤
     * â­ åœºæ™¯ï¼šç”¨æˆ·æ–°å¢äº†æŸåŒºåŸŸæƒé™ï¼Œéœ€è¦åŒæ­¥æ¨¡æ¿åˆ°è¯¥åŒºåŸŸè®¾å¤‡
     */
    @Async("permissionSyncExecutor")
    public void syncOnPermissionChange(UserAreaPermissionChangeEvent event) {
        Long userId = event.getUserId();
        Long areaId = event.getAreaId();
        
        if (event.getChangeType() == ChangeType.ADDED) {
            // æ–°å¢æƒé™ â†’ åŒæ­¥æ¨¡æ¿åˆ°è¯¥åŒºåŸŸè®¾å¤‡
            List<DeviceEntity> devices = 
                deviceDao.selectByAreaIdAndType(areaId, DeviceType.ACCESS_CONTROL);
            
            BiometricTemplateEntity template = 
                templateDao.selectByUserIdAndType(userId, BiometricType.FACE);
            
            if (template != null) {
                devices.forEach(device -> {
                    deviceCommClient.syncBiometricTemplate(
                        device.getDeviceId(),
                        buildSyncDTO(template)
                    );
                });
            }
            
        } else if (event.getChangeType() == ChangeType.REMOVED) {
            // åˆ é™¤æƒé™ â†’ ä»è¯¥åŒºåŸŸè®¾å¤‡åˆ é™¤æ¨¡æ¿
            List<DeviceEntity> devices = 
                deviceDao.selectByAreaIdAndType(areaId, DeviceType.ACCESS_CONTROL);
            
            devices.forEach(device -> {
                deviceCommClient.deleteBiometricTemplate(
                    device.getDeviceId(),
                    userId
                );
            });
        }
    }
}
```
```java
@Service
public class BiometricTemplateSyncService {
    
    @Resource
    private DeviceCommServiceClient deviceCommClient;
    
    @Resource
    private BiometricTemplateDao templateDao;
    
    @Resource
    private DeviceTemplateMappingDao mappingDao;
    
    /**
     * åŒæ­¥ç”¨æˆ·æ¨¡æ¿åˆ°è®¾å¤‡
     */
    @Transactional(rollbackFor = Exception.class)
    public ResponseDTO<TemplateSyncResult> syncTemplateToDevice(
            Long userId, String deviceId) {
        
        // 1. æŸ¥è¯¢ç”¨æˆ·æ‰€æœ‰ç”Ÿç‰©æ¨¡æ¿
        List<BiometricTemplateEntity> templates = templateDao.selectByUserId(userId);
        if (templates.isEmpty()) {
            return ResponseDTO.error("ç”¨æˆ·æ— ç”Ÿç‰©æ¨¡æ¿");
        }
        
        // 2. æŸ¥è¯¢è®¾å¤‡æ”¯æŒçš„ç”Ÿç‰©ç±»å‹
        DeviceEntity device = deviceDao.selectById(deviceId);
        List<BiometricType> supportedTypes = parseSupportedTypes(device);
        
        // 3. è¿‡æ»¤è®¾å¤‡æ”¯æŒçš„æ¨¡æ¿
        List<BiometricTemplateEntity> syncTemplates = templates.stream()
            .filter(t -> supportedTypes.contains(t.getBiometricType()))
            .collect(Collectors.toList());
        
        // 4. ä¸‹å‘åˆ°è®¾å¤‡
        List<TemplateSyncRecord> syncRecords = new ArrayList<>();
        for (BiometricTemplateEntity template : syncTemplates) {
            try {
                // è°ƒç”¨è®¾å¤‡é€šè®¯æœåŠ¡
                ResponseDTO<Void> response = deviceCommClient.syncTemplate(
                    TemplateSyncRequest.builder()
                        .deviceId(deviceId)
                        .userId(userId)
                        .biometricType(template.getBiometricType())
                        .featureData(template.getFeatureData())
                        .build()
                );
                
                if (response.isSuccess()) {
                    // åˆ›å»ºæ˜ å°„è®°å½•
                    DeviceTemplateMappingEntity mapping = new DeviceTemplateMappingEntity();
                    mapping.setDeviceId(deviceId);
                    mapping.setTemplateId(template.getTemplateId());
                    mapping.setUserId(userId);
                    mapping.setSyncStatus(SyncStatus.SUCCESS);
                    mapping.setSyncTime(LocalDateTime.now());
                    mappingDao.insert(mapping);
                    
                    syncRecords.add(TemplateSyncRecord.success(template));
                } else {
                    syncRecords.add(TemplateSyncRecord.failed(
                        template, response.getMessage()
                    ));
                }
            } catch (Exception e) {
                log.error("[æ¨¡æ¿åŒæ­¥å¤±è´¥] templateId={}, deviceId={}", 
                    template.getTemplateId(), deviceId, e);
                syncRecords.add(TemplateSyncRecord.error(template, e.getMessage()));
            }
        }
        
        // 5. è¿”å›åŒæ­¥ç»“æœ
        return ResponseDTO.ok(TemplateSyncResult.builder()
            .totalCount(syncTemplates.size())
            .successCount((int) syncRecords.stream()
                .filter(TemplateSyncRecord::isSuccess).count())
            .syncRecords(syncRecords)
            .build());
    }
}
```

**3. ç‰¹å¾æå–æœåŠ¡ï¼ˆâš ï¸ é‡è¦ï¼šéªŒè¯å’Œè¯†åˆ«ç”±è®¾å¤‡ç«¯å®Œæˆï¼‰**
```java
@Service
public class BiometricFeatureExtractionService {
    
    @Resource
    private Map<BiometricType, IBiometricFeatureExtractionStrategy> biometricFeatureExtractionStrategyFactory;
    
    @Resource
    private BiometricTemplateDao templateDao;
    
    @Resource
    private UnifiedCacheManager cacheManager;
    
    /**
     * æå–ç‰¹å¾å‘é‡ï¼ˆåªç”¨äºå…¥èŒæ—¶å¤„ç†ä¸Šä¼ çš„ç…§ç‰‡ï¼‰
     * âš ï¸ æ³¨æ„ï¼šéªŒè¯å’Œè¯†åˆ«ç”±è®¾å¤‡ç«¯å®Œæˆï¼ŒæœåŠ¡ç«¯ä¸å®ç°
     */
    public ResponseDTO<FeatureVector> extractFeature(MultipartFile photo, BiometricType type) {
        // 1. é€‰æ‹©ç‰¹å¾æå–ç­–ç•¥
        IBiometricFeatureExtractionStrategy strategy = biometricFeatureExtractionStrategyFactory.get(type);
        if (strategy == null) {
            return ResponseDTO.error("ä¸æ”¯æŒçš„ç”Ÿç‰©è¯†åˆ«ç±»å‹");
        }
        
        // 2. æ„å»ºæ ·æœ¬
        BiometricSample sample = BiometricSample.builder()
            .type(type)
            .imageData(Base64.getEncoder().encodeToString(photo.getBytes()))
            .build();
        
        // 3. æå–ç‰¹å¾å‘é‡
        FeatureVector featureVector = strategy.extractFeature(sample);
        
        // 4. è´¨é‡éªŒè¯
        if (!strategy.validateFeatureQuality(featureVector)) {
            return ResponseDTO.error("ç‰¹å¾è´¨é‡ä¸è¾¾æ ‡ï¼Œè¯·é‡æ–°é‡‡é›†");
        }
        
        return ResponseDTO.ok(featureVector);
    }
    
    /**
     * ä¿å­˜æ¨¡æ¿åˆ°æ•°æ®åº“ï¼ˆç”¨äºåç»­ä¸‹å‘åˆ°è®¾å¤‡ï¼‰
     */
    public ResponseDTO<Void> saveTemplate(Long userId, BiometricType type, FeatureVector featureVector) {
        BiometricTemplateEntity template = BiometricTemplateEntity.builder()
            .userId(userId)
            .biometricType(type.getCode())
            .featureData(serializeFeatureVector(featureVector))
            .build();
        templateDao.insert(template);
        
        // æ¸…é™¤ç¼“å­˜
        String cacheKey = String.format("biometric:template:%d:%s", userId, type.name());
        cacheManager.evict(cacheKey);
        
        return ResponseDTO.ok();
    }
    
    /**
     * è·å–æ¨¡æ¿ï¼ˆå¸¦ç¼“å­˜ï¼‰
     */
    private BiometricTemplateEntity getTemplate(Long userId, BiometricType type) {
        String cacheKey = String.format("biometric:template:%d:%s", userId, type.name());
        return cacheManager.get(cacheKey, () -> {
            return templateDao.selectByUserIdAndType(userId, type.getCode());
        });
    }
}
```

#### **æ€§èƒ½ä¼˜åŒ–**

**1. å¯¹è±¡æ± ä¼˜åŒ–**
```java
@Component
public class FeatureVectorPool {
    
    private final GenericObjectPool<float[]> vectorPool;
    
    public FeatureVectorPool() {
        GenericObjectPoolConfig<float[]> config = new GenericObjectPoolConfig<>();
        config.setMaxTotal(1000);
        config.setMaxIdle(100);
        config.setMinIdle(10);
        
        this.vectorPool = new GenericObjectPool<>(
            new BasePooledObjectFactory<float[]>() {
                @Override
                public float[] create() {
                    return new float[512];  // FaceNetå‘é‡ç»´åº¦
                }
                
                @Override
                public PooledObject<float[]> wrap(float[] obj) {
                    return new DefaultPooledObject<>(obj);
                }
            },
            config
        );
    }
    
    public float[] borrowVector() throws Exception {
        return vectorPool.borrowObject();
    }
    
    public void returnVector(float[] vector) {
        Arrays.fill(vector, 0);  // æ¸…ç©ºæ•°æ®
        vectorPool.returnObject(vector);
    }
}
```

**2. æ€§èƒ½æŒ‡æ ‡**
- ç‰¹å¾æå–: P99 < 50ms
- 1:1éªŒè¯: P99 < 30ms
- 1:Nè¯†åˆ«(1000äºº): P99 < 200ms
- å†…å­˜å ç”¨: < 500MB

---

### **2.4 ioedream-attendance-service (8091) - è€ƒå‹¤ç®¡ç†æœåŠ¡**

#### **èŒè´£å®šä½**
- æ‰“å¡ç®¡ç†ï¼šç§»åŠ¨ç«¯/è®¾å¤‡ç«¯æ‰“å¡
- æ’ç­ç®¡ç†ï¼šâ­ å¤šç­æ¬¡ã€è½®ç­åˆ¶ã€å¼¹æ€§å·¥æ—¶
- è€ƒå‹¤è®¡ç®—ï¼šâ­ ç»“åˆæ‰“å¡+æ’ç­+è§„åˆ™ï¼Œç²¾å‡†è®¡ç®—
- ç»Ÿè®¡æŠ¥è¡¨ï¼šæ—¥æŠ¥/æœˆæŠ¥/å¹´æŠ¥
- å‡æœŸç®¡ç†ï¼šè¯·å‡/åŠ ç­/è°ƒä¼‘

#### **â­ è®¾å¤‡äº¤äº’æ¨¡å¼ï¼šè¾¹ç¼˜è¯†åˆ«+ä¸­å¿ƒè®¡ç®—+æ’ç­è”åŠ¨**

```
ã€æ•°æ®ä¸‹å‘ã€‘è½¯ä»¶ â†’ è®¾å¤‡
  â”œâ”€ äººå‘˜ä¿¡æ¯
  â”œâ”€ ç”Ÿç‰©æ¨¡æ¿
  â””â”€ âš ï¸ ä¸ä¸‹å‘æ’ç­è®¡åˆ’å’Œè€ƒå‹¤è§„åˆ™ï¼ˆè®¡ç®—åœ¨è½¯ä»¶ç«¯ï¼‰

ã€å®æ—¶æ‰“å¡ã€‘è®¾å¤‡ç«¯è½»é‡è¯†åˆ«
  â”œâ”€ é‡‡é›†ç”Ÿç‰©ç‰¹å¾
  â”œâ”€ æœ¬åœ°è¯†åˆ«åŒ¹é…userId
  â”œâ”€ ç”Ÿæˆæ‰“å¡è®°å½•ï¼šuserId + æ—¶é—´ + è®¾å¤‡ID
  â””â”€ ç«‹å³ä¸Šä¼ åˆ°è½¯ä»¶ç«¯

ã€äº‹åè®¡ç®—ã€‘è½¯ä»¶ç«¯ç»¼åˆè®¡ç®— â­ æ ¸å¿ƒé€»è¾‘
  æ¯æ—¥å‡Œæ™¨2ç‚¹ï¼Œè®¡ç®—å‰ä¸€å¤©è€ƒå‹¤ï¼š
  
  æ­¥éª¤1ï¼šæŸ¥è¯¢æ’ç­è®¡åˆ’ â­
    SELECT * FROM attendance_schedule
    WHERE userId=? AND scheduleDate=?
    â†’ è·å–ï¼šç­æ¬¡ç±»å‹ã€å¼€å§‹æ—¶é—´ã€ç»“æŸæ—¶é—´ã€ä¼‘æ¯æ—¶æ®µã€åº”å‡ºå‹¤æ—¶é•¿
  
  æ­¥éª¤2ï¼šæŸ¥è¯¢æ‰“å¡è®°å½•
    SELECT * FROM attendance_punch_record
    WHERE userId=? AND punchDate=?
    â†’ è·å–ï¼šä¸Šç­æ‰“å¡æ—¶é—´ã€ä¸‹ç­æ‰“å¡æ—¶é—´
  
  æ­¥éª¤3ï¼šæŸ¥è¯¢è€ƒå‹¤è§„åˆ™
    SELECT * FROM attendance_rule WHERE ruleId=?
    â†’ è·å–ï¼šè¿Ÿåˆ°å®½é™ã€æ—©é€€å®½é™ã€åŠ ç­èµ·ç®—æ—¶é•¿
  
  æ­¥éª¤4ï¼šä¸‰è¦ç´ ç»“åˆè®¡ç®— â­ æ ¸å¿ƒç®—æ³•
    æ‰“å¡è®°å½• + æ’ç­è®¡åˆ’ + è€ƒå‹¤è§„åˆ™ = è€ƒå‹¤ç»“æœ
    
    a) è®¡ç®—å®é™…å·¥æ—¶ï¼š
       (ä¸‹ç­æ—¶é—´ - ä¸Šç­æ—¶é—´) - ä¼‘æ¯æ—¶é•¿
    
    b) åˆ¤æ–­è¿Ÿåˆ°ï¼š
       ä¸Šç­æ‰“å¡æ—¶é—´ > (æ’ç­å¼€å§‹æ—¶é—´ + å®½é™)
    
    c) åˆ¤æ–­æ—©é€€ï¼š
       ä¸‹ç­æ‰“å¡æ—¶é—´ < (æ’ç­ç»“æŸæ—¶é—´ - å®½é™)
    
    d) åˆ¤æ–­åŠ ç­ï¼š
       (ä¸‹ç­æ‰“å¡ - æ’ç­ç»“æŸ) > åŠ ç­èµ·ç®—æ—¶é•¿
  
  æ­¥éª¤5ï¼šç”Ÿæˆè€ƒå‹¤ç»“æœ
    AttendanceRecordEntity:
      - scheduleId: å…³è”æ’ç­
      - scheduledWorkMinutes: åº”å‡ºå‹¤æ—¶é•¿
      - actualWorkMinutes: å®é™…å‡ºå‹¤æ—¶é•¿
      - status: æ­£å¸¸/è¿Ÿåˆ°/æ—©é€€/æ—·å·¥
  
  æ­¥éª¤6ï¼šæœˆåº¦æ±‡æ€»
    æ¯æœˆ1æ—¥æ‰§è¡Œï¼š
      - å‡ºå‹¤å¤©æ•° vs åº”å‡ºå‹¤å¤©æ•°
      - æ€»å·¥æ—¶ vs æ ‡å‡†å·¥æ—¶
      - è¿Ÿåˆ°æ¬¡æ•°ã€æ—©é€€æ¬¡æ•°ã€åŠ ç­æ—¶é•¿

ã€ä¼˜åŠ¿ã€‘
  âœ… è®¾å¤‡ç«¯è½»é‡ï¼šåªè´Ÿè´£è¯†åˆ«ï¼Œä¸éœ€å­˜å‚¨å¤æ‚è§„åˆ™
  âœ… è§„åˆ™çµæ´»ï¼šè€ƒå‹¤è§„åˆ™å˜æ›´æ— éœ€æ›´æ–°è®¾å¤‡
  âœ… æ’ç­è”åŠ¨ï¼šæ”¯æŒæ ‡å‡†/å¼¹æ€§/è½®ç­/å¤–å‹¤å¤šç§åˆ¶åº¦
  âœ… å¤šç»´è®¡ç®—ï¼šç»¼åˆæ‰“å¡+æ’ç­+è§„åˆ™ï¼Œç²¾å‡†è®¡ç®—å·¥æ—¶
  âœ… äº‹åå®¡è®¡ï¼šå¯é‡æ–°è®¡ç®—å†å²æ•°æ®
```

#### **æ ¸å¿ƒè®¾è®¡**

**1. ç­–ç•¥æ¨¡å¼ï¼šè€ƒå‹¤è§„åˆ™å¼•æ“**
```java
public interface IAttendanceRuleStrategy {
    /**
     * è§„åˆ™åç§°
     */
    String getRuleName();
    
    /**
     * è®¡ç®—è€ƒå‹¤ç»“æœ
     */
    AttendanceResult calculate(AttendancePunchRecord record, AttendanceRule rule);
}

@Component
@StrategyMarker(name = "STANDARD_WORKING_HOURS")
public class StandardWorkingHoursStrategy implements IAttendanceRuleStrategy {
    
    @Override
    public String getRuleName() {
        return "æ ‡å‡†å·¥æ—¶åˆ¶";
    }
    
    @Override
    public AttendanceResult calculate(AttendancePunchRecord record, AttendanceRule rule) {
        LocalTime punchTime = record.getPunchTime().toLocalTime();
        LocalTime workStart = rule.getWorkStartTime();
        LocalTime workEnd = rule.getWorkEndTime();
        
        AttendanceResult result = new AttendanceResult();
        result.setUserId(record.getUserId());
        result.setDate(record.getPunchTime().toLocalDate());
        
        // ä¸Šç­æ‰“å¡
        if (record.getPunchType() == PunchType.CLOCK_IN) {
            if (punchTime.isAfter(workStart.plusMinutes(rule.getLateGracePeriod()))) {
                result.setStatus(AttendanceStatus.LATE);
                result.setLateDuration(
                    Duration.between(workStart, punchTime).toMinutes()
                );
            } else if (punchTime.isAfter(workStart)) {
                result.setStatus(AttendanceStatus.NORMAL);
                result.setRemark("åœ¨å®½é™æœŸå†…åˆ°è¾¾");
            } else {
                result.setStatus(AttendanceStatus.NORMAL);
            }
        }
        
        // ä¸‹ç­æ‰“å¡
        else if (record.getPunchType() == PunchType.CLOCK_OUT) {
            if (punchTime.isBefore(workEnd.minusMinutes(rule.getEarlyGracePeriod()))) {
                result.setStatus(AttendanceStatus.EARLY_LEAVE);
                result.setEarlyDuration(
                    Duration.between(punchTime, workEnd).toMinutes()
                );
            } else {
                result.setStatus(AttendanceStatus.NORMAL);
                
                // åŠ ç­åˆ¤å®š
                if (punchTime.isAfter(workEnd.plusMinutes(30))) {
                    result.setOvertimeDuration(
                        Duration.between(workEnd, punchTime).toMinutes()
                    );
                }
            }
        }
        
        return result;
    }
}

@Component
@StrategyMarker(name = "FLEXIBLE_WORKING_HOURS")
public class FlexibleWorkingHoursStrategy implements IAttendanceRuleStrategy {
    
    @Resource
    private AttendanceRecordDao recordDao;
    
    @Override
    public String getRuleName() {
        return "å¼¹æ€§å·¥ä½œåˆ¶";
    }
    
    @Override
    public AttendanceResult calculate(AttendancePunchRecord record, AttendanceRule rule) {
        Long userId = record.getUserId();
        LocalDate date = record.getPunchTime().toLocalDate();
        
        // æŸ¥è¯¢å½“å¤©æ‰€æœ‰æ‰“å¡è®°å½•
        List<AttendancePunchRecord> dayRecords = recordDao.selectByUserAndDate(
            userId, date
        );
        
        // è®¡ç®—æ€»å·¥ä½œæ—¶é•¿
        long totalMinutes = calculateTotalWorkingMinutes(dayRecords);
        
        AttendanceResult result = new AttendanceResult();
        result.setUserId(userId);
        result.setDate(date);
        result.setWorkingMinutes(totalMinutes);
        
        // å¼¹æ€§å·¥ä½œåˆ¶: åªè¦æ»¡è¶³8å°æ—¶å³å¯
        if (totalMinutes >= 480) {  // 8å°æ—¶ = 480åˆ†é’Ÿ
            result.setStatus(AttendanceStatus.NORMAL);
        } else {
            result.setStatus(AttendanceStatus.INSUFFICIENT_HOURS);
            result.setShortfallMinutes(480 - totalMinutes);
        }
        
        return result;
    }
    
    private long calculateTotalWorkingMinutes(List<AttendancePunchRecord> records) {
        // æˆå¯¹è®¡ç®—ä¸Šç­ä¸‹ç­æ—¶é•¿
        records.sort(Comparator.comparing(AttendancePunchRecord::getPunchTime));
        
        long totalMinutes = 0;
        for (int i = 0; i < records.size() - 1; i += 2) {
            if (i + 1 < records.size()) {
                LocalDateTime start = records.get(i).getPunchTime();
                LocalDateTime end = records.get(i + 1).getPunchTime();
                totalMinutes += Duration.between(start, end).toMinutes();
            }
        }
        
        return totalMinutes;
    }
}

@Component
@StrategyMarker(name = "SHIFT_WORKING_HOURS")
public class ShiftWorkingHoursStrategy implements IAttendanceRuleStrategy {
    
    @Resource
    private ShiftScheduleDao scheduleDao;
    
    @Override
    public String getRuleName() {
        return "è½®ç­åˆ¶";
    }
    
    @Override
    public AttendanceResult calculate(AttendancePunchRecord record, AttendanceRule rule) {
        // æŸ¥è¯¢å½“å¤©ç­æ¬¡
        ShiftScheduleEntity schedule = scheduleDao.selectByUserAndDate(
            record.getUserId(),
            record.getPunchTime().toLocalDate()
        );
        
        if (schedule == null) {
            return AttendanceResult.absent("æœªæ’ç­");
        }
        
        // æ ¹æ®ç­æ¬¡æ—¶é—´è®¡ç®—
        LocalTime punchTime = record.getPunchTime().toLocalTime();
        LocalTime shiftStart = schedule.getShiftStartTime();
        LocalTime shiftEnd = schedule.getShiftEndTime();
        
        AttendanceResult result = new AttendanceResult();
        result.setUserId(record.getUserId());
        result.setDate(record.getPunchTime().toLocalDate());
        result.setShiftName(schedule.getShiftName());
        
        if (record.getPunchType() == PunchType.CLOCK_IN) {
            if (punchTime.isAfter(shiftStart.plusMinutes(15))) {
                result.setStatus(AttendanceStatus.LATE);
                result.setLateDuration(
                    Duration.between(shiftStart, punchTime).toMinutes()
                );
            } else {
                result.setStatus(AttendanceStatus.NORMAL);
            }
        }
        
        return result;
    }
}
```

**2. è£…é¥°å™¨æ¨¡å¼ï¼šæ‰“å¡æµç¨‹å¢å¼º**
```java
public interface IPunchExecutor {
    PunchResult execute(MobilePunchRequest request);
}

public class BasicPunchExecutor implements IPunchExecutor {
    
    @Resource
    private AttendancePunchRecordDao recordDao;
    
    @Override
    public PunchResult execute(MobilePunchRequest request) {
        // åŸºç¡€æ‰“å¡é€»è¾‘
        AttendancePunchRecord record = new AttendancePunchRecord();
        record.setUserId(request.getUserId());
        record.setPunchTime(LocalDateTime.now());
        record.setPunchType(request.getPunchType());
        record.setLatitude(request.getLatitude());
        record.setLongitude(request.getLongitude());
        
        recordDao.insert(record);
        
        return PunchResult.success(record);
    }
}

public abstract class PunchDecorator implements IPunchExecutor {
    
    protected IPunchExecutor delegate;
    
    public PunchDecorator(IPunchExecutor delegate) {
        this.delegate = delegate;
    }
    
    @Override
    public PunchResult execute(MobilePunchRequest request) {
        return delegate.execute(request);
    }
}

public class GPSValidationDecorator extends PunchDecorator {
    
    @Resource
    private CompanyAreaService companyAreaService;
    
    public GPSValidationDecorator(IPunchExecutor delegate) {
        super(delegate);
    }
    
    @Override
    public PunchResult execute(MobilePunchRequest request) {
        // GPSä½ç½®éªŒè¯
        boolean withinCompanyArea = companyAreaService.isWithinArea(
            request.getLatitude(),
            request.getLongitude()
        );
        
        if (!withinCompanyArea) {
            return PunchResult.failed("ä¸åœ¨æ‰“å¡èŒƒå›´å†…");
        }
        
        return super.execute(request);
    }
}

public class PhotoVerificationDecorator extends PunchDecorator {
    
    @Resource
    private BiometricServiceClient biometricClient;
    
    public PhotoVerificationDecorator(IPunchExecutor delegate) {
        super(delegate);
    }
    
    @Override
    public PunchResult execute(MobilePunchRequest request) {
        // äººè„¸éªŒè¯
        if (request.getFacePhoto() != null) {
            ResponseDTO<MatchResult> verifyResult = biometricClient.verify(
                BiometricVerifyDTO.builder()
                    .userId(request.getUserId())
                    .biometricType(BiometricType.FACE)
                    .featureData(request.getFacePhoto())
                    .build()
            );
            
            if (!verifyResult.isSuccess() || !verifyResult.getData().isMatched()) {
                return PunchResult.failed("äººè„¸éªŒè¯å¤±è´¥");
            }
        }
        
        return super.execute(request);
    }
}

public class AntiCheatingDecorator extends PunchDecorator {
    
    @Resource
    private RedisTemplate<String, Object> redisTemplate;
    
    public AntiCheatingDecorator(IPunchExecutor delegate) {
        super(delegate);
    }
    
    @Override
    public PunchResult execute(MobilePunchRequest request) {
        // é˜²ä½œå¼Šæ£€æµ‹: åŒä¸€ç”¨æˆ·çŸ­æ—¶é—´å†…å¤šæ¬¡æ‰“å¡
        String lockKey = "punch:lock:" + request.getUserId();
        Boolean lockAcquired = redisTemplate.opsForValue()
            .setIfAbsent(lockKey, "1", Duration.ofMinutes(1));
        
        if (Boolean.FALSE.equals(lockAcquired)) {
            return PunchResult.failed("æ‰“å¡è¿‡äºé¢‘ç¹,è¯·ç¨åå†è¯•");
        }
        
        try {
            return super.execute(request);
        } finally {
            redisTemplate.delete(lockKey);
        }
    }
}

public class LoggingDecorator extends PunchDecorator {
    
    private static final Logger log = LoggerFactory.getLogger(LoggingDecorator.class);
    
    public LoggingDecorator(IPunchExecutor delegate) {
        super(delegate);
    }
    
    @Override
    public PunchResult execute(MobilePunchRequest request) {
        log.info("[æ‰“å¡è¯·æ±‚] userId={}, type={}, location=({}, {})",
            request.getUserId(), request.getPunchType(),
            request.getLatitude(), request.getLongitude());
        
        long startTime = System.currentTimeMillis();
        try {
            PunchResult result = super.execute(request);
            
            long duration = System.currentTimeMillis() - startTime;
            log.info("[æ‰“å¡å®Œæˆ] userId={}, result={}, duration={}ms",
                request.getUserId(), result.isSuccess(), duration);
            
            return result;
        } catch (Exception e) {
            log.error("[æ‰“å¡å¼‚å¸¸] userId={}", request.getUserId(), e);
            throw e;
        }
    }
}

// è£…é¥°å™¨ç»„è£…
@Configuration
public class PunchExecutorConfiguration {
    
    @Bean
    public IPunchExecutor punchExecutor() {
        IPunchExecutor executor = new BasicPunchExecutor();
        executor = new GPSValidationDecorator(executor);
        executor = new PhotoVerificationDecorator(executor);
        executor = new AntiCheatingDecorator(executor);
        executor = new LoggingDecorator(executor);
        return executor;
    }
}
```

**3. è€ƒå‹¤ç»Ÿè®¡æœåŠ¡**
```java
@Service
public class AttendanceStatisticsService {
    
    @Resource
    private AttendanceRecordDao recordDao;
    
    @Resource
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * ä»Šæ—¥è€ƒå‹¤å®æ—¶ç»Ÿè®¡
     */
    public AttendanceDailyStatistics getTodayStatistics(Long departmentId) {
        String cacheKey = "attendance:daily:" + LocalDate.now() + ":" + departmentId;
        
        AttendanceDailyStatistics stats = (AttendanceDailyStatistics) 
            redisTemplate.opsForValue().get(cacheKey);
        
        if (stats == null) {
            stats = calculateTodayStatistics(departmentId);
            redisTemplate.opsForValue().set(
                cacheKey, stats, Duration.ofMinutes(5)
            );
        }
        
        return stats;
    }
    
    private AttendanceDailyStatistics calculateTodayStatistics(Long departmentId) {
        List<AttendanceRecordEntity> records = recordDao.selectTodayByDepartment(
            departmentId, LocalDate.now()
        );
        
        int totalEmployees = getTotalEmployees(departmentId);
        
        Map<AttendanceStatus, Long> statusCount = records.stream()
            .collect(Collectors.groupingBy(
                AttendanceRecordEntity::getStatus,
                Collectors.counting()
            ));
        
        return AttendanceDailyStatistics.builder()
            .date(LocalDate.now())
            .departmentId(departmentId)
            .totalEmployees(totalEmployees)
            .clockedIn(statusCount.getOrDefault(AttendanceStatus.NORMAL, 0L).intValue())
            .late(statusCount.getOrDefault(AttendanceStatus.LATE, 0L).intValue())
            .earlyLeave(statusCount.getOrDefault(AttendanceStatus.EARLY_LEAVE, 0L).intValue())
            .absent(totalEmployees - records.size())
            .leave(statusCount.getOrDefault(AttendanceStatus.LEAVE, 0L).intValue())
            .build();
    }
    
    /**
     * æœˆåº¦è€ƒå‹¤æŠ¥è¡¨(å¼‚æ­¥ç”Ÿæˆ)
     */
    @Async("attendanceStatExecutor")
    public CompletableFuture<MonthlyAttendanceReport> generateMonthlyReport(
            Long departmentId, YearMonth yearMonth) {
        
        List<AttendanceRecordEntity> records = recordDao.selectByDepartmentAndMonth(
            departmentId, yearMonth
        );
        
        // æŒ‰ç”¨æˆ·åˆ†ç»„ç»Ÿè®¡
        Map<Long, EmployeeAttendanceSummary> summaryMap = records.stream()
            .collect(Collectors.groupingBy(
                AttendanceRecordEntity::getUserId,
                Collectors.collectingAndThen(
                    Collectors.toList(),
                    this::summarizeEmployeeAttendance
                )
            ));
        
        MonthlyAttendanceReport report = new MonthlyAttendanceReport();
        report.setDepartmentId(departmentId);
        report.setYearMonth(yearMonth);
        report.setEmployeeSummaries(new ArrayList<>(summaryMap.values()));
        report.setGenerateTime(LocalDateTime.now());
        
        return CompletableFuture.completedFuture(report);
    }
    
    private EmployeeAttendanceSummary summarizeEmployeeAttendance(
            List<AttendanceRecordEntity> records) {
        
        EmployeeAttendanceSummary summary = new EmployeeAttendanceSummary();
        summary.setUserId(records.get(0).getUserId());
        summary.setTotalDays(records.size());
        summary.setNormalDays((int) records.stream()
            .filter(r -> r.getStatus() == AttendanceStatus.NORMAL).count());
        summary.setLateDays((int) records.stream()
            .filter(r -> r.getStatus() == AttendanceStatus.LATE).count());
        summary.setEarlyLeaveDays((int) records.stream()
            .filter(r -> r.getStatus() == AttendanceStatus.EARLY_LEAVE).count());
        summary.setAbsentDays((int) records.stream()
            .filter(r -> r.getStatus() == AttendanceStatus.ABSENT).count());
        summary.setLeaveDays((int) records.stream()
            .filter(r -> r.getStatus() == AttendanceStatus.LEAVE).count());
        summary.setTotalOvertimeMinutes(records.stream()
            .mapToLong(r -> r.getOvertimeDuration() != null ? r.getOvertimeDuration() : 0)
            .sum());
        
        return summary;
    }
}
```

#### **æ€§èƒ½æŒ‡æ ‡**
- æ‰“å¡å“åº”: P99 < 200ms
- ç»Ÿè®¡æŸ¥è¯¢: P99 < 500ms
- æœˆæŠ¥ç”Ÿæˆ: < 10s

---

### **2.5 ioedream-consume-service (8094) - æ¶ˆè´¹ç®¡ç†æœåŠ¡**

#### **èŒè´£å®šä½**
- è´¦æˆ·ç®¡ç†ï¼šé¢„ä»˜è´¹/åä»˜è´¹è´¦æˆ·
- æ¶ˆè´¹è®°å½•ï¼šåˆ·å¡æ¶ˆè´¹ã€æ‰«ç æ”¯ä»˜
- ç¦»çº¿æ¶ˆè´¹ï¼šç¦»çº¿æ¨¡å¼ä¸‹çš„æ¶ˆè´¹åŒæ­¥
- æŠ¥è¡¨åˆ†æï¼šæ¶ˆè´¹ç»Ÿè®¡ã€è¶‹åŠ¿åˆ†æ

#### **æ ¸å¿ƒè®¾è®¡**

**1. ç­–ç•¥æ¨¡å¼ï¼šæ¶ˆè´¹æ¨¡å¼**
```java
public interface IConsumeStrategy {
    String getStrategyName();
    ConsumeResult process(ConsumeRequest request);
}

@Component
@StrategyMarker(name = "PREPAID")
public class PrepaidConsumeStrategy implements IConsumeStrategy {
    
    @Resource
    private AccountDao accountDao;
    
    @Resource
    private ConsumeRecordDao consumeRecordDao;
    
    @Override
    public String getStrategyName() {
        return "é¢„ä»˜è´¹æ¨¡å¼";
    }
    
    @Override
    public ConsumeResult process(ConsumeRequest request) {
        // 1. æŸ¥è¯¢è´¦æˆ·ä½™é¢
        AccountEntity account = accountDao.selectByUserId(request.getUserId());
        if (account == null) {
            return ConsumeResult.failed("è´¦æˆ·ä¸å­˜åœ¨");
        }
        
        if (account.getBalance().compareTo(request.getAmount()) < 0) {
            return ConsumeResult.failed("ä½™é¢ä¸è¶³");
        }
        
        // 2. æ‰£æ¬¾(ä¹è§‚é”)
        int updated = accountDao.deductBalance(
            account.getAccountId(),
            request.getAmount(),
            account.getVersion()
        );
        
        if (updated == 0) {
            throw new ConcurrentUpdateException("è´¦æˆ·ä½™é¢æ›´æ–°å¤±è´¥,è¯·é‡è¯•");
        }
        
        // 3. åˆ›å»ºæ¶ˆè´¹è®°å½•
        ConsumeRecordEntity record = createConsumeRecord(request, account);
        record.setPaymentStatus(PaymentStatus.PAID);
        consumeRecordDao.insert(record);
        
        // 4. æ›´æ–°ä½™é¢åçš„è´¦æˆ·å¯¹è±¡
        AccountEntity updatedAccount = accountDao.selectById(account.getAccountId());
        
        return ConsumeResult.success(record, updatedAccount.getBalance());
    }
}

@Component
@StrategyMarker(name = "POSTPAID")
public class PostpaidConsumeStrategy implements IConsumeStrategy {
    
    @Resource
    private ConsumeRecordDao consumeRecordDao;
    
    @Override
    public String getStrategyName() {
        return "åä»˜è´¹æ¨¡å¼";
    }
    
    @Override
    public ConsumeResult process(ConsumeRequest request) {
        // åä»˜è´¹: ç›´æ¥è®°å½•æ¶ˆè´¹,å®šæœŸç»“ç®—
        ConsumeRecordEntity record = createConsumeRecord(request, null);
        record.setPaymentStatus(PaymentStatus.PENDING);
        record.setSettlementCycle(SettlementCycle.MONTHLY);
        consumeRecordDao.insert(record);
        
        return ConsumeResult.success(record, null);
    }
}
```

**2. ç¦»çº¿æ¶ˆè´¹å¤„ç†**
```java
@Component
public class OfflineConsumeProcessor {
    
    @Resource
    private ConsumeRecordDao consumeRecordDao;
    
    @Resource
    private AccountDao accountDao;
    
    /**
     * æ‰¹é‡åŒæ­¥ç¦»çº¿æ¶ˆè´¹è®°å½•
     */
    @Transactional(rollbackFor = Exception.class)
    public BatchSyncResult syncOfflineRecords(List<OfflineConsumeRecord> offlineRecords) {
        BatchSyncResult result = new BatchSyncResult();
        
        for (OfflineConsumeRecord offline : offlineRecords) {
            try {
                // 1. éªŒè¯è®°å½•åˆæ³•æ€§
                validateOfflineRecord(offline);
                
                // 2. é˜²é‡å¤æ¶ˆè´¹æ£€æŸ¥
                boolean exists = consumeRecordDao.existsByOfflineId(offline.getOfflineId());
                if (exists) {
                    result.addDuplicate(offline);
                    continue;
                }
                
                // 3. è½¬æ¢ä¸ºåœ¨çº¿è®°å½•
                ConsumeRecordEntity record = convertToOnlineRecord(offline);
                record.setIsOfflineSync(true);
                record.setSyncTime(LocalDateTime.now());
                
                // 4. è¡¥æ‰£è´¦æˆ·ä½™é¢
                accountDao.deductBalance(
                    offline.getAccountId(),
                    offline.getAmount(),
                    null  // ç¦»çº¿æ¶ˆè´¹ä¸ä½¿ç”¨ä¹è§‚é”
                );
                
                // 5. ä¿å­˜è®°å½•
                consumeRecordDao.insert(record);
                
                result.addSuccess(offline);
                
            } catch (Exception e) {
                log.error("[ç¦»çº¿æ¶ˆè´¹åŒæ­¥å¤±è´¥] offlineId={}", offline.getOfflineId(), e);
                result.addFailed(offline, e.getMessage());
            }
        }
        
        return result;
    }
}
```

**3. æ¶ˆè´¹æŠ¥è¡¨æœåŠ¡**
```java
@Service
public class ConsumeReportService {
    
    @Resource
    private ConsumeRecordDao consumeRecordDao;
    
    /**
     * ç”Ÿæˆéƒ¨é—¨æ¶ˆè´¹æŠ¥è¡¨
     */
    @Async("reportExecutor")
    public CompletableFuture<DepartmentConsumeReport> generateDepartmentReport(
            Long departmentId, LocalDate startDate, LocalDate endDate) {
        
        List<ConsumeRecordEntity> records = consumeRecordDao.selectByDepartmentAndDateRange(
            departmentId, startDate, endDate
        );
        
        DepartmentConsumeReport report = new DepartmentConsumeReport();
        report.setDepartmentId(departmentId);
        report.setStartDate(startDate);
        report.setEndDate(endDate);
        report.setTotalAmount(records.stream()
            .map(ConsumeRecordEntity::getAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add));
        report.setTotalCount(records.size());
        report.setAverageAmount(report.getTotalAmount().divide(
            BigDecimal.valueOf(report.getTotalCount()), 2, RoundingMode.HALF_UP));
        
        // æŒ‰æ¶ˆè´¹ç±»å‹åˆ†ç»„
        Map<String, BigDecimal> categoryStats = records.stream()
            .collect(Collectors.groupingBy(
                ConsumeRecordEntity::getConsumeCategory,
                Collectors.reducing(BigDecimal.ZERO,
                    ConsumeRecordEntity::getAmount,
                    BigDecimal::add)
            ));
        report.setCategoryStats(categoryStats);
        
        // æŒ‰æ—¥æœŸç»Ÿè®¡è¶‹åŠ¿
        Map<LocalDate, BigDecimal> dailyTrend = records.stream()
            .collect(Collectors.groupingBy(
                r -> r.getConsumeTime().toLocalDate(),
                Collectors.reducing(BigDecimal.ZERO,
                    ConsumeRecordEntity::getAmount,
                    BigDecimal::add)
            ));
        report.setDailyTrend(dailyTrend);
        
        return CompletableFuture.completedFuture(report);
    }
}
```

#### **æ€§èƒ½æŒ‡æ ‡**
- æ¶ˆè´¹å“åº”: P99 < 100ms
- ä½™é¢æŸ¥è¯¢: P99 < 50ms
- ç¦»çº¿åŒæ­¥: 1000æ¡/ç§’

---

### **2.6 ioedream-visitor-service (8095) - è®¿å®¢ç®¡ç†æœåŠ¡**

#### **èŒè´£å®šä½**
- é¢„çº¦ç®¡ç†ï¼šè®¿å®¢é¢„çº¦ã€å®¡æ‰¹æµç¨‹
- ç­¾åˆ°ç­¾å‡ºï¼šäºŒç»´ç é€šè¡Œè¯ã€äººè„¸éªŒè¯
- è½¨è¿¹è¿½è¸ªï¼šå®æ—¶ä½ç½®è¿½è¸ªã€å¼‚å¸¸å‘Šè­¦
- VIPç®¡ç†ï¼šVIPè®¿å®¢å¿«é€Ÿé€šé“

#### **æ ¸å¿ƒè®¾è®¡**

**1. è®¿å®¢é¢„çº¦å·¥ä½œæµ**
```java
@Service
public class VisitorAppointmentWorkflowService {
    
    @Resource
    private WorkflowEngine workflowEngine;
    
    @Resource
    private VisitorAppointmentDao appointmentDao;
    
    @Resource
    private AccessPermissionService accessPermissionService;
    
    /**
     * æäº¤è®¿å®¢é¢„çº¦
     */
    @Transactional(rollbackFor = Exception.class)
    public ResponseDTO<String> submitAppointment(VisitorAppointmentDTO appointmentDTO) {
        // 1. åˆ›å»ºé¢„çº¦è®°å½•
        VisitorAppointmentEntity appointment = new VisitorAppointmentEntity();
        BeanUtils.copyProperties(appointmentDTO, appointment);
        appointment.setStatus(AppointmentStatus.PENDING);
        appointment.setAppointmentNo(generateAppointmentNo());
        appointmentDao.insert(appointment);
        
        // 2. å¯åŠ¨å®¡æ‰¹æµç¨‹
        WorkflowInstanceVO workflow = workflowEngine.startProcess(
            "visitor_appointment",
            appointment.getAppointmentId().toString(),
            Map.of(
                "visitorName", appointment.getVisitorName(),
                "visitDate", appointment.getVisitDate(),
                "hostUserId", appointment.getHostUserId(),
                "visitPurpose", appointment.getVisitPurpose()
            )
        );
        
        // 3. æ›´æ–°å·¥ä½œæµID
        appointment.setWorkflowInstanceId(workflow.getInstanceId());
        appointmentDao.updateById(appointment);
        
        // 4. å‘é€é€šçŸ¥ç»™è¢«è®¿äºº
        notifyHost(appointment);
        
        return ResponseDTO.ok(appointment.getAppointmentNo());
    }
    
    /**
     * å®¡æ‰¹è®¿å®¢é¢„çº¦
     */
    @Transactional(rollbackFor = Exception.class)
    public ResponseDTO<Void> approveAppointment(Long appointmentId, ApprovalForm form) {
        // 1. æŸ¥è¯¢é¢„çº¦
        VisitorAppointmentEntity appointment = appointmentDao.selectById(appointmentId);
        
        // 2. æäº¤å®¡æ‰¹
        workflowEngine.completeTask(
            form.getTaskId(),
            form.getApproved(),
            form.getComment()
        );
        
        // 3. å®¡æ‰¹é€šè¿‡åç”Ÿæˆè®¿å®¢é€šè¡Œè¯
        if (form.getApproved()) {
            appointment.setStatus(AppointmentStatus.APPROVED);
            appointment.setApprovalTime(LocalDateTime.now());
            
            // ç”ŸæˆäºŒç»´ç é€šè¡Œè¯
            String qrCode = generateVisitorQRCode(appointment);
            appointment.setQrCode(qrCode);
            
            // å‘é€é€šè¡Œè¯åˆ°è®¿å®¢æ‰‹æœº
            sendVisitorPass(appointment);
            
            // ä¸´æ—¶æƒé™ä¸‹å‘åˆ°é—¨ç¦è®¾å¤‡
            grantTemporaryAccess(appointment);
            
        } else {
            appointment.setStatus(AppointmentStatus.REJECTED);
            appointment.setRejectReason(form.getComment());
            
            // é€šçŸ¥è®¿å®¢é¢„çº¦è¢«æ‹’ç»
            notifyVisitorRejection(appointment);
        }
        
        appointmentDao.updateById(appointment);
        return ResponseDTO.ok();
    }
    
    /**
     * è®¿å®¢ç­¾åˆ°
     */
    public ResponseDTO<VisitorCheckInVO> checkIn(VisitorCheckInRequest request) {
        // 1. éªŒè¯äºŒç»´ç 
        VisitorAppointmentEntity appointment = validateQRCode(request.getQrCode());
        if (appointment.getStatus() != AppointmentStatus.APPROVED) {
            return ResponseDTO.error("é¢„çº¦æœªå®¡æ‰¹é€šè¿‡");
        }
        
        // 2. æ—¶é—´éªŒè¯
        if (!isWithinVisitTime(appointment)) {
            return ResponseDTO.error("ä¸åœ¨é¢„çº¦æ—¶é—´èŒƒå›´å†…");
        }
        
        // 3. äººè„¸éªŒè¯(å¯é€‰)
        if (request.getFacePhoto() != null) {
            boolean faceMatched = verifyVisitorFace(appointment, request.getFacePhoto());
            if (!faceMatched) {
                return ResponseDTO.error("äººè„¸éªŒè¯å¤±è´¥");
            }
        }
        
        // 4. åˆ›å»ºç­¾åˆ°è®°å½•
        VisitorCheckInRecord record = new VisitorCheckInRecord();
        record.setAppointmentId(appointment.getAppointmentId());
        record.setCheckInTime(LocalDateTime.now());
        record.setCheckInDevice(request.getDeviceId());
        record.setCheckInMethod(request.getFacePhoto() != null ? "FACE" : "QR_CODE");
        visitorCheckInDao.insert(record);
        
        // 5. æ›´æ–°é¢„çº¦çŠ¶æ€
        appointment.setStatus(AppointmentStatus.CHECKED_IN);
        appointmentDao.updateById(appointment);
        
        // 6. å¼€å§‹è½¨è¿¹è¿½è¸ª
        startVisitorTracking(appointment);
        
        // 7. é€šçŸ¥è¢«è®¿äºº
        notifyHostVisitorArrival(appointment);
        
        return ResponseDTO.ok(VisitorCheckInVO.from(appointment, record));
    }
    
    /**
     * ç”Ÿæˆä¸´æ—¶é€šè¡Œæƒé™
     */
    private void grantTemporaryAccess(VisitorAppointmentEntity appointment) {
        // ä¸´æ—¶æƒé™: é¢„çº¦æ—¶é—´å†…æœ‰æ•ˆ
        accessPermissionService.grantTemporaryPermission(
            TemporaryPermissionDTO.builder()
                .userId(appointment.getVisitorId())  // è®¿å®¢ä¸´æ—¶è´¦æˆ·ID
                .areaIds(appointment.getAllowedAreaIds())
                .startTime(appointment.getVisitStartTime())
                .endTime(appointment.getVisitEndTime())
                .permissionType("VISITOR")
                .build()
        );
    }
}
```

**2. è®¿å®¢è½¨è¿¹è¿½è¸ª**
```java
@Service
public class VisitorTrackingService {
    
    @Resource
    private RedisTemplate<String, Object> redisTemplate;
    
    @Resource
    private VisitorTrackingDao trackingDao;
    
    @Resource
    private WebSocketService websocketService;
    
    /**
     * è®°å½•è®¿å®¢è½¨è¿¹
     */
    public void recordTrackingPoint(Long appointmentId, TrackingPoint point) {
        String trackingKey = "visitor:tracking:" + appointmentId;
        
        // 1. å®æ—¶è½¨è¿¹å­˜å…¥Redis
        redisTemplate.opsForList().rightPush(trackingKey, point);
        redisTemplate.expire(trackingKey, Duration.ofDays(1));
        
        // 2. æ¨é€åˆ°ç›‘æ§ç«¯(WebSocket)
        websocketService.sendTrackingUpdate(
            VisitorTrackingUpdate.builder()
                .appointmentId(appointmentId)
                .currentArea(point.getAreaName())
                .timestamp(point.getTimestamp())
                .build()
        );
        
        // 3. å¼‚å¸¸åŒºåŸŸå‘Šè­¦
        checkUnauthorizedArea(appointmentId, point);
        
        // 4. å¼‚æ­¥æŒä¹…åŒ–åˆ°æ•°æ®åº“
        CompletableFuture.runAsync(() -> {
            VisitorTrackingEntity tracking = new VisitorTrackingEntity();
            tracking.setAppointmentId(appointmentId);
            tracking.setDeviceId(point.getDeviceId());
            tracking.setAreaId(point.getAreaId());
            tracking.setTrackingTime(point.getTimestamp());
            trackingDao.insert(tracking);
        });
    }
    
    /**
     * è·å–è®¿å®¢å®æ—¶è½¨è¿¹
     */
    public List<TrackingPoint> getRealtimeTracking(Long appointmentId) {
        String trackingKey = "visitor:tracking:" + appointmentId;
        return redisTemplate.opsForList().range(trackingKey, 0, -1)
            .stream()
            .map(obj -> (TrackingPoint) obj)
            .collect(Collectors.toList());
    }
    
    /**
     * æ£€æŸ¥æœªæˆæƒåŒºåŸŸè®¿é—®
     */
    private void checkUnauthorizedArea(Long appointmentId, TrackingPoint point) {
        VisitorAppointmentEntity appointment = appointmentDao.selectById(appointmentId);
        List<Long> allowedAreaIds = appointment.getAllowedAreaIds();
        
        if (!allowedAreaIds.contains(point.getAreaId())) {
            // è®¿å®¢è¿›å…¥æœªæˆæƒåŒºåŸŸ,å‘é€å‘Šè­¦
            VisitorAlertEvent alert = VisitorAlertEvent.builder()
                .appointmentId(appointmentId)
                .visitorName(appointment.getVisitorName())
                .alertType("UNAUTHORIZED_AREA")
                .currentArea(point.getAreaName())
                .alertTime(LocalDateTime.now())
                .build();
            
            // WebSocketå®æ—¶æ¨é€å‘Šè­¦
            websocketService.sendAlert(alert);
            
            // çŸ­ä¿¡é€šçŸ¥è¢«è®¿äººå’Œå®‰ä¿äººå‘˜
            notifyUnauthorizedAreaAccess(appointment, point);
        }
    }
}
```

#### **æ€§èƒ½æŒ‡æ ‡**
- é¢„çº¦åˆ›å»º: P99 < 300ms
- ç­¾åˆ°å“åº”: P99 < 200ms
- è½¨è¿¹è¿½è¸ª: å®æ—¶æ¨é€å»¶è¿Ÿ < 500ms

---

### **2.7 ioedream-video-service (8092) - è§†é¢‘ç›‘æ§æœåŠ¡**

#### **èŒè´£å®šä½**
- è§†é¢‘æµç®¡ç†ï¼šå®æ—¶è§†é¢‘æµæ¨æ‹‰æµ
- AIåˆ†æï¼šäººè„¸æ£€æµ‹ã€å…¥ä¾µæ£€æµ‹ã€è¡Œä¸ºåˆ†æ
- å½•åƒç®¡ç†ï¼šäº‹ä»¶è”åŠ¨å½•åƒã€å½•åƒå›æ”¾
- å‘Šè­¦è”åŠ¨ï¼šå¼‚å¸¸äº‹ä»¶å‘Šè­¦æ¨é€

#### **æ ¸å¿ƒè®¾è®¡**

**1. å·¥å‚æ¨¡å¼ï¼šè§†é¢‘æµé€‚é…å™¨**
```java
public interface IVideoStreamAdapter {
    String getVendorName();
    VideoStream createStream(DeviceEntity device);
    void stopStream(String streamId);
}

@Component
public class HikvisionStreamAdapter implements IVideoStreamAdapter {
    
    @Override
    public String getVendorName() {
        return "HIKVISION";
    }
    
    @Override
    public VideoStream createStream(DeviceEntity device) {
        // æµ·åº·RTSPæµ
        String rtspUrl = String.format(
            "rtsp://%s:%s@%s:%d/Streaming/Channels/101",
            device.getUsername(),
            device.getPassword(),
            device.getIpAddress(),
            device.getPort()
        );
        
        return VideoStream.builder()
            .deviceId(device.getDeviceId())
            .streamUrl(rtspUrl)
            .protocol("RTSP")
            .build();
    }
}

@Component
public class DahuaStreamAdapter implements IVideoStreamAdapter {
    
    @Override
    public String getVendorName() {
        return "DAHUA";
    }
    
    @Override
    public VideoStream createStream(DeviceEntity device) {
        // å¤§åRTSPæµ
        String rtspUrl = String.format(
            "rtsp://%s:%s@%s:%d/cam/realmonitor?channel=1&subtype=0",
            device.getUsername(),
            device.getPassword(),
            device.getIpAddress(),
            device.getPort()
        );
        
        return VideoStream.builder()
            .deviceId(device.getDeviceId())
            .streamUrl(rtspUrl)
            .protocol("RTSP")
            .build();
    }
}
```

**2. ç­–ç•¥æ¨¡å¼ï¼šAIåˆ†æç­–ç•¥**
```java
public interface IVideoAnalysisStrategy {
    String getAnalysisType();
    AnalysisResult analyze(VideoFrame frame);
}

@Component
@StrategyMarker(type = "FACE_DETECTION")
public class FaceDetectionStrategy implements IVideoAnalysisStrategy {
    
    @Override
    public AnalysisResult analyze(VideoFrame frame) {
        // OpenCVäººè„¸æ£€æµ‹
        Mat image = frame.getMat();
        CascadeClassifier faceDetector = new CascadeClassifier(
            "haarcascade_frontalface_default.xml"
        );
        MatOfRect faceDetections = new MatOfRect();
        faceDetector.detectMultiScale(image, faceDetections);
        
        List<FaceRegion> faces = Arrays.stream(faceDetections.toArray())
            .map(rect -> new FaceRegion(
                rect.x, rect.y, rect.width, rect.height
            ))
            .collect(Collectors.toList());
        
        return AnalysisResult.builder()
            .type("FACE_DETECTION")
            .detectedFaces(faces)
            .faceCount(faces.size())
            .build();
    }
}
```

**3. äº‹ä»¶è”åŠ¨å½•åƒ**
```java
@Service
public class VideoEventLinkageService {
    
    @Resource
    private VideoStreamService streamService;
    
    @Resource
    private VideoRecordDao recordDao;
    
    /**
     * é—¨ç¦äº‹ä»¶è”åŠ¨å½•åƒ
     */
    @EventListener
    @Async("videoEventExecutor")
    public void handleAccessEvent(AccessEvent event) {
        // 1. æŸ¥è¯¢è¯¥é—¨ç¦ç‚¹çš„æ‘„åƒå¤´
        List<DeviceEntity> cameras = deviceDao.selectCamerasByArea(
            event.getAreaId()
        );
        
        // 2. è§¦å‘å½•åƒ
        for (DeviceEntity camera : cameras) {
            streamService.startRecording(
                camera.getDeviceId(),
                Duration.ofMinutes(5)
            );
        }
        
        // 3. åˆ›å»ºå½•åƒè®°å½•
        VideoRecordEntity record = new VideoRecordEntity();
        record.setDeviceId(cameras.get(0).getDeviceId());
        record.setEventType("ACCESS");
        record.setEventId(event.getRecordId());
        record.setStartTime(LocalDateTime.now());
        recordDao.insert(record);
    }
}
```

#### **æ€§èƒ½æŒ‡æ ‡**
- è§†é¢‘æµå¯åŠ¨: < 2s
- AIåˆ†æå»¶è¿Ÿ: < 100ms/å¸§
- å¹¶å‘è§†é¢‘æµ: 100+

---

### **2.8 ioedream-oa-service (8089) - OAåŠå…¬æœåŠ¡**

#### **èŒè´£å®šä½**
- å·¥ä½œæµå¼•æ“ï¼šå®¡æ‰¹æµç¨‹ç®¡ç†
- é€šçŸ¥æœåŠ¡ï¼šå¤šæ¸ é“æ¶ˆæ¯æ¨é€
- æ–‡æ¡£ç®¡ç†ï¼šæ–‡ä»¶ä¸Šä¼ ä¸‹è½½
- æ—¥ç¨‹ç®¡ç†ï¼šä¼šè®®å®¤é¢„è®¢ã€æ—¥ç¨‹æé†’

#### **æ ¸å¿ƒè®¾è®¡**

**1. å·¥ä½œæµå¼•æ“**
```java
@Service
public class WorkflowEngineService {
    
    @Resource
    private WorkflowInstanceDao instanceDao;
    
    @Resource
    private WorkflowTaskDao taskDao;
    
    /**
     * å¯åŠ¨æµç¨‹
     */
    @Transactional(rollbackFor = Exception.class)
    public WorkflowInstanceVO startProcess(
            String processKey, 
            String businessKey, 
            Map<String, Object> variables) {
        
        // 1. åˆ›å»ºæµç¨‹å®ä¾‹
        WorkflowInstanceEntity instance = new WorkflowInstanceEntity();
        instance.setProcessKey(processKey);
        instance.setBusinessKey(businessKey);
        instance.setStatus(WorkflowStatus.RUNNING);
        instance.setVariables(JSON.toJSONString(variables));
        instanceDao.insert(instance);
        
        // 2. åˆ›å»ºé¦–ä¸ªä»»åŠ¡
        WorkflowTaskEntity firstTask = createFirstTask(instance, variables);
        taskDao.insert(firstTask);
        
        // 3. å‘é€å¾…åŠé€šçŸ¥
        notifyAssignee(firstTask);
        
        return WorkflowInstanceVO.from(instance);
    }
    
    /**
     * å®Œæˆä»»åŠ¡
     */
    @Transactional(rollbackFor = Exception.class)
    public void completeTask(Long taskId, boolean approved, String comment) {
        // 1. æ›´æ–°ä»»åŠ¡çŠ¶æ€
        WorkflowTaskEntity task = taskDao.selectById(taskId);
        task.setStatus(approved ? TaskStatus.APPROVED : TaskStatus.REJECTED);
        task.setComment(comment);
        task.setCompleteTime(LocalDateTime.now());
        taskDao.updateById(task);
        
        // 2. åˆ¤æ–­æµç¨‹èµ°å‘
        if (approved) {
            WorkflowTaskEntity nextTask = createNextTask(task);
            if (nextTask != null) {
                taskDao.insert(nextTask);
                notifyAssignee(nextTask);
            } else {
                completeProcess(task.getInstanceId());
            }
        } else {
            terminateProcess(task.getInstanceId());
        }
    }
}
```

**2. å¤šæ¸ é“é€šçŸ¥æœåŠ¡**
```java
@Service
public class NotificationService {
    
    @Resource
    private RabbitTemplate rabbitTemplate;
    
    @Resource
    private WebSocketService websocketService;
    
    @Resource
    private SmsService smsService;
    
    @Resource
    private EmailService emailService;
    
    /**
     * å‘é€å¤šæ¸ é“é€šçŸ¥
     */
    public void sendNotification(NotificationMessage message) {
        // 1. ç«™å†…æ¶ˆæ¯(WebSocketå®æ—¶æ¨é€)
        if (message.getChannels().contains(NotificationChannel.WEBSOCKET)) {
            websocketService.sendToUser(
                message.getUserId(), 
                message.getContent()
            );
        }
        
        // 2. çŸ­ä¿¡é€šçŸ¥
        if (message.getChannels().contains(NotificationChannel.SMS)) {
            smsService.send(message.getPhone(), message.getContent());
        }
        
        // 3. é‚®ä»¶é€šçŸ¥
        if (message.getChannels().contains(NotificationChannel.EMAIL)) {
            emailService.send(
                message.getEmail(), 
                message.getSubject(), 
                message.getContent()
            );
        }
        
        // 4. æ¨é€åˆ°MQ(å¼‚æ­¥å¤„ç†)
        rabbitTemplate.convertAndSend(
            "notification.exchange", 
            "notification.route", 
            message
        );
    }
}
```

#### **æ€§èƒ½æŒ‡æ ‡**
- æµç¨‹å¯åŠ¨: P99 < 200ms
- é€šçŸ¥æ¨é€: P99 < 100ms
- å¹¶å‘å®¡æ‰¹: 1000+ TPS

---

### **2.9 ioedream-device-comm-service (8087) - è®¾å¤‡é€šè®¯æœåŠ¡**

#### **èŒè´£å®šä½**
- åè®®é€‚é…ï¼šå¤šå‚å•†è®¾å¤‡åè®®é€‚é…
- è¿æ¥ç®¡ç†ï¼šè®¾å¤‡è¿æ¥æ± ç®¡ç†
- æŒ‡ä»¤ä¸‹å‘ï¼šå¼€é—¨/å…³é—¨/é‡å¯ç­‰æŒ‡ä»¤
- å¿ƒè·³æ£€æµ‹ï¼šè®¾å¤‡åœ¨çº¿çŠ¶æ€ç›‘æ§

#### **æ ¸å¿ƒè®¾è®¡**ï¼ˆå·²åœ¨å‰é¢å®Œæ•´è®¾è®¡ï¼‰

---

### **2.10 ioedream-common-service (8088) - å…¬å…±ä¸šåŠ¡æœåŠ¡**

#### **èŒè´£å®šä½**
- ç”¨æˆ·ç®¡ç†ï¼šç”¨æˆ·CRUDã€è§’è‰²æƒé™
- ç»„ç»‡ç®¡ç†ï¼šéƒ¨é—¨/åŒºåŸŸ/è®¾å¤‡ç®¡ç†
- å­—å…¸ç®¡ç†ï¼šç³»ç»Ÿå­—å…¸é…ç½®
- é…ç½®ç®¡ç†ï¼šç³»ç»Ÿå‚æ•°é…ç½®

---

### **2.11 ioedream-database-service (8093) - æ•°æ®åº“ç®¡ç†æœåŠ¡**

#### **èŒè´£å®šä½**
- æ•°æ®å¤‡ä»½ï¼šå®šæ—¶å…¨é‡/å¢é‡å¤‡ä»½
- æ•°æ®æ¢å¤ï¼šå¤‡ä»½æ–‡ä»¶æ¢å¤
- æ€§èƒ½ç›‘æ§ï¼šæ…¢æŸ¥è¯¢/è¿æ¥æ•°ç›‘æ§
- æ•°æ®è¿ç§»ï¼šæ•°æ®å¯¼å…¥å¯¼å‡º

---

## ğŸ¯ **ä¸‰ã€å®Œæ•´çš„10ä¸ªå…¬å…±ç»„ä»¶åº“è¯¦ç»†è®¾è®¡**

### **3.1 microservices-common-core - æ ¸å¿ƒç»„ä»¶**

```java
/**
 * ResponseDTO - ç»Ÿä¸€è¿”å›æ ¼å¼
 */
@Data
public class ResponseDTO<T> {
    private Integer code;
    private String message;
    private T data;
    private Long timestamp;
    
    public static <T> ResponseDTO<T> ok(T data) {
        ResponseDTO<T> response = new ResponseDTO<>();
        response.setCode(200);
        response.setMessage("success");
        response.setData(data);
        response.setTimestamp(System.currentTimeMillis());
        return response;
    }
    
    public static <T> ResponseDTO<T> error(String message) {
        ResponseDTO<T> response = new ResponseDTO<>();
        response.setCode(500);
        response.setMessage(message);
        response.setTimestamp(System.currentTimeMillis());
        return response;
    }
    
    public boolean isSuccess() {
        return code != null && code == 200;
    }
}

/**
 * PageResult - åˆ†é¡µè¿”å›
 */
@Data
public class PageResult<T> {
    private Long total;
    private List<T> records;
    private Integer pageNum;
    private Integer pageSize;
    private Integer totalPages;
    
    public static <T> PageResult<T> from(Page<T> page) {
        PageResult<T> result = new PageResult<>();
        result.setTotal(page.getTotal());
        result.setRecords(page.getRecords());
        result.setPageNum((int) page.getCurrent());
        result.setPageSize((int) page.getSize());
        result.setTotalPages((int) page.getPages());
        return result;
    }
}

/**
 * BusinessException - ä¸šåŠ¡å¼‚å¸¸
 */
public class BusinessException extends RuntimeException {
    private final String errorCode;
    
    public BusinessException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }
    
    public String getErrorCode() {
        return errorCode;
    }
}

/**
 * Constants - å¸¸é‡å®šä¹‰
 */
public class Constants {
    public static final String CACHE_PREFIX = "ioedream:";
    public static final int DEFAULT_PAGE_SIZE = 20;
    public static final long TOKEN_EXPIRE_SECONDS = 7200;
    public static final int MAX_UPLOAD_SIZE_MB = 50;
}
```

### **3.2 microservices-common-security - å®‰å…¨ç»„ä»¶**

```java
/**
 * TokenUtil - Tokenå·¥å…·
 */
@Component
public class TokenUtil {
    
    @Value("${jwt.secret}")
    private String secret;
    
    public String generateToken(UserContext userContext) {
        return Jwts.builder()
            .setSubject(userContext.getUserId().toString())
            .claim("username", userContext.getUserName())
            .claim("roles", userContext.getRoles())
            .claim("departmentId", userContext.getDepartmentId())
            .setExpiration(new Date(
                System.currentTimeMillis() + Constants.TOKEN_EXPIRE_SECONDS * 1000
            ))
            .signWith(SignatureAlgorithm.HS512, secret)
            .compact();
    }
    
    public UserContext parseToken(String token) {
        Claims claims = Jwts.parser()
            .setSigningKey(secret)
            .parseClaimsJws(token)
            .getBody();
        
        UserContext context = new UserContext();
        context.setUserId(Long.parseLong(claims.getSubject()));
        context.setUserName(claims.get("username", String.class));
        context.setRoles(claims.get("roles", String.class));
        context.setDepartmentId(claims.get("departmentId", Long.class));
        return context;
    }
    
    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(secret).parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}

/**
 * EncryptionUtil - åŠ å¯†å·¥å…·
 */
@Component
public class EncryptionUtil {
    
    public String md5(String input) {
        return DigestUtils.md5DigestAsHex(input.getBytes());
    }
    
    public String sha256(String input) {
        return DigestUtils.sha256Hex(input);
    }
    
    public String bcryptEncode(String rawPassword) {
        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
        return encoder.encode(rawPassword);
    }
    
    public boolean bcryptMatches(String rawPassword, String encodedPassword) {
        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
        return encoder.matches(rawPassword, encodedPassword);
    }
}
```

### **3.3 microservices-common-cache - ç¼“å­˜ç»„ä»¶**

```java
/**
 * UnifiedCacheManager - å¤šçº§ç¼“å­˜ç®¡ç†å™¨
 */
@Component
public class UnifiedCacheManager {
    
    private final Cache<String, Object> localCache;  // Caffeineæœ¬åœ°ç¼“å­˜
    private final RedisTemplate<String, Object> redisTemplate;
    private final BloomFilter<String> bloomFilter;
    private final RedissonClient redissonClient;
    
    public UnifiedCacheManager(
            RedisTemplate<String, Object> redisTemplate,
            RedissonClient redissonClient) {
        
        this.redisTemplate = redisTemplate;
        this.redissonClient = redissonClient;
        
        // é…ç½®Caffeineæœ¬åœ°ç¼“å­˜
        this.localCache = Caffeine.newBuilder()
            .maximumSize(10000)
            .expireAfterWrite(Duration.ofMinutes(5))
            .recordStats()
            .build();
        
        // é…ç½®å¸ƒéš†è¿‡æ»¤å™¨
        this.bloomFilter = BloomFilter.create(
            Funnels.stringFunnel(Charset.defaultCharset()),
            100000,
            0.01
        );
    }
    
    /**
     * å¤šçº§ç¼“å­˜è·å–
     */
    public <T> T get(String key, Class<T> type, Supplier<T> loader) {
        // L1: æœ¬åœ°ç¼“å­˜
        T value = (T) localCache.getIfPresent(key);
        if (value != null) {
            return value;
        }
        
        // å¸ƒéš†è¿‡æ»¤å™¨æ£€æŸ¥
        if (!bloomFilter.mightContain(key)) {
            return null;
        }
        
        // L2: Redisç¼“å­˜
        value = (T) redisTemplate.opsForValue().get(key);
        if (value != null) {
            localCache.put(key, value);
            return value;
        }
        
        // L3: åˆ†å¸ƒå¼é”+æ•°æ®åŠ è½½
        String lockKey = "lock:" + key;
        RLock lock = redissonClient.getLock(lockKey);
        try {
            if (lock.tryLock(5, TimeUnit.SECONDS)) {
                // åŒé‡æ£€æŸ¥
                value = (T) redisTemplate.opsForValue().get(key);
                if (value != null) {
                    localCache.put(key, value);
                    return value;
                }
                
                // åŠ è½½æ•°æ®
                value = loader.get();
                if (value != null) {
                    put(key, value, Duration.ofMinutes(30));
                    bloomFilter.put(key);
                }
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
        
        return value;
    }
    
    /**
     * å†™å…¥ç¼“å­˜
     */
    public void put(String key, Object value, Duration ttl) {
        localCache.put(key, value);
        redisTemplate.opsForValue().set(key, value, ttl);
        bloomFilter.put(key);
    }
    
    /**
     * åˆ é™¤ç¼“å­˜
     */
    public void evict(String key) {
        localCache.invalidate(key);
        redisTemplate.delete(key);
    }
}
```

### **3.4 microservices-common-data - æ•°æ®ç»„ä»¶**

```java
/**
 * MyBatis-Plusé…ç½®
 */
@Configuration
public class MyBatisPlusConfiguration {
    
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        
        // åˆ†é¡µæ’ä»¶
        interceptor.addInnerInterceptor(
            new PaginationInnerInterceptor(DbType.MYSQL)
        );
        
        // ä¹è§‚é”æ’ä»¶
        interceptor.addInnerInterceptor(
            new OptimisticLockerInnerInterceptor()
        );
        
        return interceptor;
    }
    
    @Bean
    public MetaObjectHandler metaObjectHandler() {
        return new MetaObjectHandler() {
            @Override
            public void insertFill(MetaObject metaObject) {
                this.strictInsertFill(
                    metaObject, "createTime", 
                    LocalDateTime.class, LocalDateTime.now()
                );
                this.strictInsertFill(
                    metaObject, "updateTime", 
                    LocalDateTime.class, LocalDateTime.now()
                );
            }
            
            @Override
            public void updateFill(MetaObject metaObject) {
                this.strictUpdateFill(
                    metaObject, "updateTime", 
                    LocalDateTime.class, LocalDateTime.now()
                );
            }
        };
    }
}

/**
 * BaseEntity - åŸºç¡€å®ä½“
 */
@Data
public abstract class BaseEntity {
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;
    
    @TableField(fill = FieldFill.INSERT)
    private Long createBy;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Long updateBy;
    
    @TableLogic
    private Integer deleted;
    
    @Version
    private Integer version;
}
```

### **3.5 microservices-common-monitor - ç›‘æ§ç»„ä»¶**

```java
/**
 * BusinessMetrics - ä¸šåŠ¡æŒ‡æ ‡
 */
@Component
public class BusinessMetrics {
    
    private final MeterRegistry meterRegistry;
    
    public BusinessMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    /**
     * è®°å½•é€šè¡Œäº‹ä»¶
     */
    public void recordAccessEvent(String result) {
        Counter.builder("access.event")
            .tag("result", result)
            .register(meterRegistry)
            .increment();
    }
    
    /**
     * è®°å½•APIå“åº”æ—¶é—´
     */
    public void recordResponseTime(String api, long duration) {
        Timer.builder("api.response.time")
            .tag("api", api)
            .register(meterRegistry)
            .record(duration, TimeUnit.MILLISECONDS);
    }
    
    /**
     * è®°å½•ç”Ÿç‰©è¯†åˆ«æ€§èƒ½
     */
    public void recordBiometricPerformance(
            String type, long duration, boolean success) {
        
        Timer.builder("biometric.recognition.time")
            .tag("type", type)
            .tag("success", String.valueOf(success))
            .register(meterRegistry)
            .record(duration, TimeUnit.MILLISECONDS);
    }
}

/**
 * AuditLogAspect - å®¡è®¡æ—¥å¿—åˆ‡é¢
 */
@Aspect
@Component
public class AuditLogAspect {
    
    @Resource
    private AuditLogDao auditLogDao;
    
    @Around("@annotation(auditLog)")
    public Object around(ProceedingJoinPoint pjp, AuditLog auditLog) throws Throwable {
        long startTime = System.currentTimeMillis();
        
        // è·å–ç”¨æˆ·ä¿¡æ¯
        UserContext userContext = UserContextHolder.get();
        
        // è·å–è¯·æ±‚å‚æ•°
        Object[] args = pjp.getArgs();
        String params = JSON.toJSONString(args);
        
        Object result = null;
        Exception exception = null;
        
        try {
            result = pjp.proceed();
            return result;
        } catch (Exception e) {
            exception = e;
            throw e;
        } finally {
            long duration = System.currentTimeMillis() - startTime;
            
            // è®°å½•å®¡è®¡æ—¥å¿—
            AuditLogEntity log = new AuditLogEntity();
            log.setUserId(userContext.getUserId());
            log.setUserName(userContext.getUserName());
            log.setModule(auditLog.module());
            log.setOperationType(auditLog.operationType());
            log.setDescription(auditLog.description());
            log.setParams(params);
            log.setResult(exception == null ? "SUCCESS" : "FAILED");
            log.setErrorMessage(exception != null ? exception.getMessage() : null);
            log.setDuration(duration);
            log.setOperationTime(LocalDateTime.now());
            
            auditLogDao.insert(log);
        }
    }
}
```

### **3.6 microservices-common-export - å¯¼å‡ºç»„ä»¶**

```java
/**
 * ExcelExportService - Excelå¯¼å‡º
 */
@Component
public class ExcelExportService {
    
    public <T> void exportExcel(
            List<T> data, 
            Class<T> clazz, 
            HttpServletResponse response) {
        
        try {
            response.setContentType("application/vnd.ms-excel");
            response.setCharacterEncoding("utf-8");
            String filename = URLEncoder.encode(
                "export_" + System.currentTimeMillis(), 
                "UTF-8"
            );
            response.setHeader(
                "Content-Disposition", 
                "attachment;filename=" + filename + ".xlsx"
            );
            
            EasyExcel.write(response.getOutputStream(), clazz)
                .sheet("Sheet1")
                .doWrite(data);
                
        } catch (Exception e) {
            throw new ExportException("Excelå¯¼å‡ºå¤±è´¥", e);
        }
    }
}
```

### **3.7 microservices-common-workflow - å·¥ä½œæµç»„ä»¶**

ï¼ˆå·²åœ¨oa-serviceä¸­è®¾è®¡ï¼‰

### **3.8 microservices-common-permission - æƒé™ç»„ä»¶**

```java
/**
 * PermissionValidator - æƒé™éªŒè¯å™¨
 */
@Component
public class PermissionValidator {
    
    @Resource
    private UserPermissionDao permissionDao;
    
    /**
     * éªŒè¯ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®åŒºåŸŸ
     */
    public boolean hasAreaPermission(Long userId, Long areaId) {
        UserAreaPermissionEntity permission = 
            permissionDao.selectByUserAndArea(userId, areaId);
        
        if (permission == null) {
            return false;
        }
        
        // æ£€æŸ¥æƒé™æ˜¯å¦è¿‡æœŸ
        if (permission.getEndTime() != null && 
            LocalDateTime.now().isAfter(permission.getEndTime())) {
            return false;
        }
        
        return true;
    }
}
```

### **3.9 microservices-common-business - ä¸šåŠ¡ç»„ä»¶**

ï¼ˆåŒ…å«æ‰€æœ‰å…±äº«å®ä½“ã€DAOã€Managerï¼‰

### **3.10 microservices-common - èšåˆç»„ä»¶**

ï¼ˆæ•´åˆä¸Šè¿°æ‰€æœ‰ç»„ä»¶ï¼‰

---

## ğŸ¯ **å››ã€å®Œæ•´ä¸šåŠ¡åœºæ™¯è®¾è®¡**

### **åœºæ™¯1ï¼šå‘˜å·¥åˆ·è„¸é—¨ç¦é€šè¡Œï¼ˆå®Œæ•´æµç¨‹ï¼‰**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åœºæ™¯: å‘˜å·¥åˆ·è„¸é—¨ç¦é€šè¡Œ                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1ï¸âƒ£ å‘˜å·¥åœ¨é—¨ç¦è®¾å¤‡åˆ·è„¸
   â””â”€> device-comm-service æ¥æ”¶è®¾å¤‡äº‹ä»¶
       â””â”€> è°ƒç”¨ biometric-service è¿›è¡Œäººè„¸è¯†åˆ«
           â””â”€> FaceRecognitionStrategy.identify()
               â””â”€> è¿”å› userId + matchScore
               
2ï¸âƒ£ è°ƒç”¨ access-service éªŒè¯æƒé™
   â””â”€> BiometricAccessFlow.processAccess()
       â””â”€> TimeBasedAccessStrategy.hasPermission()
       â””â”€> GeofenceAccessStrategy.hasPermission()
       â””â”€> RoleBasedAccessStrategy.hasPermission()
           â””â”€> æƒé™éªŒè¯é€šè¿‡
           
3ï¸âƒ£ ä¸‹å‘å¼€é—¨æŒ‡ä»¤
   â””â”€> DeviceCommandService.execute(OPEN_DOOR)
       â””â”€> HikvisionProtocolAdapter.sendCommand()
           â””â”€> é—¨ç¦è®¾å¤‡å¼€é—¨5ç§’
           
4ï¸âƒ£ è®°å½•é€šè¡Œäº‹ä»¶
   â””â”€> AccessRecordDao.insert(record)
   â””â”€> WebSocketå®æ—¶æ¨é€ç›‘æ§ç«¯
   â””â”€> RabbitMQå¼‚æ­¥æ¶ˆæ¯
   
5ï¸âƒ£ è§†é¢‘è”åŠ¨å½•åƒ
   â””â”€> video-service æ¥æ”¶MQæ¶ˆæ¯
       â””â”€> å¯åŠ¨è¯¥åŒºåŸŸæ‰€æœ‰æ‘„åƒå¤´å½•åƒ5åˆ†é’Ÿ
       â””â”€> VideoRecordDao.insert(record)
       
æ¶‰åŠæœåŠ¡: 5ä¸ª (gateway â†’ device-comm â†’ biometric â†’ access â†’ video)
è®¾è®¡æ¨¡å¼: ç­–ç•¥æ¨¡å¼ + æ¨¡æ¿æ–¹æ³• + è£…é¥°å™¨
æ€§èƒ½æŒ‡æ ‡: ç«¯åˆ°ç«¯å“åº” < 500ms
```

### **åœºæ™¯2ï¼šè®¿å®¢é¢„çº¦+ç°åœºç­¾åˆ°ï¼ˆå®Œæ•´æµç¨‹ï¼‰**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åœºæ™¯: è®¿å®¢é¢„çº¦+ç°åœºç­¾åˆ°                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1ï¸âƒ£ è®¿å®¢åœ¨å¾®ä¿¡å°ç¨‹åºæäº¤é¢„çº¦
   â””â”€> visitor-service.submitAppointment()
       â””â”€> åˆ›å»ºé¢„çº¦è®°å½• (status=PENDING)
       â””â”€> å¯åŠ¨å®¡æ‰¹æµç¨‹
           â””â”€> oa-service.startProcess("visitor_appointment")
               â””â”€> åˆ›å»ºWorkflowInstance + é¦–ä¸ªTask
               â””â”€> é€šçŸ¥è¢«è®¿äººå®¡æ‰¹
               
2ï¸âƒ£ è¢«è®¿äººå®¡æ‰¹é€šè¿‡
   â””â”€> oa-service.completeTask(approved=true)
       â””â”€> visitor-service æ›´æ–°é¢„çº¦çŠ¶æ€ (status=APPROVED)
           â””â”€> ç”ŸæˆäºŒç»´ç é€šè¡Œè¯ (QR Code)
           â””â”€> å‘é€é€šè¡Œè¯åˆ°è®¿å®¢æ‰‹æœº
           â””â”€> ä¸´æ—¶æˆæƒé—¨ç¦æƒé™
               â””â”€> access-service.grantTemporaryPermission()
                   â””â”€> åˆ›å»º UserAreaPermissionEntity (ä¸´æ—¶)
                   
3ï¸âƒ£ è®¿å®¢åˆ°è¾¾ç°åœºæ‰«ç ç­¾åˆ°
   â””â”€> visitor-service.checkIn(qrCode)
       â””â”€> éªŒè¯äºŒç»´ç  + æ—¶é—´èŒƒå›´
       â””â”€> å¯é€‰äººè„¸éªŒè¯
           â””â”€> biometric-service.verify(FACE)
       â””â”€> åˆ›å»ºç­¾åˆ°è®°å½• (CheckInRecord)
       â””â”€> æ›´æ–°é¢„çº¦çŠ¶æ€ (status=CHECKED_IN)
       â””â”€> å¼€å§‹è½¨è¿¹è¿½è¸ª
           â””â”€> æ¯æ¬¡é€šè¿‡é—¨ç¦/æ‘„åƒå¤´è¯†åˆ«
               â””â”€> visitor-service.recordTrackingPoint()
                   â””â”€> Rediså®æ—¶è½¨è¿¹
                   â””â”€> WebSocketæ¨é€ç›‘æ§ç«¯
                   â””â”€> æ£€æŸ¥æœªæˆæƒåŒºåŸŸ
                       â””â”€> è§¦å‘å‘Šè­¦ (SMS + WebSocket)
                       
4ï¸âƒ£ è®¿å®¢ç¦»å¼€ç­¾å‡º
   â””â”€> visitor-service.checkOut()
       â””â”€> æ›´æ–°é¢„çº¦çŠ¶æ€ (status=CHECKED_OUT)
       â””â”€> åœæ­¢è½¨è¿¹è¿½è¸ª
       â””â”€> æ’¤é”€ä¸´æ—¶æƒé™
       
æ¶‰åŠæœåŠ¡: 4ä¸ª (visitor â†’ oa â†’ access â†’ biometric)
è®¾è®¡æ¨¡å¼: å·¥ä½œæµå¼•æ“ + çŠ¶æ€æœº + è§‚å¯Ÿè€…
æ€§èƒ½æŒ‡æ ‡: é¢„çº¦æäº¤ < 300ms, ç­¾åˆ° < 200ms
```

### **åœºæ™¯3ï¼šè€ƒå‹¤æœˆæŠ¥ç”Ÿæˆï¼ˆå®Œæ•´æµç¨‹ï¼‰**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åœºæ™¯: è€ƒå‹¤æœˆæŠ¥ç”Ÿæˆ                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1ï¸âƒ£ å®šæ—¶ä»»åŠ¡è§¦å‘æœˆæŠ¥ç”Ÿæˆ
   â””â”€> @Scheduled(cron = "0 0 2 1 * ?")  // æ¯æœˆ1å·å‡Œæ™¨2ç‚¹
       â””â”€> attendance-service.generateMonthlyReport()
           â””â”€> æŸ¥è¯¢ä¸Šæœˆæ‰€æœ‰æ‰“å¡è®°å½•
               â””â”€> AttendanceRecordDao.selectByMonth()
               
2ï¸âƒ£ åº”ç”¨è€ƒå‹¤è§„åˆ™è®¡ç®—
   â””â”€> æŒ‰ç”¨æˆ·åˆ†ç»„ç»Ÿè®¡
       â””â”€> StandardWorkingHoursStrategy.calculate()
           â””â”€> è®¡ç®—è¿Ÿåˆ°/æ—©é€€/ç¼ºå‹¤
       â””â”€> FlexibleWorkingHoursStrategy.calculate()
           â””â”€> è®¡ç®—æ€»å·¥æ—¶
           
3ï¸âƒ£ æ±‡æ€»ç»Ÿè®¡æ•°æ®
   â””â”€> EmployeeAttendanceSummary
       - æ­£å¸¸å¤©æ•°: 20å¤©
       - è¿Ÿåˆ°æ¬¡æ•°: 2æ¬¡
       - æ—©é€€æ¬¡æ•°: 0æ¬¡
       - ç¼ºå‹¤æ¬¡æ•°: 1å¤©
       - åŠ ç­æ—¶é•¿: 30å°æ—¶
       
4ï¸âƒ£ å¯¼å‡ºExcelæŠ¥è¡¨
   â””â”€> export-service.exportExcel()
       â””â”€> EasyExcel.write()
           â””â”€> ç”Ÿæˆ attendance_report_202412.xlsx
           
5ï¸âƒ£ å‘é€é‚®ä»¶é€šçŸ¥
   â””â”€> oa-service.sendEmail()
       â””â”€> éƒ¨é—¨ç»ç† + HR
       â””â”€> é™„ä»¶: ExcelæŠ¥è¡¨
       
æ¶‰åŠæœåŠ¡: 3ä¸ª (attendance â†’ export â†’ oa)
è®¾è®¡æ¨¡å¼: ç­–ç•¥æ¨¡å¼(è§„åˆ™å¼•æ“) + æ¨¡æ¿æ–¹æ³•
æ€§èƒ½æŒ‡æ ‡: 1000äººæœˆæŠ¥ç”Ÿæˆ < 10s
```

### **åœºæ™¯4ï¼šæ¶ˆè´¹ç¦»çº¿åŒæ­¥ï¼ˆå®Œæ•´æµç¨‹ï¼‰**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åœºæ™¯: æ¶ˆè´¹æœºç¦»çº¿æ¶ˆè´¹åŒæ­¥                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1ï¸âƒ£ ç¦»çº¿æ¶ˆè´¹å‘ç”Ÿ
   â””â”€> æ¶ˆè´¹æœºæ— ç½‘ç»œè¿æ¥
       â””â”€> æœ¬åœ°éªŒè¯ä½™é¢ (ç¦»çº¿ç™½åå•)
       â””â”€> è®°å½•ç¦»çº¿æ¶ˆè´¹
           â””â”€> offlineId: OFL20251218001
           â””â”€> userId, amount, timestamp
           
2ï¸âƒ£ ç½‘ç»œæ¢å¤åä¸Šä¼ ç¦»çº¿è®°å½•
   â””â”€> device-comm-service æ¥æ”¶è®¾å¤‡ä¸Šä¼ 
       â””â”€> æ‰¹é‡ç¦»çº¿æ¶ˆè´¹è®°å½• (1000æ¡)
       â””â”€> è°ƒç”¨ consume-service.syncOfflineRecords()
       
3ï¸âƒ£ æ‰¹é‡åŒæ­¥å¤„ç†
   â””â”€> OfflineConsumeProcessor.syncOfflineRecords()
       â””â”€> é€æ¡å¤„ç†:
           - éªŒè¯åˆæ³•æ€§
           - é˜²é‡å¤æ¶ˆè´¹æ£€æŸ¥ (offlineIdå»é‡)
           - è¡¥æ‰£è´¦æˆ·ä½™é¢
           - åˆ›å»ºåœ¨çº¿æ¶ˆè´¹è®°å½•
       â””â”€> è¿”å›åŒæ­¥ç»“æœ:
           - æˆåŠŸ: 980æ¡
           - å¤±è´¥: 15æ¡ (ä½™é¢ä¸è¶³)
           - é‡å¤: 5æ¡
           
4ï¸âƒ£ å¼‚å¸¸å¤„ç†
   â””â”€> ä½™é¢ä¸è¶³çš„è®°å½•
       â””â”€> åˆ›å»ºæ¬ è´¹è®°å½•
       â””â”€> å‘é€å‚¬ç¼´é€šçŸ¥
   â””â”€> é‡å¤è®°å½•
       â””â”€> è®°å½•æ—¥å¿—,ä¸¢å¼ƒ
       
æ¶‰åŠæœåŠ¡: 2ä¸ª (device-comm â†’ consume)
è®¾è®¡æ¨¡å¼: æ‰¹å¤„ç†æ¨¡å¼ + è¡¥å¿äº‹åŠ¡
æ€§èƒ½æŒ‡æ ‡: 1000æ¡åŒæ­¥ < 5s
```

---

## ğŸš€ **äº”ã€ä¼ä¸šçº§æ€§èƒ½ä¼˜åŒ–å®Œæ•´æ–¹æ¡ˆ**

### **5.1 è¿æ¥æ± ä¼˜åŒ–**

```java
/**
 * DeviceConnectionPoolManager - è®¾å¤‡è¿æ¥æ± 
 */
@Component
public class DeviceConnectionPoolManager {
    
    private final Map<String, GenericObjectPool<DeviceConnection>> pools 
        = new ConcurrentHashMap<>();
    
    public DeviceConnection borrowConnection(String deviceId) throws Exception {
        return getOrCreatePool(deviceId).borrowObject();
    }
    
    public void returnConnection(String deviceId, DeviceConnection connection) {
        GenericObjectPool<DeviceConnection> pool = pools.get(deviceId);
        if (pool != null) {
            pool.returnObject(connection);
        }
    }
    
    private GenericObjectPool<DeviceConnection> getOrCreatePool(String deviceId) {
        return pools.computeIfAbsent(deviceId, id -> {
            GenericObjectPoolConfig<DeviceConnection> config 
                = new GenericObjectPoolConfig<>();
            config.setMaxTotal(5);        // æœ€å¤§è¿æ¥æ•°
            config.setMaxIdle(2);         // æœ€å¤§ç©ºé—²è¿æ¥
            config.setMinIdle(1);         // æœ€å°ç©ºé—²è¿æ¥
            config.setTestOnBorrow(true); // å€Ÿç”¨æ—¶æµ‹è¯•
            
            return new GenericObjectPool<>(
                new DeviceConnectionFactory(id), 
                config
            );
        });
    }
}
```

### **5.2 å¯¹è±¡æ± ä¼˜åŒ–**

```java
/**
 * FeatureVectorPool - ç‰¹å¾å‘é‡å¯¹è±¡æ± 
 */
@Component
public class FeatureVectorPool {
    
    private final GenericObjectPool<float[]> vectorPool;
    
    public FeatureVectorPool() {
        GenericObjectPoolConfig<float[]> config = new GenericObjectPoolConfig<>();
        config.setMaxTotal(1000);
        config.setMaxIdle(100);
        config.setMinIdle(10);
        
        this.vectorPool = new GenericObjectPool<>(
            new BasePooledObjectFactory<float[]>() {
                @Override
                public float[] create() {
                    return new float[512];  // FaceNetå‘é‡ç»´åº¦
                }
                
                @Override
                public PooledObject<float[]> wrap(float[] obj) {
                    return new DefaultPooledObject<>(obj);
                }
            },
            config
        );
    }
    
    public float[] borrowVector() throws Exception {
        return vectorPool.borrowObject();
    }
    
    public void returnVector(float[] vector) {
        Arrays.fill(vector, 0);  // æ¸…ç©ºæ•°æ®
        vectorPool.returnObject(vector);
    }
}
```

### **5.3 å¼‚æ­¥ä»»åŠ¡ç¼–æ’**

```java
/**
 * AsyncTaskConfiguration - å¼‚æ­¥ä»»åŠ¡é…ç½®
 */
@Configuration
@EnableAsync
public class AsyncTaskConfiguration {
    
    @Bean("attendanceStatExecutor")
    public Executor attendanceStatExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("attendance-stat-");
        executor.setRejectedExecutionHandler(
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
        executor.initialize();
        return executor;
    }
    
    @Bean("reportExecutor")
    public Executor reportExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(3);
        executor.setMaxPoolSize(5);
        executor.setQueueCapacity(50);
        executor.setThreadNamePrefix("report-");
        executor.initialize();
        return executor;
    }
}
```

### **5.4 æ€§èƒ½ç›‘æ§æŒ‡æ ‡**

```yaml
management:
  endpoints:
    web:
      exposure:
        include: "*"
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
      environment: ${spring.profiles.active}
```

---

## ğŸ“… **å…­ã€10å‘¨å®æ–½è·¯çº¿å›¾**

### **Phase 1: åŸºç¡€è®¾æ–½é‡æ„ (Week 1-2)**

**ç›®æ ‡**: æ­å»ºä¼ä¸šçº§åŸºç¡€è®¾æ–½

**ä»»åŠ¡æ¸…å•**:
- [ ] åˆ›å»º biometric-service æ–°æœåŠ¡
- [ ] å®ç°ç­–ç•¥å·¥å‚ StrategyFactory
- [ ] å®ç° UnifiedCacheManager å¤šçº§ç¼“å­˜
- [ ] é…ç½® Resilience4j é™æµç†”æ–­
- [ ] é…ç½® Prometheus + Grafana ç›‘æ§

**äº¤ä»˜ç‰©**:
- biometric-service åŸºç¡€éª¨æ¶
- å…¬å…±ç»„ä»¶åº“å‡çº§
- ç›‘æ§ä»ªè¡¨æ¿

### **Phase 2: æ¨¡å—æ‹†åˆ†é‡æ„ (Week 3-5)**

**ç›®æ ‡**: å®Œæˆæ ¸å¿ƒæ¨¡å—æ‹†åˆ†

**ä»»åŠ¡æ¸…å•**:
- [ ] è¿ç§»ç”Ÿç‰©è¯†åˆ«åŠŸèƒ½åˆ° biometric-service
- [ ] å®ç° 5 å¤§è¯†åˆ«ç­–ç•¥ (äººè„¸/æŒ‡çº¹/è™¹è†œ/æŒçº¹/å£°çº¹)
- [ ] å®ç°æ¨¡æ¿åŒæ­¥æœåŠ¡
- [ ] ä¿®æ­£ access-service çš„ package å£°æ˜é”™è¯¯
- [ ] æ–°å¢ UserAreaPermissionEntity ç­‰4ä¸ªå®ä½“

**äº¤ä»˜ç‰©**:
- biometric-service å®Œæ•´åŠŸèƒ½
- æƒé™æ¨¡å‹å®Œå–„
- EntityåŒ…ç»“æ„è§„èŒƒ

### **Phase 3: è®¾è®¡æ¨¡å¼åº”ç”¨ (Week 6-7)**

**ç›®æ ‡**: å……åˆ†åº”ç”¨ä¼ä¸šçº§è®¾è®¡æ¨¡å¼

**ä»»åŠ¡æ¸…å•**:
- [ ] ç­–ç•¥æ¨¡å¼: è¯†åˆ«ç®—æ³•/è€ƒå‹¤è§„åˆ™/æ¶ˆè´¹æ¨¡å¼
- [ ] å·¥å‚æ¨¡å¼: è®¾å¤‡é€‚é…å™¨/è§†é¢‘æµé€‚é…å™¨
- [ ] è£…é¥°å™¨æ¨¡å¼: æ‰“å¡æµç¨‹å¢å¼º/å‘½ä»¤å¢å¼º
- [ ] æ¨¡æ¿æ–¹æ³•: é€šè¡Œæµç¨‹/æ¨¡æ¿åŒæ­¥æµç¨‹
- [ ] ä¾èµ–å€’ç½®: æ‰€æœ‰ Strategy/Adapter æ¥å£åŒ–

**äº¤ä»˜ç‰©**:
- 5å¤§è®¾è®¡æ¨¡å¼å®Œæ•´å®ç°
- ä»£ç å¤ç”¨ç‡æå‡ 40%+

### **Phase 4: æ€§èƒ½ä¼˜åŒ– (Week 8-9)**

**ç›®æ ‡**: è¾¾åˆ°ä¼ä¸šçº§æ€§èƒ½æ ‡å‡†

**ä»»åŠ¡æ¸…å•**:
- [ ] è®¾å¤‡è¿æ¥æ± ä¼˜åŒ–
- [ ] ç‰¹å¾å‘é‡å¯¹è±¡æ± ä¼˜åŒ–
- [ ] å¤šçº§ç¼“å­˜å…¨é¢åº”ç”¨
- [ ] å¼‚æ­¥ä»»åŠ¡ç¼–æ’ä¼˜åŒ–
- [ ] æ…¢æŸ¥è¯¢ä¼˜åŒ– (ç´¢å¼•/åˆ†é¡µ)

**äº¤ä»˜ç‰©**:
- å“åº”æ—¶é—´é™ä½ 50%+
- å¹¶å‘èƒ½åŠ›æå‡ 300%+
- å†…å­˜å ç”¨é™ä½ 30%+

### **Phase 5: æ–‡æ¡£ä¸è§„èŒƒ (Week 10)**

**ç›®æ ‡**: å®Œå–„æ–‡æ¡£å’Œç¼–ç è§„èŒƒ

**ä»»åŠ¡æ¸…å•**:
- [ ] æ›´æ–°æ‰€æœ‰æ¶æ„æ–‡æ¡£
- [ ] æ›´æ–°æ‰€æœ‰APIæ–‡æ¡£
- [ ] æ›´æ–°æ‰€æœ‰å¾®æœåŠ¡æ–‡æ¡£
- [ ] ç¼–å†™å¼€å‘æŒ‡å—
- [ ] ç¼–å†™éƒ¨ç½²æ‰‹å†Œ

**äº¤ä»˜ç‰©**:
- å®Œæ•´æ–‡æ¡£ä½“ç³» (100+ æ–‡æ¡£)
- å¼€å‘è§„èŒƒæ‰‹å†Œ
- è¿ç»´æ‰‹å†Œ

---

âœ… **å®Œæ•´çš„11ä¸ªå¾®æœåŠ¡**å…¨é¢é‡æ„è®¾è®¡  
âœ… **å®Œæ•´çš„10ä¸ªå…¬å…±ç»„ä»¶**ä¼ä¸šçº§æ ‡å‡†å®ç°  
âœ… **5å¤§è®¾è®¡æ¨¡å¼**å……åˆ†åº”ç”¨  
âœ… **å…¨ä¸šåŠ¡åœºæ™¯**100%è¦†ç›–  
âœ… **æ€§èƒ½ä¼˜åŒ–**æ¶æ„å…¨é¢å‡çº§  
âœ… **10å‘¨å®æ–½è·¯çº¿å›¾**æ¸…æ™°å¯æ‰§è¡Œ  

é€šè¿‡æœ¬æ–¹æ¡ˆçš„å®æ–½ï¼ŒIOE-DREAMé¡¹ç›®å°†è¾¾åˆ°ï¼š
- **ä¼ä¸šçº§æ¶æ„æ ‡å‡†**
- **é«˜æ€§èƒ½**ï¼ˆå“åº”æ—¶é—´â†“50%ï¼Œå¹¶å‘â†‘300%ï¼‰
- **ä½å†…å­˜**ï¼ˆå†…å­˜å ç”¨â†“40%ï¼‰
- **é«˜å¯æ‰©å±•æ€§**ï¼ˆæ¨¡å—åŒ–+ç»„ä»¶åŒ–+ç­–ç•¥åŒ–ï¼‰
- **é«˜å¯ç»´æŠ¤æ€§**ï¼ˆä»£ç å¤ç”¨ç‡â†‘42%ï¼‰

---

**æ–‡æ¡£ç‰ˆæœ¬**: v3.0.0-COMPLETE  
**æœ€åæ›´æ–°**: 2025-12-18  
**å®¡æ ¸çŠ¶æ€**: âœ… å·²å®Œæˆ  
**å®æ–½çŠ¶æ€**: â³ å¾…å®æ–½
