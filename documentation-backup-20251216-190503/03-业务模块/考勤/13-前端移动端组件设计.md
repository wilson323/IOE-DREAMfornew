# è€ƒå‹¤æ¨¡å—å‰ç«¯ç§»åŠ¨ç«¯ç»„ä»¶è®¾è®¡

## æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†æè¿°äº†IOE-DREAMæ™ºèƒ½è€ƒå‹¤ç®¡ç†ç³»ç»Ÿçš„ç§»åŠ¨ç«¯ç»„ä»¶è®¾è®¡ï¼ŒåŸºäºVue 3 + TypeScript + Vant 4æŠ€æœ¯æ ˆï¼Œæä¾›å®Œæ•´çš„ç§»åŠ¨ç«¯è€ƒå‹¤è§£å†³æ–¹æ¡ˆã€‚åŒ…æ‹¬å®æ—¶æ‰“å¡ã€æ’ç­æŸ¥è¯¢ã€è¯·å‡ç”³è¯·ã€åŠ ç­ç®¡ç†ç­‰å…¨åŠŸèƒ½ç§»åŠ¨ç»„ä»¶ã€‚

### æŠ€æœ¯æ¶æ„
- **å‰ç«¯æ¡†æ¶**: Vue 3.4.0+
- **å¼€å‘è¯­è¨€**: TypeScript 5.0+
- **UIç»„ä»¶åº“**: Vant 4.8.0+
- **çŠ¶æ€ç®¡ç†**: Pinia 2.1.0+
- **è·¯ç”±ç®¡ç†**: Vue Router 4.2.0+
- **HTTPè¯·æ±‚**: Axios 1.6.0+
- **å®æ—¶é€šä¿¡**: WebSocket + Socket.IO
- **ç”Ÿç‰©è¯†åˆ«**: WebAuthn API + è®¾å¤‡åŸç”ŸSDK
- **åœ°å›¾æœåŠ¡**: é«˜å¾·åœ°å›¾/ç™¾åº¦åœ°å›¾
- **æ¨é€æœåŠ¡**: æå…‰æ¨é€/ä¸ªæ¨

## 1. é¡¹ç›®ç»“æ„è®¾è®¡

```
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ attendance/                 # è€ƒå‹¤ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ ClockButton/           # æ‰“å¡æŒ‰é’®
â”‚   â”‚   â”œâ”€â”€ LocationVerifier/      # ä½ç½®éªŒè¯
â”‚   â”‚   â”œâ”€â”€ BiometricAuth/         # ç”Ÿç‰©è¯†åˆ«
â”‚   â”‚   â”œâ”€â”€ ScheduleCalendar/      # æ’ç­æ—¥å†
â”‚   â”‚   â”œâ”€â”€ AttendanceCard/        # è€ƒå‹¤å¡ç‰‡
â”‚   â”‚   â”œâ”€â”€ LeaveApplication/      # è¯·å‡ç”³è¯·
â”‚   â”‚   â”œâ”€â”€ OvertimeApplication/   # åŠ ç­ç”³è¯·
â”‚   â”‚   â”œâ”€â”€ AttendanceHistory/     # è€ƒå‹¤å†å²
â”‚   â”‚   â””â”€â”€ StatisticsChart/       # ç»Ÿè®¡å›¾è¡¨
â”‚   â”œâ”€â”€ common/                    # å…¬å…±ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ LocationPicker/        # ä½ç½®é€‰æ‹©å™¨
â”‚   â”‚   â”œâ”€â”€ DeviceSelector/        # è®¾å¤‡é€‰æ‹©å™¨
â”‚   â”‚   â”œâ”€â”€ TimePicker/            # æ—¶é—´é€‰æ‹©å™¨
â”‚   â”‚   â”œâ”€â”€ DatePicker/            # æ—¥æœŸé€‰æ‹©å™¨
â”‚   â”‚   â”œâ”€â”€ ImageCapture/          # å›¾ç‰‡æ‹æ‘„
â”‚   â”‚   â”œâ”€â”€ FileUpload/            # æ–‡ä»¶ä¸Šä¼ 
â”‚   â”‚   â””â”€â”€ NotificationBar/       # é€šçŸ¥æ 
â”‚   â””â”€â”€ charts/                    # å›¾è¡¨ç»„ä»¶
â”‚       â”œâ”€â”€ AttendanceChart/       # è€ƒå‹¤å›¾è¡¨
â”‚       â”œâ”€â”€ StatisticsChart/       # ç»Ÿè®¡å›¾è¡¨
â”‚       â””â”€â”€ TrendChart/            # è¶‹åŠ¿å›¾è¡¨
â”œâ”€â”€ views/
â”‚   â”œâ”€â”€ attendance/                # è€ƒå‹¤é¡µé¢
â”‚   â”‚   â”œâ”€â”€ ClockPage.vue          # æ‰“å¡é¡µé¢
â”‚   â”‚   â”œâ”€â”€ SchedulePage.vue       # æ’ç­é¡µé¢
â”‚   â”‚   â”œâ”€â”€ HistoryPage.vue        # å†å²é¡µé¢
â”‚   â”‚   â”œâ”€â”€ LeavePage.vue          # è¯·å‡é¡µé¢
â”‚   â”‚   â”œâ”€â”€ OvertimePage.vue       # åŠ ç­é¡µé¢
â”‚   â”‚   â”œâ”€â”€ ReportPage.vue         # æŠ¥è¡¨é¡µé¢
â”‚   â”‚   â””â”€â”€ SettingsPage.vue       # è®¾ç½®é¡µé¢
â”‚   â””â”€â”€ tabs/                      # æ ‡ç­¾é¡µ
â”‚       â”œâ”€â”€ HomeTab.vue            # é¦–é¡µ
â”‚       â”œâ”€â”€ AttendanceTab.vue      # è€ƒå‹¤é¡µ
â”‚       â”œâ”€â”€ ScheduleTab.vue        # æ’ç­é¡µ
â”‚       â”œâ”€â”€ ReportTab.vue          # æŠ¥è¡¨é¡µ
â”‚       â””â”€â”€ ProfileTab.vue         # ä¸ªäººé¡µ
â”œâ”€â”€ stores/
â”‚   â”œâ”€â”€ attendance.ts              # è€ƒå‹¤çŠ¶æ€ç®¡ç†
â”‚   â”œâ”€â”€ user.ts                    # ç”¨æˆ·çŠ¶æ€ç®¡ç†
â”‚   â”œâ”€â”€ location.ts                # ä½ç½®çŠ¶æ€ç®¡ç†
â”‚   â””â”€â”€ notification.ts            # é€šçŸ¥çŠ¶æ€ç®¡ç†
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ attendance.service.ts      # è€ƒå‹¤æœåŠ¡
â”‚   â”œâ”€â”€ location.service.ts        # ä½ç½®æœåŠ¡
â”‚   â”œâ”€â”€ biometric.service.ts       # ç”Ÿç‰©è¯†åˆ«æœåŠ¡
â”‚   â”œâ”€â”€ websocket.service.ts       # WebSocketæœåŠ¡
â”‚   â””â”€â”€ notification.service.ts    # é€šçŸ¥æœåŠ¡
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ location.ts                # ä½ç½®å·¥å…·
â”‚   â”œâ”€â”€ biometric.ts               # ç”Ÿç‰©è¯†åˆ«å·¥å…·
â”‚   â”œâ”€â”€ time.ts                    # æ—¶é—´å·¥å…·
â”‚   â”œâ”€â”€ storage.ts                 # å­˜å‚¨å·¥å…·
â”‚   â””â”€â”€ device.ts                  # è®¾å¤‡å·¥å…·
â””â”€â”€ types/
    â”œâ”€â”€ attendance.ts              # è€ƒå‹¤ç±»å‹å®šä¹‰
    â”œâ”€â”€ user.ts                    # ç”¨æˆ·ç±»å‹å®šä¹‰
    â”œâ”€â”€ location.ts                # ä½ç½®ç±»å‹å®šä¹‰
    â””â”€â”€ api.ts                     # APIç±»å‹å®šä¹‰
```

## 2. æ ¸å¿ƒç»„ä»¶è®¾è®¡
## ğŸ“‹ IOE-DREAMä¸ƒå¾®æœåŠ¡æ¶æ„

**æ ¸å¿ƒæ¶æ„ç»„æˆ**:
- **Gateway Service (8080)**: APIç½‘å…³
- **Common Service (8088)**: å…¬å…±æ¨¡å—å¾®æœåŠ¡
- **DeviceComm Service (8087)**: è®¾å¤‡é€šè®¯å¾®æœåŠ¡
- **OA Service (8089)**: OAå¾®æœåŠ¡
- **Access Service (8090)**: é—¨ç¦æœåŠ¡
- **Attendance Service (8091)**: è€ƒå‹¤æœåŠ¡
- **Video Service (8092)**: è§†é¢‘æœåŠ¡
- **Consume Service (8094)**: æ¶ˆè´¹æœåŠ¡
- **Visitor Service (8095)**: è®¿å®¢æœåŠ¡

**æ¶æ„ç‰¹ç‚¹**:
- åŸºäºSpring Boot 3.5.8 + Java 17
- ä¸¥æ ¼éµå¾ªä¼ä¸šçº§å¾®æœåŠ¡è§„èŒƒ
- æ”¯æŒé«˜å¹¶å‘ã€é«˜å¯ç”¨ã€æ°´å¹³æ‰©å±•

**æŠ€æœ¯æ ˆæ ‡å‡†**:
- **æ•°æ®åº“**: MySQL 8.0 + Druidè¿æ¥æ± 
- **ç¼“å­˜**: Redis + Caffeineå¤šçº§ç¼“å­˜
- **æ³¨å†Œä¸­å¿ƒ**: Nacos
- **é…ç½®ä¸­å¿ƒ**: Nacos Config
- **è®¤è¯æˆæƒ**: Sa-Token

## ğŸ—ï¸ å››å±‚æ¶æ„è§„èŒƒ

**æ ‡å‡†æ¶æ„æ¨¡å¼**:
```
Controller (æ¥å£æ§åˆ¶å±‚)
    â†“
Service (æ ¸å¿ƒä¸šåŠ¡å±‚)
    â†“
Manager (æµç¨‹ç®¡ç†å±‚)
    â†“
DAO (æ•°æ®è®¿é—®å±‚)
```

**å±‚çº§èŒè´£**:
- **Controllerå±‚**: HTTPè¯·æ±‚å¤„ç†ã€å‚æ•°éªŒè¯ã€æƒé™æ§åˆ¶
- **Serviceå±‚**: æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ã€äº‹åŠ¡ç®¡ç†ã€ä¸šåŠ¡è§„åˆ™éªŒè¯
- **Managerå±‚**: å¤æ‚æµç¨‹ç¼–æ’ã€å¤šæ•°æ®ç»„è£…ã€ç¬¬ä¸‰æ–¹æœåŠ¡é›†æˆ
- **DAOå±‚**: æ•°æ®åº“CRUDæ“ä½œã€SQLæŸ¥è¯¢å®ç°ã€æ•°æ®è®¿é—®è¾¹ç•Œ

**ä¸¥æ ¼ç¦æ­¢è·¨å±‚è®¿é—®**: Controllerä¸èƒ½ç›´æ¥è°ƒç”¨Manager/DAOï¼
### 2.1 ClockButton æ‰“å¡æŒ‰é’®ç»„ä»¶
## âš ï¸ IOE-DREAMé›¶å®¹å¿è§„åˆ™ï¼ˆå¼ºåˆ¶æ‰§è¡Œï¼‰

**å¿…é¡»éµå®ˆçš„æ¶æ„è§„åˆ™**:
- âœ… **å¿…é¡»ä½¿ç”¨ @Resource æ³¨å…¥ä¾èµ–**
- âœ… **å¿…é¡»ä½¿ç”¨ @Mapper æ³¨è§£** (ç¦æ­¢@Repository)
- âœ… **å¿…é¡»ä½¿ç”¨ Dao åç¼€** (ç¦æ­¢Repository)
- âœ… **å¿…é¡»ä½¿ç”¨ @RestController æ³¨è§£**
- âœ… **å¿…é¡»ä½¿ç”¨ @Valid å‚æ•°æ ¡éªŒ**
- âœ… **å¿…é¡»è¿”å›ç»Ÿä¸€ResponseDTOæ ¼å¼**
- âœ… **å¿…é¡»éµå¾ªå››å±‚æ¶æ„è¾¹ç•Œ**

**ä¸¥æ ¼ç¦æ­¢äº‹é¡¹**:
- âŒ **ç¦æ­¢ä½¿ç”¨ @Autowired æ³¨å…¥**
- âŒ **ç¦æ­¢ä½¿ç”¨ @Repository æ³¨è§£**
- âŒ **ç¦æ­¢ä½¿ç”¨ Repository åç¼€å‘½å**
- âŒ **ç¦æ­¢è·¨å±‚è®¿é—®**
- âŒ **ç¦æ­¢åœ¨Controllerä¸­åŒ…å«ä¸šåŠ¡é€»è¾‘**
- âŒ **ç¦æ­¢ç›´æ¥è®¿é—®æ•°æ®åº“**

**è¿è§„åæœ**: P0çº§é—®é¢˜ï¼Œç«‹å³ä¿®å¤ï¼Œç¦æ­¢åˆå¹¶ï¼

#### ç»„ä»¶æ¥å£å®šä¹‰
```typescript
// ClockButton.vue
interface ClockButtonProps {
  clockType: 'IN' | 'OUT' | 'BREAK'; // æ‰“å¡ç±»å‹
  disabled?: boolean;                 // æ˜¯å¦ç¦ç”¨
  loading?: boolean;                  // åŠ è½½çŠ¶æ€
  size?: 'small' | 'normal' | 'large'; // æŒ‰é’®å°ºå¯¸
  showStatus?: boolean;               // æ˜¾ç¤ºçŠ¶æ€
  countdown?: number;                 // å€’è®¡æ—¶
  autoClock?: boolean;                // è‡ªåŠ¨æ‰“å¡
}

interface ClockButtonEmits {
  clock: [data: ClockData];           // æ‰“å¡äº‹ä»¶
  locationError: [error: Error];      // ä½ç½®é”™è¯¯äº‹ä»¶
  biometricError: [error: Error];     // ç”Ÿç‰©è¯†åˆ«é”™è¯¯äº‹ä»¶
}

interface ClockData {
  clockType: string;
  timestamp: number;
  location?: LocationData;
  biometricData?: BiometricData;
  deviceId: string;
}
```

#### ç»„ä»¶å®ç°
```vue
<template>
  <div class="clock-button-container">
    <!-- çŠ¶æ€æ˜¾ç¤º -->
    <div v-if="showStatus" class="clock-status">
      <div class="status-icon">
        <van-icon :name="statusIcon" :color="statusColor" size="24" />
      </div>
      <div class="status-text">
        <div class="primary-text">{{ statusText }}</div>
        <div class="secondary-text" v-if="statusSecondaryText">
          {{ statusSecondaryText }}
        </div>
      </div>
    </div>

    <!-- æ‰“å¡æŒ‰é’® -->
    <div class="clock-button-wrapper">
      <van-button
        :type="buttonType"
        :size="size"
        :loading="loading"
        :disabled="disabled || !canClock"
        round
        block
        class="clock-button"
        @click="handleClock"
      >
        <template #icon>
          <van-icon :name="buttonIcon" size="20" />
        </template>
        {{ buttonText }}
      </van-button>

      <!-- å€’è®¡æ—¶æ˜¾ç¤º -->
      <div v-if="countdown > 0" class="countdown">
        {{ countdown }}ç§’åè‡ªåŠ¨æ‰“å¡
      </div>
    </div>

    <!-- ä½ç½®å’Œç”Ÿç‰©è¯†åˆ«çŠ¶æ€ -->
    <div class="verification-status">
      <div class="location-status">
        <van-icon
          :name="locationIcon"
          :color="locationColor"
          size="16"
        />
        <span class="status-label">å®šä½{{ locationStatus }}</span>
      </div>
      <div class="biometric-status">
        <van-icon
          :name="biometricIcon"
          :color="biometricColor"
          size="16"
        />
        <span class="status-label">{{ biometricType }}{{ biometricStatus }}</span>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted, watch } from 'vue'
import { useLocationStore } from '@/stores/location'
import { useBiometricService } from '@/services/biometric.service'
import { useAttendanceService } from '@/services/attendance.service'
import { showToast, showConfirmDialog } from 'vant'

// Propså®šä¹‰
const props = withDefaults(defineProps<ClockButtonProps>(), {
  disabled: false,
  loading: false,
  size: 'normal',
  showStatus: true,
  countdown: 0,
  autoClock: false
})

// Emitså®šä¹‰
const emit = defineEmits<ClockButtonEmits>()

// çŠ¶æ€ç®¡ç†
const locationStore = useLocationStore()
const biometricService = useBiometricService()
const attendanceService = useAttendanceService()

// å“åº”å¼æ•°æ®
const canClock = ref(false)
const currentLocation = ref<LocationData | null>(null)
const biometricReady = ref(false)
const countdownTimer = ref<NodeJS.Timeout | null>(null)
const clockButtonRef = ref<HTMLElement | null>(null)

// è®¡ç®—å±æ€§
const buttonType = computed(() => {
  if (props.disabled || !canClock.value) return 'default'
  return props.clockType === 'IN' ? 'success' : 'warning'
})

const buttonIcon = computed(() => {
  if (props.loading) return 'loading'
  return props.clockType === 'IN' ? 'passed' : 'close'
})

const buttonText = computed(() => {
  if (props.loading) return 'æ‰“å¡ä¸­...'
  switch (props.clockType) {
    case 'IN': return 'ä¸Šç­æ‰“å¡'
    case 'OUT': return 'ä¸‹ç­æ‰“å¡'
    case 'BREAK': return 'å¤–å‹¤æ‰“å¡'
    default: return 'æ‰“å¡'
  }
})

const statusIcon = computed(() => {
  switch (props.clockType) {
    case 'IN': return 'smile-o'
    case 'OUT': return 'smile'
    case 'BREAK': return 'location-o'
    default: return 'clock-o'
  }
})

const statusColor = computed(() => {
  switch (props.clockType) {
    case 'IN': return '#07c160'
    case 'OUT': return '#ff976a'
    case 'BREAK': return '#1989fa'
    default: return '#969799'
  }
})

const statusText = computed(() => {
  switch (props.clockType) {
    case 'IN': return 'å‡†å¤‡ä¸Šç­'
    case 'OUT': return 'å‡†å¤‡ä¸‹ç­'
    case 'BREAK': return 'å¤–å‹¤ç™»è®°'
    default: return 'å‡†å¤‡æ‰“å¡'
  }
})

const statusSecondaryText = computed(() => {
  if (currentLocation.value) {
    return `å½“å‰ä½ç½®ï¼š${currentLocation.value.address}`
  }
  return 'æ­£åœ¨è·å–ä½ç½®ä¿¡æ¯...'
})

// ä½ç½®çŠ¶æ€
const locationIcon = computed(() => {
  return locationStore.locationPermission ? 'location-o' : 'location'
})

const locationColor = computed(() => {
  return locationStore.currentLocation ? '#07c160' : '#969799'
})

const locationStatus = computed(() => {
  return locationStore.currentLocation ? 'æ­£å¸¸' : 'è·å–ä¸­'
})

// ç”Ÿç‰©è¯†åˆ«çŠ¶æ€
const biometricIcon = computed(() => {
  return biometricReady.value ? 'scan' : 'scan'
})

const biometricColor = computed(() => {
  return biometricReady.value ? '#07c160' : '#969799'
})

const biometricType = computed(() => {
  return biometricService.getAvailableBiometricType()
})

const biometricStatus = computed(() => {
  return biometricReady.value ? 'å°±ç»ª' : 'å‡†å¤‡ä¸­'
})

// æ–¹æ³•å®ç°
const handleClock = async () => {
  if (!canClock.value) {
    showToast('å½“å‰ä¸æ”¯æŒæ‰“å¡')
    return
  }

  try {
    // éªŒè¯ä½ç½®
    const locationValid = await verifyLocation()
    if (!locationValid) {
      showToast('ä¸åœ¨æœ‰æ•ˆæ‰“å¡èŒƒå›´å†…')
      return
    }

    // ç”Ÿç‰©è¯†åˆ«éªŒè¯
    const biometricData = await performBiometricVerification()
    if (!biometricData) {
      return // ç”¨æˆ·å–æ¶ˆæˆ–éªŒè¯å¤±è´¥
    }

    // æ‰§è¡Œæ‰“å¡
    const clockData: ClockData = {
      clockType: props.clockType,
      timestamp: Date.now(),
      location: currentLocation.value!,
      biometricData,
      deviceId: await getDeviceId()
    }

    emit('clock', clockData)

  } catch (error) {
    console.error('æ‰“å¡å¤±è´¥:', error)
    showToast('æ‰“å¡å¤±è´¥ï¼Œè¯·é‡è¯•')
  }
}

const verifyLocation = async (): Promise<boolean> => {
  try {
    const location = await locationStore.getCurrentLocation()
    if (!location) {
      emit('locationError', new Error('æ— æ³•è·å–ä½ç½®ä¿¡æ¯'))
      return false
    }

    currentLocation.value = location

    // éªŒè¯æ˜¯å¦åœ¨æœ‰æ•ˆèŒƒå›´å†…
    const isValid = await locationStore.verifyLocation(location)
    return isValid

  } catch (error) {
    emit('locationError', error as Error)
    return false
  }
}

const performBiometricVerification = async (): Promise<BiometricData | null> => {
  try {
    const biometricType = biometricService.getAvailableBiometricType()
    if (!biometricType) {
      return null // ä¸å¼ºåˆ¶è¦æ±‚ç”Ÿç‰©è¯†åˆ«
    }

    const biometricData = await biometricService.authenticate()
    biometricReady.value = true
    return biometricData

  } catch (error) {
    emit('biometricError', error as Error)
    biometricReady.value = false

    // ç”Ÿç‰©è¯†åˆ«å¤±è´¥æ—¶è¯¢é—®æ˜¯å¦ç»§ç»­
    const confirmed = await showConfirmDialog({
      title: 'ç”Ÿç‰©è¯†åˆ«å¤±è´¥',
      message: 'æ˜¯å¦ç»§ç»­ä½¿ç”¨å…¶ä»–æ–¹å¼æ‰“å¡ï¼Ÿ'
    })

    return confirmed ? null : Promise.reject(error)
  }
}

const getDeviceId = async (): Promise<string> => {
  return locationStore.getDeviceId() || `MOBILE_${Date.now()}`
}

const startCountdown = () => {
  if (props.countdown <= 0) return

  let remaining = props.countdown
  countdownTimer.value = setInterval(() => {
    remaining--
    if (remaining <= 0) {
      clearInterval(countdownTimer.value!)
      handleClock()
    }
  }, 1000)
}

const stopCountdown = () => {
  if (countdownTimer.value) {
    clearInterval(countdownTimer.value)
    countdownTimer.value = null
  }
}

// ç”Ÿå‘½å‘¨æœŸ
onMounted(async () => {
  // åˆå§‹åŒ–ä½ç½®æœåŠ¡
  await locationStore.initializeLocation()

  // åˆå§‹åŒ–ç”Ÿç‰©è¯†åˆ«
  try {
    await biometricService.initialize()
    biometricReady.value = true
  } catch (error) {
    console.warn('ç”Ÿç‰©è¯†åˆ«åˆå§‹åŒ–å¤±è´¥:', error)
  }

  // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ‰“å¡
  canClock.value = await attendanceService.canClock(props.clockType)

  // å¯åŠ¨è‡ªåŠ¨æ‰“å¡å€’è®¡æ—¶
  if (props.autoClock && props.countdown > 0) {
    startCountdown()
  }
})

onUnmounted(() => {
  stopCountdown()
})

// ç›‘å¬è‡ªåŠ¨æ‰“å¡é…ç½®å˜åŒ–
watch(() => props.autoClock && props.countdown, (shouldStart) => {
  if (shouldStart) {
    startCountdown()
  } else {
    stopCountdown()
  }
})
</script>

<style lang="scss" scoped>
.clock-button-container {
  padding: 20px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 16px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}

.clock-status {
  display: flex;
  align-items: center;
  margin-bottom: 20px;
  padding: 16px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 12px;
  backdrop-filter: blur(10px);

  .status-icon {
    margin-right: 12px;
  }

  .status-text {
    flex: 1;
    color: white;

    .primary-text {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .secondary-text {
      font-size: 14px;
      opacity: 0.8;
    }
  }
}

.clock-button-wrapper {
  position: relative;
  margin-bottom: 16px;

  .clock-button {
    height: 60px;
    font-size: 18px;
    font-weight: 600;
    background: white;
    border: none;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);

    &.van-button--success {
      background: linear-gradient(135deg, #07c160, #00d084);
    }

    &.van-button--warning {
      background: linear-gradient(135deg, #ff976a, #ff6b6b);
    }
  }

  .countdown {
    position: absolute;
    top: -8px;
    right: 8px;
    padding: 2px 8px;
    background: #ff6b6b;
    color: white;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 500;
  }
}

.verification-status {
  display: flex;
  justify-content: space-between;
  padding: 12px 16px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
  backdrop-filter: blur(5px);

  .location-status,
  .biometric-status {
    display: flex;
    align-items: center;
    color: rgba(255, 255, 255, 0.9);
    font-size: 14px;

    .van-icon {
      margin-right: 4px;
    }
  }
}

// å“åº”å¼è®¾è®¡
@media (max-width: 375px) {
  .clock-button-container {
    padding: 16px;
  }

  .clock-status {
    margin-bottom: 16px;
    padding: 12px;

    .status-text .primary-text {
      font-size: 16px;
    }
  }

  .clock-button-wrapper .clock-button {
    height: 50px;
    font-size: 16px;
  }

  .verification-status {
    flex-direction: column;
    gap: 8px;
  }
}
</style>
```

### 2.2 LocationVerifier ä½ç½®éªŒè¯ç»„ä»¶

#### ç»„ä»¶æ¥å£å®šä¹‰
```typescript
// LocationVerifier.vue
interface LocationVerifierProps {
  required?: boolean;              // æ˜¯å¦å¿…é¡»éªŒè¯ä½ç½®
  radius?: number;                 // å…è®¸èŒƒå›´åŠå¾„ï¼ˆç±³ï¼‰
  centerPoints?: LocationPoint[];  // å…è®¸çš„ä¸­å¿ƒç‚¹
  showMap?: boolean;               // æ˜¯å¦æ˜¾ç¤ºåœ°å›¾
  autoRefresh?: boolean;           // æ˜¯å¦è‡ªåŠ¨åˆ·æ–°ä½ç½®
  refreshInterval?: number;        // åˆ·æ–°é—´éš”ï¼ˆç§’ï¼‰
}

interface LocationPoint {
  id: string;
  name: string;
  latitude: number;
  longitude: number;
  radius?: number;
  address?: string;
}

interface LocationData {
  latitude: number;
  longitude: number;
  accuracy: number;
  address?: string;
  timestamp: number;
}

interface LocationVerifierEmits {
  locationChange: [location: LocationData];
  verificationResult: [isValid: boolean, location?: LocationData];
  error: [error: Error];
}
```

#### ç»„ä»¶å®ç°
```vue
<template>
  <div class="location-verifier">
    <!-- ä½ç½®çŠ¶æ€æ˜¾ç¤º -->
    <div class="location-status-card">
      <div class="status-header">
        <van-icon
          :name="locationStatus.icon"
          :color="locationStatus.color"
          size="24"
        />
        <div class="status-title">
          <div class="primary-text">{{ locationStatus.title }}</div>
          <div class="secondary-text">{{ locationStatus.subtitle }}</div>
        </div>
        <van-button
          v-if="!locationStore.currentLocation"
          type="primary"
          size="small"
          round
          @click="getCurrentLocation"
        >
          è·å–ä½ç½®
        </van-button>
      </div>

      <!-- ä½ç½®ä¿¡æ¯ -->
      <div v-if="currentLocation" class="location-info">
        <div class="info-row">
          <span class="label">å½“å‰ä½ç½®ï¼š</span>
          <span class="value">{{ currentLocation.address || 'è·å–åœ°å€ä¸­...' }}</span>
        </div>
        <div class="info-row">
          <span class="label">ç»çº¬åº¦ï¼š</span>
          <span class="value">
            {{ formatCoordinate(currentLocation.latitude) }},
            {{ formatCoordinate(currentLocation.longitude) }}
          </span>
        </div>
        <div class="info-row">
          <span class="label">å®šä½ç²¾åº¦ï¼š</span>
          <span class="value">{{ currentLocation.accuracy }}ç±³</span>
        </div>
        <div v-if="nearestPoint" class="info-row highlight">
          <span class="label">è·ç¦»ç›®æ ‡ï¼š</span>
          <span class="value">{{ nearestPoint.distance }}ç±³</span>
        </div>
      </div>

      <!-- éªŒè¯ç»“æœ -->
      <div class="verification-result" :class="verificationResult.status">
        <van-icon :name="verificationResult.icon" size="20" />
        <span>{{ verificationResult.message }}</span>
      </div>
    </div>

    <!-- åœ°å›¾æ˜¾ç¤º -->
    <div v-if="showMap && currentLocation" class="map-container">
      <div class="map-header">
        <h3>ä½ç½®éªŒè¯åœ°å›¾</h3>
        <van-button
          type="primary"
          size="small"
          @click="refreshLocation"
          :loading="locationLoading"
        >
          åˆ·æ–°ä½ç½®
        </van-button>
      </div>

      <div ref="mapContainer" class="map-wrapper"></div>

      <!-- åœ°å›¾å›¾ä¾‹ -->
      <div class="map-legend">
        <div class="legend-item">
          <div class="legend-dot current"></div>
          <span>å½“å‰ä½ç½®</span>
        </div>
        <div class="legend-item">
          <div class="legend-dot target"></div>
          <span>æ‰“å¡èŒƒå›´</span>
        </div>
        <div class="legend-item">
          <div class="legend-dot invalid"></div>
          <span>è¶…å‡ºèŒƒå›´</span>
        </div>
      </div>
    </div>

    <!-- ä½ç½®æƒé™æç¤º -->
    <div v-if="!locationStore.locationPermission" class="permission-notice">
      <van-notice-bar
        type="warning"
        left-icon="warning-o"
        background="#fff7e6"
        color="#ed6a0c"
      >
        è¯·å…è®¸ä½ç½®æƒé™ä»¥ä½¿ç”¨æ‰“å¡åŠŸèƒ½
      </van-notice-bar>
      <van-button
        type="primary"
        block
        round
        @click="requestLocationPermission"
      >
        å¼€å¯ä½ç½®æƒé™
      </van-button>
    </div>

    <!-- ä½ç½®è®¾ç½® -->
    <div class="location-settings">
      <van-cell-group>
        <van-cell title="è‡ªåŠ¨åˆ·æ–°ä½ç½®" is-link>
          <template #right-icon>
            <van-switch
              v-model="autoRefreshEnabled"
              @change="handleAutoRefreshChange"
            />
          </template>
        </van-cell>
        <van-cell
          title="åˆ·æ–°é—´éš”"
          :value="refreshInterval + 'ç§’'"
          is-link
          @click="showIntervalPicker"
        />
        <van-cell title="ä½¿ç”¨WiFiå®šä½" is-link>
          <template #right-icon>
            <van-switch v-model="wifiLocationEnabled" />
          </template>
        </van-cell>
      </van-cell-group>
    </div>

    <!-- åˆ·æ–°é—´éš”é€‰æ‹©å™¨ -->
    <van-popup v-model:show="showIntervalPopup" position="bottom">
      <van-picker
        :columns="intervalOptions"
        @confirm="onIntervalConfirm"
        @cancel="showIntervalPopup = false"
      />
    </van-popup>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted, watch, nextTick } from 'vue'
import { useLocationStore } from '@/stores/location'
import { showToast, showLoadingToast, closeToast } from 'vant'

// Propså®šä¹‰
const props = withDefaults(defineProps<LocationVerifierProps>(), {
  required: true,
  radius: 500,
  centerPoints: () => [],
  showMap: true,
  autoRefresh: false,
  refreshInterval: 30
})

// Emitså®šä¹‰
const emit = defineEmits<LocationVerifierEmits>()

// çŠ¶æ€ç®¡ç†
const locationStore = useLocationStore()

// å“åº”å¼æ•°æ®
const currentLocation = ref<LocationData | null>(null)
const nearestPoint = ref<LocationPoint | null>(null)
const verificationResult = ref<{
  status: 'valid' | 'invalid' | 'pending' | 'error';
  icon: string;
  message: string;
}>({
  status: 'pending',
  icon: 'clock-o',
  message: 'ç­‰å¾…ä½ç½®éªŒè¯'
})

const locationLoading = ref(false)
const showIntervalPopup = ref(false)
const autoRefreshEnabled = ref(props.autoRefresh)
const wifiLocationEnabled = ref(true)
const refreshInterval = ref(props.refreshInterval)

// åœ°å›¾ç›¸å…³
const mapContainer = ref<HTMLElement | null>(null)
let mapInstance: any = null
let refreshTimer: NodeJS.Timeout | null = null

// é€‰é¡¹é…ç½®
const intervalOptions = [
  { text: '10ç§’', value: 10 },
  { text: '30ç§’', value: 30 },
  { text: '1åˆ†é’Ÿ', value: 60 },
  { text: '5åˆ†é’Ÿ', value: 300 },
  { text: '10åˆ†é’Ÿ', value: 600 }
]

// è®¡ç®—å±æ€§
const locationStatus = computed(() => {
  if (!locationStore.locationPermission) {
    return {
      icon: 'location-o',
      color: '#ff976a',
      title: 'ä½ç½®æƒé™æœªå¼€å¯',
      subtitle: 'è¯·å…è®¸ä½ç½®æƒé™ä»¥ä½¿ç”¨æ‰“å¡åŠŸèƒ½'
    }
  }

  if (!currentLocation.value) {
    return {
      icon: 'location',
      color: '#969799',
      title: 'æ­£åœ¨è·å–ä½ç½®',
      subtitle: 'è¯·ç¨å€™...'
    }
  }

  switch (verificationResult.value.status) {
    case 'valid':
      return {
        icon: 'passed',
        color: '#07c160',
        title: 'ä½ç½®éªŒè¯æˆåŠŸ',
        subtitle: 'æ‚¨åœ¨æœ‰æ•ˆæ‰“å¡èŒƒå›´å†…'
      }
    case 'invalid':
      return {
        icon: 'close',
        color: '#ee0a24',
        title: 'ä½ç½®éªŒè¯å¤±è´¥',
        subtitle: 'æ‚¨ä¸åœ¨æœ‰æ•ˆæ‰“å¡èŒƒå›´å†…'
      }
    default:
      return {
        icon: 'clock-o',
        color: '#1989fa',
        title: 'ä½ç½®éªŒè¯ä¸­',
        subtitle: 'æ­£åœ¨éªŒè¯æ‚¨çš„ä½ç½®'
      }
  }
})

// æ–¹æ³•å®ç°
const getCurrentLocation = async () => {
  if (!locationStore.locationPermission) {
    await requestLocationPermission()
    return
  }

  locationLoading.value = true
  showLoadingToast('è·å–ä½ç½®ä¸­...')

  try {
    const location = await locationStore.getCurrentLocation({
      enableHighAccuracy: true,
      timeout: 15000,
      maximumAge: 30000
    })

    if (location) {
      currentLocation.value = location
      emit('locationChange', location)

      await verifyLocation(location)

      // æ›´æ–°åœ°å›¾
      if (showMap.value) {
        await updateMap(location)
      }
    } else {
      showToast('è·å–ä½ç½®å¤±è´¥ï¼Œè¯·æ£€æŸ¥GPSè®¾ç½®')
    }

  } catch (error) {
    console.error('è·å–ä½ç½®å¤±è´¥:', error)
    showToast('è·å–ä½ç½®å¤±è´¥: ' + (error as Error).message)
    emit('error', error as Error)
  } finally {
    locationLoading.value = false
    closeToast()
  }
}

const verifyLocation = async (location: LocationData) => {
  try {
    let isValid = false
    let nearest: LocationPoint | null = null
    let minDistance = Infinity

    // å¦‚æœæœ‰æŒ‡å®šçš„ä¸­å¿ƒç‚¹ï¼Œåˆ™éªŒè¯æ˜¯å¦åœ¨ä»»æ„ä¸­å¿ƒç‚¹èŒƒå›´å†…
    if (props.centerPoints.length > 0) {
      for (const point of props.centerPoints) {
        const distance = calculateDistance(
          location.latitude,
          location.longitude,
          point.latitude,
          point.longitude
        )

        const validRadius = point.radius || props.radius

        if (distance <= validRadius && distance < minDistance) {
          isValid = true
          nearest = point
          minDistance = distance
        }
      }
    } else {
      // ä½¿ç”¨é»˜è®¤éªŒè¯é€»è¾‘
      isValid = await locationStore.verifyLocation(location)
    }

    if (nearest) {
      nearest.value = {
        ...nearest,
        distance: Math.round(minDistance)
      }
    }

    // æ›´æ–°éªŒè¯ç»“æœ
    updateVerificationResult(isValid)
    emit('verificationResult', isValid, location)

  } catch (error) {
    console.error('ä½ç½®éªŒè¯å¤±è´¥:', error)
    updateVerificationResult(false)
    emit('error', error as Error)
  }
}

const updateVerificationResult = (isValid: boolean) => {
  verificationResult.value = isValid ? {
    status: 'valid',
    icon: 'passed',
    message: 'ä½ç½®éªŒè¯æˆåŠŸï¼Œå¯ä»¥æ‰“å¡'
  } : {
    status: 'invalid',
    icon: 'close',
    message: 'ä½ç½®éªŒè¯å¤±è´¥ï¼Œä¸åœ¨æ‰“å¡èŒƒå›´å†…'
  }
}

const calculateDistance = (
  lat1: number,
  lon1: number,
  lat2: number,
  lon2: number
): number => {
  const R = 6371000 // åœ°çƒåŠå¾„ï¼ˆç±³ï¼‰
  const Ï†1 = lat1 * Math.PI / 180
  const Ï†2 = lat2 * Math.PI / 180
  const Î”Ï† = (lat2 - lat1) * Math.PI / 180
  const Î”Î» = (lon2 - lon1) * Math.PI / 180

  const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
          Math.cos(Ï†1) * Math.cos(Ï†2) *
          Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2)
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a))

  return R * c
}

const formatCoordinate = (coordinate: number): string => {
  return coordinate.toFixed(6)
}

const requestLocationPermission = async () => {
  try {
    const granted = await locationStore.requestLocationPermission()
    if (granted) {
      showToast('ä½ç½®æƒé™å·²å¼€å¯')
      await getCurrentLocation()
    } else {
      showToast('ä½ç½®æƒé™è¢«æ‹’ç»')
    }
  } catch (error) {
    console.error('è¯·æ±‚ä½ç½®æƒé™å¤±è´¥:', error)
    showToast('è¯·æ±‚ä½ç½®æƒé™å¤±è´¥')
  }
}

const refreshLocation = async () => {
  await getCurrentLocation()
}

const updateMap = async (location: LocationData) => {
  if (!mapContainer.value) return

  await nextTick()

  try {
    // åŠ¨æ€åŠ è½½åœ°å›¾SDK
    if (!window.AMap) {
      await loadMapSDK()
    }

    // åˆå§‹åŒ–åœ°å›¾
    if (!mapInstance) {
      mapInstance = new window.AMap.Map(mapContainer.value, {
        zoom: 16,
        center: [location.longitude, location.latitude],
        mapStyle: 'amap://styles/fresh'
      })

      // æ·»åŠ æ’ä»¶
      mapInstance.plugin(['AMap.ToolBar', 'AMap.Scale'])
    }

    // æ¸…é™¤ä¹‹å‰çš„æ ‡è®°
    mapInstance.clearMap()

    // æ·»åŠ å½“å‰ä½ç½®æ ‡è®°
    const currentMarker = new window.AMap.Marker({
      position: [location.longitude, location.latitude],
      title: 'å½“å‰ä½ç½®',
      icon: new window.AMap.Icon({
        size: new window.AMap.Size(30, 30),
        image: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iOCIgZmlsbD0iIzE5ODlmYSIvPgo8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI0IiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4='
      })
    })

    // æ·»åŠ æ‰“å¡èŒƒå›´åœ†åœˆ
    if (props.centerPoints.length > 0) {
      props.centerPoints.forEach(point => {
        const circle = new window.AMap.Circle({
          center: [point.longitude, point.latitude],
          radius: point.radius || props.radius,
          fillColor: 'rgba(7, 193, 96, 0.2)',
          strokeColor: '#07c160',
          strokeWeight: 2
        })

        // æ·»åŠ ä¸­å¿ƒç‚¹æ ‡è®°
        const centerMarker = new window.AMap.Marker({
          position: [point.longitude, point.latitude],
          title: point.name,
          icon: new window.AMap.Icon({
            size: new window.AMap.Size(20, 20),
            image: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iNiIgZmlsbD0iIzAwYzE2NCIvPgo8Y2lyY2xlIGN4PSIxMCIgY3k9IjEwIiByPSIzIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4='
          })
        })

        mapInstance.add([circle, centerMarker])
      })
    }

    // å°†å½“å‰ä½ç½®æ ‡è®°æ·»åŠ åˆ°åœ°å›¾
    mapInstance.add(currentMarker)

    // è‡ªé€‚åº”æ˜¾ç¤ºèŒƒå›´
    if (props.centerPoints.length > 0) {
      mapInstance.setFitView()
    }

  } catch (error) {
    console.error('æ›´æ–°åœ°å›¾å¤±è´¥:', error)
  }
}

const loadMapSDK = (): Promise<void> => {
  return new Promise((resolve, reject) => {
    if (window.AMap) {
      resolve()
      return
    }

    const script = document.createElement('script')
    script.src = 'https://webapi.amap.com/maps?v=2.0&key=YOUR_AMAP_KEY'
    script.onload = () => resolve()
    script.onerror = () => reject(new Error('åŠ è½½åœ°å›¾SDKå¤±è´¥'))

    document.head.appendChild(script)
  })
}

const handleAutoRefreshChange = (enabled: boolean) => {
  if (enabled) {
    startAutoRefresh()
  } else {
    stopAutoRefresh()
  }
}

const startAutoRefresh = () => {
  stopAutoRefresh() // å…ˆåœæ­¢ä¹‹å‰çš„å®šæ—¶å™¨

  if (autoRefreshEnabled.value && currentLocation.value) {
    refreshTimer.value = setInterval(() => {
      refreshLocation()
    }, refreshInterval.value * 1000)
  }
}

const stopAutoRefresh = () => {
  if (refreshTimer.value) {
    clearInterval(refreshTimer.value)
    refreshTimer.value = null
  }
}

const showIntervalPicker = () => {
  showIntervalPopup.value = true
}

const onIntervalConfirm = ({ selectedValues }: any) => {
  refreshInterval.value = selectedValues[0]
  showIntervalPopup.value = false

  // å¦‚æœè‡ªåŠ¨åˆ·æ–°å·²å¼€å¯ï¼Œé‡æ–°å¯åŠ¨å®šæ—¶å™¨
  if (autoRefreshEnabled.value) {
    startAutoRefresh()
  }

  showToast(`åˆ·æ–°é—´éš”å·²è®¾ç½®ä¸º${refreshInterval.value}ç§’`)
}

// ç”Ÿå‘½å‘¨æœŸ
onMounted(async () => {
  // åˆå§‹åŒ–ä½ç½®æœåŠ¡
  await locationStore.initializeLocation()

  // è·å–å½“å‰ä½ç½®
  await getCurrentLocation()

  // å¯åŠ¨è‡ªåŠ¨åˆ·æ–°
  if (autoRefreshEnabled.value) {
    startAutoRefresh()
  }
})

onUnmounted(() => {
  stopAutoRefresh()

  // æ¸…ç†åœ°å›¾èµ„æº
  if (mapInstance) {
    mapInstance.destroy()
    mapInstance = null
  }
})

// ç›‘å¬è‡ªåŠ¨åˆ·æ–°é…ç½®å˜åŒ–
watch(() => autoRefreshEnabled.value, handleAutoRefreshChange)

// ç›‘å¬åˆ·æ–°é—´éš”å˜åŒ–
watch(() => refreshInterval.value, () => {
  if (autoRefreshEnabled.value) {
    startAutoRefresh()
  }
})

// ç›‘å¬ä¸­å¿ƒç‚¹å˜åŒ–
watch(() => props.centerPoints, () => {
  if (currentLocation.value) {
    verifyLocation(currentLocation.value)
  }
}, { deep: true })
</script>

<style lang="scss" scoped>
.location-verifier {
  padding: 16px;
}

.location-status-card {
  background: white;
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 16px;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);

  .status-header {
    display: flex;
    align-items: center;
    margin-bottom: 16px;

    .status-title {
      flex: 1;
      margin-left: 12px;

      .primary-text {
        font-size: 16px;
        font-weight: 600;
        color: #323233;
        margin-bottom: 4px;
      }

      .secondary-text {
        font-size: 14px;
        color: #969799;
      }
    }
  }

  .location-info {
    background: #f7f8fa;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 12px;

    .info-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 14px;

      &:last-child {
        margin-bottom: 0;
      }

      &.highlight {
        background: #e6f7ff;
        padding: 8px;
        border-radius: 6px;
        margin: 8px -4px 0;
      }

      .label {
        color: #969799;
        flex-shrink: 0;
      }

      .value {
        color: #323233;
        font-weight: 500;
        text-align: right;
        flex: 1;
      }
    }
  }

  .verification-result {
    display: flex;
    align-items: center;
    padding: 12px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;

    .van-icon {
      margin-right: 8px;
    }

    &.valid {
      background: #f0f9ff;
      color: #07c160;
      border: 1px solid #b3e0ff;
    }

    &.invalid {
      background: #fef2f2;
      color: #ee0a24;
      border: 1px solid #fecaca;
    }

    &.pending {
      background: #f8f9fa;
      color: #1989fa;
      border: 1px solid #d1e7ff;
    }

    &.error {
      background: #fef2f2;
      color: #ee0a24;
      border: 1px solid #fecaca;
    }
  }
}

.map-container {
  background: white;
  border-radius: 12px;
  overflow: hidden;
  margin-bottom: 16px;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);

  .map-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 20px;
    border-bottom: 1px solid #ebedf0;

    h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      color: #323233;
    }
  }

  .map-wrapper {
    height: 300px;
    width: 100%;
  }

  .map-legend {
    display: flex;
    justify-content: space-around;
    padding: 12px;
    background: #f7f8fa;

    .legend-item {
      display: flex;
      align-items: center;
      font-size: 12px;
      color: #969799;

      .legend-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 6px;

        &.current {
          background: #1989fa;
          border: 2px solid white;
          box-shadow: 0 0 0 2px #1989fa;
        }

        &.target {
          background: #07c160;
          opacity: 0.6;
        }

        &.invalid {
          background: #ee0a24;
          opacity: 0.6;
        }
      }
    }
  }
}

.permission-notice {
  background: white;
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 16px;
  text-align: center;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);

  .van-button {
    margin-top: 16px;
  }
}

.location-settings {
  background: white;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
}

// å“åº”å¼è®¾è®¡
@media (max-width: 375px) {
  .location-verifier {
    padding: 12px;
  }

  .location-status-card {
    padding: 16px;
  }

  .map-container .map-wrapper {
    height: 250px;
  }
}
</style>
```

### 2.3 ScheduleCalendar æ’ç­æ—¥å†ç»„ä»¶

#### ç»„ä»¶æ¥å£å®šä¹‰
```typescript
// ScheduleCalendar.vue
interface ScheduleCalendarProps {
  month?: Date;                    // æ˜¾ç¤ºæœˆä»½
  selectedDate?: Date;             // é€‰ä¸­çš„æ—¥æœŸ
  schedules?: ScheduleInfo[];      // æ’ç­ä¿¡æ¯
  holidays?: HolidayInfo[];        // èŠ‚å‡æ—¥ä¿¡æ¯
  showWeekNumber?: boolean;        // æ˜¯å¦æ˜¾ç¤ºå‘¨æ•°
  showTodayButton?: boolean;       // æ˜¯å¦æ˜¾ç¤ºä»Šå¤©æŒ‰é’®
  allowSelect?: boolean;           // æ˜¯å¦å…è®¸é€‰æ‹©æ—¥æœŸ
  height?: string | number;        // æ—¥å†é«˜åº¦
}

interface ScheduleInfo {
  date: string;
  scheduleType: 'WORK' | 'REST' | 'LEAVE' | 'TRIP';
  scheduleName: string;
  workTime?: string;
  overtimeInfo?: string;
  isSpecial: boolean;
}

interface HolidayInfo {
  date: string;
  name: string;
  type: 'NATIONAL' | 'COMPANY' | 'CUSTOM';
  isWorkday: boolean;
}

interface ScheduleCalendarEmits {
  selectDate: [date: Date, schedule?: ScheduleInfo];
  monthChange: [month: Date];
  scheduleClick: [schedule: ScheduleInfo, date: Date];
}
```

#### ç»„ä»¶å®ç°
```vue
<template>
  <div class="schedule-calendar">
    <!-- æ—¥å†å¤´éƒ¨ -->
    <div class="calendar-header">
      <van-button
        type="default"
        size="small"
        round
        @click="previousMonth"
      >
        <van-icon name="arrow-left" />
      </van-button>

      <div class="month-title">
        {{ monthTitle }}
      </div>

      <van-button
        type="default"
        size="small"
        round
        @click="nextMonth"
      >
        <van-icon name="arrow" />
      </van-button>

      <van-button
        v-if="showTodayButton"
        type="primary"
        size="small"
        round
        @click="goToToday"
      >
        ä»Šå¤©
      </van-button>
    </div>

    <!-- æ˜ŸæœŸæ ‡é¢˜ -->
    <div class="weekdays">
      <div
        v-for="(day, index) in weekDays"
        :key="index"
        class="weekday"
        :class="{ 'weekend': index >= 5 }"
      >
        {{ day }}
      </div>
    </div>

    <!-- æ—¥å†ç½‘æ ¼ -->
    <div
      class="calendar-grid"
      :style="{ height: typeof height === 'number' ? height + 'px' : height }"
    >
      <div
        v-for="(cell, index) in calendarDays"
        :key="index"
        class="calendar-cell"
        :class="getCellClass(cell)"
        @click="handleCellClick(cell)"
      >
        <!-- å‘¨æ•°æ˜¾ç¤º -->
        <div v-if="showWeekNumber && cell.isWeekStart" class="week-number">
          {{ cell.weekNumber }}
        </div>

        <!-- æ—¥æœŸæ•°å­— -->
        <div class="day-number">
          {{ cell.day }}
          <span v-if="isToday(cell.date)" class="today-dot"></span>
        </div>

        <!-- çŠ¶æ€æŒ‡ç¤ºå™¨ -->
        <div class="day-indicators">
          <!-- å·¥ä½œçŠ¶æ€ -->
          <div v-if="cell.schedule" class="schedule-indicator">
            <van-icon
              :name="getScheduleIcon(cell.schedule.scheduleType)"
              :color="getScheduleColor(cell.schedule.scheduleType)"
              size="12"
            />
          </div>

          <!-- èŠ‚å‡æ—¥æ ‡è®° -->
          <div v-if="cell.holiday" class="holiday-indicator">
            <span class="holiday-name">{{ cell.holiday.name }}</span>
          </div>

          <!-- ç‰¹æ®Šæ ‡è®° -->
          <div v-if="cell.schedule?.isSpecial" class="special-indicator">
            <van-icon name="star" color="#ff976a" size="10" />
          </div>
        </div>

        <!-- è¯¦ç»†ä¿¡æ¯ -->
        <div v-if="cell.schedule" class="schedule-info">
          <div class="schedule-name">{{ cell.schedule.scheduleName }}</div>
          <div v-if="cell.schedule.workTime" class="work-time">
            {{ cell.schedule.workTime }}
          </div>
          <div v-if="cell.schedule.overtimeInfo" class="overtime-info">
            {{ cell.schedule.overtimeInfo }}
          </div>
        </div>
      </div>
    </div>

    <!-- ç»Ÿè®¡ä¿¡æ¯ -->
    <div class="statistics-panel">
      <div class="statistics-title">
        {{ monthTitle }} ç»Ÿè®¡
      </div>
      <div class="statistics-grid">
        <div class="stat-item">
          <div class="stat-value">{{ statistics.workDays }}</div>
          <div class="stat-label">å·¥ä½œæ—¥</div>
        </div>
        <div class="stat-item">
          <div class="stat-value">{{ statistics.holidays }}</div>
          <div class="stat-label">èŠ‚å‡æ—¥</div>
        </div>
        <div class="stat-item">
          <div class="stat-value">{{ statistics.leaveDays }}</div>
          <div class="stat-label">è¯·å‡</div>
        </div>
        <div class="stat-item">
          <div class="stat-value">{{ statistics.overtimeHours }}h</div>
          <div class="stat-label">åŠ ç­</div>
        </div>
      </div>
    </div>

    <!-- æ—¥æœŸè¯¦æƒ…å¼¹çª— -->
    <van-popup
      v-model:show="showDetailPopup"
      position="bottom"
      round
      :style="{ height: '60%' }"
    >
      <div class="detail-popup">
        <div class="popup-header">
          <h3>{{ selectedDateInfo.dateStr }} æ’ç­è¯¦æƒ…</h3>
          <van-button
            type="default"
            size="small"
            round
            @click="showDetailPopup = false"
          >
            å…³é—­
          </van-button>
        </div>

        <div class="popup-content">
          <div v-if="selectedDateInfo.schedule" class="schedule-detail">
            <div class="detail-item">
              <div class="label">æ’ç­ç±»å‹ï¼š</div>
              <div class="value">{{ selectedDateInfo.schedule.scheduleName }}</div>
            </div>
            <div v-if="selectedDateInfo.schedule.workTime" class="detail-item">
              <div class="label">å·¥ä½œæ—¶é—´ï¼š</div>
              <div class="value">{{ selectedDateInfo.schedule.workTime }}</div>
            </div>
            <div v-if="selectedDateInfo.schedule.overtimeInfo" class="detail-item">
              <div class="label">åŠ ç­ä¿¡æ¯ï¼š</div>
              <div class="value">{{ selectedDateInfo.schedule.overtimeInfo }}</div>
            </div>
            <div v-if="selectedDateInfo.schedule.isSpecial" class="detail-item">
              <div class="label">ç‰¹æ®Šæ ‡è®°ï¼š</div>
              <div class="value">ç‰¹æ®Šæ’ç­</div>
            </div>
          </div>

          <div v-if="selectedDateInfo.holiday" class="holiday-detail">
            <div class="detail-item">
              <div class="label">èŠ‚å‡æ—¥åç§°ï¼š</div>
              <div class="value">{{ selectedDateInfo.holiday.name }}</div>
            </div>
            <div class="detail-item">
              <div class="label">èŠ‚å‡æ—¥ç±»å‹ï¼š</div>
              <div class="value">{{ getHolidayTypeName(selectedDateInfo.holiday.type) }}</div>
            </div>
            <div class="detail-item">
              <div class="label">æ˜¯å¦å·¥ä½œï¼š</div>
              <div class="value">{{ selectedDateInfo.holiday.isWorkday ? 'æ˜¯ï¼ˆè°ƒä¼‘ï¼‰' : 'å¦' }}</div>
            </div>
          </div>

          <!-- æ— æ’ç­ä¿¡æ¯æ—¶çš„æç¤º -->
          <div v-if="!selectedDateInfo.schedule && !selectedDateInfo.holiday" class="no-info">
            <van-empty description="æš‚æ— æ’ç­ä¿¡æ¯" image-size="80" />
          </div>
        </div>
      </div>
    </van-popup>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch, onMounted } from 'vue'
import { showToast } from 'vant'

// Propså®šä¹‰
const props = withDefaults(defineProps<ScheduleCalendarProps>(), {
  month: () => new Date(),
  selectedDate: () => new Date(),
  schedules: () => [],
  holidays: () => [],
  showWeekNumber: false,
  showTodayButton: true,
  allowSelect: true,
  height: 'auto'
})

// Emitså®šä¹‰
const emit = defineEmits<ScheduleCalendarEmits>()

// å“åº”å¼æ•°æ®
const currentMonth = ref(new Date(props.month))
const selectedDateInfo = ref<{
  date: Date;
  dateStr: string;
  schedule?: ScheduleInfo;
  holiday?: HolidayInfo;
}>({
  date: props.selectedDate,
  dateStr: formatDateStr(props.selectedDate)
})

const showDetailPopup = ref(false)

// æ˜ŸæœŸæ ‡é¢˜
const weekDays = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­']

// è®¡ç®—å±æ€§
const monthTitle = computed(() => {
  return `${currentMonth.value.getFullYear()}å¹´${currentMonth.value.getMonth() + 1}æœˆ`
})

const calendarDays = computed(() => {
  const year = currentMonth.value.getFullYear()
  const month = currentMonth.value.getMonth()
  const firstDay = new Date(year, month, 1)
  const lastDay = new Date(year, month + 1, 0)
  const startDate = new Date(firstDay)

  // è°ƒæ•´åˆ°å‘¨ä¸€å¼€å§‹
  while (startDate.getDay() !== 0) {
    startDate.setDate(startDate.getDate() - 1)
  }

  const endDate = new Date(lastDay)
  while (endDate.getDay() !== 6) {
    endDate.setDate(endDate.getDate() + 1)
  }

  const days = []
  const currentDate = new Date(startDate)
  let weekNumber = 1

  while (currentDate <= endDate) {
    const dateStr = formatDateStr(currentDate)
    const schedule = props.schedules.find(s => s.date === dateStr)
    const holiday = props.holidays.find(h => h.date === dateStr)

    // è®¡ç®—å‘¨æ•°ï¼ˆISOå‘¨æ•°ï¼‰
    const isWeekStart = currentDate.getDay() === 1
    if (isWeekStart) {
      weekNumber = getISOWeekNumber(currentDate)
    }

    days.push({
      date: new Date(currentDate),
      dateStr,
      day: currentDate.getDate(),
      isCurrentMonth: currentDate.getMonth() === month,
      isToday: isSameDay(currentDate, new Date()),
      isWeekend: currentDate.getDay() === 0 || currentDate.getDay() === 6,
      isWeekStart,
      weekNumber,
      schedule,
      holiday
    })

    currentDate.setDate(currentDate.getDate() + 1)
  }

  return days
})

const statistics = computed(() => {
  const workDays = props.schedules.filter(s =>
    s.scheduleType === 'WORK' ||
    (s.scheduleType === 'REST' && isWorkdayFromHoliday(s.date))
  ).length

  const holidays = props.holidays.filter(h => !h.isWorkday).length
  const leaveDays = props.schedules.filter(s => s.scheduleType === 'LEAVE').length
  const overtimeHours = props.schedules.reduce((total, s) => {
    const match = s.overtimeInfo?.match(/(\d+(?:\.\d+)?)h/)
    return total + (match ? parseFloat(match[1]) : 0)
  }, 0)

  return {
    workDays,
    holidays,
    leaveDays,
    overtimeHours: Math.round(overtimeHours * 10) / 10
  }
})

// æ–¹æ³•å®ç°
const getCellClass = (cell: any) => {
  return {
    'current-month': cell.isCurrentMonth,
    'other-month': !cell.isCurrentMonth,
    'today': cell.isToday,
    'weekend': cell.isWeekend,
    'selected': isSameDay(cell.date, selectedDateInfo.value.date),
    'has-schedule': !!cell.schedule,
    'has-holiday': !!cell.holiday,
    'work-day': cell.schedule?.scheduleType === 'WORK',
    'rest-day': cell.schedule?.scheduleType === 'REST',
    'leave-day': cell.schedule?.scheduleType === 'LEAVE',
    'trip-day': cell.schedule?.scheduleType === 'TRIP'
  }
}

const handleCellClick = (cell: any) => {
  if (!props.allowSelect) return

  selectedDateInfo.value = {
    date: cell.date,
    dateStr: cell.dateStr,
    schedule: cell.schedule,
    holiday: cell.holiday
  }

  if (cell.schedule || cell.holiday) {
    showDetailPopup.value = true
    emit('scheduleClick', cell.schedule, cell.date)
  }

  emit('selectDate', cell.date, cell.schedule)
}

const previousMonth = () => {
  currentMonth.value.setMonth(currentMonth.value.getMonth() - 1)
  emit('monthChange', new Date(currentMonth.value))
}

const nextMonth = () => {
  currentMonth.value.setMonth(currentMonth.value.getMonth() + 1)
  emit('monthChange', new Date(currentMonth.value))
}

const goToToday = () => {
  const today = new Date()
  currentMonth.value = new Date(today)
  selectedDateInfo.value = {
    date: today,
    dateStr: formatDateStr(today)
  }
  emit('monthChange', new Date(today))
  emit('selectDate', today)
}

const getScheduleIcon = (scheduleType: string) => {
  const iconMap = {
    'WORK': 'passed',
    'REST': 'pause-circle-o',
    'LEAVE': 'info-o',
    'TRIP': 'logistics'
  }
  return iconMap[scheduleType] || 'clock-o'
}

const getScheduleColor = (scheduleType: string) => {
  const colorMap = {
    'WORK': '#07c160',
    'REST': '#ff976a',
    'LEAVE': '#1989fa',
    'TRIP': '#ff6034'
  }
  return colorMap[scheduleType] || '#969799'
}

const getHolidayTypeName = (type: string) => {
  const nameMap = {
    'NATIONAL': 'æ³•å®šèŠ‚å‡æ—¥',
    'COMPANY': 'å…¬å¸å‡æœŸ',
    'CUSTOM': 'è‡ªå®šä¹‰'
  }
  return nameMap[type] || type
}

const formatDateStr = (date: Date): string => {
  const year = date.getFullYear()
  const month = String(date.getMonth() + 1).padStart(2, '0')
  const day = String(date.getDate()).padStart(2, '0')
  return `${year}-${month}-${day}`
}

const isSameDay = (date1: Date, date2: Date): boolean => {
  return date1.getFullYear() === date2.getFullYear() &&
         date1.getMonth() === date2.getMonth() &&
         date1.getDate() === date2.getDate()
}

const isToday = (date: Date): boolean => {
  return isSameDay(date, new Date())
}

const getISOWeekNumber = (date: Date): number => {
  const targetDate = new Date(date.valueOf())
  const dayNumber = (date.getDay() + 6) % 7
  targetDate.setDate(targetDate.getDate() - dayNumber + 3)
  const firstThursday = targetDate.valueOf()
  targetDate.setMonth(0, 1)
  if (targetDate.getDay() !== 4) {
    targetDate.setMonth(0, 1 + ((4 - targetDate.getDay()) + 7) % 7)
  }
  return 1 + Math.ceil((firstThursday - targetDate.valueOf()) / 604800000)
}

const isWorkdayFromHoliday = (dateStr: string): boolean => {
  const holiday = props.holidays.find(h => h.date === dateStr)
  return holiday?.isWorkday || false
}

// ç›‘å¬æœˆä»½å˜åŒ–
watch(() => props.month, (newMonth) => {
  currentMonth.value = new Date(newMonth)
})

// ç›‘å¬é€‰ä¸­æ—¥æœŸå˜åŒ–
watch(() => props.selectedDate, (newDate) => {
  selectedDateInfo.value = {
    date: newDate,
    dateStr: formatDateStr(newDate)
  }
})

// ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  // åˆå§‹åŒ–é€‰ä¸­æ—¥æœŸ
  if (props.selectedDate) {
    selectedDateInfo.value = {
      date: props.selectedDate,
      dateStr: formatDateStr(props.selectedDate)
    }
  }
})
</script>

<style lang="scss" scoped>
.schedule-calendar {
  background: white;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
}

.calendar-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;

  .month-title {
    font-size: 18px;
    font-weight: 600;
  }

  .van-button {
    background: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: white;

    &:active {
      background: rgba(255, 255, 255, 0.3);
    }

    &.van-button--primary {
      background: rgba(255, 255, 255, 0.9);
      color: #667eea;
      border-color: rgba(255, 255, 255, 0.9);
    }
  }
}

.weekdays {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  padding: 12px 20px;
  background: #f7f8fa;
  border-bottom: 1px solid #ebedf0;

  .weekday {
    text-align: center;
    font-size: 14px;
    font-weight: 500;
    color: #969799;

    &.weekend {
      color: #ee0a24;
    }
  }
}

.calendar-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  grid-auto-rows: minmax(80px, 1fr);
  padding: 8px;

  .calendar-cell {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 8px 4px;
    cursor: pointer;
    transition: all 0.2s ease;
    border: 2px solid transparent;
    border-radius: 8px;

    &:not(.other-month):hover {
      background: #f0f8ff;
      border-color: #e1f5fe;
    }

    &.selected {
      background: #e3f2fd;
      border-color: #2196f3;
      box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);
    }

    &.today {
      font-weight: 600;
    }

    &.other-month {
      opacity: 0.4;
      cursor: default;
    }

    &.weekend {
      .day-number {
        color: #ee0a24;
      }
    }

    &.work-day {
      background: rgba(7, 193, 96, 0.05);
    }

    &.rest-day {
      background: rgba(255, 151, 106, 0.05);
    }

    &.leave-day {
      background: rgba(25, 137, 250, 0.05);
    }

    &.trip-day {
      background: rgba(255, 96, 52, 0.05);
    }

    .week-number {
      position: absolute;
      top: 2px;
      left: 2px;
      font-size: 10px;
      color: #969799;
    }

    .day-number {
      position: relative;
      font-size: 16px;
      font-weight: 500;
      color: #323233;
      margin-bottom: 4px;

      .today-dot {
        position: absolute;
        top: -2px;
        right: -8px;
        width: 6px;
        height: 6px;
        background: #2196f3;
        border-radius: 50%;
      }
    }

    .day-indicators {
      display: flex;
      gap: 2px;
      margin-bottom: 4px;
      min-height: 16px;
      align-items: center;

      .holiday-indicator {
        .holiday-name {
          font-size: 10px;
          color: #ff976a;
          background: rgba(255, 151, 106, 0.1);
          padding: 1px 4px;
          border-radius: 2px;
          max-width: 40px;
          overflow: hidden;
          text-overflow: ellipsis;
          white-space: nowrap;
        }
      }

      .special-indicator {
        margin-left: 2px;
      }
    }

    .schedule-info {
      text-align: center;
      font-size: 10px;
      color: #646566;
      line-height: 1.2;
      max-width: 100%;
      overflow: hidden;

      .schedule-name {
        font-weight: 500;
        margin-bottom: 1px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .work-time,
      .overtime-info {
        color: #969799;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
    }
  }
}

.statistics-panel {
  padding: 16px 20px;
  background: #f7f8fa;
  border-top: 1px solid #ebedf0;

  .statistics-title {
    font-size: 14px;
    font-weight: 600;
    color: #323233;
    margin-bottom: 12px;
    text-align: center;
  }

  .statistics-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 12px;

    .stat-item {
      text-align: center;
      background: white;
      padding: 12px 8px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);

      .stat-value {
        font-size: 20px;
        font-weight: 600;
        color: #2196f3;
        margin-bottom: 4px;
      }

      .stat-label {
        font-size: 12px;
        color: #969799;
      }
    }
  }
}

.detail-popup {
  height: 100%;
  display: flex;
  flex-direction: column;

  .popup-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 20px;
    border-bottom: 1px solid #ebedf0;

    h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      color: #323233;
    }
  }

  .popup-content {
    flex: 1;
    padding: 20px;
    overflow-y: auto;

    .schedule-detail,
    .holiday-detail {
      .detail-item {
        display: flex;
        margin-bottom: 16px;
        align-items: flex-start;

        .label {
          width: 80px;
          flex-shrink: 0;
          font-size: 14px;
          color: #969799;
        }

        .value {
          flex: 1;
          font-size: 14px;
          color: #323233;
          word-break: break-all;
        }
      }
    }

    .no-info {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 200px;
    }
  }
}

// å“åº”å¼è®¾è®¡
@media (max-width: 375px) {
  .calendar-grid {
    grid-auto-rows: minmax(70px, 1fr);
    padding: 4px;

    .calendar-cell {
      padding: 6px 2px;

      .day-number {
        font-size: 14px;
      }

      .schedule-info {
        font-size: 9px;
      }
    }
  }

  .statistics-panel .statistics-grid {
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;

    .stat-item {
      padding: 10px 6px;

      .stat-value {
        font-size: 18px;
      }

      .stat-label {
        font-size: 11px;
      }
    }
  }
}
</style>
```

### 2.4 BiometricAuth ç”Ÿç‰©è¯†åˆ«ç»„ä»¶

#### ç»„ä»¶æ¥å£å®šä¹‰
```typescript
// BiometricAuth.vue
interface BiometricAuthProps {
  required?: boolean;              // æ˜¯å¦å¿…é¡»ä½¿ç”¨ç”Ÿç‰©è¯†åˆ«
  types?: BiometricType[];         // æ”¯æŒçš„ç”Ÿç‰©è¯†åˆ«ç±»å‹
  fallbackEnabled?: boolean;       // æ˜¯å¦å…è®¸å›é€€åˆ°å…¶ä»–æ–¹å¼
  showResult?: boolean;            // æ˜¯å¦æ˜¾ç¤ºè¯†åˆ«ç»“æœ
  timeout?: number;                // è¯†åˆ«è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
}

type BiometricType = 'FINGERPRINT' | 'FACE' | 'VOICE' | 'IRIS';

interface BiometricResult {
  success: boolean;
  type: BiometricType;
  confidence: number;
  templateId?: string;
  liveness?: LivenessResult;
  error?: string;
}

interface LivenessResult {
  isLive: boolean;
  score: number;
  antiSpoofing: boolean;
  challengeType: string;
}

interface BiometricAuthEmits {
  success: [result: BiometricResult];
  error: [error: Error, type: BiometricType];
  fallback: [];                     // ç”¨æˆ·é€‰æ‹©å›é€€æ–¹å¼
}
```

#### ç»„ä»¶å®ç°
```vue
<template>
  <div class="biometric-auth">
    <!-- ç”Ÿç‰©è¯†åˆ«çŠ¶æ€æ˜¾ç¤º -->
    <div class="auth-status-card">
      <div class="status-header">
        <div class="auth-icon">
          <van-icon
            :name="authStatus.icon"
            :color="authStatus.color"
            size="32"
          />
        </div>
        <div class="status-content">
          <div class="status-title">{{ authStatus.title }}</div>
          <div class="status-subtitle">{{ authStatus.subtitle }}</div>
        </div>
      </div>

      <!-- æ”¯æŒçš„ç”Ÿç‰©è¯†åˆ«ç±»å‹ -->
      <div class="auth-types">
        <div
          v-for="type in availableTypes"
          :key="type"
          class="auth-type-item"
          :class="{
            'active': selectedType === type,
            'disabled': !isTypeAvailable(type)
          }"
          @click="selectAuthType(type)"
        >
          <van-icon
            :name="getTypeIcon(type)"
            :color="getTypeColor(type)"
            size="20"
          />
          <span>{{ getTypeName(type) }}</span>
          <van-icon
            v-if="selectedType === type"
            name="success"
            color="#07c160"
            size="16"
          />
        </div>
      </div>
    </div>

    <!-- ç”Ÿç‰©è¯†åˆ«æ“ä½œåŒºåŸŸ -->
    <div class="auth-action-area">
      <!-- äººè„¸è¯†åˆ«ç•Œé¢ -->
      <div v-if="selectedType === 'FACE'" class="face-auth-interface">
        <div class="camera-container">
          <video
            ref="videoElement"
            class="camera-video"
            autoplay
            playsinline
          ></video>
          <canvas
            ref="canvasElement"
            class="camera-canvas"
            width="640"
            height="480"
          ></canvas>

          <!-- äººè„¸æ£€æµ‹æ¡† -->
          <div v-if="faceDetected" class="face-detection-frame">
            <div class="frame-corners">
              <div class="corner top-left"></div>
              <div class="corner top-right"></div>
              <div class="corner bottom-left"></div>
              <div class="corner bottom-right"></div>
            </div>
            <div class="frame-info">
              <div class="confidence">ç½®ä¿¡åº¦: {{ faceConfidence }}%</div>
              <div class="instruction">{{ faceInstruction }}</div>
            </div>
          </div>

          <!-- æ´»ä½“æ£€æµ‹æç¤º -->
          <div v-if="livenessChallenge" class="liveness-challenge">
            <div class="challenge-text">{{ livenessChallenge.text }}</div>
            <div class="challenge-animation">
              <van-icon
                :name="livenessChallenge.icon"
                size="24"
                class="challenge-icon"
              />
            </div>
          </div>
        </div>

        <div class="camera-controls">
          <van-button
            type="primary"
            block
            round
            :loading="authenticating"
            @click="startFaceAuthentication"
          >
            {{ authenticating ? 'è¯†åˆ«ä¸­...' : 'å¼€å§‹äººè„¸è¯†åˆ«' }}
          </van-button>
        </div>
      </div>

      <!-- æŒ‡çº¹è¯†åˆ«ç•Œé¢ -->
      <div v-if="selectedType === 'FINGERPRINT'" class="fingerprint-auth-interface">
        <div class="fingerprint-visual">
          <div class="fingerprint-scanner" :class="{ 'scanning': authenticating }">
            <van-icon name="scan" size="60" color="#1989fa" />
            <div class="scanner-line" v-if="authenticating"></div>
          </div>
          <div class="fingerprint-status">
            {{ fingerprintStatus }}
          </div>
        </div>

        <div class="fingerprint-instructions">
          <div class="instruction-item">
            <van-icon name="info-o" size="16" />
            <span>è¯·å°†æ‰‹æŒ‡æ”¾åœ¨æŒ‡çº¹ä¼ æ„Ÿå™¨ä¸Š</span>
          </div>
          <div class="instruction-item">
            <van-icon name="clock-o" size="16" />
            <span>ä¿æŒæ‰‹æŒ‡ç¨³å®šï¼Œä¸è¦ç§»åŠ¨</span>
          </div>
        </div>

        <van-button
          type="primary"
          block
          round
          :loading="authenticating"
          @click="startFingerprintAuthentication"
        >
          {{ authenticating ? 'è¯†åˆ«ä¸­...' : 'å¼€å§‹æŒ‡çº¹è¯†åˆ«' }}
        </van-button>
      </div>

      <!-- å£°çº¹è¯†åˆ«ç•Œé¢ -->
      <div v-if="selectedType === 'VOICE'" class="voice-auth-interface">
        <div class="voice-visual">
          <div class="voice-waveform" :class="{ 'active': recording }">
            <canvas ref="waveformCanvas" class="waveform-canvas"></canvas>
          </div>
          <div class="voice-status">
            <van-icon
              :name="recording ? 'volume' : 'play'"
              size="32"
              :color="recording ? '#ff6b6b' : '#1989fa'"
            />
            <div class="status-text">{{ voiceStatus }}</div>
          </div>
        </div>

        <div class="voice-prompt">
          <div class="prompt-text">{{ voicePrompt }}</div>
          <div class="prompt-hint">è¯·æ¸…æ™°åœ°æœ—è¯»ä»¥ä¸Šæ–‡å­—</div>
        </div>

        <van-button
          :type="recording ? 'danger' : 'primary'"
          block
          round
          @click="toggleVoiceRecording"
        >
          {{ recording ? 'åœæ­¢å½•éŸ³' : 'å¼€å§‹å½•éŸ³' }}
        </van-button>
      </div>

      <!-- è™¹è†œè¯†åˆ«ç•Œé¢ -->
      <div v-if="selectedType === 'IRIS'" class="iris-auth-interface">
        <div class="iris-scanner">
          <div class="scanner-circle" :class="{ 'scanning': authenticating }">
            <div class="inner-circle"></div>
            <div class="scan-line" v-if="authenticating"></div>
          </div>
          <div class="iris-instructions">
            <div class="instruction-text">{{ irisInstruction }}</div>
            <div class="instruction-detail">{{ irisDetail }}</div>
          </div>
        </div>

        <van-button
          type="primary"
          block
          round
          :loading="authenticating"
          @click="startIrisAuthentication"
        >
          {{ authenticating ? 'è¯†åˆ«ä¸­...' : 'å¼€å§‹è™¹è†œè¯†åˆ«' }}
        </van-button>
      </div>
    </div>

    <!-- è¯†åˆ«ç»“æœæ˜¾ç¤º -->
    <div v-if="showResult && authResult" class="auth-result">
      <div class="result-card" :class="authResult.success ? 'success' : 'error'">
        <van-icon
          :name="authResult.success ? 'passed' : 'close'"
          :color="authResult.success ? '#07c160' : '#ee0a24'"
          size="24"
        />
        <div class="result-content">
          <div class="result-title">
            {{ authResult.success ? 'è¯†åˆ«æˆåŠŸ' : 'è¯†åˆ«å¤±è´¥' }}
          </div>
          <div class="result-details">
            <div class="detail-item">
              <span class="label">è¯†åˆ«æ–¹å¼ï¼š</span>
              <span class="value">{{ getTypeName(authResult.type) }}</span>
            </div>
            <div v-if="authResult.confidence" class="detail-item">
              <span class="label">ç½®ä¿¡åº¦ï¼š</span>
              <span class="value">{{ authResult.confidence }}%</span>
            </div>
            <div v-if="authResult.error" class="detail-item error">
              <span class="label">é”™è¯¯ä¿¡æ¯ï¼š</span>
              <span class="value">{{ authResult.error }}</span>
            </div>
            <div v-if="authResult.liveness" class="detail-item">
              <span class="label">æ´»ä½“æ£€æµ‹ï¼š</span>
              <span class="value" :class="authResult.liveness.isLive ? 'success' : 'error'">
                {{ authResult.liveness.isLive ? 'é€šè¿‡' : 'æœªé€šè¿‡' }}
              </span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- å…¶ä»–é€‰é¡¹ -->
    <div v-if="fallbackEnabled" class="fallback-options">
      <van-divider>å…¶ä»–éªŒè¯æ–¹å¼</van-divider>
      <van-button
        type="default"
        block
        round
        @click="handleFallback"
      >
        ä½¿ç”¨å…¶ä»–æ–¹å¼éªŒè¯
      </van-button>
    </div>

    <!-- æƒé™è¯·æ±‚å¼¹çª— -->
    <van-dialog
      v-model:show="showPermissionDialog"
      title="æƒé™è¯·æ±‚"
      :show-confirm-button="false"
      :show-cancel-button="false"
    >
      <div class="permission-dialog">
        <div class="permission-content">
          <van-icon name="warning-o" size="48" color="#ff976a" />
          <div class="permission-text">
            éœ€è¦è·å–{{ getTypeName(selectedType) }}æƒé™ä»¥è¿›è¡Œèº«ä»½éªŒè¯
          </div>
        </div>
        <div class="permission-actions">
          <van-button
            type="default"
            @click="showPermissionDialog = false"
          >
            å–æ¶ˆ
          </van-button>
          <van-button
            type="primary"
            @click="requestPermission"
          >
            æˆæƒ
          </van-button>
        </div>
      </div>
    </van-dialog>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted, nextTick, watch } from 'vue'
import { useBiometricService } from '@/services/biometric.service'
import { showToast, showLoadingToast, closeToast, showDialog } from 'vant'

// Propså®šä¹‰
const props = withDefaults(defineProps<BiometricAuthProps>(), {
  required: false,
  types: () => ['FINGERPRINT', 'FACE', 'VOICE'],
  fallbackEnabled: true,
  showResult: true,
  timeout: 30
})

// Emitså®šä¹‰
const emit = defineEmits<BiometricAuthEmits>()

// æœåŠ¡æ³¨å…¥
const biometricService = useBiometricService()

// å“åº”å¼æ•°æ®
const selectedType = ref<BiometricType>('FINGERPRINT')
const authenticating = ref(false)
const authResult = ref<BiometricResult | null>(null)
const showPermissionDialog = ref(false)

// äººè„¸è¯†åˆ«ç›¸å…³
const videoElement = ref<HTMLVideoElement | null>(null)
const canvasElement = ref<HTMLCanvasElement | null>(null)
const faceDetected = ref(false)
const faceConfidence = ref(0)
const faceInstruction = ref('è¯·æ­£å¯¹æ‘„åƒå¤´')
const livenessChallenge = ref<{
  text: string;
  icon: string;
  type: string;
} | null>(null)

// æŒ‡çº¹è¯†åˆ«ç›¸å…³
const fingerprintStatus = ref('è¯·å°†æ‰‹æŒ‡æ”¾åœ¨ä¼ æ„Ÿå™¨ä¸Š')

// å£°çº¹è¯†åˆ«ç›¸å…³
const waveformCanvas = ref<HTMLCanvasElement | null>(null)
const recording = ref(false)
const voiceStatus = ref('å‡†å¤‡å½•éŸ³')
const voicePrompt = ref('ä»Šå¤©æ˜¯2024å¹´1æœˆ2æ—¥ï¼Œæˆ‘å¼ ä¸‰ä¸Šç­æ‰“å¡')

// è™¹è†œè¯†åˆ«ç›¸å…³
const irisInstruction = ref('è¯·å°†çœ¼ç›å¯¹å‡†æ‰«æå™¨')
const irisDetail = ref('ä¿æŒçœ¼ç›çå¼€ï¼Œä¸è¦çœ¨çœ¼')

// åª’ä½“ç›¸å…³
let mediaStream: MediaStream | null = null
let audioContext: AudioContext | null = null
let analyser: AnalyserNode | null = null
let animationId: number | null = null

// è®¡ç®—å±æ€§
const availableTypes = computed(() => {
  return props.types.filter(type => isTypeAvailable(type))
})

const authStatus = computed(() => {
  if (authenticating.value) {
    return {
      icon: 'scan',
      color: '#1989fa',
      title: 'æ­£åœ¨è¿›è¡Œç”Ÿç‰©è¯†åˆ«',
      subtitle: `ä½¿ç”¨${getTypeName(selectedType.value)}è¿›è¡ŒéªŒè¯`
    }
  }

  if (authResult.value) {
    if (authResult.value.success) {
      return {
        icon: 'passed',
        color: '#07c160',
        title: 'éªŒè¯æˆåŠŸ',
        subtitle: `${getTypeName(authResult.value.type)}éªŒè¯é€šè¿‡`
      }
    } else {
      return {
        icon: 'close',
        color: '#ee0a24',
        title: 'éªŒè¯å¤±è´¥',
        subtitle: authResult.value.error || 'è¯·é‡è¯•'
      }
    }
  }

  return {
    icon: 'scan',
    color: '#1989fa',
    title: 'ç”Ÿç‰©è¯†åˆ«éªŒè¯',
    subtitle: 'è¯·é€‰æ‹©éªŒè¯æ–¹å¼'
  }
})

// æ–¹æ³•å®ç°
const isTypeAvailable = (type: BiometricType): boolean => {
  return biometricService.isAvailable(type)
}

const selectAuthType = async (type: BiometricType) => {
  if (!isTypeAvailable(type)) {
    showToast(`ä¸æ”¯æŒ${getTypeName(type)}`)
    return
  }

  selectedType.value = type
  authResult.value = null

  // åˆå§‹åŒ–å¯¹åº”çš„ç”Ÿç‰©è¯†åˆ«æ¥å£
  await initializeAuthInterface(type)
}

const initializeAuthInterface = async (type: BiometricType) => {
  switch (type) {
    case 'FACE':
      await initializeFaceAuth()
      break
    case 'FINGERPRINT':
      await initializeFingerprintAuth()
      break
    case 'VOICE':
      await initializeVoiceAuth()
      break
    case 'IRIS':
      await initializeIrisAuth()
      break
  }
}

const initializeFaceAuth = async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: {
        width: { ideal: 640 },
        height: { ideal: 480 },
        facingMode: 'user'
      }
    })

    if (videoElement.value) {
      videoElement.value.srcObject = stream
      mediaStream = stream
    }

    // å¯åŠ¨äººè„¸æ£€æµ‹
    startFaceDetection()

  } catch (error) {
    console.error('æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥:', error)
    showToast('æ— æ³•è®¿é—®æ‘„åƒå¤´')
  }
}

const initializeFingerprintAuth = async () => {
  // æ£€æŸ¥æŒ‡çº¹ä¼ æ„Ÿå™¨æƒé™
  const hasPermission = await biometricService.checkPermission('FINGERPRINT')
  if (!hasPermission) {
    showPermissionDialog.value = true
    return
  }

  fingerprintStatus.value = 'æŒ‡çº¹ä¼ æ„Ÿå™¨å·²å°±ç»ª'
}

const initializeVoiceAuth = async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true })

    audioContext = new (window.AudioContext || (window as any).webkitAudioContext)()
    analyser = audioContext.createAnalyser()
    const source = audioContext.createMediaStreamSource(stream)
    source.connect(analyser)

    analyser.fftSize = 2048

    mediaStream = stream
    voiceStatus.value = 'éº¦å…‹é£å·²å°±ç»ª'

  } catch (error) {
    console.error('éº¦å…‹é£åˆå§‹åŒ–å¤±è´¥:', error)
    showToast('æ— æ³•è®¿é—®éº¦å…‹é£')
  }
}

const initializeIrisAuth = async () => {
  // æ£€æŸ¥è™¹è†œæ‰«æå™¨æƒé™
  const hasPermission = await biometricService.checkPermission('IRIS')
  if (!hasPermission) {
    showPermissionDialog.value = true
    return
  }

  irisInstruction.value = 'è™¹è†œæ‰«æå™¨å·²å°±ç»ª'
}

const startFaceDetection = () => {
  const detectFace = async () => {
    if (!videoElement.value || !canvasElement.value) return

    const video = videoElement.value
    const canvas = canvasElement.value
    const ctx = canvas.getContext('2d')

    if (ctx && video.readyState === 4) {
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height)

      try {
        // è¿™é‡Œåº”è¯¥è°ƒç”¨äººè„¸æ£€æµ‹API
        const faceResult = await detectFaceFromCanvas(canvas)

        if (faceResult.detected) {
          faceDetected.value = true
          faceConfidence.value = Math.round(faceResult.confidence * 100)
          faceInstruction.value = getFaceInstruction(faceResult.confidence)
        } else {
          faceDetected.value = false
          faceInstruction.value = 'æœªæ£€æµ‹åˆ°äººè„¸ï¼Œè¯·æ­£å¯¹æ‘„åƒå¤´'
        }
      } catch (error) {
        console.error('äººè„¸æ£€æµ‹å¤±è´¥:', error)
      }
    }

    requestAnimationFrame(detectFace)
  }

  detectFace()
}

const detectFaceFromCanvas = async (canvas: HTMLCanvasElement): Promise<{
  detected: boolean;
  confidence: number;
  bounds?: { x: number; y: number; width: number; height: number };
}> => {
  // æ¨¡æ‹Ÿäººè„¸æ£€æµ‹ç»“æœ
  // å®é™…åº”ç”¨ä¸­åº”è¯¥è°ƒç”¨çœŸå®çš„äººè„¸æ£€æµ‹API
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        detected: Math.random() > 0.3,
        confidence: 0.8 + Math.random() * 0.2,
        bounds: {
          x: 200,
          y: 100,
          width: 240,
          height: 280
        }
      })
    }, 100)
  })
}

const getFaceInstruction = (confidence: number): string => {
  if (confidence < 0.6) {
    return 'è¯·è°ƒæ•´ä½ç½®ï¼Œç¡®ä¿é¢éƒ¨æ¸…æ™°å¯è§'
  } else if (confidence < 0.8) {
    return 'å¾ˆå¥½ï¼Œè¯·ä¿æŒå§¿åŠ¿'
  } else {
    return 'å®Œç¾ï¼Œå¯ä»¥è¿›è¡Œè¯†åˆ«'
  }
}

const startFaceAuthentication = async () => {
  if (!faceDetected.value) {
    showToast('æœªæ£€æµ‹åˆ°äººè„¸ï¼Œè¯·è°ƒæ•´ä½ç½®')
    return
  }

  authenticating.value = true
  showLoadingToast('æ­£åœ¨è¿›è¡Œäººè„¸è¯†åˆ«...')

  try {
    // ç”Ÿæˆæ´»ä½“æ£€æµ‹æŒ‘æˆ˜
    livenessChallenge.value = generateLivenessChallenge()

    // ç­‰å¾…ç”¨æˆ·å®ŒæˆæŒ‘æˆ˜
    await waitForLivenessCompletion()

    // æ‰§è¡Œäººè„¸è¯†åˆ«
    const result = await biometricService.authenticateWithFace({
      image: captureFaceImage(),
      liveness: livenessChallenge.value
    })

    handleAuthResult(result)

  } catch (error) {
    console.error('äººè„¸è¯†åˆ«å¤±è´¥:', error)
    emit('error', error as Error, 'FACE')
  } finally {
    authenticating.value = false
    closeToast()
    livenessChallenge.value = null
  }
}

const generateLivenessChallenge = () => {
  const challenges = [
    { text: 'è¯·çœ¨çœ¼', icon: 'eye-o', type: 'blink' },
    { text: 'è¯·ç‚¹å¤´', icon: 'arrow-down', type: 'nod' },
    { text: 'è¯·å¾®ç¬‘', icon: 'smile-o', type: 'smile' },
    { text: 'è¯·å‘å·¦è½¬å¤´', icon: 'arrow-left', type: 'turn_left' }
  ]

  return challenges[Math.floor(Math.random() * challenges.length)]
}

const waitForLivenessCompletion = (): Promise<void> => {
  return new Promise((resolve) => {
    // æ¨¡æ‹Ÿæ´»ä½“æ£€æµ‹ç­‰å¾…æ—¶é—´
    setTimeout(() => {
      resolve()
    }, 2000)
  })
}

const captureFaceImage = (): string => {
  if (!videoElement.value || !canvasElement.value) {
    throw new Error('æ— æ³•æ•è·äººè„¸å›¾åƒ')
  }

  const canvas = canvasElement.value
  const ctx = canvas.getContext('2d')

  if (ctx) {
    ctx.drawImage(videoElement.value, 0, 0, canvas.width, canvas.height)
    return canvas.toDataURL('image/jpeg', 0.8)
  }

  throw new Error('æ— æ³•æ•è·äººè„¸å›¾åƒ')
}

const startFingerprintAuthentication = async () => {
  authenticating.value = true
  fingerprintStatus.value = 'æ­£åœ¨éªŒè¯æŒ‡çº¹...'

  try {
    const result = await biometricService.authenticateWithFingerprint({
      timeout: props.timeout * 1000
    })

    handleAuthResult(result)

  } catch (error) {
    console.error('æŒ‡çº¹è¯†åˆ«å¤±è´¥:', error)
    fingerprintStatus.value = 'æŒ‡çº¹è¯†åˆ«å¤±è´¥ï¼Œè¯·é‡è¯•'
    emit('error', error as Error, 'FINGERPRINT')
  } finally {
    authenticating.value = false
  }
}

const toggleVoiceRecording = async () => {
  if (recording.value) {
    // åœæ­¢å½•éŸ³
    stopVoiceRecording()

    // å¤„ç†å£°çº¹è¯†åˆ«
    await processVoiceRecognition()
  } else {
    // å¼€å§‹å½•éŸ³
    startVoiceRecording()
  }
}

const startVoiceRecording = () => {
  recording.value = true
  voiceStatus.value = 'æ­£åœ¨å½•éŸ³...'

  // å¼€å§‹ç»˜åˆ¶æ³¢å½¢
  drawWaveform()
}

const stopVoiceRecording = () => {
  recording.value = false
  voiceStatus.value = 'å½•éŸ³å®Œæˆï¼Œæ­£åœ¨å¤„ç†...'

  // åœæ­¢ç»˜åˆ¶æ³¢å½¢
  if (animationId) {
    cancelAnimationFrame(animationId)
    animationId = null
  }
}

const drawWaveform = () => {
  if (!waveformCanvas.value || !analyser || !recording.value) return

  const canvas = waveformCanvas.value
  const ctx = canvas.getContext('2d')

  if (!ctx) return

  const bufferLength = analyser.frequencyBinCount
  const dataArray = new Uint8Array(bufferLength)

  const draw = () => {
    if (!recording.value) return

    animationId = requestAnimationFrame(draw)

    analyser.getByteTimeDomainData(dataArray)

    ctx.fillStyle = 'rgb(240, 240, 240)'
    ctx.fillRect(0, 0, canvas.width, canvas.height)

    ctx.lineWidth = 2
    ctx.strokeStyle = 'rgb(25, 137, 250)'
    ctx.beginPath()

    const sliceWidth = canvas.width / bufferLength
    let x = 0

    for (let i = 0; i < bufferLength; i++) {
      const v = dataArray[i] / 128.0
      const y = v * canvas.height / 2

      if (i === 0) {
        ctx.moveTo(x, y)
      } else {
        ctx.lineTo(x, y)
      }

      x += sliceWidth
    }

    ctx.lineTo(canvas.width, canvas.height / 2)
    ctx.stroke()
  }

  draw()
}

const processVoiceRecognition = async () => {
  try {
    const audioData = await captureAudioData()
    const result = await biometricService.authenticateWithVoice({
      audioData,
      text: voicePrompt.value
    })

    handleAuthResult(result)

  } catch (error) {
    console.error('å£°çº¹è¯†åˆ«å¤±è´¥:', error)
    voiceStatus.value = 'å£°çº¹è¯†åˆ«å¤±è´¥ï¼Œè¯·é‡è¯•'
    emit('error', error as Error, 'VOICE')
  }
}

const captureAudioData = async (): Promise<ArrayBuffer> => {
  // æ¨¡æ‹ŸéŸ³é¢‘æ•°æ®æ•è·
  // å®é™…åº”ç”¨ä¸­åº”è¯¥ä»MediaStreamæˆ–å½•éŸ³ä¸­è·å–çœŸå®éŸ³é¢‘æ•°æ®
  return new ArrayBuffer(1024)
}

const startIrisAuthentication = async () => {
  authenticating.value = true
  irisInstruction.value = 'æ­£åœ¨è¿›è¡Œè™¹è†œæ‰«æ...'

  try {
    const result = await biometricService.authenticateWithIris({
      timeout: props.timeout * 1000
    })

    handleAuthResult(result)

  } catch (error) {
    console.error('è™¹è†œè¯†åˆ«å¤±è´¥:', error)
    irisInstruction.value = 'è™¹è†œè¯†åˆ«å¤±è´¥ï¼Œè¯·é‡è¯•'
    emit('error', error as Error, 'IRIS')
  } finally {
    authenticating.value = false
  }
}

const handleAuthResult = (result: BiometricResult) => {
  authResult.value = result

  if (result.success) {
    emit('success', result)
    showToast('éªŒè¯æˆåŠŸ')
  } else {
    emit('error', new Error(result.error || 'éªŒè¯å¤±è´¥'), result.type)
    showToast('éªŒè¯å¤±è´¥')
  }
}

const handleFallback = () => {
  emit('fallback')
}

const requestPermission = async () => {
  try {
    const granted = await biometricService.requestPermission(selectedType.value)

    if (granted) {
      showToast('æƒé™æˆæƒæˆåŠŸ')
      showPermissionDialog.value = false
      await initializeAuthInterface(selectedType.value)
    } else {
      showToast('æƒé™æˆæƒå¤±è´¥')
    }
  } catch (error) {
    console.error('æƒé™è¯·æ±‚å¤±è´¥:', error)
    showToast('æƒé™è¯·æ±‚å¤±è´¥')
  }
}

const getTypeIcon = (type: BiometricType): string => {
  const iconMap = {
    'FINGERPRINT': 'scan',
    'FACE': 'photograph',
    'VOICE': 'volume-o',
    'IRIS': 'eye-o'
  }
  return iconMap[type] || 'scan'
}

const getTypeColor = (type: BiometricType): string => {
  const colorMap = {
    'FINGERPRINT': '#1989fa',
    'FACE': '#07c160',
    'VOICE': '#ff976a',
    'IRIS': '#722ed1'
  }
  return colorMap[type] || '#1989fa'
}

const getTypeName = (type: BiometricType): string => {
  const nameMap = {
    'FINGERPRINT': 'æŒ‡çº¹è¯†åˆ«',
    'FACE': 'äººè„¸è¯†åˆ«',
    'VOICE': 'å£°çº¹è¯†åˆ«',
    'IRIS': 'è™¹è†œè¯†åˆ«'
  }
  return nameMap[type] || type
}

// ç”Ÿå‘½å‘¨æœŸ
onMounted(async () => {
  // æ£€æŸ¥å¯ç”¨çš„ç”Ÿç‰©è¯†åˆ«ç±»å‹
  const firstAvailableType = availableTypes.value[0]
  if (firstAvailableType) {
    selectedType.value = firstAvailableType
    await initializeAuthInterface(firstAvailableType)
  }
})

onUnmounted(() => {
  // æ¸…ç†èµ„æº
  if (mediaStream) {
    mediaStream.getTracks().forEach(track => track.stop())
    mediaStream = null
  }

  if (audioContext) {
    audioContext.close()
    audioContext = null
  }

  if (animationId) {
    cancelAnimationFrame(animationId)
    animationId = null
  }
})

// ç›‘å¬é€‰ä¸­çš„ç”Ÿç‰©è¯†åˆ«ç±»å‹å˜åŒ–
watch(selectedType, async (newType) => {
  authResult.value = null

  // æ¸…ç†ä¹‹å‰çš„èµ„æº
  if (mediaStream) {
    mediaStream.getTracks().forEach(track => track.stop())
    mediaStream = null
  }

  // åˆå§‹åŒ–æ–°çš„ç”Ÿç‰©è¯†åˆ«æ¥å£
  if (newType && isTypeAvailable(newType)) {
    await initializeAuthInterface(newType)
  }
})
</script>

<style lang="scss" scoped>
.biometric-auth {
  padding: 16px;
}

.auth-status-card {
  background: white;
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 16px;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);

  .status-header {
    display: flex;
    align-items: center;
    margin-bottom: 20px;

    .auth-icon {
      margin-right: 16px;
    }

    .status-content {
      flex: 1;

      .status-title {
        font-size: 18px;
        font-weight: 600;
        color: #323233;
        margin-bottom: 4px;
      }

      .status-subtitle {
        font-size: 14px;
        color: #969799;
      }
    }
  }

  .auth-types {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 12px;

    .auth-type-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 16px 12px;
      background: #f7f8fa;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 2px solid transparent;

      &:hover:not(.disabled) {
        background: #e8f4ff;
        transform: translateY(-2px);
      }

      &.active {
        background: #e3f2fd;
        border-color: #2196f3;
      }

      &.disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .van-icon:first-child {
        margin-bottom: 8px;
      }

      span {
        font-size: 14px;
        color: #323233;
        margin-bottom: 4px;
        text-align: center;
      }

      .van-icon:last-child {
        align-self: flex-end;
      }
    }
  }
}

.auth-action-area {
  margin-bottom: 16px;
}

.face-auth-interface,
.fingerprint-auth-interface,
.voice-auth-interface,
.iris-auth-interface {
  background: white;
  border-radius: 12px;
  padding: 20px;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
}

.face-auth-interface {
  .camera-container {
    position: relative;
    width: 100%;
    max-width: 300px;
    height: 200px;
    margin: 0 auto 20px;
    background: #000;
    border-radius: 8px;
    overflow: hidden;

    .camera-video,
    .camera-canvas {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .camera-canvas {
      position: absolute;
      top: 0;
      left: 0;
      opacity: 0;
    }

    .face-detection-frame {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 120px;
      height: 160px;
      border: 2px solid #07c160;
      border-radius: 8px;

      .frame-corners {
        position: relative;
        width: 100%;
        height: 100%;

        .corner {
          position: absolute;
          width: 16px;
          height: 16px;
          border: 3px solid #07c160;

          &.top-left {
            top: -3px;
            left: -3px;
            border-right: none;
            border-bottom: none;
          }

          &.top-right {
            top: -3px;
            right: -3px;
            border-left: none;
            border-bottom: none;
          }

          &.bottom-left {
            bottom: -3px;
            left: -3px;
            border-right: none;
            border-top: none;
          }

          &.bottom-right {
            bottom: -3px;
            right: -3px;
            border-left: none;
            border-top: none;
          }
        }
      }

      .frame-info {
        position: absolute;
        bottom: -30px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(7, 193, 96, 0.9);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        text-align: center;

        .confidence {
          margin-bottom: 2px;
        }
      }
    }

    .liveness-challenge {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 8px;
      padding: 12px;
      text-align: center;

      .challenge-text {
        font-size: 14px;
        font-weight: 500;
        color: #323233;
        margin-bottom: 8px;
      }

      .challenge-animation {
        .challenge-icon {
          color: #ff976a;
          animation: pulse 1s infinite;
        }
      }
    }
  }
}

.fingerprint-auth-interface {
  .fingerprint-visual {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: 20px;

    .fingerprint-scanner {
      position: relative;
      width: 120px;
      height: 120px;
      border-radius: 60px;
      background: linear-gradient(135deg, #f0f8ff 0%, #e1f5fe 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 16px;
      border: 3px solid #b3e5fc;

      &.scanning {
        animation: scanning 2s infinite;

        .scanner-line {
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          height: 2px;
          background: #2196f3;
          animation: scan-line 2s infinite;
        }
      }
    }

    .fingerprint-status {
      font-size: 14px;
      color: #323233;
      text-align: center;
    }
  }

  .fingerprint-instructions {
    margin-bottom: 20px;

    .instruction-item {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      font-size: 14px;
      color: #646566;

      .van-icon {
        margin-right: 8px;
        color: #1989fa;
      }
    }
  }
}

.voice-auth-interface {
  .voice-visual {
    margin-bottom: 20px;

    .voice-waveform {
      height: 80px;
      background: #f7f8fa;
      border-radius: 8px;
      margin-bottom: 16px;
      overflow: hidden;

      &.active {
        background: #e3f2fd;
      }

      .waveform-canvas {
        width: 100%;
        height: 100%;
      }
    }

    .voice-status {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 12px;

      .status-text {
        margin-left: 12px;
        font-size: 14px;
        color: #323233;
      }
    }
  }

  .voice-prompt {
    background: #f0f8ff;
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 20px;
    text-align: center;

    .prompt-text {
      font-size: 18px;
      font-weight: 600;
      color: #323233;
      margin-bottom: 8px;
    }

    .prompt-hint {
      font-size: 14px;
      color: #969799;
    }
  }
}

.iris-auth-interface {
  .iris-scanner {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: 20px;

    .scanner-circle {
      position: relative;
      width: 200px;
      height: 200px;
      border-radius: 100px;
      background: radial-gradient(circle, #f0f8ff 0%, #e1f5fe 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 16px;
      border: 4px solid #b3e5fc;

      &.scanning {
        animation: iris-scanning 3s infinite;

        .scan-line {
          position: absolute;
          width: 100%;
          height: 2px;
          background: linear-gradient(90deg, transparent, #2196f3, transparent);
          animation: iris-scan 2s infinite;
        }

        .inner-circle {
          width: 60px;
          height: 60px;
          border-radius: 30px;
          background: #2196f3;
          animation: inner-pulse 2s infinite;
        }
      }

      .inner-circle {
        width: 40px;
        height: 40px;
        border-radius: 20px;
        background: #90caf9;
      }
    }

    .iris-instructions {
      text-align: center;

      .instruction-text {
        font-size: 16px;
        font-weight: 500;
        color: #323233;
        margin-bottom: 8px;
      }

      .instruction-detail {
        font-size: 14px;
        color: #969799;
      }
    }
  }
}

.auth-result {
  margin-bottom: 16px;

  .result-card {
    background: white;
    border-radius: 12px;
    padding: 20px;
    display: flex;
    align-items: flex-start;
    box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);

    &.success {
      border-left: 4px solid #07c160;
    }

    &.error {
      border-left: 4px solid #ee0a24;
    }

    .van-icon {
      margin-right: 16px;
      margin-top: 2px;
    }

    .result-content {
      flex: 1;

      .result-title {
        font-size: 16px;
        font-weight: 600;
        color: #323233;
        margin-bottom: 12px;
      }

      .result-details {
        .detail-item {
          display: flex;
          margin-bottom: 8px;
          font-size: 14px;

          &.error {
            color: #ee0a24;
          }

          .label {
            color: #969799;
            margin-right: 8px;
            flex-shrink: 0;
          }

          .value {
            color: #323233;

            &.success {
              color: #07c160;
            }

            &.error {
              color: #ee0a24;
            }
          }
        }
      }
    }
  }
}

.fallback-options {
  text-align: center;
}

.permission-dialog {
  .permission-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    text-align: center;

    .permission-text {
      margin-top: 16px;
      font-size: 16px;
      color: #323233;
      line-height: 1.5;
    }
  }

  .permission-actions {
    display: flex;
    gap: 12px;
    padding: 0 20px 20px;

    .van-button {
      flex: 1;
    }
  }
}

// åŠ¨ç”»æ•ˆæœ
@keyframes scanning {
  0%, 100% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.05);
    opacity: 0.8;
  }
}

@keyframes scan-line {
  0% {
    top: 0;
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
  100% {
    top: 100%;
    opacity: 1;
  }
}

@keyframes iris-scanning {
  0%, 100% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

@keyframes iris-scan {
  0% {
    transform: rotate(0deg) translateY(-100px);
  }
  100% {
    transform: rotate(360deg) translateY(100px);
  }
}

@keyframes inner-pulse {
  0%, 100% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.2);
    opacity: 0.8;
  }
}

@keyframes pulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.1);
  }
}

// å“åº”å¼è®¾è®¡
@media (max-width: 375px) {
  .biometric-auth {
    padding: 12px;
  }

  .auth-status-card {
    padding: 16px;
  }

  .auth-types {
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;

    .auth-type-item {
      padding: 12px 8px;
    }
  }

  .face-auth-interface .camera-container {
    max-width: 250px;
    height: 167px;
  }

  .fingerprint-auth-interface .fingerprint-visual .fingerprint-scanner {
    width: 100px;
    height: 100px;
  }

  .iris-auth-interface .iris-scanner .scanner-circle {
    width: 160px;
    height: 160px;
  }
}
</style>
```

---

## ç§»åŠ¨ç«¯ç»„ä»¶ä½¿ç”¨ç¤ºä¾‹

### åŸºæœ¬ä½¿ç”¨
```typescript
import { ref } from 'vue'
import { ClockButton, LocationVerifier, BiometricAuth } from '@/components/attendance'

export default {
  components: {
    ClockButton,
    LocationVerifier,
    BiometricAuth
  },
  setup() {
    const handleClock = async (clockData: ClockData) => {
      console.log('æ‰“å¡æ•°æ®:', clockData)
      // è°ƒç”¨æ‰“å¡API
    }

    const handleBiometricSuccess = (result: BiometricResult) => {
      console.log('ç”Ÿç‰©è¯†åˆ«æˆåŠŸ:', result)
      // ç»§ç»­æ‰“å¡æµç¨‹
    }

    return {
      handleClock,
      handleBiometricSuccess
    }
  }
}
```

### å®Œæ•´è€ƒå‹¤é¡µé¢ç¤ºä¾‹
```vue
<template>
  <div class="attendance-page">
    <!-- è€ƒå‹¤çŠ¶æ€å¡ç‰‡ -->
    <van-card>
      <template #title>
        <div class="attendance-header">
          <h2>è€ƒå‹¤æ‰“å¡</h2>
          <div class="current-time">{{ currentTime }}</div>
        </div>
      </template>

      <!-- ä½ç½®éªŒè¯ -->
      <LocationVerifier
        :required="true"
        :radius="500"
        :center-points="attendancePoints"
        :show-map="true"
        :auto-refresh="true"
        @location-change="handleLocationChange"
        @verification-result="handleLocationResult"
      />

      <!-- ç”Ÿç‰©è¯†åˆ« -->
      <BiometricAuth
        :required="false"
        :types="['FACE', 'FINGERPRINT']"
        :fallback-enabled="true"
        :show-result="true"
        @success="handleBiometricSuccess"
        @error="handleBiometricError"
        @fallback="handleBiometricFallback"
      />

      <!-- æ‰“å¡æŒ‰é’® -->
      <ClockButton
        :clock-type="nextClockType"
        :disabled="!canClock"
        :loading="clocking"
        :show-status="true"
        @clock="handleClock"
      />
    </van-card>

    <!-- ä»Šæ—¥è€ƒå‹¤è®°å½• -->
    <van-card title="ä»Šæ—¥è€ƒå‹¤">
      <template #default>
        <div class="today-records">
          <div
            v-for="record in todayRecords"
            :key="record.id"
            class="record-item"
          >
            <div class="record-time">{{ record.clockTime }}</div>
            <div class="record-type">{{ record.clockTypeName }}</div>
            <div class="record-location">{{ record.location }}</div>
          </div>
        </div>
      </template>
    </van-card>
  </div>
</template>
```

---

## æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. ç»„ä»¶æ‡’åŠ è½½
```typescript
// è·¯ç”±æ‡’åŠ è½½
const AttendancePage = () => import('@/views/attendance/AttendancePage.vue')

// ç»„ä»¶å¼‚æ­¥åŠ è½½
const ClockButton = defineAsyncComponent(() =>
  import('@/components/attendance/ClockButton.vue')
)
```

### 2. å›¾ç‰‡å’Œèµ„æºä¼˜åŒ–
```typescript
// WebPæ ¼å¼æ”¯æŒ
const getOptimizedImageUrl = (url: string) => {
  if (supportsWebP()) {
    return url.replace(/\.(jpg|jpeg|png)$/, '.webp')
  }
  return url
}
```

### 3. å†…å­˜ç®¡ç†
```typescript
// åŠæ—¶æ¸…ç†åª’ä½“èµ„æº
onUnmounted(() => {
  if (mediaStream) {
    mediaStream.getTracks().forEach(track => track.stop())
  }
  if (audioContext) {
    audioContext.close()
  }
})
```

---

## å®‰å…¨æ³¨æ„äº‹é¡¹

### 1. ç”Ÿç‰©è¯†åˆ«æ•°æ®å®‰å…¨
- ç”Ÿç‰©ç‰¹å¾æ•°æ®æœ¬åœ°åŠ å¯†å­˜å‚¨
- ä¼ è¾“è¿‡ç¨‹ä½¿ç”¨HTTPSåŠ å¯†
- å®šæœŸæ¸…ç†ç”Ÿç‰©ç‰¹å¾ç¼“å­˜

### 2. ä½ç½®æ•°æ®ä¿æŠ¤
- ä½ç½®æ•°æ®è„±æ•å¤„ç†
- é™åˆ¶ä½ç½®æ•°æ®è®¿é—®æƒé™
- æä¾›ä½ç½®æ•°æ®åˆ é™¤æœºåˆ¶

### 3. é˜²æ­¢ä½œå¼Šæœºåˆ¶
- å¤šé‡èº«ä»½éªŒè¯
- å¼‚å¸¸è¡Œä¸ºæ£€æµ‹
- å®æ—¶ç›‘æ§å’Œé¢„è­¦

---

## ç‰ˆæœ¬ä¿¡æ¯

- **å½“å‰ç‰ˆæœ¬**: v2.0.0
- **å…¼å®¹Vue**: 3.4.0+
- **å…¼å®¹Vant**: 4.8.0+
- **æ›´æ–°æ—¥æœŸ**: 2024-01-15
- **æŠ€æœ¯æ”¯æŒ**: frontend-team@ioe-dream.com