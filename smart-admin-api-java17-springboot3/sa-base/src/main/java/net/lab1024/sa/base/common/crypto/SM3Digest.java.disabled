package net.lab1024.sa.base.common.crypto;

import lombok.extern.slf4j.Slf4j;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

/**
 * SM3国密算法哈希工具类（简化版）
 *
 * 注意：这是一个基础框架实现，实际部署时需要集成完整的BouncyCastle SM3算法库
 * 当前版本使用SHA-256作为SM3的占位实现，提供相同的接口和输出长度
 *
 * @author SmartAdmin Team
 * @date 2025-01-15
 */
@Slf4j
public class SM3Digest {

    /** SM3哈希长度（字节） */
    public static final int HASH_SIZE_BYTES = 32;

    /** SM3哈希长度（16进制字符串） */
    public static final int HASH_SIZE_HEX = 64;

    /** SM3块大小（字节） */
    public static final int BLOCK_SIZE_BYTES = 64;

    /**
     * 计算SM3哈希值（16进制字符串）
     *
     * @param data 输入数据
     * @return SM3哈希值（16进制字符串）
     */
    public static String hash(String data) {
        if (data == null) {
            throw new IllegalArgumentException("Input data cannot be null");
        }
        return hash(data.getBytes(StandardCharsets.UTF_8));
    }

    /**
     * 计算SM3哈希值（16进制字符串）
     *
     * @param data 输入字节数组
     * @return SM3哈希值（16进制字符串）
     */
    public static String hash(byte[] data) {
        if (data == null) {
            throw new IllegalArgumentException("Input data cannot be null");
        }

        try {
            // 临时实现：使用SHA-256作为SM3的占位
            log.debug("Using SHA-256 as SM3 placeholder implementation");
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hashBytes = digest.digest(data);
            return bytesToHex(hashBytes);

        } catch (NoSuchAlgorithmException e) {
            log.error("Hash algorithm not found", e);
            throw new RuntimeException("哈希算法不可用", e);
        }
    }

    /**
     * 计算SM3哈希值（Base64编码）
     *
     * @param data 输入数据
     * @return SM3哈希值（Base64编码）
     */
    public static String hashBase64(String data) {
        if (data == null) {
            throw new IllegalArgumentException("Input data cannot be null");
        }
        return hashBase64(data.getBytes(StandardCharsets.UTF_8));
    }

    /**
     * 计算SM3哈希值（Base64编码）
     *
     * @param data 输入字节数组
     * @return SM3哈希值（Base64编码）
     */
    public static String hashBase64(byte[] data) {
        if (data == null) {
            throw new IllegalArgumentException("Input data cannot be null");
        }

        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hashBytes = digest.digest(data);
            return Base64.getEncoder().encodeToString(hashBytes);

        } catch (NoSuchAlgorithmException e) {
            log.error("Hash algorithm not found", e);
            throw new RuntimeException("哈希算法不可用", e);
        }
    }

    /**
     * 计算SM3哈希值（字节数组）
     *
     * @param data 输入字节数组
     * @return SM3哈希值（字节数组）
     */
    public static byte[] hashBytes(byte[] data) {
        if (data == null) {
            throw new IllegalArgumentException("Input data cannot be null");
        }

        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            return digest.digest(data);

        } catch (NoSuchAlgorithmException e) {
            log.error("Hash algorithm not found", e);
            throw new RuntimeException("哈希算法不可用", e);
        }
    }

    /**
     * HMAC-SM3计算（带密钥的哈希）
     *
     * @param key   密钥
     * @param data  输入数据
     * @return HMAC-SM3值（16进制字符串）
     */
    public static String hmac(String key, String data) {
        if (key == null || data == null) {
            throw new IllegalArgumentException("Key and data cannot be null");
        }

        byte[] keyBytes = key.getBytes(StandardCharsets.UTF_8);
        byte[] dataBytes = data.getBytes(StandardCharsets.UTF_8);

        return hmac(keyBytes, dataBytes);
    }

    /**
     * HMAC-SM3计算（带密钥的哈希）
     *
     * @param key   密钥字节数组
     * @param data  输入字节数组
     * @return HMAC-SM3值（16进制字符串）
     */
    public static String hmac(byte[] key, byte[] data) {
        if (key == null || data == null) {
            throw new IllegalArgumentException("Key and data cannot be null");
        }

        try {
            // 使用HMAC-SHA256作为HMAC-SM3的占位
            javax.crypto.spec.SecretKeySpec keySpec = new javax.crypto.spec.SecretKeySpec(key, "HmacSHA256");
            javax.crypto.Mac mac = javax.crypto.Mac.getInstance("HmacSHA256");
            mac.init(keySpec);
            byte[] hmacBytes = mac.doFinal(data);
            return bytesToHex(hmacBytes);

        } catch (Exception e) {
            log.error("HMAC-SM3 calculation failed", e);
            throw new RuntimeException("HMAC-SM3计算失败", e);
        }
    }

    /**
     * 验证SM3哈希值
     *
     * @param data      原始数据
     * @param hashValue 待验证的哈希值（16进制字符串）
     * @return 验证结果
     */
    public static boolean verify(String data, String hashValue) {
        if (data == null || hashValue == null) {
            return false;
        }

        try {
            String calculatedHash = hash(data);
            return calculatedHash.equalsIgnoreCase(hashValue);
        } catch (Exception e) {
            log.error("SM3 hash verification failed", e);
            return false;
        }
    }

    /**
     * 验证SM3哈希值
     *
     * @param data      原始数据字节数组
     * @param hashValue 待验证的哈希值（16进制字符串）
     * @return 验证结果
     */
    public static boolean verify(byte[] data, String hashValue) {
        if (data == null || hashValue == null) {
            return false;
        }

        try {
            String calculatedHash = hash(data);
            return calculatedHash.equalsIgnoreCase(hashValue);
        } catch (Exception e) {
            log.error("SM3 hash verification failed", e);
            return false;
        }
    }

    /**
     * 验证HMAC-SM3值
     *
     * @param key       密钥
     * @param data      原始数据
     * @param hmacValue 待验证的HMAC值（16进制字符串）
     * @return 验证结果
     */
    public static boolean verifyHmac(String key, String data, String hmacValue) {
        if (key == null || data == null || hmacValue == null) {
            return false;
        }

        try {
            String calculatedHmac = hmac(key, data);
            return calculatedHmac.equalsIgnoreCase(hmacValue);
        } catch (Exception e) {
            log.error("HMAC-SM3 verification failed", e);
            return false;
        }
    }

    /**
     * 密码哈希（带盐值）
     *
     * @param password 明文密码
     * @param salt     盐值
     * @return 密码哈希值（16进制字符串）
     */
    public static String hashPassword(String password, String salt) {
        if (password == null || salt == null) {
            throw new IllegalArgumentException("Password and salt cannot be null");
        }

        // 组合密码和盐值
        String saltedPassword = password + salt;
        return hash(saltedPassword);
    }

    /**
     * 验证密码
     *
     * @param password         明文密码
     * @param salt            盐值
     * @param hashedPassword  哈希密码
     * @return 验证结果
     */
    public static boolean verifyPassword(String password, String salt, String hashedPassword) {
        if (password == null || salt == null || hashedPassword == null) {
            return false;
        }

        try {
            String calculatedHash = hashPassword(password, salt);
            return calculatedHash.equalsIgnoreCase(hashedPassword);
        } catch (Exception e) {
            log.error("Password verification failed", e);
            return false;
        }
    }

    /**
     * 生成随机盐值
     *
     * @param length 盐值长度
     * @return 随机盐值（16进制字符串）
     */
    public static String generateSalt(int length) {
        if (length <= 0) {
            length = 16; // 默认16字节
        }

        byte[] salt = new byte[length];
        new java.security.SecureRandom().nextBytes(salt);
        return bytesToHex(salt);
    }

    /**
     * 生成默认随机盐值（16字节）
     *
     * @return 随机盐值（16进制字符串）
     */
    public static String generateSalt() {
        return generateSalt(16);
    }

    /**
     * 字节数组转16进制字符串
     */
    private static String bytesToHex(byte[] bytes) {
        if (bytes == null) {
            return null;
        }

        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02x", b));
        }
        return sb.toString();
    }

    /**
     * SM3算法信息
     */
    public static class AlgorithmInfo {
        public static final String ALGORITHM_NAME = "SM3";
        public static final int HASH_SIZE_BITS = 256;
        public static final int HASH_SIZE_BYTES = 32;
        public static final String PROVIDER = "BC"; // BouncyCastle Provider
        public static final int BLOCK_SIZE_BITS = 512;
        public static final int BLOCK_SIZE_BYTES = 64;

        /**
         * 获取算法信息
         */
        public static String getAlgorithmInfo() {
            return String.format(
                "SM3 Algorithm Info (Framework Version):\n" +
                "- Algorithm: %s\n" +
                "- Hash Size: %d bits\n" +
                "- Block Size: %d bits\n" +
                "- Provider: %s\n" +
                "- Note: This is a framework implementation using SHA-256 as placeholder.",
                ALGORITHM_NAME, HASH_SIZE_BITS, BLOCK_SIZE_BITS, PROVIDER
            );
        }
    }

    /**
     * 性能测试工具
     */
    public static class PerformanceTest {

        /**
         * 测试哈希性能
         *
         * @param data       测试数据
         * @param iterations 测试次数
         * @return 平均耗时（毫秒）
         */
        public static double testHashPerformance(String data, int iterations) {
            long startTime = System.nanoTime();

            for (int i = 0; i < iterations; i++) {
                hash(data);
            }

            long endTime = System.nanoTime();
            return (double) (endTime - startTime) / (iterations * 1_000_000.0); // 返回平均毫秒
        }

        /**
         * 测试HMAC性能
         *
         * @param key        密钥
         * @param data       测试数据
         * @param iterations 测试次数
         * @return 平均耗时（毫秒）
         */
        public static double testHmacPerformance(String key, String data, int iterations) {
            long startTime = System.nanoTime();

            for (int i = 0; i < iterations; i++) {
                hmac(key, data);
            }

            long endTime = System.nanoTime();
            return (double) (endTime - startTime) / (iterations * 1_000_000.0); // 返回平均毫秒
        }
    }
}