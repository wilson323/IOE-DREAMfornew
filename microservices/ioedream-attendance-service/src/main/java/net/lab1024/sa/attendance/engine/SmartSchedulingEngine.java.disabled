package net.lab1024.sa.attendance.engine;
import lombok.extern.slf4j.Slf4j;

import net.lab1024.sa.attendance.engine.model.OptimizationConfig;
import net.lab1024.sa.attendance.engine.optimizer.OptimizationResult;
import net.lab1024.sa.attendance.engine.optimizer.GeneticAlgorithmOptimizer;
import net.lab1024.sa.attendance.engine.optimizer.HybridOptimizer;
import net.lab1024.sa.attendance.engine.optimizer.SimulatedAnnealingOptimizer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Component
@Slf4j
public class SmartSchedulingEngine {

    @org.springframework.beans.factory.annotation.Autowired
    private GeneticAlgorithmOptimizer geneticOptimizer;

    @org.springframework.beans.factory.annotation.Autowired
    private SimulatedAnnealingOptimizer simulatedAnnealingOptimizer;

    @org.springframework.beans.factory.annotation.Autowired
    private HybridOptimizer hybridOptimizer;

    public OptimizationResult optimize(OptimizationConfig config) {
        log.info("智能排班引擎启动，算法类型: {}", config.getAlgorithmType());

        config.validate();

        switch (config.getAlgorithmType()) {
            case 1:
                return geneticOptimizer.optimize(config);
            case 2:
                return simulatedAnnealingOptimizer.optimize(config);
            case 3:
                return hybridOptimizer.optimize(config);
            case 4:
                return autoSelectAndOptimize(config);
            default:
                return autoSelectAndOptimize(config);
        }
    }

    private OptimizationResult autoSelectAndOptimize(OptimizationConfig config) {
        int problemSize = config.getEmployeeIds().size() *
                         (int) getDaysBetween(config.getStartDate(), config.getEndDate());

        log.info("自动算法选择，问题规模: {}", problemSize);

        if (problemSize < 50) {
            log.info("选择模拟退火算法（适合小规模问题）");
            return simulatedAnnealingOptimizer.optimize(config);
        } else if (problemSize < 200) {
            log.info("选择遗传算法（适合中规模问题）");
            return geneticOptimizer.optimize(config);
        } else {
            log.info("选择混合算法（适合大规模问题）");
            return hybridOptimizer.optimize(config);
        }
    }

    private long getDaysBetween(java.time.LocalDate start, java.time.LocalDate end) {
        return java.time.temporal.ChronoUnit.DAYS.between(start, end) + 1;
    }
}
