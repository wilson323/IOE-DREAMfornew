# 服务依赖优化方案

## 📋 问题分析

### 1. 循环依赖问题

#### 当前情况
- **consume-service** → **device-service** (通过FeignClient)
- **device-service** → **consume-service** (未发现直接调用，可能通过其他方式)

#### 问题影响
- 服务启动顺序依赖
- 服务降级困难
- 测试复杂度增加

### 2. 服务职责重叠

#### 当前情况
- **enterprise-service** 包含 oa 模块（document、workflow、approval）
- **oa-service** 也包含相同模块（document、workflow、approval）
- 两个服务功能完全重复

#### 问题影响
- 代码重复维护
- 数据可能不一致
- 用户混淆

### 3. 直接依赖过多

#### 当前情况
- 多个服务直接使用 FeignClient 调用其他服务
- 未通过网关统一调用
- 服务间耦合度高

#### 问题影响
- 服务治理困难
- 无法统一限流、熔断
- 监控和追踪困难

---

## 🎯 解决方案

### 方案1: 解决循环依赖 - 事件驱动架构

**策略**: 使用消息队列解耦服务调用

**实施步骤**:
1. 引入消息队列（RabbitMQ/Kafka）
2. consume-service 通过消息队列通知 device-service
3. device-service 通过消息队列通知 consume-service
4. 移除直接的 FeignClient 调用

### 方案2: 解决职责重叠 - 服务合并

**策略**: 合并 enterprise-service 和 oa-service

**实施步骤**:
1. 保留 enterprise-service（功能更完整）
2. 将 oa-service 的功能迁移到 enterprise-service
3. 删除 oa-service
4. 更新网关路由配置

### 方案3: 统一服务调用 - 网关路由

**策略**: 所有服务间调用通过网关

**实施步骤**:
1. 移除服务间的 FeignClient 直接调用
2. 通过网关路由转发服务调用
3. 统一限流、熔断、监控

---

## 📝 详细实施计划

### 阶段1: 解决循环依赖（优先级：高）

1. **引入消息队列**
   - 添加 RabbitMQ 依赖
   - 配置消息队列连接

2. **改造 consume-service**
   - 移除 DeviceServiceClient
   - 添加消息发送逻辑

3. **改造 device-service**
   - 添加消息监听逻辑
   - 处理消费相关事件

### 阶段2: 解决职责重叠（优先级：中）

1. **分析功能差异**
   - 对比两个服务的功能
   - 确定保留的功能

2. **迁移功能**
   - 将 oa-service 功能迁移到 enterprise-service
   - 更新数据库表结构

3. **删除 oa-service**
   - 删除服务代码
   - 更新网关配置

### 阶段3: 统一服务调用（优先级：高）

1. **分析现有调用**
   - 列出所有 FeignClient 调用
   - 确定调用场景

2. **改造网关路由**
   - 添加服务间调用路由
   - 配置限流和熔断

3. **移除直接调用**
   - 删除 FeignClient
   - 改为通过网关调用

---

## ⚠️ 风险评估

### 风险1: 消息队列引入复杂度
- **影响**: 中等
- **缓解**: 使用成熟的 RabbitMQ，提供完善的文档

### 风险2: 服务合并影响现有功能
- **影响**: 高
- **缓解**: 充分测试，逐步迁移

### 风险3: 网关调用性能影响
- **影响**: 低
- **缓解**: 网关性能优化，使用缓存

---

## 📊 预期收益

1. **消除循环依赖**: 服务启动更稳定
2. **减少代码重复**: 维护成本降低
3. **统一服务治理**: 更好的监控和限流
4. **提高系统可维护性**: 架构更清晰

